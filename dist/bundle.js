(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Map_1 = require("../DataTypes/Map");
    /**
     * A manager class for all of the AI in a scene.
     * Keeps a list of registered actors and handles AI generation for actors.
     */
    class AIManager {
        constructor() {
            this.actors = new Array();
            this.registeredAI = new Map_1.default();
        }
        /**
         * Registers an actor with the AIManager
         * @param actor The actor to register
         */
        registerActor(actor) {
            this.actors.push(actor);
        }
        removeActor(actor) {
            let index = this.actors.indexOf(actor);
            if (index !== -1) {
                this.actors.splice(index, 1);
            }
        }
        /**
         * Registers an AI with the AIManager for use later on
         * @param name The name of the AI to register
         * @param constr The constructor for the AI
         */
        registerAI(name, constr) {
            this.registeredAI.add(name, constr);
        }
        /**
         * Generates an AI instance from its name
         * @param name The name of the AI to add
         * @returns A new AI instance
         */
        generateAI(name) {
            if (this.registeredAI.has(name)) {
                return new (this.registeredAI.get(name))();
            }
            else {
                throw `Cannot create AI with name ${name}, no AI with that name is registered`;
            }
        }
        update(deltaT) {
            // Run the ai for every active actor
            this.actors.forEach(actor => { if (actor.aiActive)
                actor.ai.update(deltaT); });
        }
    }
    exports.default = AIManager;
    },{"../DataTypes/Map":19}],2:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const GoapAction_1 = require("../../DataTypes/Interfaces/GoapAction");
    class AttackAction extends GoapAction_1.default {
        constructor(cost, preconditions, effects, options) {
            super();
            this.cost = cost;
            this.preconditions = preconditions;
            this.effects = effects;
        }
        performAction(statuses, actor, deltaT, target) {
            //Check if preconditions are met for this action to be performed
            if (this.checkPreconditions(statuses)) {
                let enemy = actor;
                //If the player is out of sight, don't bother attacking
                if (enemy.getPlayerPosition() == null) {
                    return null;
                }
                //Randomize attack direction, gives the enemy gun users stormtrooper aim
                let dir = enemy
                    .getPlayerPosition()
                    .clone()
                    .sub(enemy.owner.position)
                    .normalize();
                if (enemy.weapon.use(enemy.owner, "enemy", dir)) {
                    // If we fired, face that direction
                }
                return this.effects;
            }
            return null;
        }
        updateCost(options) { }
        toString() {
            return "(AttackAction)";
        }
    }
    exports.default = AttackAction;
    },{"../../DataTypes/Interfaces/GoapAction":17}],3:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const GoapAction_1 = require("../../../Wolfie2D/DataTypes/Interfaces/GoapAction");
    const Timer_1 = require("../../../Wolfie2D/Timing/Timer");
    // HOMEWORK 4 - TODO
    /**
     * Implement berserk action so that the enemy gains 1.5x speed, 2x damage, and has a 2x lower cooldown on attacking.
     * Note that you'll also need to manage how enemies use this action in the initializeEnemies method in hw4_scene.
     */
    class Berserk extends GoapAction_1.default {
        constructor(cost, preconditions, effects, options) {
            super();
            this.cost = cost;
            this.preconditions = preconditions;
            this.effects = effects;
        }
        performAction(statuses, actor, deltaT, target) {
            if (this.checkPreconditions(statuses)) {
                console.log("enemy going berserk");
                let enemy = actor;
                let newTime = enemy.weapon.type.cooldown;
                enemy.weapon.cooldownTimer = new Timer_1.default(newTime * 0.5); //2x cdr //TODO: to show obivous berserk// chnage this later to 0.5
                enemy.weapon.type.damage = enemy.weapon.type.damage * 2; //2x dmg
                enemy.speed = enemy.speed * 2; //2x ms
                // enemy.currentStatus.filter(function (e){
                //     return e!==hw4_Statuses.CAN_BERSERK
                // });
                return this.effects;
            }
            return null;
        }
        updateCost(options) { }
        toString() {
            return "(Berserk)";
        }
    }
    exports.default = Berserk;
    },{"../../../Wolfie2D/DataTypes/Interfaces/GoapAction":17,"../../../Wolfie2D/Timing/Timer":107}],4:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const GoapAction_1 = require("../../DataTypes/Interfaces/GoapAction");
    class Move extends GoapAction_1.default {
        constructor(cost, preconditions, effects, options) {
            super();
            this.cost = cost;
            this.preconditions = preconditions;
            this.effects = effects;
            this.loopAction = true;
            this.inRange = options.inRange;
        }
        performAction(statuses, actor, deltaT, target) {
            if (this.checkPreconditions(statuses)) {
                //Check distance from player
                let enemy = actor;
                let playerPos = enemy.lastPlayerPos;
                let distance = enemy.owner.position.distanceTo(playerPos);
                //If close enough, we've moved far enough and this loop action is done
                if (distance <= this.inRange) {
                    return this.effects;
                }
                this.path = enemy.path;
                //Otherwise move on path
                var direction = this.path.getMoveDirection(enemy.owner);
                if (direction.x > 0) {
                    enemy.owner.animation.playIfNotAlready("run_right", true);
                }
                else {
                    enemy.owner.animation.playIfNotAlready("run_left", true);
                }
                enemy.owner.moveOnPath(enemy.speed * deltaT, this.path);
                return null;
            }
            return this.effects;
        }
        updateCost(options) { }
        toString() {
            return "(Move)";
        }
    }
    exports.default = Move;
    },{"../../DataTypes/Interfaces/GoapAction":17}],5:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const GoapAction_1 = require("../../DataTypes/Interfaces/GoapAction");
    class Retreat extends GoapAction_1.default {
        constructor(cost, preconditions, effects, options) {
            super();
            this.cost = cost;
            this.preconditions = preconditions;
            this.loopAction = true;
            this.effects = effects;
            this.retreatDistance = options.retreatDistance;
        }
        // HOMEWORK 4 - TODO
        /**
         * Implement retreat action so that the enemy constantly moves away from the player until they get past the retreatDistance. If they succesfully move
         * far away enough, they heal back to their max health. The low health status should NOT be removed, once an enemy is low health, that remains
         * as a status signaling the enemy has gotten below a certain health once.
         *
         * Look at other actions for hints as to how this can be implemented, and know that there's a function in Active.ts that is needed to fully implement
         * this. You'll know this action if working correctly if a retreating enemy changes their retreat direction if the player moves around, trying to get
         * as far away as possible.
         */
        performAction(statuses, actor, deltaT, target) {
            return null;
        }
        updateCost(options) { }
        toString() {
            return "(Retreat)";
        }
    }
    exports.default = Retreat;
    },{"../../DataTypes/Interfaces/GoapAction":17}],6:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Timer_1 = require("../../Timing/Timer");
    const constants_1 = require("../../constants");
    const EnemyAI_1 = require("../../../mayhemFiles/AI/EnemyAI");
    const EnemyState_1 = require("./EnemyState");
    class Active extends EnemyState_1.default {
        constructor(parent, owner) {
            super(parent, owner);
            // Regularly update the player location
            this.pollTimer = new Timer_1.default(100);
            this.exitTimer = new Timer_1.default(1000);
        }
        onEnter(options) {
            // Reset the return object
            this.retObj = {};
            // Choose path to last seen player position
            this.retObj = { target: this.parent.lastPlayerPos };
            this.parent.path = this.owner.getScene().getNavigationManager().getPath(constants_1.hw4_Names.NAVMESH, this.owner.position, this.parent.lastPlayerPos, true);
            this.pickRetreatPath(this.parent.path);
        }
        handleInput(event) { }
        // HOMEWORK 4 - TODO
        /**
         * This function is called whenever we're defining a path towards the player, and it should create a path that moves
         * in the complete opposite direction. For example, if the path to the player is moving straight left, this method should create
         * a retreat path that moves straight right. This path should then be set to retreatPath in EnemyAI.
         *
         * You'll have to implement this function so you can use retreatPath in the Retreat action.
         */
        pickRetreatPath(pathToPlayer) {
        }
        update(deltaT) {
            //Poll for player position
            if (this.pollTimer.isStopped()) {
                // Restart the timer
                this.pollTimer.start();
                this.parent.playerPos = this.parent.getPlayerPosition();
                if (this.parent.playerPos !== null) {
                    // If we see a new player position, update the last position
                    this.parent.path = this.owner.getScene().getNavigationManager().getPath(constants_1.hw4_Names.NAVMESH, this.owner.position, this.parent.lastPlayerPos, true);
                    this.pickRetreatPath(this.parent.path);
                    this.parent.lastPlayerPos = this.parent.playerPos;
                    this.exitTimer.start();
                }
            }
            if (this.exitTimer.isStopped()) {
                // We haven't seen the player in a while, go check out where we last saw them, if possible
                if (this.parent.lastPlayerPos !== null) {
                    this.retObj = { target: this.parent.lastPlayerPos };
                    this.finished(EnemyAI_1.EnemyStates.ALERT);
                }
                else {
                    this.finished(EnemyAI_1.EnemyStates.DEFAULT);
                }
            }
            //Add in range to status if close enough to a player
            if (this.parent.playerPos !== null) {
                let distance = this.owner.position.distanceTo(this.parent.playerPos);
                if (distance > this.parent.inRange) {
                    let index = this.parent.currentStatus.indexOf(constants_1.hw4_Statuses.IN_RANGE);
                    if (index != -1) {
                        this.parent.currentStatus.splice(index, 1);
                    }
                }
            }
            //Choose next action
            let nextAction = this.parent.plan.peek();
            //Perform the action
            let result = nextAction.performAction(this.parent.currentStatus, this.parent, deltaT);
            //Our action was successful
            if (result !== null) {
                //If the action was Retreat or Berserk, remove the CAN_RETREAT or CAN_BERSERK status from the enemy, they can only use them once
                if (nextAction.toString() === "(Retreat)") {
                    let index = this.parent.currentStatus.indexOf(constants_1.hw4_Statuses.CAN_RETREAT);
                    if (index != -1) {
                        this.parent.currentStatus.splice(index, 1);
                    }
                }
                if (nextAction.toString() === "(Berserk)") {
                    let index = this.parent.currentStatus.indexOf(constants_1.hw4_Statuses.CAN_BERSERK);
                    if (index != -1) {
                        this.parent.currentStatus.splice(index, 1);
                    }
                }
                //The action has not reached the goal yet, pass along the effects of our action
                if (!result.includes(constants_1.hw4_Statuses.REACHED_GOAL)) {
                    this.parent.currentStatus = this.parent.currentStatus.concat(...result);
                }
                this.parent.plan.pop();
            }
            else {
                // Our action was not successful. However, if the action was a loop action like Move, we continue to do it until it's succesful
                if (!nextAction.loopAction) {
                    this.parent.plan.pop();
                }
            }
        }
        onExit() {
            return this.retObj;
        }
    }
    exports.default = Active;
    },{"../../../mayhemFiles/AI/EnemyAI":117,"../../Timing/Timer":107,"../../constants":115,"./EnemyState":8}],7:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Vec2_1 = require("../../DataTypes/Vec2");
    const Timer_1 = require("../../Timing/Timer");
    const constants_1 = require("../../constants");
    const EnemyAI_1 = require("../../../mayhemFiles/AI/EnemyAI");
    const EnemyState_1 = require("./EnemyState");
    /** When an enemy has seen a player recently, it will move to the last known location they saw them, giving up after a certain time */
    class Alert extends EnemyState_1.default {
        constructor(parent, owner) {
            super(parent, owner);
            this.alertTimer = new Timer_1.default(10000);
        }
        // Receives options.target
        onEnter(options) {
            this.alertTimer.start();
            this.path = this.owner.getScene().getNavigationManager().getPath(constants_1.hw4_Names.NAVMESH, this.owner.position, options.target, true);
        }
        handleInput(event) {
        }
        update(deltaT) {
            if (this.alertTimer.isStopped()) {
                // The timer is up, return to the default state
                this.finished(EnemyAI_1.EnemyStates.DEFAULT);
                return;
            }
            else {
                this.owner.moveOnPath(this.parent.speed * deltaT, this.path);
                this.owner.rotation = Vec2_1.default.UP.angleToCCW(this.path.getMoveDirection(this.owner));
            }
            // If we see one of the players, target them and move into active mode
            this.parent.lastPlayerPos = this.parent.getPlayerPosition();
            if (this.parent.lastPlayerPos !== null) {
                this.finished(EnemyAI_1.EnemyStates.TARGETING);
            }
        }
        onExit() {
            return {};
        }
    }
    exports.default = Alert;
    },{"../../../mayhemFiles/AI/EnemyAI":117,"../../DataTypes/Vec2":32,"../../Timing/Timer":107,"../../constants":115,"./EnemyState":8}],8:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const State_1 = require("../../DataTypes/State/State");
    class EnemyState extends State_1.default {
        constructor(parent, owner) {
            super(parent);
            this.owner = owner;
        }
    }
    exports.default = EnemyState;
    },{"../../DataTypes/State/State":29}],9:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Vec2_1 = require("../../DataTypes/Vec2");
    const constants_1 = require("../../constants");
    const EnemyAI_1 = require("../../../mayhemFiles/AI/EnemyAI");
    const EnemyState_1 = require("./EnemyState");
    class Guard extends EnemyState_1.default {
        constructor(parent, owner, guardPosition) {
            super(parent, owner);
            this.guardPosition = guardPosition;
        }
        onEnter(options) {
            // Go to the guard position if not already there
            if (!(this.owner.position.distanceSqTo(this.guardPosition) < 8 * 8)) {
                // We need a new route
                this.awayFromGuardPosition = true;
                this.owner.pathfinding = true;
                this.route = this.owner.getScene().getNavigationManager().getPath(constants_1.hw4_Names.NAVMESH, this.owner.position, this.guardPosition);
            }
            else {
                this.awayFromGuardPosition = false;
                this.owner.pathfinding = false;
            }
        }
        handleInput(event) { }
        update(deltaT) {
            if (this.awayFromGuardPosition) {
                // Navigate back home
                if (this.route.isDone()) {
                    this.awayFromGuardPosition = false;
                    this.owner.pathfinding = false;
                }
                else {
                    this.owner.moveOnPath(this.parent.speed * deltaT, this.route);
                    this.owner.rotation = Vec2_1.default.UP.angleToCCW(this.route.getMoveDirection(this.owner));
                }
            }
            this.parent.lastPlayerPos = this.parent.getPlayerPosition();
            if (this.parent.lastPlayerPos !== null) {
                this.finished(EnemyAI_1.EnemyStates.TARGETING);
            }
        }
        onExit() {
            return this.retObj;
        }
    }
    exports.default = Guard;
    },{"../../../mayhemFiles/AI/EnemyAI":117,"../../DataTypes/Vec2":32,"../../constants":115,"./EnemyState":8}],10:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Vec2_1 = require("../../DataTypes/Vec2");
    const constants_1 = require("../../constants");
    const EnemyAI_1 = require("../../../mayhemFiles/AI/EnemyAI");
    const EnemyState_1 = require("./EnemyState");
    class Patrol extends EnemyState_1.default {
        constructor(parent, owner, patrolRoute) {
            super(parent, owner);
            this.patrolRoute = patrolRoute;
            this.routeIndex = 0;
        }
        onEnter(options) {
            this.currentPath = this.getNextPath();
        }
        handleInput(event) { }
        update(deltaT) {
            // If the enemy sees the player, start attacking
            this.parent.lastPlayerPos = this.parent.getPlayerPosition();
            if (this.parent.lastPlayerPos !== null) {
                this.finished(EnemyAI_1.EnemyStates.TARGETING);
            }
            else {
                //Move along patrol path
                if (this.currentPath.isDone()) {
                    this.currentPath = this.getNextPath();
                }
                else {
                    this.owner.moveOnPath(this.parent.speed * deltaT, this.currentPath);
                    this.owner.rotation = Vec2_1.default.UP.angleToCCW(this.currentPath.getMoveDirection(this.owner));
                }
            }
        }
        onExit() {
            return this.retObj;
        }
        getNextPath() {
            let path = this.owner.getScene().getNavigationManager().getPath(constants_1.hw4_Names.NAVMESH, this.owner.position, this.patrolRoute[this.routeIndex]);
            this.routeIndex = (this.routeIndex + 1) % this.patrolRoute.length;
            return path;
        }
    }
    exports.default = Patrol;
    },{"../../../mayhemFiles/AI/EnemyAI":117,"../../DataTypes/Vec2":32,"../../constants":115,"./EnemyState":8}],11:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Graph_1 = require("../DataTypes/Graphs/Graph");
    const Stack_1 = require("../DataTypes/Stack");
    const GraphUtils_1 = require("../Utils/GraphUtils");
    class GoapActionPlanner {
        plan(goal, possibleActions, currentStatus, actor) {
            this.graph = new Graph_1.default(true);
            this.mapping = new Map();
            //0 is our root
            this.graph.addNode();
            this.mapping.set(0, "Start");
            //1 is the goal
            this.graph.addNode();
            this.mapping.set(1, "Goal");
            this.graph.addEdge(1, 1, Number.POSITIVE_INFINITY);
            //Build tree from 0 to 1
            this.buildTree(0, goal, possibleActions, currentStatus);
            //console.log(this.graph.toString());
            //Run djikstra to find shortest path
            this.path = GraphUtils_1.default.djikstra(this.graph, 0);
            //Push all elements of the plan
            let plan = new Stack_1.default();
            let i = 1;
            while (this.path[i] !== -1) {
                //console.log(this.path[i]);
                if (this.path[i] !== 0) {
                    plan.push(this.mapping.get(this.path[i]));
                }
                i = this.path[i];
            }
            return plan;
        }
        buildTree(root, goal, possibleActions, currentStatus) {
            //For each possible action 
            possibleActions.forEach(action => {
                /*console.log("root:" + root + ",action precons:" + action.preconditions.toString()
                    + ", action effects:" + action.effects.toString() + ", current Status:" + currentStatus.toString())*/
                //Can it be performed?
                if (action.checkPreconditions(currentStatus)) {
                    //This action can be performed
                    //Add effects to currentStatus
                    let newStatus = [...currentStatus];
                    newStatus.push(...action.effects);
                    //Check if the new node is the goal
                    if (newStatus.includes(goal)) {
                        //console.log("AT GOAL");
                        let newNode = this.graph.addNode() - 1;
                        this.mapping.set(newNode, action);
                        this.graph.addEdge(root, newNode, action.cost);
                        this.graph.addEdge(newNode, 1, 0);
                        return;
                    }
                    //Add node and edge from root
                    let newNode = this.graph.addNode() - 1;
                    this.mapping.set(newNode, action);
                    this.graph.addEdge(root, newNode, action.cost);
                    //Recursive call
                    //console.log(possibleActions.indexOf(action))
                    let newActions = possibleActions.filter(act => act !== action);
                    this.buildTree(newNode, goal, newActions, action.effects);
                }
            });
        }
    }
    exports.default = GoapActionPlanner;
    },{"../DataTypes/Graphs/Graph":15,"../DataTypes/Stack":28,"../Utils/GraphUtils":111}],12:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const StateMachine_1 = require("../DataTypes/State/StateMachine");
    /**
     * A version of a @reference[StateMachine] that is configured to work as an AI controller for a @reference[GameNode]
     */
    class StateMachineGoapAI extends StateMachine_1.default {
        // @implemented
        initializeAI(owner, config) { }
        // @implemented
        destroy() {
            // Get rid of our reference to the owner
            delete this.owner;
            this.receiver.destroy();
        }
        // @implemented
        activate(options) { }
        changeGoal(goal) { }
    }
    exports.default = StateMachineGoapAI;
    },{"../DataTypes/State/StateMachine":30}],13:[function(require,module,exports){
    "use strict";
    // @ignorePage
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A placeholder function for No Operation. Does nothing
     */
    const NullFunc = () => { };
    exports.default = NullFunc;
    },{}],14:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A linked-list for the edges in a @reference[Graph].
     */
    class EdgeNode {
        /**
         * Creates a new EdgeNode
         * @param index The index of the node this edge connects to
         * @param weight The weight of this edge
         */
        constructor(index, weight) {
            this.y = index;
            this.next = null;
            this.weight = weight ? weight : 1;
        }
    }
    exports.default = EdgeNode;
    },{}],15:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MAX_V = void 0;
    const EdgeNode_1 = require("./EdgeNode");
    exports.MAX_V = 100;
    /**
     * An implementation of a graph data structure using edge lists. Inspired by The Algorithm Design Manual.
     */
    class Graph {
        /**
         * Constructs a new graph
         * @param directed Whether or not this graph is directed
         */
        constructor(directed = false) {
            this.directed = directed;
            this.weighted = false;
            this.numVertices = 0;
            this.numEdges = 0;
            this.edges = new Array(exports.MAX_V);
            this.degree = new Array(exports.MAX_V);
        }
        /** Adds a node to this graph and returns the index of it
         * @returns The index of the new node
        */
        addNode() {
            this.numVertices++;
            return this.numVertices;
        }
        /** Adds an edge between node x and y, with an optional weight
         * @param x The index of the start of the edge
         * @param y The index of the end of the edge
         * @param weight The optional weight of the new edge
        */
        addEdge(x, y, weight) {
            let edge = new EdgeNode_1.default(y, weight);
            if (this.edges[x]) {
                edge.next = this.edges[x];
            }
            this.edges[x] = edge;
            if (!this.directed) {
                edge = new EdgeNode_1.default(x, weight);
                if (this.edges[y]) {
                    edge.next = this.edges[y];
                }
                this.edges[y] = edge;
            }
            this.numEdges += 1;
        }
        /**
         * Checks whether or not an edge exists between two nodes.
         * This check is directional if this is a directed graph.
         * @param x The first node
         * @param y The second node
         * @returns true if an edge exists, false otherwise
         */
        edgeExists(x, y) {
            let edge = this.edges[x];
            while (edge !== null) {
                if (edge.y === y) {
                    return true;
                }
                edge = edge.next;
            }
        }
        /**
         * Gets the edge list associated with node x
         * @param x The index of the node
         * @returns The head of a linked-list of edges
         */
        getEdges(x) {
            return this.edges[x];
        }
        /**
         * Gets the degree associated with node x
         * @param x The index of the node
         */
        getDegree(x) {
            return this.degree[x];
        }
        /**
         * Converts the specifed node into a string
         * @param index The index of the node to convert to a string
         * @returns The string representation of the node: "Node x"
         */
        nodeToString(index) {
            return "Node " + index;
        }
        /**
         * Converts the Graph into a string format
         * @returns The graph as a string
         */
        toString() {
            let retval = "";
            for (let i = 0; i < this.numVertices; i++) {
                let edge = this.edges[i];
                let edgeStr = "";
                while (edge !== undefined && edge !== null) {
                    edgeStr += edge.y.toString();
                    if (this.weighted) {
                        edgeStr += " (" + edge.weight + ")";
                    }
                    if (edge.next !== null) {
                        edgeStr += ", ";
                    }
                    edge = edge.next;
                }
                retval += this.nodeToString(i) + ": " + edgeStr + "\n";
            }
            return retval;
        }
    }
    exports.default = Graph;
    },{"./EdgeNode":14}],16:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Graph_1 = require("./Graph");
    /**
     * An extension of Graph that has nodes with positions in 2D space.
     * This is a weighted graph (though not inherently directd)
    */
    class PositionGraph extends Graph_1.default {
        /**
         * Createes a new PositionGraph
         * @param directed Whether or not this graph is directed
         */
        constructor(directed = false) {
            super(directed);
            this.debugRender = () => {
                // for(let point of this.positions){
                // 	ctx.fillRect((point.x - origin.x - 4)*zoom, (point.y - origin.y - 4)*zoom, 8, 8);
                // }
            };
            this.positions = new Array(Graph_1.MAX_V);
        }
        /**
         * Adds a positioned node to this graph
         * @param position The position of the node to add
         * @returns The index of the added node
         */
        addPositionedNode(position) {
            this.positions[this.numVertices] = position;
            return this.addNode();
        }
        /**
         * Changes the position of a node.
         * Automatically adjusts the weights of the graph tied to this node.
         * As such, be warned that this function has an O(n + m) running time, and use it sparingly.
         * @param index The index of the node
         * @param position The new position of the node
         */
        setNodePosition(index, position) {
            this.positions[index] = position;
            // Recalculate all weights associated with this index
            for (let i = 0; i < this.numEdges; i++) {
                let edge = this.edges[i];
                while (edge !== null) {
                    // If this node is on either side of the edge, recalculate weight
                    if (i === index || edge.y === index) {
                        edge.weight = this.positions[i].distanceTo(this.positions[edge.y]);
                    }
                    edge = edge.next;
                }
            }
        }
        /**
         * Gets the position of a node
         * @param index The index of the node
         * @returns The position of the node
         */
        getNodePosition(index) {
            return this.positions[index];
        }
        /**
         * Adds an edge to this graph between node x and y.
         * Automatically calculates the weight of the edge as the distance between the nodes.
         * @param x The beginning of the edge
         * @param y The end of the edge
         */
        addEdge(x, y) {
            if (!this.positions[x] || !this.positions[y]) {
                throw "Can't add edge to un-positioned node!";
            }
            // Weight is the distance between the nodes
            let weight = this.positions[x].distanceTo(this.positions[y]);
            super.addEdge(x, y, weight);
        }
        // @override
        nodeToString(index) {
            return "Node " + index + " - " + this.positions[index].toString();
        }
    }
    exports.default = PositionGraph;
    },{"./Graph":15}],17:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class GoapAction {
        /** Check preconditions with current statuses to see if action can be performed */
        checkPreconditions(statuses) {
            // Check that every element in the preconditions array is found in the statuses array
            return (this.preconditions.every((status) => {
                if (!statuses.includes(status)) {
                    return false;
                }
                return true;
            }));
        }
        /** Add one or more preconditions to this action */
        addPrecondition(preconditions) {
            this.preconditions.push(...preconditions);
        }
        /** Add one or more effects to this action */
        addEffect(effects) {
            this.effects.push(...effects);
        }
        /** Removes an precondition, returns true if successful */
        removePrecondition(precondition) {
            throw new Error("Method not implemented.");
        }
        /** Removes an precondition, returns true if successful */
        removeEffect(effect) {
            throw new Error("Method not implemented.");
        }
    }
    exports.default = GoapAction;
    },{}],18:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isRegion = void 0;
    function isRegion(arg) {
        return arg && arg.size && arg.scale && arg.boundary;
    }
    exports.isRegion = isRegion;
    },{}],19:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Associates strings with elements of type T
     */
    class Map {
        /** Creates a new map */
        constructor() {
            this.map = {};
        }
        /**
         * Adds a value T stored at a key.
         * @param key The key of the item to be stored
         * @param value The item to be stored
         */
        add(key, value) {
            this.map[key] = value;
        }
        /**
         * Get the value associated with a key.
         * @param key The key of the item
         * @returns The item at the key or undefined
         */
        get(key) {
            return this.map[key];
        }
        /**
         * An alias of add. Sets the value stored at key to the new specified value
         * @param key The key of the item to be stored
         * @param value The item to be stored
         */
        set(key, value) {
            this.add(key, value);
        }
        /**
         * Returns true if there is a value stored at the specified key, false otherwise.
         * @param key The key to check
         * @returns A boolean representing whether or not there is an item at the given key.
         */
        has(key) {
            return this.map[key] !== undefined;
        }
        /**
         * Returns an array of all of the keys in this map.
         * @returns An array containing all keys in the map.
         */
        keys() {
            return Object.keys(this.map);
        }
        // @implemented
        forEach(func) {
            Object.keys(this.map).forEach(key => func(key));
        }
        /**
         * Deletes an item associated with a key
         * @param key The key at which to delete an item
         */
        delete(key) {
            delete this.map[key];
        }
        // @implemented
        clear() {
            this.forEach(key => delete this.map[key]);
        }
        /**
         * Converts this map to a string representation.
         * @returns The string representation of this map.
         */
        toString() {
            let str = "";
            this.forEach((key) => str += key + " -> " + this.get(key).toString() + "\n");
            return str;
        }
    }
    exports.default = Map;
    },{}],20:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Vec2_1 = require("./Vec2");
    /** A 4x4 matrix0 */
    class Mat4x4 {
        constructor() {
            this.mat = new Float32Array([
                0, 0, 0, 0,
                0, 0, 0, 0,
                0, 0, 0, 0,
                0, 0, 0, 0
            ]);
        }
        // Static members
        static get IDENTITY() {
            return new Mat4x4().identity();
        }
        static get ZERO() {
            return new Mat4x4().zero();
        }
        // Accessors
        set _00(x) {
            this.mat[0] = x;
        }
        set(col, row, value) {
            if (col < 0 || col > 3 || row < 0 || row > 3) {
                throw `Error - index (${col}, ${row}) is out of bounds for Mat4x4`;
            }
            this.mat[row * 4 + col] = value;
            return this;
        }
        get(col, row) {
            return this.mat[row * 4 + col];
        }
        setAll(...items) {
            this.mat.set(items);
            return this;
        }
        identity() {
            return this.setAll(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }
        zero() {
            return this.setAll(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
        /**
         * Makes this Mat4x4 a rotation matrix of the specified number of radians ccw
         * @param zRadians The number of radians to rotate
         * @returns this Mat4x4
         */
        rotate(zRadians) {
            return this.setAll(Math.cos(zRadians), -Math.sin(zRadians), 0, 0, Math.sin(zRadians), Math.cos(zRadians), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }
        /**
         * Turns this Mat4x4 into a translation matrix of the specified translation
         * @param translation The translation in x and y
         * @returns this Mat4x4
         */
        translate(translation) {
            // If translation is a vec, get its array
            if (translation instanceof Vec2_1.default) {
                translation = translation.toArray();
            }
            return this.setAll(1, 0, 0, translation[0], 0, 1, 0, translation[1], 0, 0, 1, 0, 0, 0, 0, 1);
        }
        scale(scale) {
            // Make sure scale is a float32Array
            if (scale instanceof Vec2_1.default) {
                scale = scale.toArray();
            }
            else if (!(scale instanceof Float32Array)) {
                scale = new Float32Array([scale, scale]);
            }
            return this.setAll(scale[0], 0, 0, 0, 0, scale[1], 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }
        /**
         * Returns a new Mat4x4 that represents the right side multiplication THIS x OTHER
         * @param other The other Mat4x4 to multiply by
         * @returns a new Mat4x4 containing the product of these two Mat4x4s
         */
        mult(other, out) {
            let temp = new Float32Array(16);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    let value = 0;
                    for (let k = 0; k < 4; k++) {
                        value += this.get(k, i) * other.get(j, k);
                    }
                    temp[j * 4 + i] = value;
                }
            }
            if (out !== undefined) {
                return out.setAll(...temp);
            }
            else {
                return new Mat4x4().setAll(...temp);
            }
        }
        /**
         * Multiplies all given matricies in order. e.g. MULT(A, B, C) -> A*B*C
         * @param mats A list of Mat4x4s to multiply in order
         * @returns A new Mat4x4 holding the result of the operation
         */
        static MULT(...mats) {
            // Create a new array
            let temp = Mat4x4.IDENTITY;
            // Multiply by every array in order, in place
            for (let i = 0; i < mats.length; i++) {
                temp.mult(mats[i], temp);
            }
            return temp;
        }
        toArray() {
            return this.mat;
        }
        toString() {
            return `|${this.mat[0].toFixed(2)}, ${this.mat[1].toFixed(2)}, ${this.mat[2].toFixed(2)}, ${this.mat[3].toFixed(2)}|\n` +
                `|${this.mat[4].toFixed(2)}, ${this.mat[5].toFixed(2)}, ${this.mat[6].toFixed(2)}, ${this.mat[7].toFixed(2)}|\n` +
                `|${this.mat[8].toFixed(2)}, ${this.mat[9].toFixed(2)}, ${this.mat[10].toFixed(2)}, ${this.mat[11].toFixed(2)}|\n` +
                `|${this.mat[12].toFixed(2)}, ${this.mat[13].toFixed(2)}, ${this.mat[14].toFixed(2)}, ${this.mat[15].toFixed(2)}|`;
        }
    }
    exports.default = Mat4x4;
    },{"./Vec2":32}],21:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A class that contains the area of overlap of two colliding objects to allow for sorting by the physics system.
     */
    class AreaCollision {
        /**
         * Creates a new AreaCollision object
         * @param area The area of the collision
         * @param collider The other collider
         */
        constructor(area, collider, other, type, tile) {
            this.area = area;
            this.collider = collider;
            this.other = other;
            this.type = type;
            this.tile = tile;
        }
    }
    exports.default = AreaCollision;
    },{}],22:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Vec2_1 = require("../Vec2");
    /**
     * An object representing the data collected from a physics hit between two geometric objects.
     * Inspired by the helpful collision documentation @link(here)(https://noonat.github.io/intersect/).
     */
    class Hit {
        constructor() {
            /** The near times of the collision */
            this.nearTimes = Vec2_1.default.ZERO;
            /** The position of the collision */
            this.pos = Vec2_1.default.ZERO;
            /** The overlap distance of the hit */
            this.delta = Vec2_1.default.ZERO;
            /** The normal vector of the hit */
            this.normal = Vec2_1.default.ZERO;
        }
    }
    exports.default = Hit;
    },{"../Vec2":32}],23:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A FIFO queue with elements of type T
     */
    class Queue {
        /**
         * Constructs a new queue
         * @param maxElements The maximum size of the stack
         */
        constructor(maxElements = 100) {
            this.MAX_ELEMENTS = maxElements;
            this.q = new Array(this.MAX_ELEMENTS);
            this.head = 0;
            this.tail = 0;
            this.size = 0;
        }
        /**
         * Adds an item to the back of the queue
         * @param item The item to add to the back of the queue
         */
        enqueue(item) {
            if ((this.tail + 1) % this.MAX_ELEMENTS === this.head) {
                throw new Error("Queue full - cannot add element");
            }
            this.size += 1;
            this.q[this.tail] = item;
            this.tail = (this.tail + 1) % this.MAX_ELEMENTS;
        }
        /**
         * Retrieves an item from the front of the queue
         * @returns The item at the front of the queue
         */
        dequeue() {
            if (this.head === this.tail) {
                throw new Error("Queue empty - cannot remove element");
            }
            this.size -= 1;
            let item = this.q[this.head];
            // Now delete the item
            delete this.q[this.head];
            this.head = (this.head + 1) % this.MAX_ELEMENTS;
            return item;
        }
        /**
         * Returns the item at the front of the queue, but does not remove it
         * @returns The item at the front of the queue
         */
        peekNext() {
            if (this.head === this.tail) {
                throw "Queue empty - cannot get element";
            }
            let item = this.q[this.head];
            return item;
        }
        /**
         * Returns true if the queue has items in it, false otherwise
         * @returns A boolean representing whether or not this queue has items
         */
        hasItems() {
            return this.head !== this.tail;
        }
        /**
         * Returns the number of elements in the queue.
         * @returns The size of the queue
         */
        getSize() {
            return this.size;
        }
        // @implemented
        clear() {
            this.forEach((item, index) => delete this.q[index]);
            this.size = 0;
            this.head = this.tail;
        }
        // @implemented
        forEach(func) {
            let i = this.head;
            while (i !== this.tail) {
                func(this.q[i], i);
                i = (i + 1) % this.MAX_ELEMENTS;
            }
        }
        /**
         * Converts this queue into a string format
         * @returns A string representing this queue
         */
        toString() {
            let retval = "";
            this.forEach((item, index) => {
                let str = item.toString();
                if (index !== 0) {
                    str += " -> ";
                }
                retval = str + retval;
            });
            return "Top -> " + retval;
        }
    }
    exports.default = Queue;
    },{}],24:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /** A container for info about a webGL shader program */
    class WebGLProgramType {
        /**
         * Deletes this shader program
         */
        delete(gl) {
            // Clean up all aspects of this program
            if (this.program) {
                gl.deleteProgram(this.program);
            }
            if (this.vertexShader) {
                gl.deleteShader(this.vertexShader);
            }
            if (this.fragmentShader) {
                gl.deleteShader(this.fragmentShader);
            }
        }
    }
    exports.default = WebGLProgramType;
    },{}],25:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Shape_1 = require("./Shape");
    const Vec2_1 = require("../Vec2");
    const MathUtils_1 = require("../../Utils/MathUtils");
    const Circle_1 = require("./Circle");
    const Hit_1 = require("../Physics/Hit");
    /**
     * An Axis-Aligned Bounding Box. In other words, a rectangle that is always aligned to the x-y grid.
     * Inspired by the helpful collision documentation @link(here)(https://noonat.github.io/intersect/).
     */
    class AABB extends Shape_1.default {
        /**
         * Creates a new AABB
         * @param center The center of the AABB
         * @param halfSize The half size of the AABB - The distance from the center to an edge in x and y
         */
        constructor(center, halfSize) {
            super();
            this.center = center ? center : new Vec2_1.default(0, 0);
            this.halfSize = halfSize ? halfSize : new Vec2_1.default(0, 0);
        }
        /** Returns a point representing the top left corner of the AABB */
        get topLeft() {
            return new Vec2_1.default(this.left, this.top);
        }
        /** Returns a point representing the top right corner of the AABB */
        get topRight() {
            return new Vec2_1.default(this.right, this.top);
        }
        /** Returns a point representing the bottom left corner of the AABB */
        get bottomLeft() {
            return new Vec2_1.default(this.left, this.bottom);
        }
        /** Returns a point representing the bottom right corner of the AABB */
        get bottomRight() {
            return new Vec2_1.default(this.right, this.bottom);
        }
        // @override
        getBoundingRect() {
            return this.clone();
        }
        // @override
        getBoundingCircle() {
            let r = Math.max(this.hw, this.hh);
            return new Circle_1.default(this.center.clone(), r);
        }
        // @deprecated
        getHalfSize() {
            return this.halfSize;
        }
        // @deprecated
        setHalfSize(halfSize) {
            this.halfSize = halfSize;
        }
        // TODO - move these all to the Shape class
        /**
         * A simple boolean check of whether this AABB contains a point
         * @param point The point to check
         * @returns A boolean representing whether this AABB contains the specified point
         */
        containsPoint(point) {
            return point.x >= this.x - this.hw && point.x <= this.x + this.hw
                && point.y >= this.y - this.hh && point.y <= this.y + this.hh;
        }
        /**
         * A simple boolean check of whether this AABB contains a point
         * @param point The point to check
         * @returns A boolean representing whether this AABB contains the specified point
         */
        intersectPoint(point) {
            let dx = point.x - this.x;
            let px = this.hw - Math.abs(dx);
            if (px <= 0) {
                return false;
            }
            let dy = point.y - this.y;
            let py = this.hh - Math.abs(dy);
            if (py <= 0) {
                return false;
            }
            return true;
        }
        /**
         * A boolean check of whether this AABB contains a point with soft left and top boundaries.
         * In other words, if the top left is (0, 0), the point (0, 0) is not in the AABB
         * @param point The point to check
         * @returns A boolean representing whether this AABB contains the specified point
         */
        containsPointSoft(point) {
            return point.x > this.x - this.hw && point.x <= this.x + this.hw
                && point.y > this.y - this.hh && point.y <= this.y + this.hh;
        }
        /**
         * Returns the data from the intersection of this AABB with a line segment from a point in a direction
         * @param point The point that the line segment starts from
         * @param delta The direction and distance of the segment
         * @param padding Pads the AABB to make it wider for the intersection test
         * @returns The Hit object representing the intersection, or null if there was no intersection
         */
        intersectSegment(point, delta, padding) {
            let paddingX = padding ? padding.x : 0;
            let paddingY = padding ? padding.y : 0;
            let scaleX = 1 / delta.x;
            let scaleY = 1 / delta.y;
            let signX = MathUtils_1.default.sign(scaleX);
            let signY = MathUtils_1.default.sign(scaleY);
            let tnearx = scaleX * (this.x - signX * (this.hw + paddingX) - point.x);
            let tneary = scaleY * (this.y - signY * (this.hh + paddingY) - point.y);
            let tfarx = scaleX * (this.x + signX * (this.hw + paddingX) - point.x);
            let tfary = scaleY * (this.y + signY * (this.hh + paddingY) - point.y);
            if (tnearx > tfary || tneary > tfarx) {
                // We aren't colliding - we clear one axis before intersecting another
                return null;
            }
            let tnear = Math.max(tnearx, tneary);
            // Double check for NaNs
            if (tnearx !== tnearx) {
                tnear = tneary;
            }
            else if (tneary !== tneary) {
                tnear = tnearx;
            }
            let tfar = Math.min(tfarx, tfary);
            if (tnear === -Infinity) {
                return null;
            }
            if (tnear >= 1 || tfar <= 0) {
                return null;
            }
            // We are colliding
            let hit = new Hit_1.default();
            hit.time = MathUtils_1.default.clamp01(tnear);
            hit.nearTimes.x = tnearx;
            hit.nearTimes.y = tneary;
            if (tnearx > tneary) {
                // We hit on the left or right size
                hit.normal.x = -signX;
                hit.normal.y = 0;
            }
            else if (Math.abs(tnearx - tneary) < 0.0001) {
                // We hit on the corner
                hit.normal.x = -signX;
                hit.normal.y = -signY;
                hit.normal.normalize();
            }
            else {
                // We hit on the top or bottom
                hit.normal.x = 0;
                hit.normal.y = -signY;
            }
            hit.delta.x = (1.0 - hit.time) * -delta.x;
            hit.delta.y = (1.0 - hit.time) * -delta.y;
            hit.pos.x = point.x + delta.x * hit.time;
            hit.pos.y = point.y + delta.y * hit.time;
            return hit;
        }
        // @override
        overlaps(other) {
            if (other instanceof AABB) {
                return this.overlapsAABB(other);
            }
            throw "Overlap not defined between these shapes.";
        }
        /**
         * A simple boolean check of whether this AABB overlaps another
         * @param other The other AABB to check against
         * @returns True if this AABB overlaps the other, false otherwise
         */
        overlapsAABB(other) {
            let dx = other.x - this.x;
            let px = this.hw + other.hw - Math.abs(dx);
            if (px <= 0) {
                return false;
            }
            let dy = other.y - this.y;
            let py = this.hh + other.hh - Math.abs(dy);
            if (py <= 0) {
                return false;
            }
            return true;
        }
        /**
         * Determines whether these AABBs are JUST touching - not overlapping.
         * Vec2.x is -1 if the other is to the left, 1 if to the right.
         * Likewise, Vec2.y is -1 if the other is on top, 1 if on bottom.
         * @param other The other AABB to check
         * @returns The collision sides stored in a Vec2 if the AABBs are touching, null otherwise
         */
        touchesAABB(other) {
            let dx = other.x - this.x;
            let px = this.hw + other.hw - Math.abs(dx);
            let dy = other.y - this.y;
            let py = this.hh + other.hh - Math.abs(dy);
            // If one axis is just touching and the other is overlapping, true
            if ((px === 0 && py >= 0) || (py === 0 && px >= 0)) {
                let ret = new Vec2_1.default();
                if (px === 0) {
                    ret.x = other.x < this.x ? -1 : 1;
                }
                if (py === 0) {
                    ret.y = other.y < this.y ? -1 : 1;
                }
                return ret;
            }
            else {
                return null;
            }
        }
        /**
         * Determines whether these AABBs are JUST touching - not overlapping.
         * Also, if they are only touching corners, they are considered not touching.
         * Vec2.x is -1 if the other is to the left, 1 if to the right.
         * Likewise, Vec2.y is -1 if the other is on top, 1 if on bottom.
         * @param other The other AABB to check
         * @returns The side of the touch, stored as a Vec2, or null if there is no touch
         */
        touchesAABBWithoutCorners(other) {
            let dx = other.x - this.x;
            let px = this.hw + other.hw - Math.abs(dx);
            let dy = other.y - this.y;
            let py = this.hh + other.hh - Math.abs(dy);
            // If one axis is touching, and the other is strictly overlapping
            if ((px === 0 && py > 0) || (py === 0 && px > 0)) {
                let ret = new Vec2_1.default();
                if (px === 0) {
                    ret.x = other.x < this.x ? -1 : 1;
                }
                else {
                    ret.y = other.y < this.y ? -1 : 1;
                }
                return ret;
            }
            else {
                return null;
            }
        }
        /**
         * Calculates the area of the overlap between this AABB and another
         * @param other The other AABB
         * @returns The area of the overlap between the AABBs
         */
        overlapArea(other) {
            let leftx = Math.max(this.x - this.hw, other.x - other.hw);
            let rightx = Math.min(this.x + this.hw, other.x + other.hw);
            let dx = rightx - leftx;
            let lefty = Math.max(this.y - this.hh, other.y - other.hh);
            let righty = Math.min(this.y + this.hh, other.y + other.hh);
            let dy = righty - lefty;
            if (dx < 0 || dy < 0)
                return 0;
            return dx * dy;
        }
        /**
         * Moves and resizes this rect from its current position to the position specified
         * @param velocity The movement of the rect from its position
         * @param fromPosition A position specified to be the starting point of sweeping
         * @param halfSize The halfSize of the sweeping rect
         */
        sweep(velocity, fromPosition, halfSize) {
            if (!fromPosition) {
                fromPosition = this.center;
            }
            if (!halfSize) {
                halfSize = this.halfSize;
            }
            let centerX = fromPosition.x + velocity.x / 2;
            let centerY = fromPosition.y + velocity.y / 2;
            let minX = Math.min(fromPosition.x - halfSize.x, fromPosition.x + velocity.x - halfSize.x);
            let minY = Math.min(fromPosition.y - halfSize.y, fromPosition.y + velocity.y - halfSize.y);
            this.center.set(centerX, centerY);
            this.halfSize.set(centerX - minX, centerY - minY);
        }
        // @override
        clone() {
            return new AABB(this.center.clone(), this.halfSize.clone());
        }
        /**
         * Converts this AABB to a string format
         * @returns (center: (x, y), halfSize: (x, y))
         */
        toString() {
            return "(center: " + this.center.toString() + ", half-size: " + this.halfSize.toString() + ")";
        }
    }
    exports.default = AABB;
    },{"../../Utils/MathUtils":112,"../Physics/Hit":22,"../Vec2":32,"./Circle":26,"./Shape":27}],26:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Vec2_1 = require("../Vec2");
    const AABB_1 = require("./AABB");
    const Shape_1 = require("./Shape");
    /**
     * A Circle
     */
    class Circle extends Shape_1.default {
        /**
         * Creates a new Circle
         * @param center The center of the circle
         * @param radius The radius of the circle
         */
        constructor(center, radius) {
            super();
            this._center = center ? center : new Vec2_1.default(0, 0);
            this.radius = radius ? radius : 0;
        }
        get center() {
            return this._center;
        }
        set center(center) {
            this._center = center;
        }
        get halfSize() {
            return new Vec2_1.default(this.radius, this.radius);
        }
        get r() {
            return this.radius;
        }
        set r(radius) {
            this.radius = radius;
        }
        // @override
        /**
         * A simple boolean check of whether this AABB contains a point
         * @param point The point to check
         * @returns A boolean representing whether this AABB contains the specified point
         */
        containsPoint(point) {
            return this.center.distanceSqTo(point) <= this.radius * this.radius;
        }
        // @override
        getBoundingRect() {
            return new AABB_1.default(this._center.clone(), new Vec2_1.default(this.radius, this.radius));
        }
        // @override
        getBoundingCircle() {
            return this.clone();
        }
        // @override
        overlaps(other) {
            throw new Error("Method not implemented.");
        }
        // @override
        clone() {
            return new Circle(this._center.clone(), this.radius);
        }
        toString() {
            return "(center: " + this.center.toString() + ", radius: " + this.radius + ")";
        }
    }
    exports.default = Circle;
    },{"../Vec2":32,"./AABB":25,"./Shape":27}],27:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Vec2_1 = require("../Vec2");
    const AABB_1 = require("./AABB");
    /**
     * An abstract Shape class that acts as an interface for better interactions with subclasses.
     */
    class Shape {
        get x() {
            return this.center.x;
        }
        get y() {
            return this.center.y;
        }
        get hw() {
            return this.halfSize.x;
        }
        get hh() {
            return this.halfSize.y;
        }
        get top() {
            return this.y - this.hh;
        }
        get bottom() {
            return this.y + this.hh;
        }
        get left() {
            return this.x - this.hw;
        }
        get right() {
            return this.x + this.hw;
        }
        static getTimeOfCollision(A, velA, B, velB) {
            if (A instanceof AABB_1.default && B instanceof AABB_1.default) {
                return Shape.getTimeOfCollision_AABB_AABB(A, velA, B, velB);
            }
        }
        static getTimeOfCollision_AABB_AABB(A, velA, B, velB) {
            let posSmaller = A.center;
            let posLarger = B.center;
            let sizeSmaller = A.halfSize;
            let sizeLarger = B.halfSize;
            let firstContact = new Vec2_1.default(0, 0);
            let lastContact = new Vec2_1.default(0, 0);
            let collidingX = false;
            let collidingY = false;
            // Sort by position
            if (posLarger.x < posSmaller.x) {
                // Swap, because smaller is further right than larger
                let temp;
                temp = sizeSmaller;
                sizeSmaller = sizeLarger;
                sizeLarger = temp;
                temp = posSmaller;
                posSmaller = posLarger;
                posLarger = temp;
                temp = velA;
                velA = velB;
                velB = temp;
            }
            // A is left, B is right
            firstContact.x = Infinity;
            lastContact.x = Infinity;
            if (posLarger.x - sizeLarger.x >= posSmaller.x + sizeSmaller.x) {
                // If we aren't currently colliding
                let relVel = velA.x - velB.x;
                if (relVel > 0) {
                    // If they are moving towards each other
                    firstContact.x = ((posLarger.x - sizeLarger.x) - (posSmaller.x + sizeSmaller.x)) / (relVel);
                    lastContact.x = ((posLarger.x + sizeLarger.x) - (posSmaller.x - sizeSmaller.x)) / (relVel);
                }
            }
            else {
                collidingX = true;
            }
            if (posLarger.y < posSmaller.y) {
                // Swap, because smaller is further up than larger
                let temp;
                temp = sizeSmaller;
                sizeSmaller = sizeLarger;
                sizeLarger = temp;
                temp = posSmaller;
                posSmaller = posLarger;
                posLarger = temp;
                temp = velA;
                velA = velB;
                velB = temp;
            }
            // A is top, B is bottom
            firstContact.y = Infinity;
            lastContact.y = Infinity;
            if (posLarger.y - sizeLarger.y >= posSmaller.y + sizeSmaller.y) {
                // If we aren't currently colliding
                let relVel = velA.y - velB.y;
                if (relVel > 0) {
                    // If they are moving towards each other
                    firstContact.y = ((posLarger.y - sizeLarger.y) - (posSmaller.y + sizeSmaller.y)) / (relVel);
                    lastContact.y = ((posLarger.y + sizeLarger.y) - (posSmaller.y - sizeSmaller.y)) / (relVel);
                }
            }
            else {
                collidingY = true;
            }
            return [firstContact, lastContact, collidingX, collidingY];
        }
    }
    exports.default = Shape;
    },{"../Vec2":32,"./AABB":25}],28:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A LIFO stack with items of type T
     */
    class Stack {
        /**
         * Constructs a new stack
         * @param maxElements The maximum size of the stack
         */
        constructor(maxElements = 100) {
            this.MAX_ELEMENTS = maxElements;
            this.stack = new Array(this.MAX_ELEMENTS);
            this.head = -1;
        }
        /**
         * Adds an item to the top of the stack
         * @param item The new item to add to the stack
         */
        push(item) {
            if (this.head + 1 === this.MAX_ELEMENTS) {
                throw "Stack full - cannot add element";
            }
            this.head += 1;
            this.stack[this.head] = item;
        }
        /**
         * Removes an item from the top of the stack
         * @returns The item at the top of the stack
         */
        pop() {
            if (this.head === -1) {
                throw "Stack empty - cannot remove element";
            }
            this.head -= 1;
            return this.stack[this.head + 1];
        }
        /**
         * Returns the element currently at the top of the stack
         * @returns The item at the top of the stack
         */
        peek() {
            if (this.head === -1) {
                throw "Stack empty - cannot get element";
            }
            return this.stack[this.head];
        }
        /** Returns true if this stack is empty
         * @returns A boolean that represents whether or not the stack is empty
        */
        isEmpty() {
            return this.head === -1;
        }
        // @implemented
        clear() {
            this.forEach((item, index) => delete this.stack[index]);
            this.head = -1;
        }
        /**
         * Returns the number of items currently in the stack
         * @returns The number of items in the stack
         */
        size() {
            return this.head + 1;
        }
        // @implemented
        forEach(func) {
            let i = 0;
            while (i <= this.head) {
                func(this.stack[i], i);
                i += 1;
            }
        }
        /**
         * Converts this stack into a string format
         * @returns A string representing this stack
         */
        toString() {
            let retval = "";
            this.forEach((item, index) => {
                let str = item.toString();
                if (index !== 0) {
                    str += " -> ";
                }
                retval = str + retval;
            });
            return "Top -> " + retval;
        }
    }
    exports.default = Stack;
    },{}],29:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Emitter_1 = require("../../Events/Emitter");
    /**
     * An abstract implementation of a state for a @reference[StateMachine].
     * This class should be extended to allow for custom state behaviors.
     */
    class State {
        /**
         * Constructs a new State
         * @param parent The parent StateMachine of this state
         */
        constructor(parent) {
            this.parent = parent;
            this.emitter = new Emitter_1.default();
        }
        /**
         * Tells the state machine that this state has ended, and makes it transition to the new state specified
         * @param stateName The name of the state to transition to
         */
        finished(stateName) {
            this.parent.changeState(stateName);
        }
    }
    exports.default = State;
    },{"../../Events/Emitter":35}],30:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Stack_1 = require("../Stack");
    const Map_1 = require("../Map");
    const Receiver_1 = require("../../Events/Receiver");
    const Emitter_1 = require("../../Events/Emitter");
    /**
     * An implementation of a Push Down Automata State machine. States can also be hierarchical
     * for more flexibility, as described in @link(Game Programming Patterns)(https://gameprogrammingpatterns.com/state.html).
     */
    class StateMachine {
        /**
         * Creates a new StateMachine
         */
        constructor() {
            this.stack = new Stack_1.default();
            this.stateMap = new Map_1.default();
            this.receiver = new Receiver_1.default();
            this.emitter = new Emitter_1.default();
            this.emitEventOnStateChange = false;
        }
        /**
         * Sets the activity state of this state machine
         * @param flag True if you want to set this machine running, false otherwise
         */
        setActive(flag) {
            this.active = flag;
        }
        /**
         * Makes this state machine emit an event any time its state changes
         * @param stateChangeEventName The name of the event to emit
         */
        setEmitEventOnStateChange(stateChangeEventName) {
            this.emitEventOnStateChange = true;
            this.stateChangeEventName = stateChangeEventName;
        }
        /**
         * Stops this state machine from emitting events on state change.
         */
        cancelEmitEventOnStateChange() {
            this.emitEventOnStateChange = false;
        }
        /**
         * Initializes this state machine with an initial state and sets it running
         * @param initialState The name of initial state of the state machine
         */
        initialize(initialState, options) {
            this.stack.push(this.stateMap.get(initialState));
            this.currentState = this.stack.peek();
            this.currentState.onEnter(options);
            this.setActive(true);
        }
        /**
         * Adds a state to this state machine
         * @param stateName The name of the state to add
         * @param state The state to add
         */
        addState(stateName, state) {
            this.stateMap.add(stateName, state);
        }
        /**
         * Changes the state of this state machine to the provided string
         * @param state The string name of the state to change to
         */
        changeState(state) {
            // Exit the current state
            let options = this.currentState.onExit();
            // Make sure the correct state is at the top of the stack
            if (state === "previous") {
                // Pop the current state off the stack
                this.stack.pop();
            }
            else {
                // Retrieve the new state from the statemap and put it at the top of the stack
                this.stack.pop();
                this.stack.push(this.stateMap.get(state));
            }
            // Retreive the new state from the stack
            this.currentState = this.stack.peek();
            // Emit an event if turned on
            if (this.emitEventOnStateChange) {
                this.emitter.fireEvent(this.stateChangeEventName, { state: this.currentState });
            }
            // Enter the new state
            this.currentState.onEnter(options);
        }
        /**
         * Handles input. This happens at the very beginning of this state machine's update cycle.
         * @param event The game event to process
         */
        handleEvent(event) {
            if (this.active) {
                this.currentState.handleInput(event);
            }
        }
        // @implemented
        update(deltaT) {
            // Distribute events
            while (this.receiver.hasNextEvent()) {
                let event = this.receiver.getNextEvent();
                this.handleEvent(event);
            }
            // Delegate the update to the current state
            this.currentState.update(deltaT);
        }
    }
    exports.default = StateMachine;
    },{"../../Events/Emitter":35,"../../Events/Receiver":39,"../Map":19,"../Stack":28}],31:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
    const Vec2_1 = require("../Vec2");
    /**
     * The data representation of a Tileset for the game engine. This represents one image,
     * with a startIndex if required (as it is with Tiled using two images in one tilset).
     */
    class Tileset {
        // TODO: Change this to be more general and work with other tileset formats
        constructor(tilesetData) {
            // Defer handling of the data to a helper class
            this.initFromTiledData(tilesetData);
        }
        /**
         * Initialize the tileset from the data from a Tiled json file
         * @param tiledData The parsed object from a Tiled json file
         */
        initFromTiledData(tiledData) {
            this.numRows = tiledData.tilecount / tiledData.columns;
            this.numCols = tiledData.columns;
            this.startIndex = tiledData.firstgid;
            this.endIndex = this.startIndex + tiledData.tilecount - 1;
            this.tileSize = new Vec2_1.default(tiledData.tilewidth, tiledData.tilewidth);
            this.imageKey = tiledData.image;
            this.imageSize = new Vec2_1.default(tiledData.imagewidth, tiledData.imageheight);
        }
        /**
         * Gets the image key associated with this tilemap
         * @returns The image key of this tilemap
         */
        getImageKey() {
            return this.imageKey;
        }
        /**
         * Returns a Vec2 containing the left and top offset from the image origin for this tile.
         * @param tileIndex The index of the tile from startIndex to endIndex of this tileset
         * @returns A Vec2 containing the offset for the specified tile.
         */
        getImageOffsetForTile(tileIndex) {
            // Get the true index
            let index = tileIndex - this.startIndex;
            let row = Math.floor(index / this.numCols);
            let col = index % this.numCols;
            let width = this.tileSize.x;
            let height = this.tileSize.y;
            // Calculate the position to start a crop in the tileset image
            let left = col * width;
            let top = row * height;
            return new Vec2_1.default(left, top);
        }
        /**
         * Gets the start index
         * @returns The start index
         */
        getStartIndex() {
            return this.startIndex;
        }
        /**
         * Gets the tile set
         * @returns A Vec2 containing the tile size
         */
        getTileSize() {
            return this.tileSize;
        }
        /**
         * Gets the number of rows in the tileset
         * @returns The number of rows
         */
        getNumRows() {
            return this.numRows;
        }
        /**
         * Gets the number of columns in the tilset
         * @returns The number of columns
         */
        getNumCols() {
            return this.numCols;
        }
        getTileCount() {
            return this.endIndex - this.startIndex + 1;
        }
        /**
         * Checks whether or not this tilset contains the specified tile index. This is used for rendering.
         * @param tileIndex The index of the tile to check
         * @returns A boolean representing whether or not this tilset uses the specified index
         */
        hasTile(tileIndex) {
            return tileIndex >= this.startIndex && tileIndex <= this.endIndex;
        }
        /**
         * Render a singular tile with index tileIndex from the tileset located at position dataIndex
         * @param ctx The rendering context
         * @param tileIndex The value of the tile to render
         * @param dataIndex The index of the tile in the data array
         * @param worldSize The size of the world
         * @param origin The viewport origin in the current layer
         * @param scale The scale of the tilemap
         */
        renderTile(ctx, tileIndex, dataIndex, maxCols, origin, scale, zoom) {
            let image = ResourceManager_1.default.getInstance().getImage(this.imageKey);
            // Get the true index
            let index = tileIndex - this.startIndex;
            let row = Math.floor(index / this.numCols);
            let col = index % this.numCols;
            let width = this.tileSize.x;
            let height = this.tileSize.y;
            // Calculate the position to start a crop in the tileset image
            let left = col * width;
            let top = row * height;
            // Calculate the position in the world to render the tile
            let x = Math.floor((dataIndex % maxCols) * width * scale.x);
            let y = Math.floor(Math.floor(dataIndex / maxCols) * height * scale.y);
            ctx.drawImage(image, left, top, width, height, Math.floor((x - origin.x) * zoom), Math.floor((y - origin.y) * zoom), Math.ceil(width * scale.x * zoom), Math.ceil(height * scale.y * zoom));
        }
    }
    exports.default = Tileset;
    },{"../../ResourceManager/ResourceManager":93,"../Vec2":32}],32:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const MathUtils_1 = require("../Utils/MathUtils");
    /**
     * A two-dimensional vector (x, y)
     */
    class Vec2 {
        /**
         * Creates a new Vec2
         * @param x The x value of the vector
         * @param y The y value of the vector
         */
        constructor(x = 0, y = 0) {
            /**
             * When this vector changes its value, do something
             */
            this.onChange = () => { };
            this.vec = new Float32Array(2);
            this.vec[0] = x;
            this.vec[1] = y;
        }
        // Expose x and y with getters and setters
        get x() {
            return this.vec[0];
        }
        set x(x) {
            this.vec[0] = x;
            if (this.onChange) {
                this.onChange();
            }
        }
        get y() {
            return this.vec[1];
        }
        set y(y) {
            this.vec[1] = y;
            if (this.onChange) {
                this.onChange();
            }
        }
        static get ZERO() {
            return new Vec2(0, 0);
        }
        static get INF() {
            return new Vec2(Infinity, Infinity);
        }
        static get UP() {
            return new Vec2(0, -1);
        }
        static get DOWN() {
            return new Vec2(0, 1);
        }
        static get LEFT() {
            return new Vec2(-1, 0);
        }
        static get RIGHT() {
            return new Vec2(1, 0);
        }
        /**
         * The squared magnitude of the vector. This tends to be faster, so use it in situations where taking the
         * square root doesn't matter, like for comparing distances.
         * @returns The squared magnitude of the vector
         */
        magSq() {
            return this.x * this.x + this.y * this.y;
        }
        /**
         * The magnitude of the vector.
         * @returns The magnitude of the vector.
         */
        mag() {
            return Math.sqrt(this.magSq());
        }
        /**
         * Divdes x and y by the magnitude to obtain the unit vector in the direction of this vector.
         * @returns This vector as a unit vector.
         */
        normalize() {
            if (this.x === 0 && this.y === 0)
                return this;
            let mag = this.mag();
            this.x /= mag;
            this.y /= mag;
            return this;
        }
        /**
         * Works like normalize(), but returns a new Vec2
         * @returns A new vector that is the unit vector for this one
         */
        normalized() {
            if (this.isZero()) {
                return this;
            }
            let mag = this.mag();
            return new Vec2(this.x / mag, this.y / mag);
        }
        /**
         * Sets the x and y elements of this vector to zero.
         * @returns This vector, with x and y set to zero.
         */
        zero() {
            return this.set(0, 0);
        }
        /**
         * Sets the vector's x and y based on the angle provided. Goes counter clockwise.
         * @param angle The angle in radians
         * @param radius The magnitude of the vector at the specified angle
         * @returns This vector.
         */
        setToAngle(angle, radius = 1) {
            this.x = MathUtils_1.default.floorToPlace(Math.cos(angle) * radius, 5);
            this.y = MathUtils_1.default.floorToPlace(-Math.sin(angle) * radius, 5);
            return this;
        }
        /**
         * Returns a vector that point from this vector to another one
         * @param other The vector to point to
         * @returns A new Vec2 that points from this vector to the one provided
         */
        vecTo(other) {
            return new Vec2(other.x - this.x, other.y - this.y);
        }
        /**
         * Returns a vector containing the direction from this vector to another
         * @param other The vector to point to
         * @returns A new Vec2 that points from this vector to the one provided. This new Vec2 will be a unit vector.
         */
        dirTo(other) {
            return this.vecTo(other).normalize();
        }
        /**
         * Keeps the vector's direction, but sets its magnitude to be the provided magnitude
         * @param magnitude The magnitude the vector should be
         * @returns This vector with its magnitude set to the new magnitude
         */
        scaleTo(magnitude) {
            return this.normalize().scale(magnitude);
        }
        /**
         * Scales x and y by the number provided, or if two number are provided, scales them individually.
         * @param factor The scaling factor for the vector, or for only the x-component if yFactor is provided
         * @param yFactor The scaling factor for the y-component of the vector
         * @returns This vector after scaling
         */
        scale(factor, yFactor = null) {
            if (yFactor !== null) {
                this.x *= factor;
                this.y *= yFactor;
                return this;
            }
            this.x *= factor;
            this.y *= factor;
            return this;
        }
        /**
         * Returns a scaled version of this vector without modifying it.
         * @param factor The scaling factor for the vector, or for only the x-component if yFactor is provided
         * @param yFactor The scaling factor for the y-component of the vector
         * @returns A new vector that has the values of this vector after scaling
         */
        scaled(factor, yFactor = null) {
            return this.clone().scale(factor, yFactor);
        }
        /**
         * Rotates the vector counter-clockwise by the angle amount specified
         * @param angle The angle to rotate by in radians
         * @returns This vector after rotation.
         */
        rotateCCW(angle) {
            let cs = Math.cos(angle);
            let sn = Math.sin(angle);
            let tempX = this.x * cs - this.y * sn;
            let tempY = this.x * sn + this.y * cs;
            this.x = tempX;
            this.y = tempY;
            return this;
        }
        /**
         * Sets the vectors coordinates to be the ones provided
         * @param x The new x value for this vector
         * @param y The new y value for this vector
         * @returns This vector
         */
        set(x, y) {
            this.x = x;
            this.y = y;
            return this;
        }
        /**
         * Copies the values of the other Vec2 into this one.
         * @param other The Vec2 to copy
         * @returns This vector with its values set to the vector provided
         */
        copy(other) {
            return this.set(other.x, other.y);
        }
        /**
         * Adds this vector the another vector
         * @param other The Vec2 to add to this one
         * @returns This vector after adding the one provided
         */
        add(other) {
            this.x += other.x;
            this.y += other.y;
            return this;
        }
        /**
         * Increments the fields of this vector. Both are incremented with a, if only a is provided.
         * @param a The first number to increment by
         * @param b The second number to increment by
         * @returnss This vector after incrementing
         */
        inc(a, b) {
            if (b === undefined) {
                this.x += a;
                this.y += a;
            }
            else {
                this.x += a;
                this.y += b;
            }
            return this;
        }
        /**
         * Subtracts another vector from this vector
         * @param other The Vec2 to subtract from this one
         * @returns This vector after subtracting the one provided
         */
        sub(other) {
            this.x -= other.x;
            this.y -= other.y;
            return this;
        }
        /**
         * Multiplies this vector with another vector element-wise. In other words, this.x *= other.x and this.y *= other.y
         * @param other The Vec2 to multiply this one by
         * @returns This vector after multiplying its components by this one
         */
        mult(other) {
            this.x *= other.x;
            this.y *= other.y;
            return this;
        }
        /**
         * Divides this vector with another vector element-wise. In other words, this.x /= other.x and this.y /= other.y
         * @param other The vector to divide this one by
         * @returns This vector after division
         */
        div(other) {
            if (other.x === 0 || other.y === 0)
                throw "Divide by zero error";
            this.x /= other.x;
            this.y /= other.y;
            return this;
        }
        /**
         * Does an element wise remainder operation on this vector. this.x %= other.x and this.y %= other.y
         * @param other The other vector
         * @returns this vector
         */
        remainder(other) {
            this.x = this.x % other.x;
            this.y = this.y % other.y;
            return this;
        }
        /**
         * Returns the squared distance between this vector and another vector
         * @param other The vector to compute distance squared to
         * @returns The squared distance between this vector and the one provided
         */
        distanceSqTo(other) {
            return (this.x - other.x) * (this.x - other.x) + (this.y - other.y) * (this.y - other.y);
        }
        /**
         * Returns the distance between this vector and another vector
         * @param other The vector to compute distance to
         * @returns The distance between this vector and the one provided
         */
        distanceTo(other) {
            return Math.sqrt(this.distanceSqTo(other));
        }
        /**
         * Returns the dot product of this vector and another
         * @param other The vector to compute the dot product with
         * @returns The dot product of this vector and the one provided.
         */
        dot(other) {
            return this.x * other.x + this.y * other.y;
        }
        /**
         * Returns the angle counter-clockwise in radians from this vector to another vector
         * @param other The vector to compute the angle to
         * @returns The angle, rotating CCW, from this vector to the other vector
         */
        angleToCCW(other) {
            let dot = this.dot(other);
            let det = this.x * other.y - this.y * other.x;
            let angle = -Math.atan2(det, dot);
            if (angle < 0) {
                angle += 2 * Math.PI;
            }
            return angle;
        }
        /**
         * Returns a string representation of this vector rounded to 1 decimal point
         * @returns This vector as a string
         */
        toString() {
            return this.toFixed();
        }
        /**
         * Returns a string representation of this vector rounded to the specified number of decimal points
         * @param numDecimalPoints The number of decimal points to create a string to
         * @returns This vector as a string
         */
        toFixed(numDecimalPoints = 1) {
            return "(" + this.x.toFixed(numDecimalPoints) + ", " + this.y.toFixed(numDecimalPoints) + ")";
        }
        /**
         * Returns a new vector with the same coordinates as this one.
         * @returns A new Vec2 with the same values as this one
         */
        clone() {
            return new Vec2(this.x, this.y);
        }
        /**
         * Returns true if this vector and other have the EXACT same x and y (not assured to be safe for floats)
         * @param other The vector to check against
         * @returns A boolean representing the equality of the two vectors
         */
        strictEquals(other) {
            return this.x === other.x && this.y === other.y;
        }
        /**
         * Returns true if this vector and other have the same x and y
         * @param other The vector to check against
         * @returns A boolean representing the equality of the two vectors
         */
        equals(other) {
            let xEq = Math.abs(this.x - other.x) < 0.0000001;
            let yEq = Math.abs(this.y - other.y) < 0.0000001;
            return xEq && yEq;
        }
        /**
         * Returns true if this vector is the zero vector exactly (not assured to be safe for floats).
         * @returns A boolean representing the equality of this vector and the zero vector
         */
        strictIsZero() {
            return this.x === 0 && this.y === 0;
        }
        /**
         * Returns true if this x and y for this vector are both zero.
         * @returns A boolean representing the equality of this vector and the zero vector
         */
        isZero() {
            return Math.abs(this.x) < 0.0000001 && Math.abs(this.y) < 0.0000001;
        }
        /**
         * Sets the function that is called whenever this vector is changed.
         * @param f The function to be called
         */
        setOnChange(f) {
            this.onChange = f;
        }
        toArray() {
            return this.vec;
        }
        /**
         * Performs linear interpolation between two vectors
         * @param a The first vector
         * @param b The second vector
         * @param t The time of the lerp, with 0 being vector A, and 1 being vector B
         * @returns A new Vec2 representing the lerp between vector a and b.
         */
        static lerp(a, b, t) {
            return new Vec2(MathUtils_1.default.lerp(a.x, b.x, t), MathUtils_1.default.lerp(a.y, b.y, t));
        }
    }
    exports.default = Vec2;
    Vec2.ZERO_STATIC = new Vec2(0, 0);
    },{"../Utils/MathUtils":112}],33:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Map_1 = require("../DataTypes/Map");
    const Vec2_1 = require("../DataTypes/Vec2");
    const Color_1 = require("../Utils/Color");
    /**
     * A util class for rendering Debug messages to the canvas.
     */
    class Debug {
        /**
         * Add a message to display on the debug screen
         * @param id A unique ID for this message
         * @param messages The messages to print to the debug screen
         */
        static log(id, ...messages) {
            // let message = "";
            // for(let i = 0; i < messages.length; i++){
            // 	message += messages[i].toString();
            // }
            // Join all messages with spaces
            let message = messages.map((m) => m.toString()).join(" ");
            this.logMessages.add(id, message);
        }
        /**
         * Deletes a a key from the log and stops it from keeping up space on the screen
         * @param id The id of the log item to clear
         */
        static clearLogItem(id) {
            this.logMessages.delete(id);
        }
        /**
         * Sets the list of nodes to render with the debugger
         * @param nodes The new list of nodes
         */
        static setNodes(nodes) {
            this.nodes = nodes;
        }
        /**
         * Draws a box at the specified position
         * @param center The center of the box
         * @param halfSize The dimensions of the box
         * @param filled A boolean for whether or not the box is filled
         * @param color The color of the box to draw
         */
        static drawBox(center, halfSize, filled, color) {
            let alpha = this.debugRenderingContext.globalAlpha;
            this.debugRenderingContext.globalAlpha = color.a;
            if (filled) {
                this.debugRenderingContext.fillStyle = color.toString();
                this.debugRenderingContext.fillRect(center.x - halfSize.x, center.y - halfSize.y, halfSize.x * 2, halfSize.y * 2);
            }
            else {
                let lineWidth = 2;
                this.debugRenderingContext.lineWidth = lineWidth;
                this.debugRenderingContext.strokeStyle = color.toString();
                this.debugRenderingContext.strokeRect(center.x - halfSize.x, center.y - halfSize.y, halfSize.x * 2, halfSize.y * 2);
            }
            this.debugRenderingContext.globalAlpha = alpha;
        }
        /**
         * Draws a circle at the specified position
         * @param center The center of the circle
         * @param radius The dimensions of the box
         * @param filled A boolean for whether or not the circle is filled
         * @param color The color of the circle
         */
        static drawCircle(center, radius, filled, color) {
            let alpha = this.debugRenderingContext.globalAlpha;
            this.debugRenderingContext.globalAlpha = color.a;
            if (filled) {
                this.debugRenderingContext.fillStyle = color.toString();
                this.debugRenderingContext.beginPath();
                this.debugRenderingContext.arc(center.x, center.y, radius, 0, 2 * Math.PI);
                this.debugRenderingContext.closePath();
                this.debugRenderingContext.fill();
            }
            else {
                let lineWidth = 2;
                this.debugRenderingContext.lineWidth = lineWidth;
                this.debugRenderingContext.strokeStyle = color.toString();
                this.debugRenderingContext.beginPath();
                this.debugRenderingContext.arc(center.x, center.y, radius, 0, 2 * Math.PI);
                this.debugRenderingContext.closePath();
                this.debugRenderingContext.stroke();
            }
            this.debugRenderingContext.globalAlpha = alpha;
        }
        /**
         * Draws a ray at the specified position
         * @param from The starting position of the ray
         * @param to The ending position of the ray
         * @param color The color of the ray
         */
        static drawRay(from, to, color) {
            this.debugRenderingContext.lineWidth = 2;
            this.debugRenderingContext.strokeStyle = color.toString();
            this.debugRenderingContext.beginPath();
            this.debugRenderingContext.moveTo(from.x, from.y);
            this.debugRenderingContext.lineTo(to.x, to.y);
            this.debugRenderingContext.closePath();
            this.debugRenderingContext.stroke();
        }
        /**
         * Draws a point at the specified position
         * @param pos The position of the point
         * @param color The color of the point
         */
        static drawPoint(pos, color) {
            let pointSize = 6;
            this.debugRenderingContext.fillStyle = color.toString();
            this.debugRenderingContext.fillRect(pos.x - pointSize / 2, pos.y - pointSize / 2, pointSize, pointSize);
        }
        /**
         * Sets the default rendering color for text for the debugger
         * @param color The color to render the text
         */
        static setDefaultTextColor(color) {
            this.defaultTextColor = color;
        }
        /**
         * Performs any necessary setup operations on the Debug canvas
         * @param canvas The debug canvas
         * @param width The desired width of the canvas
         * @param height The desired height of the canvas
         * @returns The rendering context extracted from the canvas
         */
        static initializeDebugCanvas(canvas, width, height) {
            canvas.width = width;
            canvas.height = height;
            this.debugCanvasSize = new Vec2_1.default(width, height);
            this.debugRenderingContext = canvas.getContext("2d");
            return this.debugRenderingContext;
        }
        /** Clears the debug canvas */
        static clearCanvas() {
            this.debugRenderingContext.clearRect(0, 0, this.debugCanvasSize.x, this.debugCanvasSize.y);
        }
        /** Renders the text and nodes sent to the Debug system */
        static render() {
            this.renderText();
            this.renderNodes();
        }
        /** Renders the text sent to the Debug canvas */
        static renderText() {
            let y = 20;
            this.debugRenderingContext.font = "20px Arial";
            this.debugRenderingContext.fillStyle = this.defaultTextColor.toString();
            // Draw all of the text
            this.logMessages.forEach((key) => {
                this.debugRenderingContext.fillText(this.logMessages.get(key), 10, y);
                y += 30;
            });
        }
        /** Renders the nodes registered with the debug canvas */
        static renderNodes() {
            if (this.nodes) {
                this.nodes.forEach(node => {
                    node.debugRender();
                });
            }
        }
    }
    exports.default = Debug;
    /** A map of log messages to display on the screen */
    Debug.logMessages = new Map_1.default();
    /** The rendering color for text */
    Debug.defaultTextColor = Color_1.default.WHITE;
    },{"../DataTypes/Map":19,"../DataTypes/Vec2":32,"../Utils/Color":109}],34:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Color_1 = require("../Utils/Color");
    // @ignorePage
    class Stats extends Object {
        static initStats() {
            let canvas = document.getElementById("stats-canvas");
            canvas.width = this.CANVAS_WIDTH;
            canvas.height = this.CANVAS_HEIGHT;
            this.ctx = canvas.getContext("2d");
            this.statsDiv = document.getElementById("stats-display");
            this.prevfps = new Array();
            this.prevClearTimes = new Array();
            this.SGClearTimes = new Array();
            this.avgSGClearTime = 0;
            this.prevFillTimes = new Array();
            this.SGFillTimes = new Array();
            this.avgSGFillTime = 0;
            this.prevUpdateTimes = new Array();
            this.SGUpdateTimes = new Array();
            this.avgSGUpdateTime = 0;
            this.prevQueryTimes = new Array();
            this.SGQueryTimes = new Array();
            this.avgSGQueryTime = 0;
            let clearTime = document.createElement("span");
            clearTime.setAttribute("id", "sgclear");
            let fillTime = document.createElement("span");
            fillTime.setAttribute("id", "sgfill");
            let updateTime = document.createElement("span");
            updateTime.setAttribute("id", "sgupdate");
            let queryTime = document.createElement("span");
            queryTime.setAttribute("id", "sgquery");
            let br1 = document.createElement("br");
            let br2 = document.createElement("br");
            let br3 = document.createElement("br");
            this.statsDiv.append(clearTime, br1, fillTime, br2, updateTime, br3, queryTime);
            this.graphChoices = document.getElementById("chart-option");
            let option1 = document.createElement("option");
            option1.value = "prevfps";
            option1.label = "FPS";
            let option2 = document.createElement("option");
            option2.value = "prevClearTimes";
            option2.label = "Clear Time";
            let option3 = document.createElement("option");
            option3.value = "prevFillTimes";
            option3.label = "Fill time";
            let option4 = document.createElement("option");
            option4.value = "prevUpdateTimes";
            option4.label = "Update time";
            let option5 = document.createElement("option");
            option5.value = "prevQueryTimes";
            option5.label = "Query Time";
            let optionAll = document.createElement("option");
            optionAll.value = "all";
            optionAll.label = "All";
            this.graphChoices.append(option1, option2, option3, option4, option5, optionAll);
        }
        static updateFPS(fps) {
            this.prevfps.push(fps);
            if (this.prevfps.length > Stats.NUM_POINTS) {
                this.prevfps.shift();
            }
            if (this.SGClearTimes.length > 0) {
                this.prevClearTimes.push(this.avgSGClearTime);
                if (this.prevClearTimes.length > this.NUM_POINTS) {
                    this.prevClearTimes.shift();
                }
            }
            if (this.SGFillTimes.length > 0) {
                this.prevFillTimes.push(this.avgSGFillTime);
                if (this.prevFillTimes.length > this.NUM_POINTS) {
                    this.prevFillTimes.shift();
                }
            }
            if (this.SGUpdateTimes.length > 0) {
                this.prevUpdateTimes.push(this.avgSGUpdateTime);
                if (this.prevUpdateTimes.length > this.NUM_POINTS) {
                    this.prevUpdateTimes.shift();
                }
            }
            if (this.SGQueryTimes.length > 0) {
                this.prevQueryTimes.push(this.avgSGQueryTime);
                if (this.prevQueryTimes.length > this.NUM_POINTS) {
                    this.prevQueryTimes.shift();
                }
            }
            this.updateSGStats();
        }
        static log(key, data) {
            if (key === "sgclear") {
                this.SGClearTimes.push(data);
                if (this.SGClearTimes.length > 100) {
                    this.SGClearTimes.shift();
                }
            }
            else if (key === "sgfill") {
                this.SGFillTimes.push(data);
                if (this.SGFillTimes.length > 100) {
                    this.SGFillTimes.shift();
                }
            }
            else if (key === "sgupdate") {
                this.SGUpdateTimes.push(data);
                if (this.SGUpdateTimes.length > 100) {
                    this.SGUpdateTimes.shift();
                }
            }
            else if (key === "sgquery") {
                this.SGQueryTimes.push(data);
                if (this.SGQueryTimes.length > 1000) {
                    this.SGQueryTimes.shift();
                }
            }
        }
        static render() {
            // Display stats
            this.drawCharts();
        }
        static drawCharts() {
            this.ctx.clearRect(0, 0, this.CANVAS_WIDTH, this.CANVAS_HEIGHT);
            let paramString = this.graphChoices.value;
            if (paramString === "prevfps" || paramString === "all") {
                let param = this.prevfps;
                let color = Color_1.default.BLUE.toString();
                this.drawChart(param, color);
            }
            if (paramString === "prevClearTimes" || paramString === "all") {
                let param = this.prevClearTimes;
                let color = Color_1.default.RED.toString();
                this.drawChart(param, color);
            }
            if (paramString === "prevFillTimes" || paramString === "all") {
                let param = this.prevFillTimes;
                let color = Color_1.default.GREEN.toString();
                this.drawChart(param, color);
            }
            if (paramString === "prevUpdateTimes" || paramString === "all") {
                let param = this.prevUpdateTimes;
                let color = Color_1.default.CYAN.toString();
                this.drawChart(param, color);
            }
            if (paramString === "prevQueryTimes" || paramString === "all") {
                let param = this.prevQueryTimes;
                let color = Color_1.default.ORANGE.toString();
                this.drawChart(param, color);
            }
        }
        static drawChart(param, color) {
            this.ctx.strokeStyle = Color_1.default.BLACK.toString();
            this.ctx.beginPath();
            this.ctx.moveTo(10, 10);
            this.ctx.lineTo(10, this.CANVAS_HEIGHT - 10);
            this.ctx.closePath();
            this.ctx.stroke();
            this.ctx.beginPath();
            this.ctx.moveTo(10, this.CANVAS_HEIGHT - 10);
            this.ctx.lineTo(this.CANVAS_WIDTH - 10, this.CANVAS_HEIGHT - 10);
            this.ctx.closePath();
            this.ctx.stroke();
            let max = Math.max(...param);
            let prevX = 10;
            let prevY = this.CANVAS_HEIGHT - 10 - param[0] / max * (this.CANVAS_HEIGHT - 20);
            this.ctx.strokeStyle = color;
            for (let i = 1; i < param.length; i++) {
                let fps = param[i];
                let x = 10 + i * (this.CANVAS_WIDTH - 20) / this.NUM_POINTS;
                let y = this.CANVAS_HEIGHT - 10 - fps / max * (this.CANVAS_HEIGHT - 20);
                this.ctx.beginPath();
                this.ctx.moveTo(prevX, prevY);
                this.ctx.lineTo(x, y);
                this.ctx.closePath();
                this.ctx.stroke();
                prevX = x;
                prevY = y;
            }
        }
        static updateSGStats() {
            if (this.SGClearTimes.length > 0) {
                this.avgSGClearTime = this.SGClearTimes.reduce((acc, val) => acc + val) / this.SGClearTimes.length;
            }
            if (this.SGFillTimes.length > 0) {
                this.avgSGFillTime = this.SGFillTimes.reduce((acc, val) => acc + val) / this.SGFillTimes.length;
            }
            if (this.SGUpdateTimes.length > 0) {
                this.avgSGUpdateTime = this.SGUpdateTimes.reduce((acc, val) => acc + val) / this.SGUpdateTimes.length;
            }
            if (this.SGQueryTimes.length > 0) {
                this.avgSGQueryTime = this.SGQueryTimes.reduce((acc, val) => acc + val) / this.SGQueryTimes.length;
            }
            document.getElementById("sgclear").innerHTML = "Avg SG clear time: " + this.avgSGClearTime;
            document.getElementById("sgfill").innerHTML = "Avg SG fill time: " + this.avgSGFillTime;
            document.getElementById("sgupdate").innerHTML = "Avg SG update time: " + this.avgSGUpdateTime;
            document.getElementById("sgquery").innerHTML = "Avg SG query time: " + this.avgSGQueryTime;
        }
    }
    exports.default = Stats;
    Stats.NUM_POINTS = 60;
    Stats.CANVAS_WIDTH = 300;
    Stats.CANVAS_HEIGHT = 300;
    },{"../Utils/Color":109}],35:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const EventQueue_1 = require("./EventQueue");
    const GameEvent_1 = require("./GameEvent");
    /**
     * An event emitter object other systems can use to hook into the EventQueue.
     * Provides an easy interface for firing off events.
     */
    class Emitter {
        /** Creates a new Emitter */
        constructor() {
            this.eventQueue = EventQueue_1.default.getInstance();
        }
        /**
         * Emit and event of type eventType with the data packet data
         * @param eventType The name of the event to fire off
         * @param data A @reference[Map] or record containing any data about the event
         */
        fireEvent(eventType, data = null) {
            this.eventQueue.addEvent(new GameEvent_1.default(eventType, data));
        }
    }
    exports.default = Emitter;
    },{"./EventQueue":36,"./GameEvent":37}],36:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Queue_1 = require("../DataTypes/Queue");
    const Map_1 = require("../DataTypes/Map");
    const GameEventType_1 = require("./GameEventType");
    /**
     * The main event system of the game engine.
     * Events are sent to the EventQueue, which handles distribution to any systems that are listening for those events.
     * This allows for handling of input without having classes directly hook into javascript event handles,
     * and allows otherwise separate classes to communicate with each other cleanly, such as a Player object
     * requesting a sound be played by the audio system.
     *
     * The distribution of @reference[GameEvent]s happens as follows:
     *
     * Events are recieved throughout a frame and are queued up by the EventQueue.
     * At the beginning of the next frame, events are sent out to any receivers that are hooked into the event type.
     * @reference[Receiver]s are then free to process events as they see fit.
     *
     * Overall, the EventQueue can be considered as something similar to an email server,
     * and the @reference[Receiver]s can be considered as the client inboxes.
     *
     * See @link(Game Programming Patterns)(https://gameprogrammingpatterns.com/event-queue.html) for more discussion on EventQueues
     */
    class EventQueue {
        constructor() {
            this.MAX_SIZE = 100;
            this.q = new Queue_1.default(this.MAX_SIZE);
            this.receivers = new Map_1.default();
        }
        /** Retrieves the instance of the Singleton EventQueue */
        static getInstance() {
            if (this.instance === null) {
                this.instance = new EventQueue();
            }
            return this.instance;
        }
        /** Adds an event to the EventQueue.
         * This is exposed to the rest of the game engine through the @reference[Emitter] class */
        addEvent(event) {
            this.q.enqueue(event);
        }
        /**
         * Associates a receiver with a type of event. Every time this event appears in the future,
         * it will be given to the receiver (and any others watching that type).
         * This is exposed to the rest of the game engine through the @reference[Receiver] class
         * @param receiver The event receiver
         * @param type The type or types of events to subscribe to
         */
        subscribe(receiver, type) {
            if (type instanceof Array) {
                // If it is an array, subscribe to all event types
                for (let t of type) {
                    this.addListener(receiver, t);
                }
            }
            else {
                this.addListener(receiver, type);
            }
        }
        /**
         * Unsubscribes the specified receiver from all events, or from whatever events are provided
         * @param receiver The receiver to unsubscribe
         * @param keys The events to unsubscribe from. If none are provided, unsubscribe from all
         */
        unsubscribe(receiver, ...events) {
            this.receivers.forEach(eventName => {
                // If keys were provided, only continue if this key is one of them
                if (events.length > 0 && events.indexOf(eventName) === -1)
                    return;
                // Find the index of our receiver for this key
                let index = this.receivers.get(eventName).indexOf(receiver);
                // If an index was found, remove the receiver
                if (index !== -1) {
                    this.receivers.get(eventName).splice(index, 1);
                }
            });
        }
        // Associate the receiver and the type
        addListener(receiver, type) {
            if (this.receivers.has(type)) {
                this.receivers.get(type).push(receiver);
            }
            else {
                this.receivers.add(type, [receiver]);
            }
        }
        update(deltaT) {
            while (this.q.hasItems()) {
                // Retrieve each event
                let event = this.q.dequeue();
                // If a receiver has this event type, send it the event
                if (this.receivers.has(event.type)) {
                    for (let receiver of this.receivers.get(event.type)) {
                        receiver.receive(event);
                    }
                }
                // If a receiver is subscribed to all events, send it the event
                if (this.receivers.has(GameEventType_1.GameEventType.ALL)) {
                    for (let receiver of this.receivers.get(GameEventType_1.GameEventType.ALL)) {
                        receiver.receive(event);
                    }
                }
            }
        }
    }
    exports.default = EventQueue;
    EventQueue.instance = null;
    },{"../DataTypes/Map":19,"../DataTypes/Queue":23,"./GameEventType":38}],37:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Map_1 = require("../DataTypes/Map");
    /**
     * A representation of an in-game event that is passed through the @reference[EventQueue]
     */
    class GameEvent {
        /**
         * Creates a new GameEvent.
         * This is handled implicitly through the @reference[Emitter] class
         * @param type The type of the GameEvent
         * @param data The data contained by the GameEvent
         */
        constructor(type, data = null) {
            // Parse the game event data
            if (data === null) {
                this.data = new Map_1.default();
            }
            else if (!(data instanceof Map_1.default)) {
                // data is a raw object, unpack
                this.data = new Map_1.default();
                for (let key in data) {
                    this.data.add(key, data[key]);
                }
            }
            else {
                this.data = data;
            }
            this.type = type;
            this.time = Date.now();
        }
        /**
         * Checks the type of the GameEvent
         * @param type The type to check
         * @returns True if the GameEvent is the specified type, false otherwise.
         */
        isType(type) {
            return this.type === type;
        }
        /**
         * Returns this GameEvent as a string
         * @returns The string representation of the GameEvent
         */
        toString() {
            return this.type + ": @" + this.time;
        }
    }
    exports.default = GameEvent;
    },{"../DataTypes/Map":19}],38:[function(require,module,exports){
    "use strict";
    // @ignorePage
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GameEventType = void 0;
    var GameEventType;
    (function (GameEventType) {
        /**
         * Mouse Down event. Has data: {position: Vec2 - Mouse Position}
         */
        GameEventType["MOUSE_DOWN"] = "mouse_down";
        /**
         * Mouse Up event. Has data: {position: Vec2 - Mouse Position}
         */
        GameEventType["MOUSE_UP"] = "mouse_up";
        /**
         * Mouse Move event. Has data: {position: Vec2 - Mouse Position}
         */
        GameEventType["MOUSE_MOVE"] = "mouse_move";
        /**
         * Key Down event. Has data: {key: string - The key that is down}
         */
        GameEventType["KEY_DOWN"] = "key_down";
        /**
         * Key Up event. Has data: {key: string - The key that is up}
         */
        GameEventType["KEY_UP"] = "key_up";
        /**
         * Canvas Blur event. Has data: {}
         */
        GameEventType["CANVAS_BLUR"] = "canvas_blur";
        /**
         * Mouse wheel up event. Has data: {}
         */
        GameEventType["WHEEL_UP"] = "wheel_up";
        /**
         * Mouse wheel down event. Has data: {}
         */
        GameEventType["WHEEL_DOWN"] = "wheel_down";
        /**
         * Start Recording event. Has data: {}
         */
        GameEventType["START_RECORDING"] = "start_recording";
        /**
         * Stop Recording event. Has data: {}
         */
        GameEventType["STOP_RECORDING"] = "stop_recording";
        /**
         * Play Recording event. Has data: {}
         */
        GameEventType["PLAY_RECORDING"] = "play_recording";
        /**
         * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean }
         */
        GameEventType["PLAY_SOUND"] = "play_sound";
        /**
         * Play Sound event. Has data: {key: string}
         */
        GameEventType["STOP_SOUND"] = "stop_sound";
        /**
         * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean, channel: AudioChannelType }
         */
        GameEventType["PLAY_SFX"] = "play_sfx";
        /**
         * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean }
         */
        GameEventType["PLAY_MUSIC"] = "play_music";
        /**
         * Mute audio channel event. Has data: {channel: AudioChannelType}
         */
        GameEventType["MUTE_CHANNEL"] = "mute_channel";
        /**
         * Unmute audio channel event. Has data: {channel: AudioChannelType}
         */
        GameEventType["UNMUTE_CHANNEL"] = "unmute_channel";
        /**
         * Encompasses all event types. Used for receivers only.
         */
        GameEventType["ALL"] = "all";
    })(GameEventType = exports.GameEventType || (exports.GameEventType = {}));
    },{}],39:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Queue_1 = require("../DataTypes/Queue");
    const EventQueue_1 = require("./EventQueue");
    /**
     * Receives subscribed events from the EventQueue.
     */
    class Receiver {
        /** Creates a new Receiver */
        constructor() {
            this.MAX_SIZE = 100;
            this.q = new Queue_1.default(this.MAX_SIZE);
        }
        destroy() {
            EventQueue_1.default.getInstance().unsubscribe(this);
        }
        /**
         * Adds these types of events to this receiver's queue every update.
         * @param eventTypes The types of events this receiver will be subscribed to
         */
        subscribe(eventTypes) {
            EventQueue_1.default.getInstance().subscribe(this, eventTypes);
            this.q.clear();
        }
        /**
         * Adds an event to the queue of this reciever. This is used by the @reference[EventQueue] to distribute events
         * @param event The event to receive
         */
        receive(event) {
            try {
                this.q.enqueue(event);
            }
            catch (e) {
                console.warn("Receiver overflow for event " + event.toString());
                throw e;
            }
        }
        /**
         * Retrieves the next event from the receiver's queue
         * @returns The next GameEvent
         */
        getNextEvent() {
            return this.q.dequeue();
        }
        /**
         * Looks at the next event in the receiver's queue, but doesn't remove it from the queue
         * @returns The next GameEvent
         */
        peekNextEvent() {
            return this.q.peekNext();
        }
        /**
         * Returns true if the receiver has any events in its queue
         * @returns True if the receiver has another event, false otherwise
         */
        hasNextEvent() {
            return this.q.hasItems();
        }
        /**
         * Ignore all events this frame
         */
        ignoreEvents() {
            this.q.clear();
        }
    }
    exports.default = Receiver;
    },{"../DataTypes/Queue":23,"./EventQueue":36}],40:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Receiver_1 = require("../Events/Receiver");
    const Map_1 = require("../DataTypes/Map");
    const Vec2_1 = require("../DataTypes/Vec2");
    const EventQueue_1 = require("../Events/EventQueue");
    const GameEventType_1 = require("../Events/GameEventType");
    /**
     * Receives input events from the @reference[EventQueue] and allows for easy access of information about input by other systems
     */
    class Input {
        /**
         * Initializes the Input object
         * @param viewport A reference to the viewport of the game
         */
        static initialize(viewport, keyMap) {
            Input.viewport = viewport;
            Input.mousePressed = false;
            Input.mouseJustPressed = false;
            Input.receiver = new Receiver_1.default();
            Input.keyJustPressed = new Map_1.default();
            Input.keyPressed = new Map_1.default();
            Input.mousePosition = new Vec2_1.default(0, 0);
            Input.mousePressPosition = new Vec2_1.default(0, 0);
            Input.scrollDirection = 0;
            Input.justScrolled = false;
            Input.keysDisabled = false;
            Input.mouseDisabled = false;
            // Initialize the keymap
            Input.keyMap = new Map_1.default();
            // Add all keys to the keymap
            for (let entry in keyMap) {
                let name = keyMap[entry].name;
                let keys = keyMap[entry].keys;
                Input.keyMap.add(name, keys);
            }
            Input.eventQueue = EventQueue_1.default.getInstance();
            // Subscribe to all input events
            Input.eventQueue.subscribe(Input.receiver, [GameEventType_1.GameEventType.MOUSE_DOWN, GameEventType_1.GameEventType.MOUSE_UP, GameEventType_1.GameEventType.MOUSE_MOVE,
                GameEventType_1.GameEventType.KEY_DOWN, GameEventType_1.GameEventType.KEY_UP, GameEventType_1.GameEventType.CANVAS_BLUR, GameEventType_1.GameEventType.WHEEL_UP, GameEventType_1.GameEventType.WHEEL_DOWN]);
        }
        static update(deltaT) {
            // Reset the justPressed values to false
            Input.mouseJustPressed = false;
            Input.keyJustPressed.forEach((key) => Input.keyJustPressed.set(key, false));
            Input.justScrolled = false;
            Input.scrollDirection = 0;
            while (Input.receiver.hasNextEvent()) {
                let event = Input.receiver.getNextEvent();
                // Handle each event type
                if (event.type === GameEventType_1.GameEventType.MOUSE_DOWN) {
                    Input.mouseJustPressed = true;
                    Input.mousePressed = true;
                    Input.mousePressPosition = event.data.get("position");
                    Input.mouseButtonPressed = event.data.get("button");
                }
                if (event.type === GameEventType_1.GameEventType.MOUSE_UP) {
                    Input.mousePressed = false;
                }
                if (event.type === GameEventType_1.GameEventType.MOUSE_MOVE) {
                    Input.mousePosition = event.data.get("position");
                }
                if (event.type === GameEventType_1.GameEventType.KEY_DOWN) {
                    let key = event.data.get("key");
                    // Handle space bar
                    if (key === " ") {
                        key = "space";
                    }
                    if (!Input.keyPressed.get(key)) {
                        Input.keyJustPressed.set(key, true);
                        Input.keyPressed.set(key, true);
                    }
                }
                if (event.type === GameEventType_1.GameEventType.KEY_UP) {
                    let key = event.data.get("key");
                    // Handle space bar
                    if (key === " ") {
                        key = "space";
                    }
                    Input.keyPressed.set(key, false);
                }
                if (event.type === GameEventType_1.GameEventType.CANVAS_BLUR) {
                    Input.clearKeyPresses();
                }
                if (event.type === GameEventType_1.GameEventType.WHEEL_UP) {
                    Input.scrollDirection = -1;
                    Input.justScrolled = true;
                }
                else if (event.type === GameEventType_1.GameEventType.WHEEL_DOWN) {
                    Input.scrollDirection = 1;
                    Input.justScrolled = true;
                }
            }
        }
        static clearKeyPresses() {
            Input.keyJustPressed.forEach((key) => Input.keyJustPressed.set(key, false));
            Input.keyPressed.forEach((key) => Input.keyPressed.set(key, false));
        }
        /**
         * Returns whether or not a key was newly pressed Input frame.
         * If the key is still pressed from last frame and wasn't re-pressed, Input will return false.
         * @param key The key
         * @returns True if the key was just pressed, false otherwise
         */
        static isKeyJustPressed(key) {
            if (Input.keysDisabled)
                return false;
            if (Input.keyJustPressed.has(key)) {
                return Input.keyJustPressed.get(key);
            }
            else {
                return false;
            }
        }
        /**
         * Returns an array of all of the keys that are newly pressed Input frame.
         * If a key is still pressed from last frame and wasn't re-pressed, it will not be in Input list.
         * @returns An array of all of the newly pressed keys.
         */
        static getKeysJustPressed() {
            if (Input.keysDisabled)
                return [];
            let keys = Array();
            Input.keyJustPressed.forEach(key => {
                if (Input.keyJustPressed.get(key)) {
                    keys.push(key);
                }
            });
            return keys;
        }
        /**
         * Returns whether or not a key is being pressed.
         * @param key The key
         * @returns True if the key is currently pressed, false otherwise
         */
        static isKeyPressed(key) {
            if (Input.keysDisabled)
                return false;
            if (Input.keyPressed.has(key)) {
                return Input.keyPressed.get(key);
            }
            else {
                return false;
            }
        }
        /**
         * Changes the binding of an input name to keys
         * @param inputName The name of the input
         * @param keys The corresponding keys
         */
        static changeKeyBinding(inputName, keys) {
            Input.keyMap.set(inputName, keys);
        }
        /**
         * Clears all key bindings
         */
        static clearAllKeyBindings() {
            Input.keyMap.clear();
        }
        /**
         * Returns whether or not an input was just pressed this frame
         * @param inputName The name of the input
         * @returns True if the input was just pressed, false otherwise
         */
        static isJustPressed(inputName) {
            if (Input.keysDisabled)
                return false;
            if (Input.keyMap.has(inputName)) {
                const keys = Input.keyMap.get(inputName);
                let justPressed = false;
                for (let key of keys) {
                    justPressed = justPressed || Input.isKeyJustPressed(key);
                }
                return justPressed;
            }
            else {
                return false;
            }
        }
        /**
         * Returns whether or not an input is currently pressed
         * @param inputName The name of the input
         * @returns True if the input is pressed, false otherwise
         */
        static isPressed(inputName) {
            if (Input.keysDisabled)
                return false;
            if (Input.keyMap.has(inputName)) {
                const keys = Input.keyMap.get(inputName);
                let pressed = false;
                for (let key of keys) {
                    pressed = pressed || Input.isKeyPressed(key);
                }
                return pressed;
            }
            else {
                return false;
            }
        }
        /**
         *
         * Returns whether or not the mouse was newly pressed Input frame.
         * @param mouseButton Optionally specify which mouse click you want to know was pressed.
         * 0 for left click, 1 for middle click, 2 for right click.
         * @returns True if the mouse was just pressed, false otherwise
         */
        static isMouseJustPressed(mouseButton) {
            if (mouseButton) {
                return Input.mouseJustPressed && !Input.mouseDisabled && mouseButton == this.mouseButtonPressed;
            }
            return Input.mouseJustPressed && !Input.mouseDisabled;
        }
        /**
         * Returns whether or not the mouse is currently pressed
         * @param mouseButton Optionally specify which mouse click you want to know was pressed.
         * 0 for left click, 1 for middle click, 2 for right click.
         * @returns True if the mouse is currently pressed, false otherwise
         */
        static isMousePressed(mouseButton) {
            if (mouseButton) {
                return Input.mousePressed && !Input.mouseDisabled && mouseButton == this.mouseButtonPressed;
            }
            return Input.mousePressed && !Input.mouseDisabled;
        }
        /**
         * Returns whether the user scrolled or not
         * @returns True if the user just scrolled Input frame, false otherwise
         */
        static didJustScroll() {
            return Input.justScrolled && !Input.mouseDisabled;
        }
        /**
         * Gets the direction of the scroll
         * @returns -1 if the user scrolled up, 1 if they scrolled down
         */
        static getScrollDirection() {
            return Input.scrollDirection;
        }
        /**
         * Gets the position of the player's mouse
         * @returns The mouse position stored as a Vec2
         */
        static getMousePosition() {
            return Input.mousePosition.scaled(1 / this.viewport.getZoomLevel());
        }
        /**
         * Gets the position of the player's mouse in the game world,
         * taking into consideration the scrolling of the viewport
         * @returns The mouse position stored as a Vec2
         */
        static getGlobalMousePosition() {
            return Input.mousePosition.clone().scale(1 / this.viewport.getZoomLevel()).add(Input.viewport.getOrigin());
        }
        /**
         * Gets the position of the last mouse press
         * @returns The mouse position stored as a Vec2
         */
        static getMousePressPosition() {
            return Input.mousePressPosition;
        }
        /**
         * Gets the position of the last mouse press in the game world,
         * taking into consideration the scrolling of the viewport
         * @returns The mouse position stored as a Vec2
         */
        static getGlobalMousePressPosition() {
            return Input.mousePressPosition.clone().add(Input.viewport.getOrigin());
        }
        /**
         * Disables all keypress and mouse click inputs
         */
        static disableInput() {
            Input.keysDisabled = true;
            Input.mouseDisabled = true;
        }
        /**
         * Enables all keypress and mouse click inputs
         */
        static enableInput() {
            Input.keysDisabled = false;
            Input.mouseDisabled = false;
        }
    }
    exports.default = Input;
    },{"../DataTypes/Map":19,"../DataTypes/Vec2":32,"../Events/EventQueue":36,"../Events/GameEventType":38,"../Events/Receiver":39}],41:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const EventQueue_1 = require("../Events/EventQueue");
    const Vec2_1 = require("../DataTypes/Vec2");
    const GameEvent_1 = require("../Events/GameEvent");
    const GameEventType_1 = require("../Events/GameEventType");
    /**
     * Handles communication with the web browser to receive asynchronous events and send them to the @reference[EventQueue]
     */
    class InputHandler {
        /**
         * Creates a new InputHandler
         * @param canvas The game canvas
         */
        constructor(canvas) {
            this.handleMouseDown = (event, canvas) => {
                let pos = this.getMousePosition(event, canvas);
                let button = event.button;
                let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.MOUSE_DOWN, { position: pos, button: button });
                this.eventQueue.addEvent(gameEvent);
            };
            this.handleMouseUp = (event, canvas) => {
                let pos = this.getMousePosition(event, canvas);
                let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.MOUSE_UP, { position: pos });
                this.eventQueue.addEvent(gameEvent);
            };
            this.handleMouseMove = (event, canvas) => {
                let pos = this.getMousePosition(event, canvas);
                let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.MOUSE_MOVE, { position: pos });
                this.eventQueue.addEvent(gameEvent);
            };
            this.handleKeyDown = (event) => {
                let key = this.getKey(event);
                let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.KEY_DOWN, { key: key });
                this.eventQueue.addEvent(gameEvent);
            };
            this.handleKeyUp = (event) => {
                let key = this.getKey(event);
                let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.KEY_UP, { key: key });
                this.eventQueue.addEvent(gameEvent);
            };
            this.handleBlur = (event) => {
                let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.CANVAS_BLUR, {});
                this.eventQueue.addEvent(gameEvent);
            };
            this.handleContextMenu = (event) => {
                event.preventDefault();
                event.stopPropagation();
            };
            this.handleWheel = (event) => {
                event.preventDefault();
                event.stopPropagation();
                let gameEvent;
                if (event.deltaY < 0) {
                    gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.WHEEL_UP, {});
                }
                else {
                    gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.WHEEL_DOWN, {});
                }
                this.eventQueue.addEvent(gameEvent);
            };
            this.eventQueue = EventQueue_1.default.getInstance();
            canvas.onmousedown = (event) => this.handleMouseDown(event, canvas);
            canvas.onmouseup = (event) => this.handleMouseUp(event, canvas);
            canvas.oncontextmenu = this.handleContextMenu;
            canvas.onmousemove = (event) => this.handleMouseMove(event, canvas);
            document.onkeydown = this.handleKeyDown;
            document.onkeyup = this.handleKeyUp;
            document.onblur = this.handleBlur;
            document.oncontextmenu = this.handleBlur;
            document.onwheel = this.handleWheel;
        }
        getKey(keyEvent) {
            return keyEvent.key.toLowerCase();
        }
        getMousePosition(mouseEvent, canvas) {
            let rect = canvas.getBoundingClientRect();
            let x = mouseEvent.clientX - rect.left;
            let y = mouseEvent.clientY - rect.top;
            return new Vec2_1.default(x, y);
        }
    }
    exports.default = InputHandler;
    },{"../DataTypes/Vec2":32,"../Events/EventQueue":36,"../Events/GameEvent":37,"../Events/GameEventType":38}],42:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // @ignorePage
    /**
     * Sets up the environment of the game engine
     */
    class EnvironmentInitializer {
        static setup() {
            CanvasRenderingContext2D.prototype.roundedRect = function (x, y, w, h, r) {
                // Clamp the radius between 0 and the min of the width or height
                if (r < 0)
                    r = 0;
                if (r > Math.min(w, h))
                    r = Math.min(w, h);
                // Draw the rounded rect
                this.beginPath();
                // Top
                this.moveTo(x + r, y);
                this.lineTo(x + w - r, y);
                this.arcTo(x + w, y, x + w, y + r, r);
                // Right
                this.lineTo(x + w, y + h - r);
                this.arcTo(x + w, y + h, x + w - r, y + h, r);
                // Bottom
                this.lineTo(x + r, y + h);
                this.arcTo(x, y + h, x, y + h - r, r);
                // Left
                this.lineTo(x, y + r);
                this.arcTo(x, y, x + r, y, r);
                this.closePath();
            };
            CanvasRenderingContext2D.prototype.strokeRoundedRect = function (x, y, w, h, r) {
                this.roundedRect(x, y, w, h, r);
                this.stroke();
            };
            CanvasRenderingContext2D.prototype.fillRoundedRect = function (x, y, w, h, r) {
                this.roundedRect(x, y, w, h, r);
                this.fill();
            };
        }
    }
    exports.default = EnvironmentInitializer;
    },{}],43:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const GameLoop_1 = require("./GameLoop");
    const Debug_1 = require("../Debug/Debug");
    const Stats_1 = require("../Debug/Stats");
    /**
     * A game loop with a fixed update time and a variable render time.
     * Every frame, the game updates until all time since the last frame has been processed.
     * If too much time has passed, such as if the last update was too slow,
     * or if the browser was put into the background, the loop will panic and discard time.
     * A render happens at the end of every frame. This happens as fast as possible unless specified.
     * A loop of this type allows for deterministic behavior - No matter what the frame rate is, the update should behave the same,
     * as it is occuring in a fixed interval.
     */
    class FixedUpdateGameLoop extends GameLoop_1.default {
        constructor() {
            super();
            /**
             * The main loop of the game. Updates until the current time is reached. Renders once
             * @param timestamp The current time in ms
             */
            this.doFrame = (timestamp) => {
                // If a pause was executed, stop doing the loop.
                if (this.paused) {
                    return;
                }
                // Request animation frame to prepare for another update or render
                window.requestAnimationFrame((t) => this.doFrame(t));
                // If we are trying to render too soon, do nothing.
                if (timestamp < this.lastFrameTime + this.minFrameDelay) {
                    return;
                }
                // A frame is actually happening
                this.startFrame(timestamp);
                // Update while there is still time to make up. If we do too many update steps, panic and exit the loop.
                this.numUpdateSteps = 0;
                let panic = false;
                while (this.frameDelta >= this.updateTimestep) {
                    // Do an update
                    this._doUpdate(this.updateTimestep / 1000);
                    // Remove the update step time from the time we have to process
                    this.frameDelta -= this.updateTimestep;
                    // Increment steps and check if we've done too many
                    this.numUpdateSteps++;
                    if (this.numUpdateSteps > 100) {
                        panic = true;
                        break;
                    }
                }
                // Updates are done, render
                this._doRender();
                // Wrap up the frame
                this.finishFrame(panic);
            };
            this.maxUpdateFPS = 60;
            this.updateTimestep = Math.floor(1000 / this.maxUpdateFPS);
            this.frameDelta = 0;
            this.lastFrameTime = 0;
            this.minFrameDelay = 0;
            this.frame = 0;
            this.fps = this.maxUpdateFPS; // Initialize the fps to the max allowed fps
            this.fpsUpdateInterval = 1000;
            this.lastFpsUpdate = 0;
            this.framesSinceLastFpsUpdate = 0;
            this.started = false;
            this.paused = false;
            this.running = false;
            this.numUpdateSteps = 0;
        }
        getFPS() {
            return 0;
        }
        /**
         * Updates the frame count and sum of time for the framerate of the game
         * @param timestep The current time in ms
         */
        updateFPS(timestamp) {
            this.fps = 0.9 * this.framesSinceLastFpsUpdate * 1000 / (timestamp - this.lastFpsUpdate) + (1 - 0.9) * this.fps;
            this.lastFpsUpdate = timestamp;
            this.framesSinceLastFpsUpdate = 0;
            Debug_1.default.log("fps", "FPS: " + this.fps.toFixed(1));
            Stats_1.default.updateFPS(this.fps);
        }
        /**
     * Changes the maximum allowed physics framerate of the game
     * @param initMax The max framerate
     */
        setMaxUpdateFPS(initMax) {
            this.maxUpdateFPS = initMax;
            this.updateTimestep = Math.floor(1000 / this.maxUpdateFPS);
        }
        /**
         * Sets the maximum rendering framerate
         * @param maxFPS The max framerate
         */
        setMaxFPS(maxFPS) {
            this.minFrameDelay = 1000 / maxFPS;
        }
        /**
         * This function is called when the game loop panics, i.e. it tries to process too much time in an entire frame.
         * This will reset the amount of time back to zero.
         * @returns The amount of time we are discarding from processing.
         */
        resetFrameDelta() {
            let oldFrameDelta = this.frameDelta;
            this.frameDelta = 0;
            return oldFrameDelta;
        }
        /**
         * Starts up the game loop and calls the first requestAnimationFrame
         */
        start() {
            if (!this.started) {
                this.started = true;
                window.requestAnimationFrame((timestamp) => this.doFirstFrame(timestamp));
            }
        }
        pause() {
            this.paused = true;
        }
        resume() {
            this.paused = false;
        }
        /**
         * The first game frame - initializes the first frame time and begins the render
         * @param timestamp The current time in ms
         */
        doFirstFrame(timestamp) {
            this.running = true;
            this._doRender();
            this.lastFrameTime = timestamp;
            this.lastFpsUpdate = timestamp;
            this.framesSinceLastFpsUpdate = 0;
            window.requestAnimationFrame((t) => this.doFrame(t));
        }
        /**
         * Handles any processing that needs to be done at the start of the frame
         * @param timestamp The time of the frame in ms
         */
        startFrame(timestamp) {
            // Update the amount of time we need our update to process
            this.frameDelta += timestamp - this.lastFrameTime;
            // Set the new time of the last frame
            this.lastFrameTime = timestamp;
            // Update the estimate of the framerate
            if (timestamp > this.lastFpsUpdate + this.fpsUpdateInterval) {
                this.updateFPS(timestamp);
            }
            // Increment the number of frames
            this.frame++;
            this.framesSinceLastFpsUpdate++;
        }
        /**
         * Wraps up the frame and handles the panic state if there is one
         * @param panic Whether or not the loop panicked
         */
        finishFrame(panic) {
            if (panic) {
                var discardedTime = Math.round(this.resetFrameDelta());
                console.warn('Main loop panicked, probably because the browser tab was put in the background. Discarding ' + discardedTime + 'ms');
            }
        }
    }
    exports.default = FixedUpdateGameLoop;
    },{"../Debug/Debug":33,"../Debug/Stats":34,"./GameLoop":45}],44:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const EventQueue_1 = require("../Events/EventQueue");
    const Input_1 = require("../Input/Input");
    const InputHandler_1 = require("../Input/InputHandler");
    const Recorder_1 = require("../Playback/Recorder");
    const Debug_1 = require("../Debug/Debug");
    const ResourceManager_1 = require("../ResourceManager/ResourceManager");
    const Viewport_1 = require("../SceneGraph/Viewport");
    const SceneManager_1 = require("../Scene/SceneManager");
    const AudioManager_1 = require("../Sound/AudioManager");
    const Stats_1 = require("../Debug/Stats");
    const CanvasRenderer_1 = require("../Rendering/CanvasRenderer");
    const Color_1 = require("../Utils/Color");
    const GameOptions_1 = require("./GameOptions");
    const FixedUpdateGameLoop_1 = require("./FixedUpdateGameLoop");
    const EnvironmentInitializer_1 = require("./EnvironmentInitializer");
    const Vec2_1 = require("../DataTypes/Vec2");
    const RegistryManager_1 = require("../Registry/RegistryManager");
    const WebGLRenderer_1 = require("../Rendering/WebGLRenderer");
    /**
     * The main loop of the game engine.
     * Handles the update order, and initializes all subsystems.
     * The Game manages the update cycle, and requests animation frames to render to the browser.
     */
    class Game {
        /**
         * Creates a new Game
         * @param options The options for Game initialization
         */
        constructor(options) {
            // Before anything else, build the environment
            EnvironmentInitializer_1.default.setup();
            // Typecast the config object to a GameConfig object
            this.gameOptions = GameOptions_1.default.parse(options);
            this.showDebug = this.gameOptions.showDebug;
            this.showStats = this.gameOptions.showStats;
            // Create an instance of a game loop
            this.loop = new FixedUpdateGameLoop_1.default();
            // Get the game canvas and give it a background color
            this.GAME_CANVAS = document.getElementById("game-canvas");
            this.DEBUG_CANVAS = document.getElementById("debug-canvas");
            // Give the canvas a size and get the rendering context
            this.WIDTH = this.gameOptions.canvasSize.x;
            this.HEIGHT = this.gameOptions.canvasSize.y;
            // This step MUST happen before the resource manager does anything
            if (this.gameOptions.useWebGL) {
                this.renderingManager = new WebGLRenderer_1.default();
            }
            else {
                this.renderingManager = new CanvasRenderer_1.default();
            }
            this.initializeGameWindow();
            this.ctx = this.renderingManager.initializeCanvas(this.GAME_CANVAS, this.WIDTH, this.HEIGHT);
            this.clearColor = new Color_1.default(this.gameOptions.clearColor.r, this.gameOptions.clearColor.g, this.gameOptions.clearColor.b);
            // Initialize debugging and stats
            Debug_1.default.initializeDebugCanvas(this.DEBUG_CANVAS, this.WIDTH, this.HEIGHT);
            Stats_1.default.initStats();
            if (this.gameOptions.showStats) {
                // Find the stats output and make it no longer hidden
                document.getElementById("stats").hidden = false;
            }
            // Size the viewport to the game canvas
            const canvasSize = new Vec2_1.default(this.WIDTH, this.HEIGHT);
            this.viewport = new Viewport_1.default(canvasSize, this.gameOptions.zoomLevel);
            // Initialize all necessary game subsystems
            this.eventQueue = EventQueue_1.default.getInstance();
            this.inputHandler = new InputHandler_1.default(this.GAME_CANVAS);
            Input_1.default.initialize(this.viewport, this.gameOptions.inputs);
            this.recorder = new Recorder_1.default();
            this.resourceManager = ResourceManager_1.default.getInstance();
            this.sceneManager = new SceneManager_1.default(this.viewport, this.renderingManager);
            this.audioManager = AudioManager_1.default.getInstance();
        }
        /**
         * Set up the game window that holds the canvases
         */
        initializeGameWindow() {
            const gameWindow = document.getElementById("game-window");
            // Set the height of the game window
            gameWindow.style.width = this.WIDTH + "px";
            gameWindow.style.height = this.HEIGHT + "px";
        }
        /**
         * Retreives the SceneManager from the Game
         * @returns The SceneManager
         */
        getSceneManager() {
            return this.sceneManager;
        }
        /**
         * Starts the game
         */
        start(InitialScene, options) {
            // Set the update function of the loop
            this.loop.doUpdate = (deltaT) => this.update(deltaT);
            // Set the render function of the loop
            this.loop.doRender = () => this.render();
            // Preload registry items
            RegistryManager_1.default.preload();
            // Load the items with the resource manager
            this.resourceManager.loadResourcesFromQueue(() => {
                // When we're done loading, start the loop
                console.log("Finished Preload - loading first scene");
                this.sceneManager.changeToScene(InitialScene, {}, options);
                this.loop.start();
            });
        }
        /**
         * Updates all necessary subsystems of the game. Defers scene updates to the sceneManager
         * @param deltaT The time sine the last update
         */
        update(deltaT) {
            try {
                // Handle all events that happened since the start of the last loop
                this.eventQueue.update(deltaT);
                // Update the input data structures so game objects can see the input
                Input_1.default.update(deltaT);
                // Update the recording of the game
                this.recorder.update(deltaT);
                // Update all scenes
                this.sceneManager.update(deltaT);
                // Update all sounds
                this.audioManager.update(deltaT);
                // Load or unload any resources if needed
                this.resourceManager.update(deltaT);
            }
            catch (e) {
                this.loop.pause();
                console.warn("Uncaught Error in Update - Crashing gracefully");
                console.error(e);
            }
        }
        /**
         * Clears the canvas and defers scene rendering to the sceneManager. Renders the debug canvas
         */
        render() {
            try {
                // Clear the canvases
                Debug_1.default.clearCanvas();
                this.renderingManager.clear(this.clearColor);
                this.sceneManager.render();
                // Hacky debug mode
                if (Input_1.default.isKeyJustPressed("g")) {
                    this.showDebug = !this.showDebug;
                }
                // Debug render
                if (this.showDebug) {
                    Debug_1.default.render();
                }
                if (this.showStats) {
                    Stats_1.default.render();
                }
            }
            catch (e) {
                this.loop.pause();
                console.warn("Uncaught Error in Render - Crashing gracefully");
                console.error(e);
            }
        }
    }
    exports.default = Game;
    },{"../DataTypes/Vec2":32,"../Debug/Debug":33,"../Debug/Stats":34,"../Events/EventQueue":36,"../Input/Input":40,"../Input/InputHandler":41,"../Playback/Recorder":70,"../Registry/RegistryManager":73,"../Rendering/CanvasRenderer":81,"../Rendering/WebGLRenderer":86,"../ResourceManager/ResourceManager":93,"../Scene/SceneManager":104,"../SceneGraph/Viewport":96,"../Sound/AudioManager":106,"../Utils/Color":109,"./EnvironmentInitializer":42,"./FixedUpdateGameLoop":43,"./GameOptions":46}],45:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const NullFunc_1 = require("../DataTypes/Functions/NullFunc");
    /**
     * The main game loop of the game. Keeps track of fps and handles scheduling of updates and rendering.
     * This class is left abstract, so that a subclass can handle exactly how the loop is scheduled.
     * For an example of different types of game loop scheduling, check out @link(Game Programming Patterns)(https://gameprogrammingpatterns.com/game-loop.html)
     */
    class GameLoop {
        constructor() {
            /** The function to call when an update occurs */
            this._doUpdate = NullFunc_1.default;
            /** The function to call when a render occurs */
            this._doRender = NullFunc_1.default;
        }
        set doUpdate(update) {
            this._doUpdate = update;
        }
        set doRender(render) {
            this._doRender = render;
        }
    }
    exports.default = GameLoop;
    },{"../DataTypes/Functions/NullFunc":13}],46:[function(require,module,exports){
    "use strict";
    // @ignorePage
    Object.defineProperty(exports, "__esModule", { value: true });
    /** The options for initializing the @reference[GameLoop] */
    class GameOptions {
        /**
         * Parses the data in the raw options object
         * @param options The game options as a Record
         * @returns A version of the options converted to a GameOptions object
         */
        static parse(options) {
            let gOpt = new GameOptions();
            gOpt.canvasSize = options.canvasSize ? options.canvasSize : { x: 800, y: 600 };
            gOpt.zoomLevel = options.zoomLevel ? options.zoomLevel : 1;
            gOpt.clearColor = options.clearColor ? options.clearColor : { r: 255, g: 255, b: 255 };
            gOpt.inputs = options.inputs ? options.inputs : [];
            gOpt.showDebug = !!options.showDebug;
            gOpt.showStats = !!options.showStats;
            gOpt.useWebGL = !!options.useWebGL;
            return gOpt;
        }
    }
    exports.default = GameOptions;
    },{}],47:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const GameNode_1 = require("./GameNode");
    const Vec2_1 = require("../DataTypes/Vec2");
    const AABB_1 = require("../DataTypes/Shapes/AABB");
    const Debug_1 = require("../Debug/Debug");
    const Color_1 = require("../Utils/Color");
    /**
     * The representation of an object in the game world that can be drawn to the screen
     */
    class CanvasNode extends GameNode_1.default {
        constructor() {
            super();
            /** A flag for whether or not the CanvasNode is visible */
            this.visible = true;
            this._size = new Vec2_1.default(0, 0);
            this._size.setOnChange(() => this.sizeChanged());
            this._scale = new Vec2_1.default(1, 1);
            this._scale.setOnChange(() => this.scaleChanged());
            this._boundary = new AABB_1.default();
            this.updateBoundary();
            this._hasCustomShader = false;
        }
        get alpha() {
            return this._alpha;
        }
        set alpha(a) {
            this._alpha = a;
        }
        get size() {
            return this._size;
        }
        set size(size) {
            this._size = size;
            // Enter as a lambda to bind "this"
            this._size.setOnChange(() => this.sizeChanged());
            this.sizeChanged();
        }
        get scale() {
            return this._scale;
        }
        set scale(scale) {
            this._scale = scale;
            // Enter as a lambda to bind "this"
            this._scale.setOnChange(() => this.scaleChanged());
            this.scaleChanged();
        }
        set scaleX(value) {
            this.scale.x = value;
        }
        set scaleY(value) {
            this.scale.y = value;
        }
        get hasCustomShader() {
            return this._hasCustomShader;
        }
        get customShaderKey() {
            return this._customShaderKey;
        }
        // @override
        positionChanged() {
            super.positionChanged();
            this.updateBoundary();
        }
        /** Called if the size vector is changed or replaced. */
        sizeChanged() {
            this.updateBoundary();
        }
        /** Called if the scale vector is changed or replaced */
        scaleChanged() {
            this.updateBoundary();
        }
        // @docIgnore
        /** Called if the position, size, or scale of the CanvasNode is changed. Updates the boundary. */
        updateBoundary() {
            this._boundary.center.set(this.position.x, this.position.y);
            this._boundary.halfSize.set(this.size.x * this.scale.x / 2, this.size.y * this.scale.y / 2);
        }
        get boundary() {
            return this._boundary;
        }
        get sizeWithZoom() {
            let zoom = this.scene.getViewScale();
            return this.boundary.halfSize.clone().scaled(zoom, zoom);
        }
        /**
         * Adds a custom shader to this CanvasNode
         * @param key The registry key of the ShaderType
         */
        useCustomShader(key) {
            this._hasCustomShader = true;
            this._customShaderKey = key;
        }
        /**
         * Returns true if the point (x, y) is inside of this canvas object
         * @param x The x position of the point
         * @param y The y position of the point
         * @returns A flag representing whether or not this node contains the point.
         */
        contains(x, y) {
            return this._boundary.containsPoint(new Vec2_1.default(x, y));
        }
        // @implemented
        debugRender() {
            Debug_1.default.drawBox(this.relativePosition, this.sizeWithZoom, false, Color_1.default.BLUE);
            super.debugRender();
        }
    }
    exports.default = CanvasNode;
    },{"../DataTypes/Shapes/AABB":25,"../DataTypes/Vec2":32,"../Debug/Debug":33,"../Utils/Color":109,"./GameNode":48}],48:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TweenableProperties = void 0;
    const Vec2_1 = require("../DataTypes/Vec2");
    const Receiver_1 = require("../Events/Receiver");
    const Emitter_1 = require("../Events/Emitter");
    const Region_1 = require("../DataTypes/Interfaces/Region");
    const AABB_1 = require("../DataTypes/Shapes/AABB");
    const TweenController_1 = require("../Rendering/Animations/TweenController");
    const Debug_1 = require("../Debug/Debug");
    const Color_1 = require("../Utils/Color");
    const Circle_1 = require("../DataTypes/Shapes/Circle");
    /**
     * The representation of an object in the game world.
     * To construct GameNodes, see the @reference[Scene] documentation.
     */
    class GameNode {
        // Constructor docs are ignored, as the user should NOT create new GameNodes with a raw constructor
        constructor() {
            /*---------- PHYSICAL ----------*/
            this.hasPhysics = false;
            this.moving = false;
            this.frozen = false;
            this.onGround = false;
            this.onWall = false;
            this.onCeiling = false;
            this.active = false;
            this.isColliding = false;
            this.pathfinding = false;
            this._position = new Vec2_1.default(0, 0);
            this._position.setOnChange(() => this.positionChanged());
            this.receiver = new Receiver_1.default();
            this.emitter = new Emitter_1.default();
            this.tweens = new TweenController_1.default(this);
            this.rotation = 0;
        }
        destroy() {
            this.tweens.destroy();
            this.receiver.destroy();
            if (this.hasPhysics) {
                this.removePhysics();
            }
            if (this._ai) {
                this._ai.destroy();
                delete this._ai;
                this.scene.getAIManager().removeActor(this);
            }
            this.scene.remove(this);
            this.layer.removeNode(this);
        }
        /*---------- POSITIONED ----------*/
        get position() {
            return this._position;
        }
        set position(pos) {
            this._position = pos;
            this._position.setOnChange(() => this.positionChanged());
            this.positionChanged();
        }
        get relativePosition() {
            return this.inRelativeCoordinates(this.position);
        }
        /**
         * Converts a point to coordinates relative to the zoom and origin of this node
         * @param point The point to conver
         * @returns A new Vec2 representing the point in relative coordinates
         */
        inRelativeCoordinates(point) {
            let origin = this.scene.getViewTranslation(this);
            let zoom = this.scene.getViewScale();
            return point.clone().sub(origin).scale(zoom);
        }
        /*---------- UNIQUE ----------*/
        get id() {
            return this._id;
        }
        set id(id) {
            // id can only be set once
            if (this._id === undefined) {
                this._id = id;
            }
            else {
                throw "Attempted to assign id to object that already has id.";
            }
        }
        /*---------- PHYSICAL ----------*/
        // @implemented
        /**
         * @param velocity The velocity with which to move the object.
         */
        move(velocity) {
            if (this.frozen)
                return;
            this.moving = true;
            this._velocity = velocity;
        }
        ;
        moveOnPath(speed, path) {
            if (this.frozen)
                return;
            this.path = path;
            let dir = path.getMoveDirection(this);
            this.moving = true;
            this.pathfinding = true;
            this._velocity = dir.scale(speed);
        }
        // @implemented
        /**
         * @param velocity The velocity with which the object will move.
         */
        finishMove() {
            this.moving = false;
            this.position.add(this._velocity);
            if (this.pathfinding) {
                this.path.handlePathProgress(this);
                this.path = null;
                this.pathfinding = false;
            }
        }
        // @implemented
        /**
         * @param collisionShape The collider for this object. If this has a region (implements Region),
         * it will be used when no collision shape is specified (or if collision shape is null).
         * @param isCollidable Whether this is collidable or not. True by default.
         * @param isStatic Whether this is static or not. False by default
         */
        addPhysics(collisionShape, colliderOffset, isCollidable = true, isStatic = false) {
            // Initialize the physics variables
            this.hasPhysics = true;
            this.moving = false;
            this.onGround = false;
            this.onWall = false;
            this.onCeiling = false;
            this.active = true;
            this.isCollidable = isCollidable;
            this.isStatic = isStatic;
            this.isTrigger = false;
            this.triggerMask = 0;
            this.triggerEnters = new Array(32);
            this.triggerExits = new Array(32);
            this._velocity = Vec2_1.default.ZERO;
            this.sweptRect = new AABB_1.default();
            this.collidedWithTilemap = false;
            this.group = -1; // The default group, collides with everything
            // Set the collision shape if provided, or simply use the the region if there is one.
            if (collisionShape) {
                this.collisionShape = collisionShape;
                this.collisionShape.center = this.position;
            }
            else if (Region_1.isRegion(this)) {
                // If the gamenode has a region and no other is specified, use that
                this.collisionShape = this.boundary.clone();
            }
            else {
                throw "No collision shape specified for physics object.";
            }
            // If we were provided with a collider offset, set it. Otherwise there is no offset, so use the zero vector
            if (colliderOffset) {
                this.colliderOffset = colliderOffset;
            }
            else {
                this.colliderOffset = Vec2_1.default.ZERO;
            }
            // Initialize the swept rect
            this.sweptRect = this.collisionShape.getBoundingRect();
            // Register the object with physics
            this.scene.getPhysicsManager().registerObject(this);
        }
        /** Removes this object from the physics system */
        removePhysics() {
            // Remove this from the physics manager
            this.scene.getPhysicsManager().deregisterObject(this);
            // Nullify all physics fields
            this.hasPhysics = false;
            this.moving = false;
            this.onGround = false;
            this.onWall = false;
            this.onCeiling = false;
            this.active = false;
            this.isCollidable = false;
            this.isStatic = false;
            this.isTrigger = false;
            this.triggerMask = 0;
            this.triggerEnters = null;
            this.triggerExits = null;
            this._velocity = Vec2_1.default.ZERO;
            this.sweptRect = null;
            this.collidedWithTilemap = false;
            this.group = -1;
            this.collisionShape = null;
            this.colliderOffset = Vec2_1.default.ZERO;
            this.sweptRect = null;
        }
        /** Disables physics movement for this node */
        freeze() {
            this.frozen = true;
        }
        /** Reenables physics movement for this node */
        unfreeze() {
            this.frozen = false;
        }
        /** Prevents this object from participating in all collisions and triggers. It can still move. */
        disablePhysics() {
            this.active = false;
        }
        /** Enables this object to participate in collisions and triggers. This is only necessary if disablePhysics was called */
        enablePhysics() {
            this.active = true;
        }
        /**
         * Sets the collider for this GameNode
         * @param collider The new collider to use
         */
        setCollisionShape(collider) {
            this.collisionShape = collider;
            this.collisionShape.center.copy(this.position);
        }
        // @implemented
        /**
         * Sets this object to be a trigger for a specific group
         * @param group The name of the group that activates the trigger
         * @param onEnter The name of the event to send when this trigger is activated
         * @param onExit The name of the event to send when this trigger stops being activated
         */
        setTrigger(group, onEnter, onExit) {
            // Make this object a trigger
            this.isTrigger = true;
            // Get the number of the physics layer
            let layerNumber = this.scene.getPhysicsManager().getGroupNumber(group);
            if (layerNumber === 0) {
                console.warn(`Trigger for GameNode ${this.id} not set - group "${group}" was not recognized by the physics manager.`);
                return;
            }
            // Add this to the trigger mask
            this.triggerMask |= layerNumber;
            // Layer numbers are bits, so get which bit it is
            let index = Math.log2(layerNumber);
            // Set the event names
            this.triggerEnters[index] = onEnter;
            this.triggerExits[index] = onExit;
        }
        ;
        // @implemented
        /**
         * @param group The physics group this node should belong to
         */
        setGroup(group) {
            this.scene.getPhysicsManager().setGroup(this, group);
        }
        // @implemened
        getLastVelocity() {
            return this._velocity;
        }
        /*---------- ACTOR ----------*/
        get ai() {
            return this._ai;
        }
        set ai(ai) {
            if (!this._ai) {
                // If we haven't been previously had an ai, register us with the ai manager
                this.scene.getAIManager().registerActor(this);
            }
            this._ai = ai;
            this.aiActive = true;
        }
        // @implemented
        addAI(ai, options, type) {
            if (!this._ai) {
                this.scene.getAIManager().registerActor(this);
            }
            if (typeof ai === "string") {
                this._ai = this.scene.getAIManager().generateAI(ai);
            }
            else {
                this._ai = new ai();
            }
            // Question, how much do we want different type of AI to be handled the same, i.e. should GoapAI and AI similar methods and signatures for the sake of unity
            this._ai.initializeAI(this, options);
            this.aiActive = true;
        }
        // @implemented
        setAIActive(active, options) {
            this.aiActive = active;
            if (this.aiActive) {
                this.ai.activate(options);
            }
        }
        /*---------- TWEENABLE PROPERTIES ----------*/
        set positionX(value) {
            this.position.x = value;
        }
        set positionY(value) {
            this.position.y = value;
        }
        /*---------- GAME NODE ----------*/
        /**
         * Sets the scene for this object.
         * @param scene The scene this object belongs to.
         */
        setScene(scene) {
            this.scene = scene;
        }
        /**
         * Gets the scene this object is in.
         * @returns The scene this object belongs to
        */
        getScene() {
            return this.scene;
        }
        /**
         * Sets the layer of this object.
         * @param layer The layer this object will be on.
         */
        setLayer(layer) {
            this.layer = layer;
        }
        /**
         * Returns the layer this object is on.
         * @returns This layer this object is on.
        */
        getLayer() {
            return this.layer;
        }
        /** Called if the position vector is modified or replaced */
        positionChanged() {
            if (this.collisionShape) {
                if (this.colliderOffset) {
                    this.collisionShape.center = this.position.clone().add(this.colliderOffset);
                }
                else {
                    this.collisionShape.center = this.position.clone();
                }
            }
        }
        ;
        /**
         * Updates this GameNode
         * @param deltaT The timestep of the update.
         */
        update(deltaT) {
            // Defer event handling to AI.
            while (this.receiver.hasNextEvent()) {
                this._ai.handleEvent(this.receiver.getNextEvent());
            }
        }
        // @implemented
        debugRender() {
            // Draw the position of this GameNode
            Debug_1.default.drawPoint(this.relativePosition, Color_1.default.BLUE);
            // If velocity is not zero, draw a vector for it
            if (this._velocity && !this._velocity.isZero()) {
                Debug_1.default.drawRay(this.relativePosition, this._velocity.clone().scaleTo(20).add(this.relativePosition), Color_1.default.BLUE);
            }
            // If this has a collider, draw it
            if (this.collisionShape) {
                let color = this.isColliding ? Color_1.default.RED : Color_1.default.GREEN;
                if (this.isTrigger) {
                    color = Color_1.default.MAGENTA;
                }
                color.a = 0.2;
                if (this.collisionShape instanceof AABB_1.default) {
                    Debug_1.default.drawBox(this.inRelativeCoordinates(this.collisionShape.center), this.collisionShape.halfSize.scaled(this.scene.getViewScale()), true, color);
                }
                else if (this.collisionShape instanceof Circle_1.default) {
                    Debug_1.default.drawCircle(this.inRelativeCoordinates(this.collisionShape.center), this.collisionShape.hw * this.scene.getViewScale(), true, color);
                }
            }
        }
    }
    exports.default = GameNode;
    var TweenableProperties;
    (function (TweenableProperties) {
        TweenableProperties["posX"] = "positionX";
        TweenableProperties["posY"] = "positionY";
        TweenableProperties["scaleX"] = "scaleX";
        TweenableProperties["scaleY"] = "scaleY";
        TweenableProperties["rotation"] = "rotation";
        TweenableProperties["alpha"] = "alpha";
    })(TweenableProperties = exports.TweenableProperties || (exports.TweenableProperties = {}));
    },{"../DataTypes/Interfaces/Region":18,"../DataTypes/Shapes/AABB":25,"../DataTypes/Shapes/Circle":26,"../DataTypes/Vec2":32,"../Debug/Debug":33,"../Events/Emitter":35,"../Events/Receiver":39,"../Rendering/Animations/TweenController":79,"../Utils/Color":109}],49:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const CanvasNode_1 = require("./CanvasNode");
    const Color_1 = require("../Utils/Color");
    /**
     * The representation of a game object that doesn't rely on any resources to render - it is drawn to the screen by the canvas
     */
    class Graphic extends CanvasNode_1.default {
        constructor() {
            super();
            this.color = Color_1.default.RED;
        }
        get alpha() {
            return this.color.a;
        }
        set alpha(a) {
            this.color.a = a;
        }
        // @deprecated
        /**
         * Sets the color of the Graphic. DEPRECATED
         * @param color The new color of the Graphic.
         */
        setColor(color) {
            this.color = color;
        }
        set colorR(r) {
            this.color.r = r;
        }
        get colorR() {
            return this.color.r;
        }
        set colorG(g) {
            this.color.g = g;
        }
        get colorG() {
            return this.color.g;
        }
        set colorB(b) {
            this.color.b = b;
        }
        get colorB() {
            return this.color.b;
        }
    }
    exports.default = Graphic;
    },{"../Utils/Color":109,"./CanvasNode":47}],50:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GraphicType = void 0;
    var GraphicType;
    (function (GraphicType) {
        GraphicType["POINT"] = "POINT";
        GraphicType["RECT"] = "RECT";
        GraphicType["LINE"] = "LINE";
        GraphicType["PARTICLE"] = "PARTICLE";
    })(GraphicType = exports.GraphicType || (exports.GraphicType = {}));
    },{}],51:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Graphic_1 = require("../Graphic");
    class Line extends Graphic_1.default {
        constructor(start, end) {
            super();
            this.start = start;
            this.end = end;
            this.thickness = 2;
            // Does this really have a meaning for lines?
            this.size.set(5, 5);
        }
        set start(pos) {
            this.position = pos;
        }
        get start() {
            return this.position;
        }
        set end(pos) {
            this._end = pos;
        }
        get end() {
            return this._end;
        }
    }
    exports.default = Line;
    },{"../Graphic":49}],52:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Point_1 = require("./Point");
    /**
     * - Position X
    - Velocity (speed and direction) X
    - Color X
    - Lifetime
    - Age can be handled as lifetime
    - Shape X
    - Size X
    - Transparency X
     */
    class Particle extends Point_1.default {
        constructor(position, size, mass) {
            // Are we making this a circle?
            super(position);
            this.inUse = false;
            this.mass = mass;
        }
        setParticleActive(lifetime, position) {
            this.age = lifetime;
            this.inUse = true;
            this.visible = true;
            this.position = position;
        }
        decrementAge(decay) {
            this.age -= decay;
        }
        setParticleInactive() {
            this.inUse = false;
            this.visible = false;
        }
        set velY(y) {
            this.vel.y = y;
        }
        get velY() {
            return this.vel.y;
        }
    }
    exports.default = Particle;
    },{"./Point":53}],53:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Graphic_1 = require("../Graphic");
    /** A basic point to be drawn on the screen. */
    class Point extends Graphic_1.default {
        constructor(position) {
            // Are we making this a circle?
            super();
            this.position = position;
            this.size.set(5, 5);
        }
    }
    exports.default = Point;
    },{"../Graphic":49}],54:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Graphic_1 = require("../Graphic");
    const Color_1 = require("../../Utils/Color");
    /** A basic rectangle to be drawn on the screen. */
    class Rect extends Graphic_1.default {
        constructor(position, size) {
            super();
            this.position = position;
            this.size = size;
            this.borderColor = Color_1.default.TRANSPARENT;
            this.borderWidth = 0;
        }
        /**
         * Sets the border color of this rectangle
         * @param color The border color
         */
        setBorderColor(color) {
            this.borderColor = color;
        }
        // @deprecated
        getBorderColor() {
            return this.borderColor;
        }
        /**
         * Sets the border width of this rectangle
         * @param width The width of the rectangle in pixels
         */
        setBorderWidth(width) {
            this.borderWidth = width;
        }
        getBorderWidth() {
            return this.borderWidth;
        }
    }
    exports.default = Rect;
    },{"../../Utils/Color":109,"../Graphic":49}],55:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Sprite_1 = require("./Sprite");
    const AnimationManager_1 = require("../../Rendering/Animations/AnimationManager");
    const Vec2_1 = require("../../DataTypes/Vec2");
    /** An sprite with specified animation frames. */
    class AnimatedSprite extends Sprite_1.default {
        constructor(spritesheet) {
            super(spritesheet.name);
            this.numCols = spritesheet.columns;
            this.numRows = spritesheet.rows;
            // Set the size of the sprite to the sprite size specified by the spritesheet
            this.size.set(spritesheet.spriteWidth, spritesheet.spriteHeight);
            this.animation = new AnimationManager_1.default(this);
            // Add the animations to the animated sprite
            for (let animation of spritesheet.animations) {
                this.animation.add(animation.name, animation);
            }
        }
        get cols() {
            return this.numCols;
        }
        get rows() {
            return this.numRows;
        }
        /**
         * Gets the image offset for the current index of animation
         * @param index The index we're at in the animation
         * @returns A Vec2 containing the image offset
         */
        getAnimationOffset(index) {
            return new Vec2_1.default((index % this.numCols) * this.size.x, Math.floor(index / this.numCols) * this.size.y);
        }
    }
    exports.default = AnimatedSprite;
    },{"../../DataTypes/Vec2":32,"../../Rendering/Animations/AnimationManager":76,"./Sprite":56}],56:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const CanvasNode_1 = require("../CanvasNode");
    const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
    const Vec2_1 = require("../../DataTypes/Vec2");
    /**
     * The representation of a sprite - an in-game image
     */
    class Sprite extends CanvasNode_1.default {
        constructor(imageId) {
            super();
            this.imageId = imageId;
            let image = ResourceManager_1.default.getInstance().getImage(this.imageId);
            this.size = new Vec2_1.default(image.width, image.height);
            this.imageOffset = Vec2_1.default.ZERO;
            this.invertX = false;
            this.invertY = false;
        }
        /**
         * Sets the offset of the sprite from (0, 0) in the image's coordinates
         * @param offset The offset of the sprite from (0, 0) in image coordinates
         */
        setImageOffset(offset) {
            this.imageOffset = offset;
        }
    }
    exports.default = Sprite;
    },{"../../DataTypes/Vec2":32,"../../ResourceManager/ResourceManager":93,"../CanvasNode":47}],57:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Vec2_1 = require("../DataTypes/Vec2");
    const CanvasNode_1 = require("./CanvasNode");
    /**
     * The representation of a tilemap - this can consist of a combination of tilesets in one layer
     */
    class Tilemap extends CanvasNode_1.default {
        // TODO: Make this no longer be specific to Tiled
        constructor(tilemapData, layer, tilesets, scale) {
            super();
            this.tilesets = tilesets;
            this.tileSize = new Vec2_1.default(0, 0);
            this.name = layer.name;
            let tilecount = 0;
            for (let tileset of tilesets) {
                tilecount += tileset.getTileCount() + 1;
            }
            this.collisionMap = new Array(tilecount);
            for (let i = 0; i < this.collisionMap.length; i++) {
                this.collisionMap[i] = false;
            }
            // Defer parsing of the data to child classes - this allows for isometric vs. orthographic tilemaps and handling of Tiled data or other data
            this.parseTilemapData(tilemapData, layer);
            this.scale.set(scale.x, scale.y);
        }
        /**
         * Returns an array of the tilesets associated with this tilemap
         * @returns An array of all of the tilesets assocaited with this tilemap.
         */
        getTilesets() {
            return this.tilesets;
        }
        /**
         * Returns the size of tiles in this tilemap as they appear in the game world after scaling
         * @returns A vector containing the size of tiles in this tilemap as they appear in the game world after scaling.
         */
        getTileSize() {
            return this.tileSize.scaled(this.scale.x, this.scale.y);
        }
        /**
         * Gets the tile size taking zoom into account
         * @returns The tile size with zoom
        */
        getTileSizeWithZoom() {
            let zoom = this.scene.getViewScale();
            return this.getTileSize().scale(zoom);
        }
        /**
         * Adds this tilemap to the physics system
        */
        addPhysics() {
            this.hasPhysics = true;
            this.active = true;
            this.group = -1;
            this.scene.getPhysicsManager().registerTilemap(this);
        }
    }
    exports.default = Tilemap;
    },{"../DataTypes/Vec2":32,"./CanvasNode":47}],58:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Tilemap_1 = require("../Tilemap");
    const Vec2_1 = require("../../DataTypes/Vec2");
    const Debug_1 = require("../../Debug/Debug");
    const Color_1 = require("../../Utils/Color");
    /**
     * The representation of an orthogonal tilemap - i.e. a top down or platformer tilemap
     */
    class OrthogonalTilemap extends Tilemap_1.default {
        // @override
        parseTilemapData(tilemapData, layer) {
            // The size of the tilemap in local space
            this.numCols = tilemapData.width;
            this.numRows = tilemapData.height;
            // The size of tiles
            this.tileSize.set(tilemapData.tilewidth, tilemapData.tileheight);
            // The size of the tilemap on the canvas
            this.size.set(this.numCols * this.tileSize.x, this.numRows * this.tileSize.y);
            this.position.copy(this.size.scaled(0.5));
            this.data = layer.data;
            this.visible = layer.visible;
            // Whether the tilemap is collidable or not
            this.isCollidable = false;
            if (layer.properties) {
                for (let item of layer.properties) {
                    if (item.name === "Collidable") {
                        this.isCollidable = item.value;
                        // Set all tiles besides "empty: 0" to be collidable
                        for (let i = 1; i < this.collisionMap.length; i++) {
                            this.collisionMap[i] = true;
                        }
                    }
                }
            }
        }
        /**
         * Gets the dimensions of the tilemap
         * @returns A Vec2 containing the number of columns and the number of rows in the tilemap.
         */
        getDimensions() {
            return new Vec2_1.default(this.numCols, this.numRows);
        }
        /**
         * Gets the data value of the tile at the specified world position
         * @param worldCoords The coordinates in world space
         * @returns The data value of the tile
         */
        getTileAtWorldPosition(worldCoords) {
            let localCoords = this.getColRowAt(worldCoords);
            return this.getTileAtRowCol(localCoords);
        }
        /**
         * Get the tile at the specified row and column
         * @param rowCol The coordinates in tilemap space
         * @returns The data value of the tile
         */
        getTileAtRowCol(rowCol) {
            if (rowCol.x < 0 || rowCol.x >= this.numCols || rowCol.y < 0 || rowCol.y >= this.numRows) {
                return -1;
            }
            return this.data[rowCol.y * this.numCols + rowCol.x];
        }
        /**
         * Gets the world position of the tile at the specified index
         * @param index The index of the tile
         * @returns A Vec2 containing the world position of the tile
         */
        getTileWorldPosition(index) {
            // Get the local position
            let col = index % this.numCols;
            let row = Math.floor(index / this.numCols);
            // Get the world position
            let x = col * this.tileSize.x;
            let y = row * this.tileSize.y;
            return new Vec2_1.default(x, y);
        }
        /**
         * Gets the data value of the tile at the specified index
         * @param index The index of the tile
         * @returns The data value of the tile
         */
        getTile(index) {
            return this.data[index];
        }
        // @override
        setTile(index, type) {
            this.data[index] = type;
        }
        /**
         * Sets the tile at the specified row and column
         * @param rowCol The position of the tile in tilemap space
         * @param type The new data value of the tile
         */
        setTileAtRowCol(rowCol, type) {
            let index = rowCol.y * this.numCols + rowCol.x;
            this.setTile(index, type);
        }
        /**
         * Returns true if the tile at the specified row and column of the tilemap is collidable
         * @param indexOrCol The index of the tile or the column it is in
         * @param row The row the tile is in
         * @returns A flag representing whether or not the tile is collidable.
         */
        isTileCollidable(indexOrCol, row) {
            // The value of the tile
            let tile = 0;
            if (row) {
                // We have a column and a row
                tile = this.getTileAtRowCol(new Vec2_1.default(indexOrCol, row));
                if (tile < 0) {
                    return false;
                }
            }
            else {
                if (indexOrCol < 0 || indexOrCol >= this.data.length) {
                    // Tiles that don't exist aren't collidable
                    return false;
                }
                // We have an index
                tile = this.getTile(indexOrCol);
            }
            return this.collisionMap[tile];
        }
        /**
         * Takes in world coordinates and returns the row and column of the tile at that position
         * @param worldCoords The coordinates of the potential tile in world space
         * @returns A Vec2 containing the coordinates of the potential tile in tilemap space
         */
        getColRowAt(worldCoords) {
            let col = Math.floor(worldCoords.x / this.tileSize.x / this.scale.x);
            let row = Math.floor(worldCoords.y / this.tileSize.y / this.scale.y);
            return new Vec2_1.default(col, row);
        }
        // @override
        update(deltaT) { }
        // @override
        debugRender() {
            // Half of the tile size
            let zoomedHalfTileSize = this.getTileSizeWithZoom().scaled(0.5);
            let halfTileSize = this.getTileSize().scaled(0.5);
            // The center of the top left tile
            let topLeft = this.position.clone().sub(this.size.scaled(0.5));
            // A vec to store the center
            let center = Vec2_1.default.ZERO;
            for (let col = 0; col < this.numCols; col++) {
                // Calculate the x-position
                center.x = topLeft.x + col * 2 * halfTileSize.x + halfTileSize.x;
                for (let row = 0; row < this.numRows; row++) {
                    if (this.isCollidable && this.isTileCollidable(col, row)) {
                        // Calculate the y-position
                        center.y = topLeft.y + row * 2 * halfTileSize.y + halfTileSize.y;
                        // Draw a box for this tile
                        Debug_1.default.drawBox(this.inRelativeCoordinates(center), zoomedHalfTileSize, false, Color_1.default.BLUE);
                    }
                }
            }
        }
    }
    exports.default = OrthogonalTilemap;
    },{"../../DataTypes/Vec2":32,"../../Debug/Debug":33,"../../Utils/Color":109,"../Tilemap":57}],59:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const CanvasNode_1 = require("./CanvasNode");
    const Color_1 = require("../Utils/Color");
    const Vec2_1 = require("../DataTypes/Vec2");
    const Input_1 = require("../Input/Input");
    /**
     * The representation of a UIElement - the parent class of things like buttons
     */
    class UIElement extends CanvasNode_1.default {
        constructor(position) {
            super();
            this.position = position;
            this.backgroundColor = new Color_1.default(0, 0, 0, 0);
            this.borderColor = new Color_1.default(0, 0, 0, 0);
            this.borderRadius = 5;
            this.borderWidth = 1;
            this.padding = Vec2_1.default.ZERO;
            this.onClick = null;
            this.onClickEventId = null;
            this.onRelease = null;
            this.onReleaseEventId = null;
            this.onEnter = null;
            this.onEnterEventId = null;
            this.onLeave = null;
            this.onLeaveEventId = null;
            this.isClicked = false;
            this.isEntered = false;
        }
        // @deprecated
        setBackgroundColor(color) {
            this.backgroundColor = color;
        }
        // @deprecated
        setPadding(padding) {
            this.padding.copy(padding);
        }
        setPosition(position) {
            this.position = position;
        }
        update(deltaT) {
            super.update(deltaT);
            // See of this object was just clicked
            if (Input_1.default.isMouseJustPressed()) {
                let clickPos = Input_1.default.getMousePressPosition();
                if (this.contains(clickPos.x, clickPos.y) && this.visible && !this.layer.isHidden()) {
                    this.isClicked = true;
                    if (this.onClick !== null) {
                        this.onClick();
                    }
                    if (this.onClickEventId !== null) {
                        let data = {};
                        this.emitter.fireEvent(this.onClickEventId, data);
                    }
                }
            }
            // If the mouse wasn't just pressed, then we definitely weren't clicked
            if (!Input_1.default.isMousePressed()) {
                if (this.isClicked) {
                    this.isClicked = false;
                }
            }
            // Check if the mouse is hovering over this element
            let mousePos = Input_1.default.getMousePosition();
            if (mousePos && this.contains(mousePos.x, mousePos.y)) {
                this.isEntered = true;
                if (this.onEnter !== null) {
                    this.onEnter();
                }
                if (this.onEnterEventId !== null) {
                    let data = {};
                    this.emitter.fireEvent(this.onEnterEventId, data);
                }
            }
            else if (this.isEntered) {
                this.isEntered = false;
                if (this.onLeave !== null) {
                    this.onLeave();
                }
                if (this.onLeaveEventId !== null) {
                    let data = {};
                    this.emitter.fireEvent(this.onLeaveEventId, data);
                }
            }
            else if (this.isClicked) {
                // If mouse is dragged off of element while down, it is not clicked anymore
                this.isClicked = false;
            }
        }
        /**
         * Overridable method for calculating background color - useful for elements that want to be colored on different after certain events
         * @returns The background color of the UIElement
         */
        calculateBackgroundColor() {
            return this.backgroundColor;
        }
        /**
         * Overridable method for calculating border color - useful for elements that want to be colored on different after certain events
         * @returns The border color of the UIElement
         */
        calculateBorderColor() {
            return this.borderColor;
        }
    }
    exports.default = UIElement;
    },{"../DataTypes/Vec2":32,"../Input/Input":40,"../Utils/Color":109,"./CanvasNode":47}],60:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Label_1 = require("./Label");
    const Color_1 = require("../../Utils/Color");
    /** A clickable button UIElement */
    class Button extends Label_1.default {
        constructor(position, text) {
            super(position, text);
            this.backgroundColor = new Color_1.default(150, 75, 203);
            this.borderColor = new Color_1.default(41, 46, 30);
            this.textColor = new Color_1.default(255, 255, 255);
        }
        // @override
        calculateBackgroundColor() {
            // Change the background color if clicked or hovered
            if (this.isEntered && !this.isClicked) {
                return this.backgroundColor.lighten();
            }
            else if (this.isClicked) {
                return this.backgroundColor.darken();
            }
            else {
                return this.backgroundColor;
            }
        }
    }
    exports.default = Button;
    },{"../../Utils/Color":109,"./Label":61}],61:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HAlign = exports.VAlign = void 0;
    const Vec2_1 = require("../../DataTypes/Vec2");
    const Color_1 = require("../../Utils/Color");
    const UIElement_1 = require("../UIElement");
    /** A basic text-containing label */
    class Label extends UIElement_1.default {
        constructor(position, text) {
            super(position);
            this.text = text;
            this.textColor = new Color_1.default(0, 0, 0, 1);
            this.font = "Fantasy";
            this.fontSize = 30;
            this.hAlign = "center";
            this.vAlign = "center";
            this.sizeAssigned = false;
        }
        // @deprecated
        setText(text) {
            this.text = text;
        }
        // @deprecated
        setTextColor(color) {
            this.textColor = color;
        }
        /**
         * Gets a string containg the font details for rendering
         * @returns A string containing the font details
         */
        getFontString() {
            return this.fontSize + "px " + this.font;
        }
        /**
         * Overridable method for calculating text color - useful for elements that want to be colored on different after certain events
         * @returns a string containg the text color
         */
        calculateTextColor() {
            return this.textColor.toStringRGBA();
        }
        /**
         * Uses the canvas to calculate the width of the text
         * @param ctx The rendering context
         * @returns A number representing the rendered text width
         */
        calculateTextWidth(ctx) {
            ctx.font = this.fontSize + "px " + this.font;
            return ctx.measureText(this.text).width;
        }
        setHAlign(align) {
            this.hAlign = align;
        }
        setVAlign(align) {
            this.vAlign = align;
        }
        /**
         * Calculate the offset of the text - this is used for rendering text with different alignments
         * @param ctx The rendering context
         * @returns The offset of the text in a Vec2
         */
        calculateTextOffset(ctx) {
            let textWidth = this.calculateTextWidth(ctx);
            let offset = new Vec2_1.default(0, 0);
            let hDiff = this.size.x - textWidth;
            if (this.hAlign === HAlign.CENTER) {
                offset.x = hDiff / 2;
            }
            else if (this.hAlign === HAlign.RIGHT) {
                offset.x = hDiff;
            }
            if (this.vAlign === VAlign.TOP) {
                ctx.textBaseline = "top";
                offset.y = 0;
            }
            else if (this.vAlign === VAlign.BOTTOM) {
                ctx.textBaseline = "bottom";
                offset.y = this.size.y;
            }
            else {
                ctx.textBaseline = "middle";
                offset.y = this.size.y / 2;
            }
            return offset;
        }
        sizeChanged() {
            super.sizeChanged();
            this.sizeAssigned = true;
        }
        /**
         * Automatically sizes the element to the text within it
         * @param ctx The rendering context
         */
        autoSize(ctx) {
            let width = this.calculateTextWidth(ctx);
            let height = this.fontSize;
            this.size.set(width + this.padding.x * 2, height + this.padding.y * 2);
            this.sizeAssigned = true;
        }
        /**
         * Initially assigns a size to the UIElement if none is provided
         * @param ctx The rendering context
         */
        handleInitialSizing(ctx) {
            if (!this.sizeAssigned) {
                this.autoSize(ctx);
            }
        }
        /** On the next render, size this element to it's current text using its current font size */
        sizeToText() {
            this.sizeAssigned = false;
        }
    }
    exports.default = Label;
    var VAlign;
    (function (VAlign) {
        VAlign["TOP"] = "top";
        VAlign["CENTER"] = "center";
        VAlign["BOTTOM"] = "bottom";
    })(VAlign = exports.VAlign || (exports.VAlign = {}));
    var HAlign;
    (function (HAlign) {
        HAlign["LEFT"] = "left";
        HAlign["CENTER"] = "center";
        HAlign["RIGHT"] = "right";
    })(HAlign = exports.HAlign || (exports.HAlign = {}));
    },{"../../DataTypes/Vec2":32,"../../Utils/Color":109,"../UIElement":59}],62:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Vec2_1 = require("../../DataTypes/Vec2");
    const Input_1 = require("../../Input/Input");
    const Color_1 = require("../../Utils/Color");
    const MathUtils_1 = require("../../Utils/MathUtils");
    const UIElement_1 = require("../UIElement");
    /** A slider UIElement */
    class Slider extends UIElement_1.default {
        constructor(position, initValue) {
            super(position);
            this.value = initValue;
            this.nibColor = Color_1.default.RED;
            this.sliderColor = Color_1.default.BLACK;
            this.backgroundColor = Color_1.default.TRANSPARENT;
            this.borderColor = Color_1.default.TRANSPARENT;
            this.nibSize = new Vec2_1.default(10, 20);
            // Set a default size
            this.size.set(200, 20);
        }
        /**
         * Retrieves the value of the slider
         * @returns The value of the slider
         */
        getValue() {
            return this.value;
        }
        /** A method called in response to the value changing */
        valueChanged() {
            if (this.onValueChange) {
                this.onValueChange(this.value);
            }
            if (this.onValueChangeEventId) {
                this.emitter.fireEvent(this.onValueChangeEventId, { target: this, value: this.value });
            }
        }
        update(deltaT) {
            super.update(deltaT);
            if (this.isClicked) {
                let val = MathUtils_1.default.invLerp(this.position.x - this.size.x / 2, this.position.x + this.size.x / 2, Input_1.default.getMousePosition().x);
                this.value = MathUtils_1.default.clamp01(val);
                this.valueChanged();
            }
        }
    }
    exports.default = Slider;
    },{"../../DataTypes/Vec2":32,"../../Input/Input":40,"../../Utils/Color":109,"../../Utils/MathUtils":112,"../UIElement":59}],63:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Color_1 = require("../../Utils/Color");
    const Label_1 = require("./Label");
    const Input_1 = require("../../Input/Input");
    /** A text input UIElement */
    class TextInput extends Label_1.default {
        constructor(position) {
            super(position, "");
            this.focused = false;
            this.cursorCounter = 0;
            // Give a default size to the x only
            this.size.set(200, this.fontSize);
            this.hAlign = "left";
            this.borderColor = Color_1.default.BLACK;
            this.backgroundColor = Color_1.default.WHITE;
        }
        update(deltaT) {
            super.update(deltaT);
            if (Input_1.default.isMouseJustPressed()) {
                let clickPos = Input_1.default.getMousePressPosition();
                if (this.contains(clickPos.x, clickPos.y)) {
                    this.focused = true;
                    this.cursorCounter = 30;
                }
                else {
                    this.focused = false;
                }
            }
            if (this.focused) {
                let keys = Input_1.default.getKeysJustPressed();
                let nums = "1234567890";
                let specialChars = "`~!@#$%^&*()-_=+[{]}\\|;:'\",<.>/?";
                let letters = "qwertyuiopasdfghjklzxcvbnm";
                let mask = nums + specialChars + letters;
                keys = keys.filter(key => mask.includes(key));
                let shiftPressed = Input_1.default.isKeyPressed("shift");
                let backspacePressed = Input_1.default.isKeyJustPressed("backspace");
                let spacePressed = Input_1.default.isKeyJustPressed("space");
                if (backspacePressed) {
                    this.text = this.text.substring(0, this.text.length - 1);
                }
                else if (spacePressed) {
                    this.text += " ";
                }
                else if (keys.length > 0) {
                    if (shiftPressed) {
                        this.text += keys[0].toUpperCase();
                    }
                    else {
                        this.text += keys[0];
                    }
                }
            }
        }
    }
    exports.default = TextInput;
    },{"../../Input/Input":40,"../../Utils/Color":109,"./Label":61}],64:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UIElementType = void 0;
    var UIElementType;
    (function (UIElementType) {
        UIElementType["BUTTON"] = "BUTTON";
        UIElementType["LABEL"] = "LABEL";
        UIElementType["SLIDER"] = "SLIDER";
        UIElementType["TEXT_INPUT"] = "TEXTINPUT";
    })(UIElementType = exports.UIElementType || (exports.UIElementType = {}));
    },{}],65:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Map_1 = require("../DataTypes/Map");
    /**
     * The manager class for navigation.
     * Handles all navigable entities, such and allows them to be accessed by outside systems by requesting a path
     * from one position to another.
     */
    class NavigationManager {
        constructor() {
            this.navigableEntities = new Map_1.default();
        }
        /**
         * Adds a navigable entity to the NavigationManager
         * @param navName The name of the navigable entitry
         * @param nav The actual Navigable instance
         */
        addNavigableEntity(navName, nav) {
            this.navigableEntities.add(navName, nav);
        }
        /**
         * Gets a path frome one point to another using a specified Navigable object
         * @param navName The name of the registered Navigable object
         * @param fromPosition The starting position of navigation
         * @param toPosition The ending position of Navigation
         * @param direct If true, go direct from fromPosition to toPosition, don't use NavMesh
         * @returns A NavigationPath containing the route to take over the Navigable entity to get between the provided positions.
         */
        getPath(navName, fromPosition, toPosition, direct) {
            let nav = this.navigableEntities.get(navName);
            return nav.getNavigationPath(fromPosition.clone(), toPosition.clone(), direct);
        }
    }
    exports.default = NavigationManager;
    },{"../DataTypes/Map":19}],66:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Vec2_1 = require("../DataTypes/Vec2");
    /**
     * A path that AIs can follow. Uses finishMove() in Physical to determine progress on the route
     */
    class NavigationPath {
        /**
         * Constructs a new NavigationPath
         * @param path The path of nodes to take
         */
        constructor(path) {
            this.path = path;
            this.currentMoveDirection = Vec2_1.default.ZERO;
            this.distanceThreshold = 4;
        }
        /**
         * Returns the status of navigation along this NavigationPath
         * @returns True if the node has reached the end of the path, false otherwise
         */
        isDone() {
            return this.path.isEmpty();
        }
        /**
         * Gets the movement direction in the current position along the path
         * @param node The node to move along the path
         * @returns The movement direction as a Vec2
         */
        getMoveDirection(node) {
            // Return direction to next point in the nav
            return node.position.dirTo(this.path.peek());
        }
        /**
         * Updates this NavigationPath to the current state of the GameNode
         * @param node The node moving along the path
         */
        handlePathProgress(node) {
            if (node.position.distanceSqTo(this.path.peek()) < this.distanceThreshold * this.distanceThreshold) {
                // We've reached our node, move on to the next destination
                this.path.pop();
            }
        }
        toString() {
            return this.path.toString();
        }
    }
    exports.default = NavigationPath;
    },{"../DataTypes/Vec2":32}],67:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Stack_1 = require("../DataTypes/Stack");
    const GraphUtils_1 = require("../Utils/GraphUtils");
    const NavigationPath_1 = require("./NavigationPath");
    /**
     * An implementation of a Navmesh. Navmeshes are graphs in the game world along which nodes can move.
     */
    class Navmesh {
        /**
         * Creates a new Navmesh from the points in the speecified graph
         * @param graph The graph to construct a navmesh from
         */
        constructor(graph) {
            this.graph = graph;
        }
        // @implemented
        getNavigationPath(fromPosition, toPosition, direct) {
            let start = this.getClosestNode(fromPosition);
            let end = this.getClosestNode(toPosition);
            let pathStack = new Stack_1.default(this.graph.numVertices);
            // Push the final position and the final position in the graph
            pathStack.push(toPosition.clone());
            if (direct) {
                return new NavigationPath_1.default(pathStack);
            }
            pathStack.push(this.graph.positions[end]);
            let parent = GraphUtils_1.default.djikstra(this.graph, start);
            // Add all parents along the path
            let i = end;
            while (parent[i] !== -1) {
                pathStack.push(this.graph.positions[parent[i]]);
                i = parent[i];
            }
            return new NavigationPath_1.default(pathStack);
        }
        /**
         * Gets the closest node in this Navmesh to the specified position
         * @param position The position to query
         * @returns The index of the closest node in the Navmesh to the position
         */
        getClosestNode(position) {
            let n = this.graph.numVertices;
            let i = 1;
            let index = 0;
            let dist = position.distanceSqTo(this.graph.positions[0]);
            while (i < n) {
                let d = position.distanceSqTo(this.graph.positions[i]);
                if (d < dist) {
                    dist = d;
                    index = i;
                }
                i++;
            }
            return index;
        }
    }
    exports.default = Navmesh;
    },{"../DataTypes/Stack":28,"../Utils/GraphUtils":111,"./NavigationPath":66}],68:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const PhysicsManager_1 = require("./PhysicsManager");
    const Vec2_1 = require("../DataTypes/Vec2");
    const AABB_1 = require("../DataTypes/Shapes/AABB");
    const OrthogonalTilemap_1 = require("../Nodes/Tilemaps/OrthogonalTilemap");
    const AreaCollision_1 = require("../DataTypes/Physics/AreaCollision");
    /**
     * ALGORITHM:
     * 	In an effort to keep things simple and working effectively, each dynamic node will resolve its
     * 	collisions considering the rest of the world as static.
     *
     * 	Collision detecting will happen first. This can be considered a broad phase, but it is not especially
     * 	efficient, as it does not need to be for this game engine. Every dynamic node is checked against every
     * 	other node for collision area. If collision area is non-zero (meaning the current node sweeps into another),
     * 	it is added to a list of hits.
     *
     * 	INITIALIZATION:
     * 		- Physics constants are reset
     * 		- Swept shapes are recalculated. If a node isn't moving, it is skipped.
     *
     * 	COLLISION DETECTION:
     * 		- For a node, collision area will be calculated using the swept AABB of the node against every other AABB in a static state
     * 		- These collisions will be sorted by area in descending order
     *
     * 	COLLISION RESOLUTION:
     * 		- For each hit, time of collision is calculated using a swept line through the AABB of the static node expanded
     * 			with minkowski sums (discretely, but the concept is there)
     * 		- The collision is resolved based on the near time of the collision (from method of separated axes)
     * 			- X is resolved by near x, Y by near y.
     * 			- There is some fudging to allow for sliding along walls of separate colliders. Sorting by area also helps with this.
     * 			- Corner to corner collisions are resolve to favor x-movement. This is in consideration of platformers, to give
     * 				the player some help with jumps
     *
     * 	Pros:
     * 		- Everything happens with a consistent time. There is a distinct before and after for each resolution.
     * 		- No back-tracking needs to be done. Once we resolve a node, it is definitively resolved.
     *
     * 	Cons:
     * 		- Nodes that are processed early have movement priority over other nodes. This can lead to some undesirable interactions.
     */
    class BasicPhysicsManager extends PhysicsManager_1.default {
        constructor(options) {
            super();
            this.staticNodes = new Array();
            this.dynamicNodes = new Array();
            this.tilemaps = new Array();
            this.collisionMasks = new Array(32);
            // Parse options
            this.parseOptions(options);
        }
        /**
         * Parses the options for constructing the physics manager
         * @param options A record of options
         */
        parseOptions(options) {
            if (options.groupNames !== undefined && options.collisions !== undefined) {
                for (let i = 0; i < options.groupNames.length; i++) {
                    let group = options.groupNames[i];
                    // Register the group name and number
                    this.groupNames[i] = group;
                    this.groupMap.set(group, 1 << i);
                    let collisionMask = 0;
                    for (let j = 0; j < options.collisions[i].length; j++) {
                        if (options.collisions[i][j]) {
                            collisionMask |= 1 << j;
                        }
                    }
                    this.collisionMasks[i] = collisionMask;
                }
            }
        }
        // @override
        registerObject(node) {
            if (node.isStatic) {
                // Static and not collidable
                this.staticNodes.push(node);
            }
            else {
                // Dynamic and not collidable
                this.dynamicNodes.push(node);
            }
        }
        // @override
        deregisterObject(node) {
            if (node.isStatic) {
                // Remove the node from the static list
                const index = this.staticNodes.indexOf(node);
                this.staticNodes.splice(index, 1);
            }
            else {
                // Remove the node from the dynamic list
                const index = this.dynamicNodes.indexOf(node);
                this.dynamicNodes.splice(index, 1);
            }
        }
        // @override
        registerTilemap(tilemap) {
            this.tilemaps.push(tilemap);
        }
        // @override
        deregisterTilemap(tilemap) {
            const index = this.tilemaps.indexOf(tilemap);
            this.tilemaps.splice(index, 1);
        }
        // @override
        update(deltaT) {
            for (let node of this.dynamicNodes) {
                /*---------- INITIALIZATION PHASE ----------*/
                // Clear frame dependent boolean values for each node
                node.onGround = false;
                node.onCeiling = false;
                node.onWall = false;
                node.collidedWithTilemap = false;
                node.isColliding = false;
                // If this node is not active, don't process it
                if (!node.active) {
                    continue;
                }
                // Update the swept shapes of each node
                if (node.moving) {
                    // If moving, reflect that in the swept shape
                    node.sweptRect.sweep(node._velocity, node.collisionShape.center, node.collisionShape.halfSize);
                }
                else {
                    // If our node isn't moving, don't bother to check it (other nodes will detect if they run into it)
                    node._velocity.zero();
                    continue;
                }
                /*---------- DETECTION PHASE ----------*/
                // Gather a set of overlaps
                let overlaps = new Array();
                let groupIndex = node.group === -1 ? -1 : Math.log2(node.group);
                // First, check this node against every static node (order doesn't actually matter here, since we sort anyways)
                for (let other of this.staticNodes) {
                    // Ignore inactive nodes
                    if (!other.active)
                        continue;
                    let collider = other.collisionShape.getBoundingRect();
                    let area = node.sweptRect.overlapArea(collider);
                    if (area > 0) {
                        // We had a collision
                        overlaps.push(new AreaCollision_1.default(area, collider, other, "GameNode", null));
                    }
                }
                // Then, check it against every dynamic node
                for (let other of this.dynamicNodes) {
                    // Ignore ourselves
                    if (node === other)
                        continue;
                    // Ignore inactive nodes
                    if (!other.active)
                        continue;
                    let collider = other.collisionShape.getBoundingRect();
                    let area = node.sweptRect.overlapArea(collider);
                    if (area > 0) {
                        // We had a collision
                        overlaps.push(new AreaCollision_1.default(area, collider, other, "GameNode", null));
                    }
                }
                // Lastly, gather a set of AABBs from the tilemap.
                // This step involves the most extra work, so it is abstracted into a method
                for (let tilemap of this.tilemaps) {
                    // Ignore inactive tilemaps
                    if (!tilemap.active)
                        continue;
                    if (tilemap instanceof OrthogonalTilemap_1.default) {
                        this.collideWithOrthogonalTilemap(node, tilemap, overlaps);
                    }
                }
                // Sort the overlaps by area
                overlaps = overlaps.sort((a, b) => b.area - a.area);
                // Keep track of hits to use later
                let hits = [];
                /*---------- RESOLUTION PHASE ----------*/
                // For every overlap, determine if we need to collide with it and when
                for (let overlap of overlaps) {
                    // Ignore nodes we don't interact with
                    if (groupIndex !== -1 && overlap.other.group !== -1 && ((this.collisionMasks[groupIndex] & overlap.other.group) === 0))
                        continue;
                    // Do a swept line test on the static AABB with this AABB size as padding (this is basically using a minkowski sum!)
                    // Start the sweep at the position of this node with a delta of _velocity
                    const point = node.collisionShape.center;
                    const delta = node._velocity;
                    const padding = node.collisionShape.halfSize;
                    const otherAABB = overlap.collider;
                    const hit = otherAABB.intersectSegment(node.collisionShape.center, node._velocity, node.collisionShape.halfSize);
                    overlap.hit = hit;
                    if (hit !== null) {
                        hits.push(hit);
                        // We got a hit, resolve with the time inside of the hit
                        let tnearx = hit.nearTimes.x;
                        let tneary = hit.nearTimes.y;
                        // Allow edge clipping (edge overlaps don't count, only area overlaps)
                        // Importantly don't allow both cases to be true. Then we clip through corners. Favor x to help players land jumps
                        if (tnearx < 1.0 && (point.y === otherAABB.top - padding.y || point.y === otherAABB.bottom + padding.y) && delta.x !== 0) {
                            tnearx = 1.0;
                        }
                        else if (tneary < 1.0 && (point.x === otherAABB.left - padding.x || point.x === otherAABB.right + padding.x) && delta.y !== 0) {
                            tneary = 1.0;
                        }
                        if (hit.nearTimes.x >= 0 && hit.nearTimes.x < 1) {
                            // Any tilemap objects that made it here are collidable
                            if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                                node._velocity.x = node._velocity.x * tnearx;
                                node.isColliding = true;
                            }
                        }
                        if (hit.nearTimes.y >= 0 && hit.nearTimes.y < 1) {
                            // Any tilemap objects that made it here are collidable
                            if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                                node._velocity.y = node._velocity.y * tneary;
                                node.isColliding = true;
                            }
                        }
                    }
                }
                /*---------- INFORMATION/TRIGGER PHASE ----------*/
                // Check if we ended up on the ground, ceiling or wall
                // Also check for triggers
                for (let overlap of overlaps) {
                    // Check for a trigger. If we care about the trigger, react
                    if (overlap.other.isTrigger && (overlap.other.triggerMask & node.group)) {
                        // Get the bit that this group is represented by
                        let index = Math.floor(Math.log2(node.group));
                        // Extract the triggerEnter event name
                        this.emitter.fireEvent(overlap.other.triggerEnters[index], {
                            node: node.id,
                            other: overlap.other.id
                        });
                    }
                    // Ignore collision sides for nodes we don't interact with
                    if (groupIndex !== -1 && overlap.other.group !== -1 && ((this.collisionMasks[groupIndex] & overlap.other.group) === 0))
                        continue;
                    // Only check for direction if the overlap was collidable
                    if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                        let collisionSide = overlap.collider.touchesAABBWithoutCorners(node.collisionShape.getBoundingRect());
                        if (collisionSide !== null) {
                            // If we touch, not including corner cases, check the collision normal
                            if (overlap.hit !== null) {
                                // If we hit a tilemap, keep track of it
                                if (overlap.type == "Tilemap") {
                                    node.collidedWithTilemap = true;
                                }
                                if (collisionSide.y === -1) {
                                    // Node is on top of overlap, so onGround
                                    node.onGround = true;
                                }
                                else if (collisionSide.y === 1) {
                                    // Node is on bottom of overlap, so onCeiling
                                    node.onCeiling = true;
                                }
                                else {
                                    // Node wasn't touching on y, so it is touching on x
                                    node.onWall = true;
                                }
                            }
                        }
                    }
                }
                // Resolve the collision with the node, and move it
                node.finishMove();
            }
        }
        /**
         * Handles a collision between this node and an orthogonal tilemap
         * @param node The node
         * @param tilemap The tilemap the node may be colliding with
         * @param overlaps The list of overlaps
         */
        collideWithOrthogonalTilemap(node, tilemap, overlaps) {
            // Get the min and max x and y coordinates of the moving node
            let min = new Vec2_1.default(node.sweptRect.left, node.sweptRect.top);
            let max = new Vec2_1.default(node.sweptRect.right, node.sweptRect.bottom);
            // Convert the min/max x/y to the min and max row/col in the tilemap array
            let minIndex = tilemap.getColRowAt(min);
            let maxIndex = tilemap.getColRowAt(max);
            let tileSize = tilemap.getTileSize();
            // Loop over all possible tiles (which isn't many in the scope of the velocity per frame)
            for (let col = minIndex.x; col <= maxIndex.x; col++) {
                for (let row = minIndex.y; row <= maxIndex.y; row++) {
                    if (tilemap.isTileCollidable(col, row)) {
                        // Get the position of this tile
                        let tilePos = new Vec2_1.default(col * tileSize.x + tileSize.x / 2, row * tileSize.y + tileSize.y / 2);
                        // Create a new collider for this tile
                        let collider = new AABB_1.default(tilePos, tileSize.scaled(1 / 2));
                        // Calculate collision area between the node and the tile
                        let area = node.sweptRect.overlapArea(collider);
                        if (area > 0) {
                            // We had a collision
                            overlaps.push(new AreaCollision_1.default(area, collider, tilemap, "Tilemap", new Vec2_1.default(col, row)));
                        }
                    }
                }
            }
        }
    }
    exports.default = BasicPhysicsManager;
    },{"../DataTypes/Physics/AreaCollision":21,"../DataTypes/Shapes/AABB":25,"../DataTypes/Vec2":32,"../Nodes/Tilemaps/OrthogonalTilemap":58,"./PhysicsManager":69}],69:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Receiver_1 = require("../Events/Receiver");
    const Emitter_1 = require("../Events/Emitter");
    const Map_1 = require("../DataTypes/Map");
    /**
     * An abstract physics manager.
     * This class exposes functions for subclasses to implement that should allow for a working physics system to be created.
     */
    class PhysicsManager {
        constructor() {
            this.receiver = new Receiver_1.default();
            this.emitter = new Emitter_1.default();
            // The creation and implementation of layers is deferred to the subclass
            this.groupMap = new Map_1.default();
            this.groupNames = new Array();
        }
        destroy() {
            this.receiver.destroy();
        }
        /**
         * Sets the physics layer of the GameNode
         * @param node The GameNode
         * @param group The group that the GameNode should be on
         */
        setGroup(node, group) {
            node.group = this.groupMap.get(group);
        }
        /**
         * Retrieves the layer number associated with the provided name
         * @param layer The name of the layer
         * @returns The layer number, or 0 if there is not a layer with that name registered
         */
        getGroupNumber(group) {
            if (this.groupMap.has(group)) {
                return this.groupMap.get(group);
            }
            else {
                return 0;
            }
        }
        /**
         * Gets all group names associated with the number provided
         * @param groups A mask of groups
         * @returns All groups contained in the mask
         */
        getGroupNames(groups) {
            if (groups === -1) {
                return [PhysicsManager.DEFAULT_GROUP];
            }
            else {
                let g = 1;
                let names = [];
                for (let i = 0; i < 32; i++) {
                    if (g & groups) {
                        // This group is in the groups number
                        names.push(this.groupNames[i]);
                    }
                    // Shift the bit over
                    g = g << 1;
                }
            }
        }
    }
    exports.default = PhysicsManager;
    /** The default group name */
    PhysicsManager.DEFAULT_GROUP = "Default";
    },{"../DataTypes/Map":19,"../Events/Emitter":35,"../Events/Receiver":39}],70:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Queue_1 = require("../DataTypes/Queue");
    const Receiver_1 = require("../Events/Receiver");
    const EventQueue_1 = require("../Events/EventQueue");
    const GameEventType_1 = require("../Events/GameEventType");
    // @ignorePage
    class Recorder {
        constructor() {
            this.receiver = new Receiver_1.default();
            this.log = new Queue_1.default(1000);
            this.recording = false;
            this.playing = false;
            this.frame = 0;
            this.eventQueue = EventQueue_1.default.getInstance();
            this.eventQueue.subscribe(this.receiver, "all");
        }
        update(deltaT) {
            if (this.recording) {
                this.frame += 1;
            }
            if (this.playing) {
                // If playing, ignore events, just feed the record to the event queue
                this.receiver.ignoreEvents();
                /*
                    While there is a next item, and while it should occur in this frame,
                    send the event. i.e., while current_frame * current_delta_t is greater
                    than recorded_frame * recorded_delta_t
                */
                while (this.log.hasItems()
                    && this.log.peekNext().frame * this.log.peekNext().delta < this.frame * deltaT) {
                    let event = this.log.dequeue().event;
                    console.log(event);
                    this.eventQueue.addEvent(event);
                }
                if (!this.log.hasItems()) {
                    this.playing = false;
                }
                this.frame += 1;
            }
            else {
                // If not playing, handle events
                while (this.receiver.hasNextEvent()) {
                    let event = this.receiver.getNextEvent();
                    if (event.type === GameEventType_1.GameEventType.STOP_RECORDING) {
                        this.recording = false;
                    }
                    if (this.recording) {
                        this.log.enqueue(new LogItem(this.frame, deltaT, event));
                    }
                    if (event.type === GameEventType_1.GameEventType.START_RECORDING) {
                        this.log.clear();
                        this.recording = true;
                        this.frame = 0;
                    }
                    if (event.type === GameEventType_1.GameEventType.PLAY_RECORDING) {
                        this.frame = 0;
                        this.recording = false;
                        this.playing = true;
                    }
                }
            }
        }
    }
    exports.default = Recorder;
    class LogItem {
        constructor(frame, deltaT, event) {
            this.frame = frame;
            this.delta = deltaT;
            this.event = event;
        }
    }
    },{"../DataTypes/Queue":23,"../Events/EventQueue":36,"../Events/GameEventType":38,"../Events/Receiver":39}],71:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Map_1 = require("../../DataTypes/Map");
    /** */
    class Registry extends Map_1.default {
    }
    exports.default = Registry;
    },{"../../DataTypes/Map":19}],72:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const LabelShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/LabelShaderType");
    const PointShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/PointShaderType");
    const RectShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/RectShaderType");
    const SpriteShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/SpriteShaderType");
    const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
    const Registry_1 = require("./Registry");
    /**
     * A registry that handles shaders
     */
    class ShaderRegistry extends Registry_1.default {
        constructor() {
            super(...arguments);
            this.registryItems = new Array();
        }
        /**
         * Preloads all built-in shaders
         */
        preload() {
            // Get the resourceManager and queue all built-in shaders for preloading
            const rm = ResourceManager_1.default.getInstance();
            // Queue a load for the point shader
            this.registerAndPreloadItem(ShaderRegistry.POINT_SHADER, PointShaderType_1.default, "builtin/shaders/point.vshader", "builtin/shaders/point.fshader");
            // Queue a load for the rect shader
            this.registerAndPreloadItem(ShaderRegistry.RECT_SHADER, RectShaderType_1.default, "builtin/shaders/rect.vshader", "builtin/shaders/rect.fshader");
            // Queue a load for the sprite shader
            this.registerAndPreloadItem(ShaderRegistry.SPRITE_SHADER, SpriteShaderType_1.default, "builtin/shaders/sprite.vshader", "builtin/shaders/sprite.fshader");
            // Queue a load for the label shader
            this.registerAndPreloadItem(ShaderRegistry.LABEL_SHADER, LabelShaderType_1.default, "builtin/shaders/label.vshader", "builtin/shaders/label.fshader");
            // Queue a load for any preloaded items
            for (let item of this.registryItems) {
                const shader = new item.constr(item.key);
                shader.initBufferObject();
                this.add(item.key, shader);
                // Load if desired
                if (item.preload !== undefined) {
                    rm.shader(item.key, item.preload.vshaderLocation, item.preload.fshaderLocation);
                }
            }
        }
        /**
         * Registers a shader in the registry and loads it before the game begins
         * @param key The key you wish to assign to the shader
         * @param constr The constructor of the ShaderType
         * @param vshaderLocation The location of the vertex shader
         * @param fshaderLocation the location of the fragment shader
         */
        registerAndPreloadItem(key, constr, vshaderLocation, fshaderLocation) {
            let shaderPreload = new ShaderPreload();
            shaderPreload.vshaderLocation = vshaderLocation;
            shaderPreload.fshaderLocation = fshaderLocation;
            let registryItem = new ShaderRegistryItem();
            registryItem.key = key;
            registryItem.constr = constr;
            registryItem.preload = shaderPreload;
            this.registryItems.push(registryItem);
        }
        /**
         * Registers a shader in the registry. NOTE: If you use this, you MUST load the shader before use.
         * If you wish to preload the shader, use registerAndPreloadItem()
         * @param key The key you wish to assign to the shader
         * @param constr The constructor of the ShaderType
         */
        registerItem(key, constr) {
            let registryItem = new ShaderRegistryItem();
            registryItem.key = key;
            registryItem.constr = constr;
            this.registryItems.push(registryItem);
        }
    }
    exports.default = ShaderRegistry;
    // Shader names
    ShaderRegistry.POINT_SHADER = "point";
    ShaderRegistry.RECT_SHADER = "rect";
    ShaderRegistry.SPRITE_SHADER = "sprite";
    ShaderRegistry.LABEL_SHADER = "label";
    class ShaderRegistryItem {
    }
    class ShaderPreload {
    }
    },{"../../Rendering/WebGLRendering/ShaderTypes/LabelShaderType":88,"../../Rendering/WebGLRendering/ShaderTypes/PointShaderType":89,"../../Rendering/WebGLRendering/ShaderTypes/RectShaderType":91,"../../Rendering/WebGLRendering/ShaderTypes/SpriteShaderType":92,"../../ResourceManager/ResourceManager":93,"./Registry":71}],73:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Map_1 = require("../DataTypes/Map");
    const ShaderRegistry_1 = require("./Registries/ShaderRegistry");
    /**
     * The Registry is the system's way of converting classes and types into string
     * representations for use elsewhere in the application.
     * It allows classes to be accessed without explicitly using constructors in code,
     * and for resources to be loaded at Game creation time.
     */
    class RegistryManager {
        static preload() {
            this.shaders.preload();
            this.registries.forEach((key) => this.registries.get(key).preload());
        }
        static addCustomRegistry(name, registry) {
            this.registries.add(name, registry);
        }
        static getRegistry(key) {
            return this.registries.get(key);
        }
    }
    exports.default = RegistryManager;
    RegistryManager.shaders = new ShaderRegistry_1.default();
    /** Additional custom registries to add to the registry manager */
    RegistryManager.registries = new Map_1.default();
    },{"../DataTypes/Map":19,"./Registries/ShaderRegistry":72}],74:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Registry_1 = require("./Registries/Registry");
    const ResourceManager_1 = require("../ResourceManager/ResourceManager");
    const LaserGun_1 = require("../../mayhemFiles/GameSystems/items/WeaponTypes/LaserGun");
    const SemiAutoGun_1 = require("../../mayhemFiles/GameSystems/items/WeaponTypes/SemiAutoGun");
    const Slice_1 = require("../../mayhemFiles/GameSystems/items/WeaponTypes/Slice");
    class WeaponTemplateRegistry extends Registry_1.default {
        preload() {
            const rm = ResourceManager_1.default.getInstance();
            // Load sprites
            rm.image("pistol", "mayhemAssets/sprites/pistol.png");
            rm.image("knife", "mayhemAssets/sprites/knife.png");
            rm.image("laserGun", "mayhemAssets/sprites/laserGun.png");
            // Load spritesheets
            rm.spritesheet("slice", "mayhemAssets/spritesheets/slice.json");
            // Register default types
            this.registerItem("slice", Slice_1.default);
            this.registerItem("laserGun", LaserGun_1.default);
            this.registerItem("semiAutoGun", SemiAutoGun_1.default);
        }
        // We don't need this for this assignment
        registerAndPreloadItem(key) { }
        registerItem(key, constr) {
            this.add(key, constr);
        }
    }
    exports.default = WeaponTemplateRegistry;
    },{"../../mayhemFiles/GameSystems/items/WeaponTypes/LaserGun":130,"../../mayhemFiles/GameSystems/items/WeaponTypes/SemiAutoGun":131,"../../mayhemFiles/GameSystems/items/WeaponTypes/Slice":132,"../ResourceManager/ResourceManager":93,"./Registries/Registry":71}],75:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Registry_1 = require("./Registries/Registry");
    class WeaponTypeRegistry extends Registry_1.default {
        preload() { }
        // We don't need this for this assignment
        registerAndPreloadItem(key) { }
        registerItem(key, type) {
            this.add(key, type);
        }
    }
    exports.default = WeaponTypeRegistry;
    },{"./Registries/Registry":71}],76:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Map_1 = require("../../DataTypes/Map");
    const Emitter_1 = require("../../Events/Emitter");
    const AnimationTypes_1 = require("./AnimationTypes");
    /**
     * An animation manager class for an animated CanvasNode.
     * This class keeps track of the possible animations, as well as the current animation state,
     * and abstracts all interactions with playing, pausing, and stopping animations as well as
     * creating new animations from the CanvasNode.
     */
    class AnimationManager {
        /**
         * Creates a new AnimationManager
         * @param owner The owner of the AnimationManager
         */
        constructor(owner) {
            this.owner = owner;
            this.animationState = AnimationTypes_1.AnimationState.STOPPED;
            this.currentAnimation = "";
            this.currentFrame = 0;
            this.frameProgress = 0;
            this.loop = false;
            this.animations = new Map_1.default();
            this.onEndEvent = null;
            this.emitter = new Emitter_1.default();
        }
        /**
         * Add an animation to this sprite
         * @param key The unique key of the animation
         * @param animation The animation data
         */
        add(key, animation) {
            this.animations.add(key, animation);
        }
        /**
         * Gets the index specified by the current animation and current frame
         * @returns The index in the current animation
         */
        getIndex() {
            if (this.animations.has(this.currentAnimation)) {
                return this.animations.get(this.currentAnimation).frames[this.currentFrame].index;
            }
            else {
                // No current animation, warn the user
                console.warn(`Animation index was requested, but the current animation: ${this.currentAnimation} was invalid`);
                return 0;
            }
        }
        getCurrentAnimation() {
            return this.currentAnimation;
        }
        /**
         * Determines whether the specified animation is currently playing
         * @param key The key of the animation to check
         * @returns true if the specified animation is playing, false otherwise
         */
        isPlaying(key) {
            return (this.currentAnimation === key &&
                this.animationState === AnimationTypes_1.AnimationState.PLAYING);
        }
        /**
         * Retrieves the current animation index and advances the animation frame
         * @returns The index of the animation frame
         */
        getIndexAndAdvanceAnimation() {
            // If we aren't playing, we won't be advancing the animation
            if (!(this.animationState === AnimationTypes_1.AnimationState.PLAYING)) {
                return this.getIndex();
            }
            if (this.animations.has(this.currentAnimation)) {
                let currentAnimation = this.animations.get(this.currentAnimation);
                let index = currentAnimation.frames[this.currentFrame].index;
                // Advance the animation
                this.frameProgress += 1;
                if (this.frameProgress >=
                    currentAnimation.frames[this.currentFrame].duration) {
                    // We have been on this frame for its whole duration, go to the next one
                    this.frameProgress = 0;
                    this.currentFrame += 1;
                    if (this.currentFrame >= currentAnimation.frames.length) {
                        // We have reached the end of this animation
                        if (this.loop) {
                            this.currentFrame = 0;
                            this.frameProgress = 0;
                        }
                        else {
                            this.endCurrentAnimation();
                        }
                    }
                }
                // Return the current index
                return index;
            }
            else {
                // No current animation, can't advance. Warn the user
                console.warn(`Animation index and advance was requested, but the current animation (${this.currentAnimation}) in node with id: ${this.owner.id} was invalid`);
                return 0;
            }
        }
        /** Ends the current animation and fires any necessary events, as well as starting any new animations */
        endCurrentAnimation() {
            this.currentFrame = 0;
            this.animationState = AnimationTypes_1.AnimationState.STOPPED;
            if (this.onEndEvent !== null) {
                this.emitter.fireEvent(this.onEndEvent, {
                    owner: this.owner.id,
                    animation: this.currentAnimation,
                });
            }
            // If there is a pending animation, play it
            if (this.pendingAnimation !== null) {
                this.play(this.pendingAnimation, this.pendingLoop, this.pendingOnEnd);
            }
        }
        /**
         * Plays the specified animation. Does not restart it if it is already playing
         * @param animation The name of the animation to play
         * @param loop Whether or not to loop the animation. False by default
         * @param onEnd The name of an event to send when this animation naturally stops playing. This only matters if loop is false.
         */
        playIfNotAlready(animation, loop, onEnd) {
            if (this.currentAnimation !== animation) {
                this.play(animation, loop, onEnd);
            }
        }
        /**
         * Plays the specified animation
         * @param animation The name of the animation to play
         * @param loop Whether or not to loop the animation. False by default
         * @param onEnd The name of an event to send when this animation naturally stops playing. This only matters if loop is false.
         */
        play(animation, loop, onEnd) {
            this.currentAnimation = animation;
            this.currentFrame = 0;
            this.frameProgress = 0;
            this.animationState = AnimationTypes_1.AnimationState.PLAYING;
            // If loop arg was provided, use that
            if (loop !== undefined) {
                this.loop = loop;
            }
            else {
                // Otherwise, use what the json file specified
                this.loop = this.animations.get(animation).repeat;
            }
            if (onEnd !== undefined) {
                this.onEndEvent = onEnd;
            }
            else {
                this.onEndEvent = null;
            }
            // Reset pending animation
            this.pendingAnimation = null;
        }
        /**
         * Queues a single animation to be played after the current one. Does NOT stack.
         * Queueing additional animations past 1 will just replace the queued animation
         * @param animation The animation to queue
         * @param loop Whether or not the loop the queued animation
         * @param onEnd The event to fire when the queued animation ends
         */
        queue(animation, loop = false, onEnd) {
            this.pendingAnimation = animation;
            this.pendingLoop = loop;
            if (onEnd !== undefined) {
                this.pendingOnEnd = onEnd;
            }
            else {
                this.pendingOnEnd = null;
            }
        }
        /** Pauses the current animation */
        pause() {
            this.animationState = AnimationTypes_1.AnimationState.PAUSED;
        }
        /** Resumes the current animation if possible */
        resume() {
            if (this.animationState === AnimationTypes_1.AnimationState.PAUSED) {
                this.animationState = AnimationTypes_1.AnimationState.PLAYING;
            }
        }
        /** Stops the current animation. The animation cannot be resumed after this. */
        stop() {
            this.animationState = AnimationTypes_1.AnimationState.STOPPED;
        }
    }
    exports.default = AnimationManager;
    },{"../../DataTypes/Map":19,"../../Events/Emitter":35,"./AnimationTypes":77}],77:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TweenData = exports.TweenEffect = exports.AnimationData = exports.AnimationState = void 0;
    // @ignorePage
    var AnimationState;
    (function (AnimationState) {
        AnimationState[AnimationState["STOPPED"] = 0] = "STOPPED";
        AnimationState[AnimationState["PAUSED"] = 1] = "PAUSED";
        AnimationState[AnimationState["PLAYING"] = 2] = "PLAYING";
    })(AnimationState = exports.AnimationState || (exports.AnimationState = {}));
    class AnimationData {
        constructor() {
            this.repeat = false;
        }
    }
    exports.AnimationData = AnimationData;
    class TweenEffect {
    }
    exports.TweenEffect = TweenEffect;
    class TweenData {
    }
    exports.TweenData = TweenData;
    },{}],78:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ParticleSystemManager {
        constructor() {
            this.particleSystems = new Array();
        }
        static getInstance() {
            if (ParticleSystemManager.instance === null) {
                ParticleSystemManager.instance = new ParticleSystemManager();
            }
            return ParticleSystemManager.instance;
        }
        registerParticleSystem(system) {
            this.particleSystems.push(system);
        }
        deregisterParticleSystem(system) {
            let index = this.particleSystems.indexOf(system);
            this.particleSystems.splice(index, 1);
        }
        clearParticleSystems() {
            this.particleSystems = new Array();
        }
        update(deltaT) {
            for (let particleSystem of this.particleSystems) {
                particleSystem.update(deltaT);
            }
        }
    }
    exports.default = ParticleSystemManager;
    ParticleSystemManager.instance = null;
    },{}],79:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Map_1 = require("../../DataTypes/Map");
    const AnimationTypes_1 = require("./AnimationTypes");
    const EaseFunctions_1 = require("../../Utils/EaseFunctions");
    const MathUtils_1 = require("../../Utils/MathUtils");
    const TweenManager_1 = require("./TweenManager");
    const Emitter_1 = require("../../Events/Emitter");
    /**
     * A manager for the tweens of a GameNode.
     * Tweens are short animations played by interpolating between two properties using an easing function.
     * For a good visual representation of easing functions, check out @link(https://easings.net/)(https://easings.net/).
     * Multiple tween can be played at the same time, as long as they don't change the same property.
     * This allows for some interesting polishes or animations that may be very difficult to do with sprite work alone
     * - especially pixel art (such as rotations or scaling).
     */
    class TweenController {
        /**
         * Creates a new TweenController
         * @param owner The owner of the TweenController
         */
        constructor(owner) {
            this.owner = owner;
            this.tweens = new Map_1.default();
            this.emitter = new Emitter_1.default();
            // Give ourselves to the TweenManager
            TweenManager_1.default.getInstance().registerTweenController(this);
        }
        /**
         * Destroys this TweenController
         */
        destroy() {
            // Only the gamenode and the tween manager should have a reference to this
            delete this.owner.tweens;
            TweenManager_1.default.getInstance().deregisterTweenController(this);
        }
        /**
         * Add a tween to this game node
         * @param key The name of the tween
         * @param tween The data of the tween
         */
        add(key, tween) {
            let typedTween = tween;
            // Initialize members that we need (and the user didn't provide)
            typedTween.progress = 0;
            typedTween.elapsedTime = 0;
            typedTween.animationState = AnimationTypes_1.AnimationState.STOPPED;
            this.tweens.add(key, typedTween);
        }
        /**
         * Play a tween with a certain name
         * @param key The name of the tween to play
         * @param loop Whether or not the tween should loop
         */
        play(key, loop) {
            if (this.tweens.has(key)) {
                let tween = this.tweens.get(key);
                // Set loop if needed
                if (loop !== undefined) {
                    tween.loop = loop;
                }
                // Set the initial values
                for (let effect of tween.effects) {
                    if (effect.resetOnComplete) {
                        effect.initialValue = this.owner[effect.property];
                    }
                }
                // Start the tween running
                tween.animationState = AnimationTypes_1.AnimationState.PLAYING;
                tween.elapsedTime = 0;
                tween.progress = 0;
                tween.reversing = false;
            }
            else {
                console.warn(`Tried to play tween "${key}" on node with id ${this.owner.id}, but no such tween exists`);
            }
        }
        /**
         * Pauses a playing tween. Does not affect tweens that are stopped.
         * @param key The name of the tween to pause.
         */
        pause(key) {
            if (this.tweens.has(key)) {
                this.tweens.get(key).animationState = AnimationTypes_1.AnimationState.PAUSED;
            }
        }
        /**
         * Resumes a paused tween.
         * @param key The name of the tween to resume
         */
        resume(key) {
            if (this.tweens.has(key)) {
                let tween = this.tweens.get(key);
                if (tween.animationState === AnimationTypes_1.AnimationState.PAUSED)
                    tween.animationState = AnimationTypes_1.AnimationState.PLAYING;
            }
        }
        /**
         * Stops a currently playing tween
         * @param key The key of the tween
         */
        stop(key) {
            if (this.tweens.has(key)) {
                let tween = this.tweens.get(key);
                tween.animationState = AnimationTypes_1.AnimationState.STOPPED;
                // Return to the initial values
                for (let effect of tween.effects) {
                    if (effect.resetOnComplete) {
                        this.owner[effect.property] = effect.initialValue;
                    }
                }
            }
        }
        /**
         * The natural stop of a currently playing tween
         * @param key The key of the tween
         */
        end(key) {
            this.stop(key);
            if (this.tweens.has(key)) {
                // Get the tween
                let tween = this.tweens.get(key);
                // If it has an onEnd, send an event
                if (tween.onEnd) {
                    this.emitter.fireEvent(tween.onEnd, { key: key, node: this.owner.id });
                }
            }
        }
        /**
         * Stops all currently playing tweens
         */
        stopAll() {
            this.tweens.forEach(key => this.stop(key));
        }
        update(deltaT) {
            this.tweens.forEach(key => {
                let tween = this.tweens.get(key);
                if (tween.animationState === AnimationTypes_1.AnimationState.PLAYING) {
                    // Update the progress of the tween
                    tween.elapsedTime += deltaT * 1000;
                    // If we're past the startDelay, do the tween
                    if (tween.elapsedTime >= tween.startDelay) {
                        if (!tween.reversing && tween.elapsedTime >= tween.startDelay + tween.duration) {
                            // If we're over time, stop the tween, loop, or reverse
                            if (tween.reverseOnComplete) {
                                // If we're over time and can reverse, do so
                                tween.reversing = true;
                            }
                            else if (tween.loop) {
                                // If we can't reverse and can loop, do so
                                tween.elapsedTime -= tween.duration;
                            }
                            else {
                                // We aren't looping and can't reverse, so stop
                                this.end(key);
                            }
                        }
                        // Check for the end of reversing
                        if (tween.reversing && tween.elapsedTime >= tween.startDelay + 2 * tween.duration) {
                            if (tween.loop) {
                                tween.reversing = false;
                                tween.elapsedTime -= 2 * tween.duration;
                            }
                            else {
                                this.end(key);
                            }
                        }
                        // Update the progress, make sure it is between 0 and 1. Errors from this should never be large
                        if (tween.reversing) {
                            tween.progress = MathUtils_1.default.clamp01((2 * tween.duration - (tween.elapsedTime - tween.startDelay)) / tween.duration);
                        }
                        else {
                            tween.progress = MathUtils_1.default.clamp01((tween.elapsedTime - tween.startDelay) / tween.duration);
                        }
                        for (let effect of tween.effects) {
                            // Get the value from the ease function that corresponds to our progress
                            let ease = EaseFunctions_1.default[effect.ease](tween.progress);
                            // Use the value to lerp the property
                            let value = MathUtils_1.default.lerp(effect.start, effect.end, ease);
                            // Assign the value of the property
                            this.owner[effect.property] = value;
                        }
                    }
                }
            });
        }
    }
    exports.default = TweenController;
    },{"../../DataTypes/Map":19,"../../Events/Emitter":35,"../../Utils/EaseFunctions":110,"../../Utils/MathUtils":112,"./AnimationTypes":77,"./TweenManager":80}],80:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class TweenManager {
        constructor() {
            this.tweenControllers = new Array();
        }
        static getInstance() {
            if (TweenManager.instance === null) {
                TweenManager.instance = new TweenManager();
            }
            return TweenManager.instance;
        }
        registerTweenController(controller) {
            this.tweenControllers.push(controller);
        }
        deregisterTweenController(controller) {
            let index = this.tweenControllers.indexOf(controller);
            this.tweenControllers.splice(index, 1);
        }
        clearTweenControllers() {
            this.tweenControllers = new Array();
        }
        update(deltaT) {
            for (let tweenController of this.tweenControllers) {
                tweenController.update(deltaT);
            }
        }
    }
    exports.default = TweenManager;
    TweenManager.instance = null;
    },{}],81:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Graphic_1 = require("../Nodes/Graphic");
    const Point_1 = require("../Nodes/Graphics/Point");
    const Rect_1 = require("../Nodes/Graphics/Rect");
    const Sprite_1 = require("../Nodes/Sprites/Sprite");
    const OrthogonalTilemap_1 = require("../Nodes/Tilemaps/OrthogonalTilemap");
    const UIElement_1 = require("../Nodes/UIElement");
    const GraphicRenderer_1 = require("./CanvasRendering/GraphicRenderer");
    const RenderingManager_1 = require("./RenderingManager");
    const TilemapRenderer_1 = require("./CanvasRendering/TilemapRenderer");
    const UIElementRenderer_1 = require("./CanvasRendering/UIElementRenderer");
    const Label_1 = require("../Nodes/UIElements/Label");
    const Button_1 = require("../Nodes/UIElements/Button");
    const Slider_1 = require("../Nodes/UIElements/Slider");
    const TextInput_1 = require("../Nodes/UIElements/TextInput");
    const AnimatedSprite_1 = require("../Nodes/Sprites/AnimatedSprite");
    const Vec2_1 = require("../DataTypes/Vec2");
    const Line_1 = require("../Nodes/Graphics/Line");
    const Debug_1 = require("../Debug/Debug");
    /**
     * An implementation of the RenderingManager class using CanvasRenderingContext2D.
     */
    class CanvasRenderer extends RenderingManager_1.default {
        constructor() {
            super();
        }
        // @override
        setScene(scene) {
            this.scene = scene;
            this.graphicRenderer.setScene(scene);
            this.tilemapRenderer.setScene(scene);
            this.uiElementRenderer.setScene(scene);
        }
        // @override
        initializeCanvas(canvas, width, height) {
            canvas.width = width;
            canvas.height = height;
            this.worldSize = new Vec2_1.default(width, height);
            this.ctx = canvas.getContext("2d");
            this.graphicRenderer = new GraphicRenderer_1.default(this.ctx);
            this.tilemapRenderer = new TilemapRenderer_1.default(this.ctx);
            this.uiElementRenderer = new UIElementRenderer_1.default(this.ctx);
            // For crisp pixel art
            this.ctx.imageSmoothingEnabled = false;
            return this.ctx;
        }
        // @override
        render(visibleSet, tilemaps, uiLayers) {
            // Sort by depth, then by visible set by y-value
            visibleSet.sort((a, b) => {
                if (a.getLayer().getDepth() === b.getLayer().getDepth()) {
                    return (a.boundary.bottom) - (b.boundary.bottom);
                }
                else {
                    return a.getLayer().getDepth() - b.getLayer().getDepth();
                }
            });
            let tilemapIndex = 0;
            let tilemapLength = tilemaps.length;
            let visibleSetIndex = 0;
            let visibleSetLength = visibleSet.length;
            while (tilemapIndex < tilemapLength || visibleSetIndex < visibleSetLength) {
                // Check conditions where we've already reached the edge of one list
                if (tilemapIndex >= tilemapLength) {
                    // Only render the remaining visible set
                    let node = visibleSet[visibleSetIndex++];
                    if (node.visible) {
                        this.renderNode(node);
                    }
                    continue;
                }
                if (visibleSetIndex >= visibleSetLength) {
                    // Only render tilemaps
                    this.renderTilemap(tilemaps[tilemapIndex++]);
                    continue;
                }
                // Render whichever is further down
                if (tilemaps[tilemapIndex].getLayer().getDepth() <= visibleSet[visibleSetIndex].getLayer().getDepth()) {
                    this.renderTilemap(tilemaps[tilemapIndex++]);
                }
                else {
                    let node = visibleSet[visibleSetIndex++];
                    if (node.visible) {
                        this.renderNode(node);
                    }
                }
            }
            // Render the uiLayers on top of everything else
            let sortedUILayers = new Array();
            uiLayers.forEach(key => sortedUILayers.push(uiLayers.get(key)));
            sortedUILayers = sortedUILayers.sort((ui1, ui2) => ui1.getDepth() - ui2.getDepth());
            sortedUILayers.forEach(uiLayer => {
                if (!uiLayer.isHidden())
                    uiLayer.getItems().forEach(node => {
                        if (node.visible) {
                            this.renderNode(node);
                        }
                    });
            });
        }
        /**
         * Renders a specified CanvasNode
         * @param node The CanvasNode to render
         */
        renderNode(node) {
            // Calculate the origin of the viewport according to this sprite
            this.origin = this.scene.getViewTranslation(node);
            // Get the zoom level of the scene
            this.zoom = this.scene.getViewScale();
            // Move the canvas to the position of the node and rotate
            let xScale = 1;
            let yScale = 1;
            if (node instanceof Sprite_1.default) {
                xScale = node.invertX ? -1 : 1;
                yScale = node.invertY ? -1 : 1;
            }
            this.ctx.setTransform(xScale, 0, 0, yScale, (node.position.x - this.origin.x) * this.zoom, (node.position.y - this.origin.y) * this.zoom);
            this.ctx.rotate(-node.rotation);
            let globalAlpha = this.ctx.globalAlpha;
            if (node instanceof Rect_1.default) {
                Debug_1.default.log("node" + node.id, "Node" + node.id + " Alpha: " + node.alpha);
            }
            this.ctx.globalAlpha = node.alpha;
            if (node instanceof AnimatedSprite_1.default) {
                this.renderAnimatedSprite(node);
            }
            else if (node instanceof Sprite_1.default) {
                this.renderSprite(node);
            }
            else if (node instanceof Graphic_1.default) {
                this.renderGraphic(node);
            }
            else if (node instanceof UIElement_1.default) {
                this.renderUIElement(node);
            }
            this.ctx.globalAlpha = globalAlpha;
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        }
        // @override
        renderSprite(sprite) {
            // Get the image from the resource manager
            let image = this.resourceManager.getImage(sprite.imageId);
            /*
                Coordinates in the space of the image:
                    image crop start -> x, y
                    image crop size  -> w, h
                Coordinates in the space of the world
                    image draw start -> x, y
                    image draw size  -> w, h
            */
            this.ctx.drawImage(image, sprite.imageOffset.x, sprite.imageOffset.y, sprite.size.x, sprite.size.y, (-sprite.size.x * sprite.scale.x / 2) * this.zoom, (-sprite.size.y * sprite.scale.y / 2) * this.zoom, sprite.size.x * sprite.scale.x * this.zoom, sprite.size.y * sprite.scale.y * this.zoom);
        }
        // @override
        renderAnimatedSprite(sprite) {
            // Get the image from the resource manager
            let image = this.resourceManager.getImage(sprite.imageId);
            let animationIndex = sprite.animation.getIndexAndAdvanceAnimation();
            let animationOffset = sprite.getAnimationOffset(animationIndex);
            /*
                Coordinates in the space of the image:
                    image crop start -> x, y
                    image crop size  -> w, h
                Coordinates in the space of the world (given we moved)
                    image draw start -> -w/2, -h/2
                    image draw size  -> w, h
            */
            this.ctx.drawImage(image, sprite.imageOffset.x + animationOffset.x, sprite.imageOffset.y + animationOffset.y, sprite.size.x, sprite.size.y, (-sprite.size.x * sprite.scale.x / 2) * this.zoom, (-sprite.size.y * sprite.scale.y / 2) * this.zoom, sprite.size.x * sprite.scale.x * this.zoom, sprite.size.y * sprite.scale.y * this.zoom);
        }
        // @override
        renderGraphic(graphic) {
            if (graphic instanceof Point_1.default) {
                this.graphicRenderer.renderPoint(graphic, this.zoom);
            }
            else if (graphic instanceof Line_1.default) {
                this.graphicRenderer.renderLine(graphic, this.origin, this.zoom);
            }
            else if (graphic instanceof Rect_1.default) {
                this.graphicRenderer.renderRect(graphic, this.zoom);
            }
        }
        // @override
        renderTilemap(tilemap) {
            if (tilemap instanceof OrthogonalTilemap_1.default) {
                this.tilemapRenderer.renderOrthogonalTilemap(tilemap);
            }
        }
        // @override
        renderUIElement(uiElement) {
            if (uiElement instanceof Label_1.default) {
                this.uiElementRenderer.renderLabel(uiElement);
            }
            else if (uiElement instanceof Button_1.default) {
                this.uiElementRenderer.renderButton(uiElement);
            }
            else if (uiElement instanceof Slider_1.default) {
                this.uiElementRenderer.renderSlider(uiElement);
            }
            else if (uiElement instanceof TextInput_1.default) {
                this.uiElementRenderer.renderTextInput(uiElement);
            }
        }
        clear(clearColor) {
            this.ctx.clearRect(0, 0, this.worldSize.x, this.worldSize.y);
            this.ctx.fillStyle = clearColor.toString();
            this.ctx.fillRect(0, 0, this.worldSize.x, this.worldSize.y);
        }
    }
    exports.default = CanvasRenderer;
    },{"../DataTypes/Vec2":32,"../Debug/Debug":33,"../Nodes/Graphic":49,"../Nodes/Graphics/Line":51,"../Nodes/Graphics/Point":53,"../Nodes/Graphics/Rect":54,"../Nodes/Sprites/AnimatedSprite":55,"../Nodes/Sprites/Sprite":56,"../Nodes/Tilemaps/OrthogonalTilemap":58,"../Nodes/UIElement":59,"../Nodes/UIElements/Button":60,"../Nodes/UIElements/Label":61,"../Nodes/UIElements/Slider":62,"../Nodes/UIElements/TextInput":63,"./CanvasRendering/GraphicRenderer":82,"./CanvasRendering/TilemapRenderer":83,"./CanvasRendering/UIElementRenderer":84,"./RenderingManager":85}],82:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
    /**
     * A utility class to help the @reference[CanvasRenderer] render @reference[Graphic]s
     */
    class GraphicRenderer {
        constructor(ctx) {
            this.resourceManager = ResourceManager_1.default.getInstance();
            this.ctx = ctx;
        }
        /**
         * Sets the scene of this GraphicRenderer
         * @param scene The current scene
         */
        setScene(scene) {
            this.scene = scene;
        }
        /**
         * Renders a point
         * @param point The point to render
         * @param zoom The zoom level
         */
        renderPoint(point, zoom) {
            this.ctx.fillStyle = point.color.toStringRGBA();
            this.ctx.fillRect((-point.size.x / 2) * zoom, (-point.size.y / 2) * zoom, point.size.x * zoom, point.size.y * zoom);
        }
        renderLine(line, origin, zoom) {
            this.ctx.strokeStyle = line.color.toStringRGBA();
            this.ctx.lineWidth = line.thickness;
            this.ctx.beginPath();
            this.ctx.moveTo(0, 0);
            this.ctx.lineTo((line.end.x - line.start.x) * zoom, (line.end.y - line.start.y) * zoom);
            this.ctx.closePath();
            this.ctx.stroke();
        }
        /**
         * Renders a rect
         * @param rect The rect to render
         * @param zoom The zoom level
         */
        renderRect(rect, zoom) {
            // Draw the interior of the rect
            if (rect.color.a !== 0) {
                this.ctx.fillStyle = rect.color.toStringRGB();
                this.ctx.fillRect((-rect.size.x / 2) * zoom, (-rect.size.y / 2) * zoom, rect.size.x * zoom, rect.size.y * zoom);
            }
            // Draw the border of the rect if it isn't transparent
            if (rect.borderColor.a !== 0) {
                this.ctx.strokeStyle = rect.getBorderColor().toStringRGB();
                this.ctx.lineWidth = rect.getBorderWidth();
                this.ctx.strokeRect((-rect.size.x / 2) * zoom, (-rect.size.y / 2) * zoom, rect.size.x * zoom, rect.size.y * zoom);
            }
        }
    }
    exports.default = GraphicRenderer;
    },{"../../ResourceManager/ResourceManager":93}],83:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
    const Vec2_1 = require("../../DataTypes/Vec2");
    /**
     * A utility class for the @reference[CanvasRenderer] to render @reference[Tilemap]s
     */
    class TilemapRenderer {
        constructor(ctx) {
            this.resourceManager = ResourceManager_1.default.getInstance();
            this.ctx = ctx;
        }
        /**
         * Sets the scene of this TilemapRenderer
         * @param scene The current scene
         */
        setScene(scene) {
            this.scene = scene;
        }
        /**
         * Renders an orthogonal tilemap
         * @param tilemap The tilemap to render
         */
        renderOrthogonalTilemap(tilemap) {
            let previousAlpha = this.ctx.globalAlpha;
            this.ctx.globalAlpha = tilemap.getLayer().getAlpha();
            let origin = this.scene.getViewTranslation(tilemap);
            let size = this.scene.getViewport().getHalfSize();
            let zoom = this.scene.getViewScale();
            let bottomRight = origin.clone().add(size.scaled(2 * zoom));
            if (tilemap.visible) {
                let minColRow = tilemap.getColRowAt(origin);
                let maxColRow = tilemap.getColRowAt(bottomRight);
                for (let x = minColRow.x; x <= maxColRow.x; x++) {
                    for (let y = minColRow.y; y <= maxColRow.y; y++) {
                        // Get the tile at this position
                        let tile = tilemap.getTileAtRowCol(new Vec2_1.default(x, y));
                        // Extract the rot/flip parameters if there are any
                        const mask = (0xE << 28);
                        const rotFlip = ((mask & tile) >> 28) & 0xF;
                        tile = tile & ~mask;
                        // Find the tileset that owns this tile index and render
                        for (let tileset of tilemap.getTilesets()) {
                            if (tileset.hasTile(tile)) {
                                this.renderTile(tileset, tile, x, y, origin, tilemap.scale, zoom, rotFlip);
                            }
                        }
                    }
                }
            }
            this.ctx.globalAlpha = previousAlpha;
        }
        /**
         * Renders a tile
         * @param tileset The tileset this tile belongs to
         * @param tileIndex The index of the tile
         * @param tilemapRow The row of the tile in the tilemap
         * @param tilemapCol The column of the tile in the tilemap
         * @param origin The origin of the viewport
         * @param scale The scale of the tilemap
         * @param zoom The zoom level of the viewport
         */
        renderTile(tileset, tileIndex, tilemapRow, tilemapCol, origin, scale, zoom, rotFlip) {
            let image = this.resourceManager.getImage(tileset.getImageKey());
            // Get the true index
            let index = tileIndex - tileset.getStartIndex();
            // Get the row and col of the tile in image space
            let row = Math.floor(index / tileset.getNumCols());
            let col = index % tileset.getNumCols();
            let width = tileset.getTileSize().x;
            let height = tileset.getTileSize().y;
            // Calculate the position to start a crop in the tileset image
            let left = col * width;
            let top = row * height;
            // Calculate the position in the world to render the tile
            let x = Math.floor(tilemapRow * width * scale.x);
            let y = Math.floor(tilemapCol * height * scale.y);
            let worldX = Math.floor((x - origin.x) * zoom);
            let worldY = Math.floor((y - origin.y) * zoom);
            let worldWidth = Math.ceil(width * scale.x * zoom);
            let worldHeight = Math.ceil(height * scale.y * zoom);
            if (rotFlip !== 0) {
                let scaleX = 1;
                let scaleY = 1;
                let shearX = 0;
                let shearY = 0;
                // Flip on the x-axis
                if (rotFlip & 8) {
                    scaleX = -1;
                }
                // Flip on the y-axis
                if (rotFlip & 4) {
                    scaleY = -1;
                }
                // Flip over the line y=x
                if (rotFlip & 2) {
                    shearX = scaleY;
                    shearY = scaleX;
                    scaleX = 0;
                    scaleY = 0;
                }
                this.ctx.setTransform(scaleX, shearX, shearY, scaleY, worldX + worldWidth / 2, worldY + worldHeight / 2);
                // Render the tile
                this.ctx.drawImage(image, left, top, width, height, -worldWidth / 2, -worldHeight / 2, worldWidth, worldHeight);
                if (rotFlip !== 0) {
                    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                }
            }
            else {
                // No rotations, don't do the calculations, just render the tile
                // Render the tile
                this.ctx.drawImage(image, left, top, width, height, worldX, worldY, worldWidth, worldHeight);
            }
        }
    }
    exports.default = TilemapRenderer;
    },{"../../DataTypes/Vec2":32,"../../ResourceManager/ResourceManager":93}],84:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Vec2_1 = require("../../DataTypes/Vec2");
    const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
    const MathUtils_1 = require("../../Utils/MathUtils");
    /**
     * A utility class to help the @reference[CanvasRenderer] render @reference[UIElement]s
     */
    class UIElementRenderer {
        constructor(ctx) {
            this.resourceManager = ResourceManager_1.default.getInstance();
            this.ctx = ctx;
        }
        /**
         * Sets the scene of this UIElementRenderer
         * @param scene The current scene
         */
        setScene(scene) {
            this.scene = scene;
        }
        /**
         * Renders a label
         * @param label The label to render
         */
        renderLabel(label) {
            // If the size is unassigned (by the user or automatically) assign it
            label.handleInitialSizing(this.ctx);
            // Grab the global alpha so we can adjust it for this render
            let previousAlpha = this.ctx.globalAlpha;
            // Get the font and text position in label
            this.ctx.font = label.getFontString();
            let offset = label.calculateTextOffset(this.ctx);
            // Stroke and fill a rounded rect and give it text
            this.ctx.globalAlpha = label.backgroundColor.a;
            this.ctx.fillStyle = label.calculateBackgroundColor().toStringRGBA();
            this.ctx.fillRoundedRect(-label.size.x / 2, -label.size.y / 2, label.size.x, label.size.y, label.borderRadius);
            this.ctx.strokeStyle = label.calculateBorderColor().toStringRGBA();
            this.ctx.globalAlpha = label.borderColor.a;
            this.ctx.lineWidth = label.borderWidth;
            this.ctx.strokeRoundedRect(-label.size.x / 2, -label.size.y / 2, label.size.x, label.size.y, label.borderRadius);
            this.ctx.fillStyle = label.calculateTextColor();
            this.ctx.globalAlpha = label.textColor.a;
            this.ctx.fillText(label.text, offset.x - label.size.x / 2, offset.y - label.size.y / 2);
            this.ctx.globalAlpha = previousAlpha;
        }
        /**
         * Renders a button
         * @param button The button to render
         */
        renderButton(button) {
            this.renderLabel(button);
        }
        /**
         * Renders a slider
         * @param slider The slider to render
         */
        renderSlider(slider) {
            // Grab the global alpha so we can adjust it for this render
            let previousAlpha = this.ctx.globalAlpha;
            this.ctx.globalAlpha = slider.getLayer().getAlpha();
            // Calcualate the slider size
            let sliderSize = new Vec2_1.default(slider.size.x, 2);
            // Draw the slider
            this.ctx.fillStyle = slider.sliderColor.toString();
            this.ctx.fillRoundedRect(-sliderSize.x / 2, -sliderSize.y / 2, sliderSize.x, sliderSize.y, slider.borderRadius);
            // Calculate the nib size and position
            let x = MathUtils_1.default.lerp(-slider.size.x / 2, slider.size.x / 2, slider.getValue());
            // Draw the nib
            this.ctx.fillStyle = slider.nibColor.toString();
            this.ctx.fillRoundedRect(x - slider.nibSize.x / 2, -slider.nibSize.y / 2, slider.nibSize.x, slider.nibSize.y, slider.borderRadius);
            // Reset the alpha
            this.ctx.globalAlpha = previousAlpha;
        }
        /**
         * Renders a textInput
         * @param textInput The textInput to render
         */
        renderTextInput(textInput) {
            // Show a cursor sometimes
            if (textInput.focused && textInput.cursorCounter % 60 > 30) {
                textInput.text += "|";
            }
            this.renderLabel(textInput);
            if (textInput.focused) {
                if (textInput.cursorCounter % 60 > 30) {
                    textInput.text = textInput.text.substring(0, textInput.text.length - 1);
                }
                textInput.cursorCounter += 1;
                if (textInput.cursorCounter >= 60) {
                    textInput.cursorCounter = 0;
                }
            }
        }
    }
    exports.default = UIElementRenderer;
    },{"../../DataTypes/Vec2":32,"../../ResourceManager/ResourceManager":93,"../../Utils/MathUtils":112}],85:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const ResourceManager_1 = require("../ResourceManager/ResourceManager");
    /**
     * An abstract framework to put all rendering in once place in the application
     */
    class RenderingManager {
        constructor() {
            this.resourceManager = ResourceManager_1.default.getInstance();
        }
        /**
         * Sets the scene currently being rendered
         * @param scene The current Scene
         */
        setScene(scene) {
            this.scene = scene;
        }
    }
    exports.default = RenderingManager;
    },{"../ResourceManager/ResourceManager":93}],86:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Vec2_1 = require("../DataTypes/Vec2");
    const Graphic_1 = require("../Nodes/Graphic");
    const Point_1 = require("../Nodes/Graphics/Point");
    const Rect_1 = require("../Nodes/Graphics/Rect");
    const AnimatedSprite_1 = require("../Nodes/Sprites/AnimatedSprite");
    const Sprite_1 = require("../Nodes/Sprites/Sprite");
    const UIElement_1 = require("../Nodes/UIElement");
    const Label_1 = require("../Nodes/UIElements/Label");
    const ShaderRegistry_1 = require("../Registry/Registries/ShaderRegistry");
    const RegistryManager_1 = require("../Registry/RegistryManager");
    const ResourceManager_1 = require("../ResourceManager/ResourceManager");
    const ParallaxLayer_1 = require("../Scene/Layers/ParallaxLayer");
    const RenderingManager_1 = require("./RenderingManager");
    class WebGLRenderer extends RenderingManager_1.default {
        initializeCanvas(canvas, width, height) {
            canvas.width = width;
            canvas.height = height;
            this.worldSize = Vec2_1.default.ZERO;
            this.worldSize.x = width;
            this.worldSize.y = height;
            // Get the WebGL context
            this.gl = canvas.getContext("webgl");
            this.gl.viewport(0, 0, canvas.width, canvas.height);
            this.gl.disable(this.gl.DEPTH_TEST);
            this.gl.enable(this.gl.BLEND);
            this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
            this.gl.enable(this.gl.CULL_FACE);
            // Tell the resource manager we're using WebGL
            ResourceManager_1.default.getInstance().useWebGL(true, this.gl);
            // Show the text canvas and get its context
            let textCanvas = document.getElementById("text-canvas");
            textCanvas.hidden = false;
            this.textCtx = textCanvas.getContext("2d");
            // Size the text canvas to be the same as the game canvas
            textCanvas.height = height;
            textCanvas.width = width;
            return this.gl;
        }
        render(visibleSet, tilemaps, uiLayers) {
            for (let node of visibleSet) {
                this.renderNode(node);
            }
            uiLayers.forEach(key => {
                if (!uiLayers.get(key).isHidden())
                    uiLayers.get(key).getItems().forEach(node => this.renderNode(node));
            });
        }
        clear(color) {
            this.gl.clearColor(color.r, color.g, color.b, color.a);
            this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
            this.textCtx.clearRect(0, 0, this.worldSize.x, this.worldSize.y);
        }
        renderNode(node) {
            // Calculate the origin of the viewport according to this sprite
            this.origin = this.scene.getViewTranslation(node);
            // Get the zoom level of the scene
            this.zoom = this.scene.getViewScale();
            if (node.hasCustomShader) {
                // If the node has a custom shader, render using that
                this.renderCustom(node);
            }
            else if (node instanceof Graphic_1.default) {
                this.renderGraphic(node);
            }
            else if (node instanceof Sprite_1.default) {
                if (node instanceof AnimatedSprite_1.default) {
                    this.renderAnimatedSprite(node);
                }
                else {
                    this.renderSprite(node);
                }
            }
            else if (node instanceof UIElement_1.default) {
                this.renderUIElement(node);
            }
        }
        renderSprite(sprite) {
            let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.SPRITE_SHADER);
            let options = this.addOptions(shader.getOptions(sprite), sprite);
            shader.render(this.gl, options);
        }
        renderAnimatedSprite(sprite) {
            let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.SPRITE_SHADER);
            let options = this.addOptions(shader.getOptions(sprite), sprite);
            shader.render(this.gl, options);
        }
        renderGraphic(graphic) {
            if (graphic instanceof Point_1.default) {
                let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.POINT_SHADER);
                let options = this.addOptions(shader.getOptions(graphic), graphic);
                shader.render(this.gl, options);
            }
            else if (graphic instanceof Rect_1.default) {
                let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.RECT_SHADER);
                let options = this.addOptions(shader.getOptions(graphic), graphic);
                shader.render(this.gl, options);
            }
        }
        renderTilemap(tilemap) {
            throw new Error("Method not implemented.");
        }
        renderUIElement(uiElement) {
            if (uiElement instanceof Label_1.default) {
                let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.LABEL_SHADER);
                let options = this.addOptions(shader.getOptions(uiElement), uiElement);
                shader.render(this.gl, options);
                this.textCtx.setTransform(1, 0, 0, 1, (uiElement.position.x - this.origin.x) * this.zoom, (uiElement.position.y - this.origin.y) * this.zoom);
                this.textCtx.rotate(-uiElement.rotation);
                let globalAlpha = this.textCtx.globalAlpha;
                this.textCtx.globalAlpha = uiElement.alpha;
                // Render text
                this.textCtx.font = uiElement.getFontString();
                let offset = uiElement.calculateTextOffset(this.textCtx);
                this.textCtx.fillStyle = uiElement.calculateTextColor();
                this.textCtx.globalAlpha = uiElement.textColor.a;
                this.textCtx.fillText(uiElement.text, offset.x - uiElement.size.x / 2, offset.y - uiElement.size.y / 2);
                this.textCtx.globalAlpha = globalAlpha;
                this.textCtx.setTransform(1, 0, 0, 1, 0, 0);
            }
        }
        renderCustom(node) {
            let shader = RegistryManager_1.default.shaders.get(node.customShaderKey);
            let options = this.addOptions(shader.getOptions(node), node);
            shader.render(this.gl, options);
        }
        addOptions(options, node) {
            // Give the shader access to the world size
            options.worldSize = this.worldSize;
            // Adjust the origin position to the parallax
            let layer = node.getLayer();
            let parallax = new Vec2_1.default(1, 1);
            if (layer instanceof ParallaxLayer_1.default) {
                parallax = layer.parallax;
            }
            options.origin = this.origin.clone().mult(parallax);
            return options;
        }
    }
    exports.default = WebGLRenderer;
    },{"../DataTypes/Vec2":32,"../Nodes/Graphic":49,"../Nodes/Graphics/Point":53,"../Nodes/Graphics/Rect":54,"../Nodes/Sprites/AnimatedSprite":55,"../Nodes/Sprites/Sprite":56,"../Nodes/UIElement":59,"../Nodes/UIElements/Label":61,"../Registry/Registries/ShaderRegistry":72,"../Registry/RegistryManager":73,"../ResourceManager/ResourceManager":93,"../Scene/Layers/ParallaxLayer":101,"./RenderingManager":85}],87:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
    /**
     * A wrapper class for WebGL shaders.
     * This class is a singleton, and there is only one for each shader type.
     * All objects that use this shader type will refer to and modify this same type.
     */
    class ShaderType {
        constructor(programKey) {
            this.programKey = programKey;
            this.resourceManager = ResourceManager_1.default.getInstance();
        }
        /**
         * Extracts the options from the CanvasNode and gives them to the render function
         * @param node The node to get options from
         * @returns An object containing the options that should be passed to the render function
         */
        getOptions(node) { return {}; }
    }
    exports.default = ShaderType;
    },{"../../ResourceManager/ResourceManager":93}],88:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Mat4x4_1 = require("../../../DataTypes/Mat4x4");
    const Vec2_1 = require("../../../DataTypes/Vec2");
    const ResourceManager_1 = require("../../../ResourceManager/ResourceManager");
    const QuadShaderType_1 = require("./QuadShaderType");
    /** */
    class LabelShaderType extends QuadShaderType_1.default {
        constructor(programKey) {
            super(programKey);
            this.resourceManager = ResourceManager_1.default.getInstance();
        }
        initBufferObject() {
            this.bufferObjectKey = "label";
            this.resourceManager.createBuffer(this.bufferObjectKey);
        }
        render(gl, options) {
            const backgroundColor = options.backgroundColor.toWebGL();
            const borderColor = options.borderColor.toWebGL();
            const program = this.resourceManager.getShaderProgram(this.programKey);
            const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
            gl.useProgram(program);
            const vertexData = this.getVertices(options.size.x, options.size.y);
            const FSIZE = vertexData.BYTES_PER_ELEMENT;
            // Bind the buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
            // Attributes
            const a_Position = gl.getAttribLocation(program, "a_Position");
            gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
            gl.enableVertexAttribArray(a_Position);
            // Uniforms
            const u_BackgroundColor = gl.getUniformLocation(program, "u_BackgroundColor");
            gl.uniform4fv(u_BackgroundColor, backgroundColor);
            const u_BorderColor = gl.getUniformLocation(program, "u_BorderColor");
            gl.uniform4fv(u_BorderColor, borderColor);
            const u_MaxSize = gl.getUniformLocation(program, "u_MaxSize");
            gl.uniform2f(u_MaxSize, -vertexData[0], vertexData[1]);
            // Get transformation matrix
            // We want a square for our rendering space, so get the maximum dimension of our quad
            let maxDimension = Math.max(options.size.x, options.size.y);
            const u_BorderWidth = gl.getUniformLocation(program, "u_BorderWidth");
            gl.uniform1f(u_BorderWidth, options.borderWidth / maxDimension);
            const u_BorderRadius = gl.getUniformLocation(program, "u_BorderRadius");
            gl.uniform1f(u_BorderRadius, options.borderRadius / maxDimension);
            // The size of the rendering space will be a square with this maximum dimension
            let size = new Vec2_1.default(maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
            // Center our translations around (0, 0)
            const translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) / maxDimension;
            const translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) / maxDimension;
            // Create our transformation matrix
            this.translation.translate(new Float32Array([translateX, translateY]));
            this.scale.scale(size);
            this.rotation.rotate(options.rotation);
            let transformation = Mat4x4_1.default.MULT(this.translation, this.scale, this.rotation);
            // Pass the translation matrix to our shader
            const u_Transform = gl.getUniformLocation(program, "u_Transform");
            gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
            // Draw the quad
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }
        /**
         * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
         * @param w The width of the quad in pixels
         * @param h The height of the quad in pixels
         * @returns An array of the vertices of the quad
         */
        getVertices(w, h) {
            let x, y;
            if (h > w) {
                y = 0.5;
                x = w / (2 * h);
            }
            else {
                x = 0.5;
                y = h / (2 * w);
            }
            return new Float32Array([
                -x, y,
                -x, -y,
                x, y,
                x, -y
            ]);
        }
        getOptions(rect) {
            let options = {
                position: rect.position,
                backgroundColor: rect.calculateBackgroundColor(),
                borderColor: rect.calculateBorderColor(),
                borderWidth: rect.borderWidth,
                borderRadius: rect.borderRadius,
                size: rect.size,
                rotation: rect.rotation
            };
            return options;
        }
    }
    exports.default = LabelShaderType;
    },{"../../../DataTypes/Mat4x4":20,"../../../DataTypes/Vec2":32,"../../../ResourceManager/ResourceManager":93,"./QuadShaderType":90}],89:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const RenderingUtils_1 = require("../../../Utils/RenderingUtils");
    const ShaderType_1 = require("../ShaderType");
    class PointShaderType extends ShaderType_1.default {
        constructor(programKey) {
            super(programKey);
        }
        initBufferObject() {
            this.bufferObjectKey = "point";
            this.resourceManager.createBuffer(this.bufferObjectKey);
        }
        render(gl, options) {
            let position = RenderingUtils_1.default.toWebGLCoords(options.position, options.origin, options.worldSize);
            let color = RenderingUtils_1.default.toWebGLColor(options.color);
            const program = this.resourceManager.getShaderProgram(this.programKey);
            const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
            gl.useProgram(program);
            const vertexData = position;
            const FSIZE = vertexData.BYTES_PER_ELEMENT;
            // Bind the buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
            // Attributes
            const a_Position = gl.getAttribLocation(program, "a_Position");
            gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
            gl.enableVertexAttribArray(a_Position);
            // Uniforms
            const u_Color = gl.getUniformLocation(program, "u_Color");
            gl.uniform4fv(u_Color, color);
            const u_PointSize = gl.getUniformLocation(program, "u_PointSize");
            gl.uniform1f(u_PointSize, options.pointSize);
            gl.drawArrays(gl.POINTS, 0, 1);
        }
        getOptions(point) {
            let options = {
                position: point.position,
                color: point.color,
                pointSize: point.size,
            };
            return options;
        }
    }
    exports.default = PointShaderType;
    },{"../../../Utils/RenderingUtils":113,"../ShaderType":87}],90:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Mat4x4_1 = require("../../../DataTypes/Mat4x4");
    const ShaderType_1 = require("../ShaderType");
    /** Represents any WebGL objects that have a quad mesh (i.e. a rectangular game object composed of only two triangles) */
    class QuadShaderType extends ShaderType_1.default {
        constructor(programKey) {
            super(programKey);
            this.scale = Mat4x4_1.default.IDENTITY;
            this.rotation = Mat4x4_1.default.IDENTITY;
            this.translation = Mat4x4_1.default.IDENTITY;
        }
    }
    exports.default = QuadShaderType;
    },{"../../../DataTypes/Mat4x4":20,"../ShaderType":87}],91:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Mat4x4_1 = require("../../../DataTypes/Mat4x4");
    const Vec2_1 = require("../../../DataTypes/Vec2");
    const ResourceManager_1 = require("../../../ResourceManager/ResourceManager");
    const QuadShaderType_1 = require("./QuadShaderType");
    /** */
    class RectShaderType extends QuadShaderType_1.default {
        constructor(programKey) {
            super(programKey);
            this.resourceManager = ResourceManager_1.default.getInstance();
        }
        initBufferObject() {
            this.bufferObjectKey = "rect";
            this.resourceManager.createBuffer(this.bufferObjectKey);
        }
        render(gl, options) {
            const color = options.color.toWebGL();
            const program = this.resourceManager.getShaderProgram(this.programKey);
            const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
            gl.useProgram(program);
            const vertexData = this.getVertices(options.size.x, options.size.y);
            const FSIZE = vertexData.BYTES_PER_ELEMENT;
            // Bind the buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
            // Attributes
            const a_Position = gl.getAttribLocation(program, "a_Position");
            gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
            gl.enableVertexAttribArray(a_Position);
            // Uniforms
            const u_Color = gl.getUniformLocation(program, "u_Color");
            gl.uniform4fv(u_Color, color);
            // Get transformation matrix
            // We want a square for our rendering space, so get the maximum dimension of our quad
            let maxDimension = Math.max(options.size.x, options.size.y);
            // The size of the rendering space will be a square with this maximum dimension
            let size = new Vec2_1.default(maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
            // Center our translations around (0, 0)
            const translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) / maxDimension;
            const translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) / maxDimension;
            // Create our transformation matrix
            this.translation.translate(new Float32Array([translateX, translateY]));
            this.scale.scale(size);
            this.rotation.rotate(options.rotation);
            let transformation = Mat4x4_1.default.MULT(this.translation, this.scale, this.rotation);
            // Pass the translation matrix to our shader
            const u_Transform = gl.getUniformLocation(program, "u_Transform");
            gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
            // Draw the quad
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }
        /*
            So as it turns out, WebGL has an issue with non-square quads.
            It doesn't like when you don't have a 1-1 scale, and rotations are entirely messed up if this is not the case.
            To solve this, I used the scale of the LARGEST dimension of the quad to make a square, then adjusted the vertex coordinates inside of that.
            A diagram of the solution follows.
    
            There is a bounding square for the quad with dimensions hxh (in this case, since height is the largest dimension).
            The offset in the vertical direction is therefore 0.5, as it is normally.
            However, the offset in the horizontal direction is not so straightforward, but isn't conceptually hard.
            All we really have to do is a range change from [0, height/2] to [0, 0.5], where our value is t = width/2, and 0 <= t <= height/2.
    
            So now we have our rect, in a space scaled with respect to the largest dimension.
            Rotations work as you would expect, even for long rectangles.
    
                        0.5
                __ __ __ __ __ __ __
                |	|88888888888|	|
                |	|88888888888|	|
                |	|88888888888|	|
            -0.5|_ _|88888888888|_ _|0.5
                |	|88888888888|	|
                |	|88888888888|	|
                |	|88888888888|	|
                |___|88888888888|___|
                        -0.5
    
            The getVertices function below does as described, and converts the range
        */
        /**
         * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
         * @param w The width of the quad in pixels
         * @param h The height of the quad in pixels
         * @returns An array of the vertices of the quad
         */
        getVertices(w, h) {
            let x, y;
            if (h > w) {
                y = 0.5;
                x = w / (2 * h);
            }
            else {
                x = 0.5;
                y = h / (2 * w);
            }
            return new Float32Array([
                -x, y,
                -x, -y,
                x, y,
                x, -y
            ]);
        }
        getOptions(rect) {
            let options = {
                position: rect.position,
                color: rect.color,
                size: rect.size,
                rotation: rect.rotation
            };
            return options;
        }
    }
    exports.default = RectShaderType;
    },{"../../../DataTypes/Mat4x4":20,"../../../DataTypes/Vec2":32,"../../../ResourceManager/ResourceManager":93,"./QuadShaderType":90}],92:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Mat4x4_1 = require("../../../DataTypes/Mat4x4");
    const Vec2_1 = require("../../../DataTypes/Vec2");
    const AnimatedSprite_1 = require("../../../Nodes/Sprites/AnimatedSprite");
    const ResourceManager_1 = require("../../../ResourceManager/ResourceManager");
    const QuadShaderType_1 = require("./QuadShaderType");
    /** A shader for sprites and animated sprites */
    class SpriteShaderType extends QuadShaderType_1.default {
        constructor(programKey) {
            super(programKey);
            this.resourceManager = ResourceManager_1.default.getInstance();
        }
        initBufferObject() {
            this.bufferObjectKey = "sprite";
            this.resourceManager.createBuffer(this.bufferObjectKey);
        }
        render(gl, options) {
            const program = this.resourceManager.getShaderProgram(this.programKey);
            const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
            const texture = this.resourceManager.getTexture(options.imageKey);
            gl.useProgram(program);
            const vertexData = this.getVertices(options.size.x, options.size.y, options.scale);
            const FSIZE = vertexData.BYTES_PER_ELEMENT;
            // Bind the buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
            // Attributes
            const a_Position = gl.getAttribLocation(program, "a_Position");
            gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 4 * FSIZE, 0 * FSIZE);
            gl.enableVertexAttribArray(a_Position);
            const a_TexCoord = gl.getAttribLocation(program, "a_TexCoord");
            gl.vertexAttribPointer(a_TexCoord, 2, gl.FLOAT, false, 4 * FSIZE, 2 * FSIZE);
            gl.enableVertexAttribArray(a_TexCoord);
            // Uniforms
            // Get transformation matrix
            // We want a square for our rendering space, so get the maximum dimension of our quad
            let maxDimension = Math.max(options.size.x, options.size.y);
            // The size of the rendering space will be a square with this maximum dimension
            let size = new Vec2_1.default(maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
            // Center our translations around (0, 0)
            const translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) / maxDimension;
            const translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) / maxDimension;
            // Create our transformation matrix
            this.translation.translate(new Float32Array([translateX, translateY]));
            this.scale.scale(size);
            this.rotation.rotate(options.rotation);
            let transformation = Mat4x4_1.default.MULT(this.translation, this.scale, this.rotation);
            // Pass the translation matrix to our shader
            const u_Transform = gl.getUniformLocation(program, "u_Transform");
            gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
            // Set up our sampler with our assigned texture unit
            const u_Sampler = gl.getUniformLocation(program, "u_Sampler");
            gl.uniform1i(u_Sampler, texture);
            // Pass in texShift
            const u_texShift = gl.getUniformLocation(program, "u_texShift");
            gl.uniform2fv(u_texShift, options.texShift);
            // Pass in texScale
            const u_texScale = gl.getUniformLocation(program, "u_texScale");
            gl.uniform2fv(u_texScale, options.texScale);
            // Draw the quad
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }
        /**
         * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
         * @param w The width of the quad in pixels
         * @param h The height of the quad in pixels
         * @returns An array of the vertices of the quad
         */
        getVertices(w, h, scale) {
            let x, y;
            if (h > w) {
                y = 0.5;
                x = w / (2 * h);
            }
            else {
                x = 0.5;
                y = h / (2 * w);
            }
            // Scale the rendering space if needed
            x *= scale[0];
            y *= scale[1];
            return new Float32Array([
                -x, y, 0.0, 0.0,
                -x, -y, 0.0, 1.0,
                x, y, 1.0, 0.0,
                x, -y, 1.0, 1.0
            ]);
        }
        getOptions(sprite) {
            let texShift;
            let texScale;
            if (sprite instanceof AnimatedSprite_1.default) {
                let animationIndex = sprite.animation.getIndexAndAdvanceAnimation();
                let offset = sprite.getAnimationOffset(animationIndex);
                texShift = new Float32Array([offset.x / (sprite.cols * sprite.size.x), offset.y / (sprite.rows * sprite.size.y)]);
                texScale = new Float32Array([1 / (sprite.cols), 1 / (sprite.rows)]);
            }
            else {
                texShift = new Float32Array([0, 0]);
                texScale = new Float32Array([1, 1]);
            }
            let options = {
                position: sprite.position,
                rotation: sprite.rotation,
                size: sprite.size,
                scale: sprite.scale.toArray(),
                imageKey: sprite.imageId,
                texShift,
                texScale
            };
            return options;
        }
    }
    exports.default = SpriteShaderType;
    },{"../../../DataTypes/Mat4x4":20,"../../../DataTypes/Vec2":32,"../../../Nodes/Sprites/AnimatedSprite":55,"../../../ResourceManager/ResourceManager":93,"./QuadShaderType":90}],93:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Map_1 = require("../DataTypes/Map");
    const Queue_1 = require("../DataTypes/Queue");
    const StringUtils_1 = require("../Utils/StringUtils");
    const AudioManager_1 = require("../Sound/AudioManager");
    const WebGLProgramType_1 = require("../DataTypes/Rendering/WebGLProgramType");
    /**
     * The resource manager for the game engine.
     * The resource manager interfaces with the loadable assets of a game such as images, data files,
     * and sounds, which are all found in the dist folder.
     * This class controls loading and updates the @reference[Scene] with the loading progress, so that the scene does
     * not start before all necessary assets are loaded.
     */
    class ResourceManager {
        constructor() {
            this.loading = false;
            this.justLoaded = false;
            this.loadonly_imagesLoaded = 0;
            this.loadonly_imagesToLoad = 0;
            this.loadonly_imageLoadingQueue = new Queue_1.default();
            this.images = new Map_1.default();
            this.loadonly_spritesheetsLoaded = 0;
            this.loadonly_spritesheetsToLoad = 0;
            this.loadonly_spritesheetLoadingQueue = new Queue_1.default();
            this.spritesheets = new Map_1.default();
            this.loadonly_tilemapsLoaded = 0;
            this.loadonly_tilemapsToLoad = 0;
            this.loadonly_tilemapLoadingQueue = new Queue_1.default();
            this.tilemaps = new Map_1.default();
            this.loadonly_audioLoaded = 0;
            this.loadonly_audioToLoad = 0;
            this.loadonly_audioLoadingQueue = new Queue_1.default();
            this.audioBuffers = new Map_1.default();
            this.loadonly_jsonLoaded = 0;
            this.loadonly_jsonToLoad = 0;
            this.loadonly_jsonLoadingQueue = new Queue_1.default();
            this.jsonObjects = new Map_1.default();
            this.loadonly_gl_ShaderProgramsLoaded = 0;
            this.loadonly_gl_ShaderProgramsToLoad = 0;
            this.loadonly_gl_ShaderLoadingQueue = new Queue_1.default();
            this.gl_ShaderPrograms = new Map_1.default();
            this.gl_Textures = new Map_1.default();
            this.gl_NextTextureID = 0;
            this.gl_Buffers = new Map_1.default();
            this.resourcesToUnload = new Array();
            this.resourcesToKeep = new Array();
        }
        ;
        /* ######################################## SINGLETON ########################################*/
        /**
         * Returns the current instance of this class or a new instance if none exist
         * @returns The resource manager
         */
        static getInstance() {
            if (!this.instance) {
                this.instance = new ResourceManager();
            }
            return this.instance;
        }
        /* ######################################## PUBLIC FUNCTION ########################################*/
        /**
         * Activates or deactivates the use of WebGL
         * @param flag True if WebGL should be used, false otherwise
         * @param gl The instance of the graphics context, if applicable
         */
        useWebGL(flag, gl) {
            this.gl_WebGLActive = flag;
            if (this.gl_WebGLActive) {
                this.gl = gl;
            }
        }
        /**
         * Loads an image from file
         * @param key The key to associate the loaded image with
         * @param path The path to the image to load
         */
        image(key, path) {
            this.loadonly_imageLoadingQueue.enqueue({ key: key, path: path });
        }
        /**
         * Tells the resource manager to keep this resource
         * @param key The key of the resource
         */
        keepImage(key) {
            this.keepResource(key, ResourceType.IMAGE);
        }
        /**
         * Retrieves a loaded image
         * @param key The key of the loaded image
         * @returns The image element associated with this key
         */
        getImage(key) {
            let image = this.images.get(key);
            if (image === undefined) {
                throw `There is no image associated with key "${key}"`;
            }
            return image;
        }
        /**
         * Loads a spritesheet from file
         * @param key The key to associate the loaded spritesheet with
         * @param path The path to the spritesheet to load
         */
        spritesheet(key, path) {
            this.loadonly_spritesheetLoadingQueue.enqueue({ key: key, path: path });
        }
        /**
         * Tells the resource manager to keep this resource
         * @param key The key of the resource
         */
        keepSpritesheet(key) {
            this.keepResource(key, ResourceType.SPRITESHEET);
        }
        /**
         * Retrieves a loaded spritesheet
         * @param key The key of the spritesheet to load
         * @returns The loaded Spritesheet
         */
        getSpritesheet(key) {
            return this.spritesheets.get(key);
        }
        /**
         * Loads an audio file
         * @param key The key to associate with the loaded audio file
         * @param path The path to the audio file to load
         */
        audio(key, path) {
            this.loadonly_audioLoadingQueue.enqueue({ key: key, path: path });
        }
        /**
         * Tells the resource manager to keep this resource
         * @param key The key of the resource
         */
        keepAudio(key) {
            this.keepResource(key, ResourceType.AUDIO);
        }
        /**
         * Retrieves a loaded audio file
         * @param key The key of the audio file to load
         * @returns The AudioBuffer created from the loaded audio fle
         */
        getAudio(key) {
            return this.audioBuffers.get(key);
        }
        /**
         * Load a tilemap from a json file. Automatically loads related images
         * @param key The key to associate with the loaded tilemap
         * @param path The path to the tilemap to load
         */
        tilemap(key, path) {
            this.loadonly_tilemapLoadingQueue.enqueue({ key: key, path: path });
        }
        /**
         * Tells the resource manager to keep this resource
         * @param key The key of the resource
         */
        keepTilemap(key) {
            this.keepResource(key, ResourceType.TILEMAP);
        }
        /**
         * Retreives a loaded tilemap
         * @param key The key of the loaded tilemap
         * @returns The tilemap data associated with the key
         */
        getTilemap(key) {
            return this.tilemaps.get(key);
        }
        /**
         * Loads an object from a json file.
         * @param key The key to associate with the loaded object
         * @param path The path to the json file to load
         */
        object(key, path) {
            this.loadonly_jsonLoadingQueue.enqueue({ key: key, path: path });
        }
        /**
         * Tells the resource manager to keep this resource
         * @param key The key of the resource
         */
        keepObject(key) {
            this.keepResource(key, ResourceType.JSON);
        }
        /**
         * Retreives a loaded object
         * @param key The key of the loaded object
         * @returns The object data associated with the key
         */
        getObject(key) {
            return this.jsonObjects.get(key);
        }
        /* ######################################## LOAD FUNCTION ########################################*/
        /**
         * Loads all resources currently in the queue
         * @param callback The function to cal when the resources are finished loading
         */
        loadResourcesFromQueue(callback) {
            this.loadonly_typesToLoad = 5;
            this.loading = true;
            // Load everything in the queues. Tilemaps have to come before images because they will add new images to the queue
            this.loadTilemapsFromQueue(() => {
                console.log("Loaded Tilemaps");
                this.loadSpritesheetsFromQueue(() => {
                    console.log("Loaded Spritesheets");
                    this.loadImagesFromQueue(() => {
                        console.log("Loaded Images");
                        this.loadAudioFromQueue(() => {
                            console.log("Loaded Audio");
                            this.loadObjectsFromQueue(() => {
                                console.log("Loaded Objects");
                                if (this.gl_WebGLActive) {
                                    this.gl_LoadShadersFromQueue(() => {
                                        console.log("Loaded Shaders");
                                        this.finishLoading(callback);
                                    });
                                }
                                else {
                                    this.finishLoading(callback);
                                }
                            });
                        });
                    });
                });
            });
        }
        finishLoading(callback) {
            // Done loading
            this.loading = false;
            this.justLoaded = true;
            callback();
        }
        /* ######################################## UNLOAD FUNCTION ########################################*/
        keepResource(key, type) {
            console.log("Keep resource...");
            for (let i = 0; i < this.resourcesToUnload.length; i++) {
                let resource = this.resourcesToUnload[i];
                if (resource.key === key && resource.resourceType === type) {
                    console.log("Found resource " + key + " of type " + type + ". Keeping.");
                    let resourceToMove = this.resourcesToUnload.splice(i, 1);
                    this.resourcesToKeep.push(...resourceToMove);
                    return;
                }
            }
        }
        /**
         * Deletes references to all resources in the resource manager
         */
        unloadAllResources() {
            this.loading = false;
            this.justLoaded = false;
            for (let resource of this.resourcesToUnload) {
                // Unload the resource
                this.unloadResource(resource);
            }
        }
        unloadResource(resource) {
            // Delete the resource itself
            switch (resource.resourceType) {
                case ResourceType.IMAGE:
                    this.images.delete(resource.key);
                    if (this.gl_WebGLActive) {
                        this.gl_Textures.delete(resource.key);
                    }
                    break;
                case ResourceType.TILEMAP:
                    this.tilemaps.delete(resource.key);
                    break;
                case ResourceType.SPRITESHEET:
                    this.spritesheets.delete(resource.key);
                    break;
                case ResourceType.AUDIO:
                    this.audioBuffers.delete(resource.key);
                    break;
                case ResourceType.JSON:
                    this.jsonObjects.delete(resource.key);
                    break;
                /*case ResourceType.SHADER:
                    this.gl_ShaderPrograms.get(resource.key).delete(this.gl);
                    this.gl_ShaderPrograms.delete(resource.key);
                    break;*/
            }
            // Delete any dependencies
            for (let dependency of resource.dependencies) {
                this.unloadResource(dependency);
            }
        }
        /* ######################################## WORK FUNCTIONS ########################################*/
        /**
         * Loads all tilemaps currently in the tilemap loading queue
         * @param onFinishLoading The function to call when loading is complete
         */
        loadTilemapsFromQueue(onFinishLoading) {
            this.loadonly_tilemapsToLoad = this.loadonly_tilemapLoadingQueue.getSize();
            this.loadonly_tilemapsLoaded = 0;
            // If no items to load, we're finished
            if (this.loadonly_tilemapsToLoad === 0) {
                onFinishLoading();
                return;
            }
            while (this.loadonly_tilemapLoadingQueue.hasItems()) {
                let tilemap = this.loadonly_tilemapLoadingQueue.dequeue();
                this.loadTilemap(tilemap.key, tilemap.path, onFinishLoading);
            }
        }
        /**
         * Loads a singular tilemap
         * @param key The key of the tilemap
         * @param pathToTilemapJSON The path to the tilemap JSON file
         * @param callbackIfLast The function to call if this is the last tilemap to load
         */
        loadTilemap(key, pathToTilemapJSON, callbackIfLast) {
            this.loadTextFile(pathToTilemapJSON, (fileText) => {
                let tilemapObject = JSON.parse(fileText);
                // We can parse the object later - it's much faster than loading
                this.tilemaps.add(key, tilemapObject);
                let resource = new ResourceReference(key, ResourceType.TILEMAP);
                // Grab the tileset images we need to load and add them to the imageloading queue
                for (let tileset of tilemapObject.tilesets) {
                    if (tileset.image) {
                        let key = tileset.image;
                        let path = StringUtils_1.default.getPathFromFilePath(pathToTilemapJSON) + key;
                        this.loadonly_imageLoadingQueue.enqueue({ key: key, path: path, isDependency: true });
                        // Add this image as a dependency to the tilemap
                        resource.addDependency(new ResourceReference(key, ResourceType.IMAGE));
                    }
                    else if (tileset.tiles) {
                        for (let tile of tileset.tiles) {
                            let key = tile.image;
                            let path = StringUtils_1.default.getPathFromFilePath(pathToTilemapJSON) + key;
                            this.loadonly_imageLoadingQueue.enqueue({ key: key, path: path, isDependency: true });
                            // Add this image as a dependency to the tilemap
                            resource.addDependency(new ResourceReference(key, ResourceType.IMAGE));
                        }
                    }
                }
                // Add the resource reference to the list of resource to unload
                this.resourcesToUnload.push(resource);
                // Finish loading
                this.finishLoadingTilemap(callbackIfLast);
            });
        }
        /**
         * Finish loading a tilemap. Calls the callback function if this is the last tilemap being loaded
         * @param callback The function to call if this is the last tilemap to load
         */
        finishLoadingTilemap(callback) {
            this.loadonly_tilemapsLoaded += 1;
            if (this.loadonly_tilemapsLoaded === this.loadonly_tilemapsToLoad) {
                // We're done loading tilemaps
                callback();
            }
        }
        /**
         * Loads all spritesheets currently in the spritesheet loading queue
         * @param onFinishLoading The function to call when the spritesheets are done loading
         */
        loadSpritesheetsFromQueue(onFinishLoading) {
            this.loadonly_spritesheetsToLoad = this.loadonly_spritesheetLoadingQueue.getSize();
            this.loadonly_spritesheetsLoaded = 0;
            // If no items to load, we're finished
            if (this.loadonly_spritesheetsToLoad === 0) {
                onFinishLoading();
                return;
            }
            while (this.loadonly_spritesheetLoadingQueue.hasItems()) {
                let spritesheet = this.loadonly_spritesheetLoadingQueue.dequeue();
                this.loadSpritesheet(spritesheet.key, spritesheet.path, onFinishLoading);
            }
        }
        /**
         * Loads a singular spritesheet
         * @param key The key of the spritesheet to load
         * @param pathToSpritesheetJSON The path to the spritesheet JSON file
         * @param callbackIfLast The function to call if this is the last spritesheet
         */
        loadSpritesheet(key, pathToSpritesheetJSON, callbackIfLast) {
            this.loadTextFile(pathToSpritesheetJSON, (fileText) => {
                let spritesheet = JSON.parse(fileText);
                // We can parse the object later - it's much faster than loading
                this.spritesheets.add(key, spritesheet);
                let resource = new ResourceReference(key, ResourceType.SPRITESHEET);
                // Grab the image we need to load and add it to the imageloading queue
                let path = StringUtils_1.default.getPathFromFilePath(pathToSpritesheetJSON) + spritesheet.spriteSheetImage;
                this.loadonly_imageLoadingQueue.enqueue({ key: spritesheet.name, path: path, isDependency: true });
                resource.addDependency(new ResourceReference(spritesheet.name, ResourceType.IMAGE));
                this.resourcesToUnload.push(resource);
                // Finish loading
                this.finishLoadingSpritesheet(callbackIfLast);
            });
        }
        /**
         * Finish loading a spritesheet. Calls the callback function if this is the last spritesheet being loaded
         * @param callback The function to call if this is the last spritesheet to load
         */
        finishLoadingSpritesheet(callback) {
            this.loadonly_spritesheetsLoaded += 1;
            if (this.loadonly_spritesheetsLoaded === this.loadonly_spritesheetsToLoad) {
                // We're done loading spritesheets
                callback();
            }
        }
        /**
         * Loads all images currently in the image loading queue
         * @param onFinishLoading The function to call when there are no more images to load
         */
        loadImagesFromQueue(onFinishLoading) {
            this.loadonly_imagesToLoad = this.loadonly_imageLoadingQueue.getSize();
            this.loadonly_imagesLoaded = 0;
            // If no items to load, we're finished
            if (this.loadonly_imagesToLoad === 0) {
                onFinishLoading();
                return;
            }
            while (this.loadonly_imageLoadingQueue.hasItems()) {
                let image = this.loadonly_imageLoadingQueue.dequeue();
                this.loadImage(image.key, image.path, image.isDependency, onFinishLoading);
            }
        }
        /**
         * Loads a singular image
         * @param key The key of the image to load
         * @param path The path to the image to load
         * @param callbackIfLast The function to call if this is the last image
         */
        loadImage(key, path, isDependency, callbackIfLast) {
            var image = new Image();
            image.onload = () => {
                // Add to loaded images
                this.images.add(key, image);
                // If not a dependency, push it to the unload list. Otherwise it's managed by something else
                if (!isDependency) {
                    this.resourcesToUnload.push(new ResourceReference(key, ResourceType.IMAGE));
                }
                // If WebGL is active, create a texture
                if (this.gl_WebGLActive) {
                    this.createWebGLTexture(key, image);
                }
                // Finish image load
                this.finishLoadingImage(callbackIfLast);
            };
            image.src = path;
        }
        /**
         * Finish loading an image. If this is the last image, it calls the callback function
         * @param callback The function to call if this is the last image
         */
        finishLoadingImage(callback) {
            this.loadonly_imagesLoaded += 1;
            if (this.loadonly_imagesLoaded === this.loadonly_imagesToLoad) {
                // We're done loading images
                callback();
            }
        }
        /**
         * Loads all audio currently in the tilemap loading queue
         * @param onFinishLoading The function to call when tilemaps are done loading
         */
        loadAudioFromQueue(onFinishLoading) {
            this.loadonly_audioToLoad = this.loadonly_audioLoadingQueue.getSize();
            this.loadonly_audioLoaded = 0;
            // If no items to load, we're finished
            if (this.loadonly_audioToLoad === 0) {
                onFinishLoading();
                return;
            }
            while (this.loadonly_audioLoadingQueue.hasItems()) {
                let audio = this.loadonly_audioLoadingQueue.dequeue();
                this.loadAudio(audio.key, audio.path, onFinishLoading);
            }
        }
        /**
         * Load a singular audio file
         * @param key The key to the audio file to load
         * @param path The path to the audio file to load
         * @param callbackIfLast The function to call if this is the last audio file to load
         */
        loadAudio(key, path, callbackIfLast) {
            let audioCtx = AudioManager_1.default.getInstance().getAudioContext();
            let request = new XMLHttpRequest();
            request.open('GET', path, true);
            request.responseType = 'arraybuffer';
            request.onload = () => {
                audioCtx.decodeAudioData(request.response, (buffer) => {
                    // Add to list of audio buffers
                    this.audioBuffers.add(key, buffer);
                    this.resourcesToUnload.push(new ResourceReference(key, ResourceType.AUDIO));
                    // Finish loading sound
                    this.finishLoadingAudio(callbackIfLast);
                }, (error) => {
                    throw "Error loading sound";
                });
            };
            request.send();
        }
        /**
         * Finish loading an audio file. Calls the callback functon if this is the last audio sample being loaded.
         * @param callback The function to call if this is the last audio file to load
         */
        finishLoadingAudio(callback) {
            this.loadonly_audioLoaded += 1;
            if (this.loadonly_audioLoaded === this.loadonly_audioToLoad) {
                // We're done loading audio
                callback();
            }
        }
        /**
         * Loads all objects currently in the object loading queue
         * @param onFinishLoading The function to call when there are no more objects to load
         */
        loadObjectsFromQueue(onFinishLoading) {
            this.loadonly_jsonToLoad = this.loadonly_jsonLoadingQueue.getSize();
            this.loadonly_jsonLoaded = 0;
            // If no items to load, we're finished
            if (this.loadonly_jsonToLoad === 0) {
                onFinishLoading();
                return;
            }
            while (this.loadonly_jsonLoadingQueue.hasItems()) {
                let obj = this.loadonly_jsonLoadingQueue.dequeue();
                this.loadObject(obj.key, obj.path, onFinishLoading);
            }
        }
        /**
         * Loads a singular object
         * @param key The key of the object to load
         * @param path The path to the object to load
         * @param callbackIfLast The function to call if this is the last object
         */
        loadObject(key, path, callbackIfLast) {
            this.loadTextFile(path, (fileText) => {
                let obj = JSON.parse(fileText);
                this.jsonObjects.add(key, obj);
                this.resourcesToUnload.push(new ResourceReference(key, ResourceType.JSON));
                this.finishLoadingObject(callbackIfLast);
            });
        }
        /**
         * Finish loading an object. If this is the last object, it calls the callback function
         * @param callback The function to call if this is the last object
         */
        finishLoadingObject(callback) {
            this.loadonly_jsonLoaded += 1;
            if (this.loadonly_jsonLoaded === this.loadonly_jsonToLoad) {
                // We're done loading objects
                callback();
            }
        }
        /* ########## WEBGL SPECIFIC FUNCTIONS ########## */
        getTexture(key) {
            return this.gl_Textures.get(key);
        }
        getShaderProgram(key) {
            return this.gl_ShaderPrograms.get(key).program;
        }
        getBuffer(key) {
            return this.gl_Buffers.get(key);
        }
        createWebGLTexture(imageKey, image) {
            // Get the texture ID
            const textureID = this.getTextureID(this.gl_NextTextureID);
            // Create the texture
            const texture = this.gl.createTexture();
            // Set up the texture
            // Enable texture0
            this.gl.activeTexture(textureID);
            // Bind our texture to texture 0
            this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
            // Set the texture parameters
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
            // Set the texture image
            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);
            // Add the texture to our map with the same key as the image
            this.gl_Textures.add(imageKey, this.gl_NextTextureID);
            // Increment the key
            this.gl_NextTextureID += 1;
        }
        getTextureID(id) {
            // Start with 9 cases - this can be expanded if needed, but for the best performance,
            // Textures should be stitched into an atlas
            switch (id) {
                case 0: return this.gl.TEXTURE0;
                case 1: return this.gl.TEXTURE1;
                case 2: return this.gl.TEXTURE2;
                case 3: return this.gl.TEXTURE3;
                case 4: return this.gl.TEXTURE4;
                case 5: return this.gl.TEXTURE5;
                case 6: return this.gl.TEXTURE6;
                case 7: return this.gl.TEXTURE7;
                case 8: return this.gl.TEXTURE8;
                default: return this.gl.TEXTURE9;
            }
        }
        createBuffer(key) {
            if (this.gl_WebGLActive) {
                let buffer = this.gl.createBuffer();
                this.gl_Buffers.add(key, buffer);
            }
        }
        /**
         * Enqueues loading of a new shader program
         * @param key The key of the shader program
         * @param vShaderFilepath
         * @param fShaderFilepath
         */
        shader(key, vShaderFilepath, fShaderFilepath) {
            let splitPath = vShaderFilepath.split(".");
            let end = splitPath[splitPath.length - 1];
            if (end !== "vshader") {
                throw `${vShaderFilepath} is not a valid vertex shader - must end in ".vshader`;
            }
            splitPath = fShaderFilepath.split(".");
            end = splitPath[splitPath.length - 1];
            if (end !== "fshader") {
                throw `${fShaderFilepath} is not a valid vertex shader - must end in ".fshader`;
            }
            let paths = new KeyPath_Shader();
            paths.key = key;
            paths.vpath = vShaderFilepath;
            paths.fpath = fShaderFilepath;
            this.loadonly_gl_ShaderLoadingQueue.enqueue(paths);
        }
        /**
         * Tells the resource manager to keep this resource
         * @param key The key of the resource
         */
        keepShader(key) {
            this.keepResource(key, ResourceType.IMAGE);
        }
        gl_LoadShadersFromQueue(onFinishLoading) {
            this.loadonly_gl_ShaderProgramsToLoad = this.loadonly_gl_ShaderLoadingQueue.getSize();
            this.loadonly_gl_ShaderProgramsLoaded = 0;
            // If webGL isn'active or there are no items to load, we're finished
            if (!this.gl_WebGLActive || this.loadonly_gl_ShaderProgramsToLoad === 0) {
                onFinishLoading();
                return;
            }
            while (this.loadonly_gl_ShaderLoadingQueue.hasItems()) {
                let shader = this.loadonly_gl_ShaderLoadingQueue.dequeue();
                this.gl_LoadShader(shader.key, shader.vpath, shader.fpath, onFinishLoading);
            }
        }
        gl_LoadShader(key, vpath, fpath, callbackIfLast) {
            this.loadTextFile(vpath, (vFileText) => {
                const vShader = vFileText;
                this.loadTextFile(fpath, (fFileText) => {
                    const fShader = fFileText;
                    // Extract the program and shaders
                    const [shaderProgram, vertexShader, fragmentShader] = this.createShaderProgram(vShader, fShader);
                    // Create a wrapper type
                    const programWrapper = new WebGLProgramType_1.default();
                    programWrapper.program = shaderProgram;
                    programWrapper.vertexShader = vertexShader;
                    programWrapper.fragmentShader = fragmentShader;
                    // Add to our map
                    this.gl_ShaderPrograms.add(key, programWrapper);
                    this.resourcesToUnload.push(new ResourceReference(key, ResourceType.SHADER));
                    // Finish loading
                    this.gl_FinishLoadingShader(callbackIfLast);
                });
            });
        }
        gl_FinishLoadingShader(callback) {
            this.loadonly_gl_ShaderProgramsLoaded += 1;
            if (this.loadonly_gl_ShaderProgramsLoaded === this.loadonly_gl_ShaderProgramsToLoad) {
                // We're done loading shaders
                callback();
            }
        }
        createShaderProgram(vShaderSource, fShaderSource) {
            const vertexShader = this.loadVertexShader(vShaderSource);
            const fragmentShader = this.loadFragmentShader(fShaderSource);
            if (vertexShader === null || fragmentShader === null) {
                // We had a problem intializing - error
                return null;
            }
            // Create a shader program
            const program = this.gl.createProgram();
            if (!program) {
                // Error creating
                console.warn("Failed to create program");
                return null;
            }
            // Attach our vertex and fragment shader
            this.gl.attachShader(program, vertexShader);
            this.gl.attachShader(program, fragmentShader);
            // Link
            this.gl.linkProgram(program);
            if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
                // Error linking
                const error = this.gl.getProgramInfoLog(program);
                console.warn("Failed to link program: " + error);
                // Clean up
                this.gl.deleteProgram(program);
                this.gl.deleteShader(vertexShader);
                this.gl.deleteShader(fragmentShader);
                return null;
            }
            // We successfully create a program
            return [program, vertexShader, fragmentShader];
        }
        loadVertexShader(shaderSource) {
            // Create a new vertex shader
            return this.loadShader(this.gl.VERTEX_SHADER, shaderSource);
        }
        loadFragmentShader(shaderSource) {
            // Create a new fragment shader
            return this.loadShader(this.gl.FRAGMENT_SHADER, shaderSource);
        }
        loadShader(type, shaderSource) {
            const shader = this.gl.createShader(type);
            // If we couldn't create the shader, error
            if (shader === null) {
                console.warn("Unable to create shader");
                return null;
            }
            // Add the source to the shader and compile
            this.gl.shaderSource(shader, shaderSource);
            this.gl.compileShader(shader);
            // Make sure there were no errors during this process
            if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                // Not compiled - error
                const error = this.gl.getShaderInfoLog(shader);
                console.warn("Failed to compile shader: " + error);
                // Clean up
                this.gl.deleteShader(shader);
                return null;
            }
            // Sucess, so return the shader
            return shader;
        }
        /* ########## GENERAL LOADING FUNCTIONS ########## */
        loadTextFile(textFilePath, callback) {
            let xobj = new XMLHttpRequest();
            xobj.overrideMimeType("application/json");
            xobj.open('GET', textFilePath, true);
            xobj.onreadystatechange = function () {
                if ((xobj.readyState == 4) && (xobj.status == 200)) {
                    callback(xobj.responseText);
                }
            };
            xobj.send(null);
        }
        /* ########## LOADING BAR INFO ########## */
        getLoadPercent() {
            return (this.loadonly_tilemapsLoaded / this.loadonly_tilemapsToLoad
                + this.loadonly_spritesheetsLoaded / this.loadonly_spritesheetsToLoad
                + this.loadonly_imagesLoaded / this.loadonly_imagesToLoad
                + this.loadonly_audioLoaded / this.loadonly_audioToLoad)
                / this.loadonly_typesToLoad;
        }
        update(deltaT) {
            if (this.loading) {
                if (this.onLoadProgress) {
                    this.onLoadProgress(this.getLoadPercent());
                }
            }
            else if (this.justLoaded) {
                this.justLoaded = false;
                if (this.onLoadComplete) {
                    this.onLoadComplete();
                }
            }
        }
    }
    exports.default = ResourceManager;
    /**
     * A class representing a reference to a resource.
     * This is used for the exemption list to assure assets and their dependencies don't get
     * destroyed if they are still needed.
     */
    class ResourceReference {
        constructor(key, resourceType) {
            this.key = key;
            this.resourceType = resourceType;
            this.dependencies = new Array();
        }
        addDependency(resource) {
            this.dependencies.push(resource);
        }
    }
    var ResourceType;
    (function (ResourceType) {
        ResourceType["IMAGE"] = "IMAGE";
        ResourceType["TILEMAP"] = "TILEMAP";
        ResourceType["SPRITESHEET"] = "SPRITESHEET";
        ResourceType["AUDIO"] = "AUDIO";
        ResourceType["JSON"] = "JSON";
        ResourceType["SHADER"] = "SHADER";
    })(ResourceType || (ResourceType = {}));
    /**
     * A pair representing a key and the path of the resource to load
     */
    class KeyPathPair {
        constructor() {
            this.isDependency = false;
        }
    }
    class KeyPath_Shader {
    }
    },{"../DataTypes/Map":19,"../DataTypes/Queue":23,"../DataTypes/Rendering/WebGLProgramType":24,"../Sound/AudioManager":106,"../Utils/StringUtils":114}],94:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Vec2_1 = require("../DataTypes/Vec2");
    /**
     * An abstract interface of a SceneGraph.
     * Exposes methods for use by other code, but leaves the implementation up to the subclasses.
     * The SceneGraph manages the positions of all GameNodes, and can easily prune a visible set for rendering.
     */
    class SceneGraph {
        /**
         * Creates a new SceneGraph
         * @param viewport The viewport
         * @param scene The Scene this SceneGraph belongs to
         */
        constructor(viewport, scene) {
            this.viewport = viewport;
            this.scene = scene;
            this.nodeMap = new Array();
            this.idCounter = 0;
        }
        /**
         * Add a node to the SceneGraph
         * @param node The CanvasNode to add to the SceneGraph
         * @returns The SceneGraph ID of this newly added CanvasNode
         */
        addNode(node) {
            this.nodeMap[node.id] = node;
            this.addNodeSpecific(node, this.idCounter);
            this.idCounter += 1;
            return this.idCounter - 1;
        }
        ;
        /**
         * Removes a node from the SceneGraph
         * @param node The node to remove
         */
        removeNode(node) {
            // Find and remove node in O(n)
            this.nodeMap[node.id] = undefined;
            this.removeNodeSpecific(node, node.id);
        }
        ;
        /**
         * Get a specific node using its id
         * @param id The id of the CanvasNode to retrieve
         * @returns The node with this ID
         */
        getNode(id) {
            return this.nodeMap[id];
        }
        /**
         * Returns the nodes at specific coordinates
         * @param vecOrX The x-coordinate of the position, or the coordinates in a Vec2
         * @param y The y-coordinate of the position
         * @returns An array of nodes found at the position provided
         */
        getNodesAt(vecOrX, y = null) {
            if (vecOrX instanceof Vec2_1.default) {
                return this.getNodesAtCoords(vecOrX.x, vecOrX.y);
            }
            else {
                return this.getNodesAtCoords(vecOrX, y);
            }
        }
        /**
         * Returns all nodes in the SceneGraph
         * @returns An Array containing all nodes in the SceneGraph
         */
        getAllNodes() {
            let arr = new Array();
            for (let i = 0; i < this.nodeMap.length; i++) {
                if (this.nodeMap[i] !== undefined) {
                    arr.push(this.nodeMap[i]);
                }
            }
            return arr;
        }
    }
    exports.default = SceneGraph;
    },{"../DataTypes/Vec2":32}],95:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const SceneGraph_1 = require("./SceneGraph");
    const Stats_1 = require("../Debug/Stats");
    /**
     * An implementation of a SceneGraph that simply stored CanvasNodes in an array.
     */
    class SceneGraphArray extends SceneGraph_1.default {
        /**
         * Creates a new SceneGraphArray
         * @param viewport The Viewport
         * @param scene The Scene this SceneGraph belongs to
         */
        constructor(viewport, scene) {
            super(viewport, scene);
            this.nodeList = new Array();
        }
        // @override
        addNodeSpecific(node, id) {
            this.nodeList.push(node);
        }
        // @override
        removeNodeSpecific(node, id) {
            let index = this.nodeList.indexOf(node);
            if (index > -1) {
                this.nodeList.splice(index, 1);
            }
        }
        // @override
        getNodesAtCoords(x, y) {
            let results = [];
            for (let node of this.nodeList) {
                if (node.contains(x, y)) {
                    results.push(node);
                }
            }
            return results;
        }
        // @override
        getNodesInRegion(boundary) {
            let t0 = performance.now();
            let results = [];
            for (let node of this.nodeList) {
                if (boundary.overlaps(node.boundary)) {
                    results.push(node);
                }
            }
            let t1 = performance.now();
            Stats_1.default.log("sgquery", (t1 - t0));
            return results;
        }
        update(deltaT) {
            let t0 = performance.now();
            for (let node of this.nodeList) {
                if (!node.getLayer().isPaused()) {
                    node.update(deltaT);
                }
            }
            let t1 = performance.now();
            Stats_1.default.log("sgupdate", (t1 - t0));
        }
        render(ctx) { }
        // @override
        getVisibleSet() {
            let visibleSet = new Array();
            for (let node of this.nodeList) {
                if (!node.getLayer().isHidden() && node.visible && this.viewport.includes(node)) {
                    visibleSet.push(node);
                }
            }
            return visibleSet;
        }
    }
    exports.default = SceneGraphArray;
    },{"../Debug/Stats":34,"./SceneGraph":94}],96:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Vec2_1 = require("../DataTypes/Vec2");
    const MathUtils_1 = require("../Utils/MathUtils");
    const Queue_1 = require("../DataTypes/Queue");
    const AABB_1 = require("../DataTypes/Shapes/AABB");
    const Input_1 = require("../Input/Input");
    const ParallaxLayer_1 = require("../Scene/Layers/ParallaxLayer");
    const UILayer_1 = require("../Scene/Layers/UILayer");
    /**
     * The viewport of the game. Corresponds to the visible window displayed in the browser.
     * The viewport keeps track of its position in the game world, and can act as a camera to follow objects.
     */
    class Viewport {
        constructor(canvasSize, zoomLevel) {
            /** The amount that is zoomed in or out. */
            this.ZOOM_FACTOR = 1.2;
            this.view = new AABB_1.default(Vec2_1.default.ZERO, Vec2_1.default.ZERO);
            this.boundary = new AABB_1.default(Vec2_1.default.ZERO, Vec2_1.default.ZERO);
            this.lastPositions = new Queue_1.default();
            this.smoothingFactor = 10;
            this.scrollZoomEnabled = false;
            this.canvasSize = Vec2_1.default.ZERO;
            this.focus = Vec2_1.default.ZERO;
            // Set the size of the canvas
            this.setCanvasSize(canvasSize);
            // Set the size of the viewport
            this.setSize(canvasSize);
            this.setZoomLevel(zoomLevel);
            // Set the center (and make the viewport stay there)
            this.setCenter(this.view.halfSize.clone());
            this.setFocus(this.view.halfSize.clone());
        }
        /** Enables the viewport to zoom in and out */
        enableZoom() {
            this.scrollZoomEnabled = true;
        }
        /**
         * Returns the position of the viewport
         * @returns The center of the viewport as a Vec2
         */
        getCenter() {
            return this.view.center;
        }
        /**
         * Returns a new Vec2 with the origin of the viewport
         * @returns The top left cornder of the Vieport as a Vec2
         */
        getOrigin() {
            return new Vec2_1.default(this.view.left, this.view.top);
        }
        /**
         * Returns the region visible to this viewport
         * @returns The AABB containing the region visible to the viewport
         */
        getView() {
            return this.view;
        }
        /**
         * Set the position of the viewport
         * @param vecOrX The new position or the x-coordinate of the new position
         * @param y The y-coordinate of the new position
         */
        setCenter(vecOrX, y = null) {
            let pos;
            if (vecOrX instanceof Vec2_1.default) {
                pos = vecOrX;
            }
            else {
                pos = new Vec2_1.default(vecOrX, y);
            }
            this.view.center = pos;
        }
        /**
         * Returns the size of the viewport as a Vec2
         * @returns The half-size of the viewport as a Vec2
         */
        getHalfSize() {
            return this.view.getHalfSize();
        }
        /**
         * Sets the size of the viewport
         * @param vecOrX The new width of the viewport or the new size as a Vec2
         * @param y The new height of the viewport
         */
        setSize(vecOrX, y = null) {
            if (vecOrX instanceof Vec2_1.default) {
                this.view.setHalfSize(vecOrX.scaled(1 / 2));
            }
            else {
                this.view.setHalfSize(new Vec2_1.default(vecOrX / 2, y / 2));
            }
        }
        /**
         * Sets the half-size of the viewport
         * @param vecOrX The new half-width of the viewport or the new half-size as a Vec2
         * @param y The new height of the viewport
         */
        setHalfSize(vecOrX, y = null) {
            if (vecOrX instanceof Vec2_1.default) {
                this.view.setHalfSize(vecOrX.clone());
            }
            else {
                this.view.setHalfSize(new Vec2_1.default(vecOrX, y));
            }
        }
        /**
         * Updates the viewport with the size of the current Canvas
         * @param vecOrX The width of the canvas, or the canvas size as a Vec2
         * @param y The height of the canvas
         */
        setCanvasSize(vecOrX, y = null) {
            if (vecOrX instanceof Vec2_1.default) {
                this.canvasSize = vecOrX.clone();
            }
            else {
                this.canvasSize = new Vec2_1.default(vecOrX, y);
            }
        }
        /**
         * Sets the zoom level of the viewport
         * @param zoom The zoom level
         */
        setZoomLevel(zoom) {
            this.view.halfSize.copy(this.canvasSize.scaled(1 / zoom / 2));
        }
        /**
         * Gets the zoom level of the viewport
         * @returns The zoom level
         */
        getZoomLevel() {
            return this.canvasSize.x / this.view.hw / 2;
        }
        /**
         * Sets the smoothing factor for the viewport movement.
         * @param smoothingFactor The smoothing factor for the viewport
         */
        setSmoothingFactor(smoothingFactor) {
            if (smoothingFactor < 1)
                smoothingFactor = 1;
            this.smoothingFactor = smoothingFactor;
        }
        /**
         * Tells the viewport to focus on a point. Overidden by "following".
         * @param focus The point the  viewport should focus on
         */
        setFocus(focus) {
            this.focus.copy(focus);
        }
        /**
         * Returns true if the CanvasNode is inside of the viewport
         * @param node The node to check
         * @returns True if the node is currently visible in the viewport, false if not
         */
        includes(node) {
            let parallax = node.getLayer() instanceof ParallaxLayer_1.default || node.getLayer() instanceof UILayer_1.default ? node.getLayer().parallax : new Vec2_1.default(1, 1);
            let center = this.view.center.clone();
            this.view.center.mult(parallax);
            let overlaps = this.view.overlaps(node.boundary);
            this.view.center = center;
            return overlaps;
        }
        // TODO: Put some error handling on this for trying to make the bounds too small for the viewport
        // TODO: This should probably be done automatically, or should consider the aspect ratio or something
        /**
         * Sets the bounds of the viewport
         * @param lowerX The left edge of the viewport
         * @param lowerY The top edge of the viewport
         * @param upperX The right edge of the viewport
         * @param upperY The bottom edge of the viewport
         */
        setBounds(lowerX, lowerY, upperX, upperY) {
            let hwidth = (upperX - lowerX) / 2;
            let hheight = (upperY - lowerY) / 2;
            let x = lowerX + hwidth;
            let y = lowerY + hheight;
            this.boundary.center.set(x, y);
            this.boundary.halfSize.set(hwidth, hheight);
        }
        /**
         * Make the viewport follow the specified GameNode
         * @param node The GameNode to follow
         */
        follow(node) {
            this.following = node;
        }
        updateView() {
            if (this.lastPositions.getSize() > this.smoothingFactor) {
                this.lastPositions.dequeue();
            }
            // Get the average of the last 10 positions
            let pos = Vec2_1.default.ZERO;
            this.lastPositions.forEach(position => pos.add(position));
            pos.scale(1 / this.lastPositions.getSize());
            // Set this position either to the object or to its bounds
            pos.x = MathUtils_1.default.clamp(pos.x, this.boundary.left + this.view.hw, this.boundary.right - this.view.hw);
            pos.y = MathUtils_1.default.clamp(pos.y, this.boundary.top + this.view.hh, this.boundary.bottom - this.view.hh);
            // Assure there are no lines in the tilemap
            pos.x = Math.floor(pos.x);
            pos.y = Math.floor(pos.y);
            this.view.center.copy(pos);
        }
        update(deltaT) {
            // If zoom is enabled
            if (this.scrollZoomEnabled) {
                if (Input_1.default.didJustScroll()) {
                    let currentSize = this.view.getHalfSize().clone();
                    if (Input_1.default.getScrollDirection() < 0) {
                        // Zoom in
                        currentSize.scale(1 / this.ZOOM_FACTOR);
                    }
                    else {
                        // Zoom out
                        currentSize.scale(this.ZOOM_FACTOR);
                    }
                    if (currentSize.x > this.boundary.hw) {
                        let factor = this.boundary.hw / currentSize.x;
                        currentSize.x = this.boundary.hw;
                        currentSize.y *= factor;
                    }
                    if (currentSize.y > this.boundary.hh) {
                        let factor = this.boundary.hh / currentSize.y;
                        currentSize.y = this.boundary.hh;
                        currentSize.x *= factor;
                    }
                    this.view.setHalfSize(currentSize);
                }
            }
            // If viewport is following an object
            if (this.following) {
                // Update our list of previous positions
                this.lastPositions.enqueue(this.following.position.clone());
            }
            else {
                this.lastPositions.enqueue(this.focus);
            }
            this.updateView();
        }
    }
    exports.default = Viewport;
    },{"../DataTypes/Queue":23,"../DataTypes/Shapes/AABB":25,"../DataTypes/Vec2":32,"../Input/Input":40,"../Scene/Layers/ParallaxLayer":101,"../Scene/Layers/UILayer":102,"../Utils/MathUtils":112}],97:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Sprite_1 = require("../../Nodes/Sprites/Sprite");
    const AnimatedSprite_1 = require("../../Nodes/Sprites/AnimatedSprite");
    const GraphicTypes_1 = require("../../Nodes/Graphics/GraphicTypes");
    const UIElementTypes_1 = require("../../Nodes/UIElements/UIElementTypes");
    const Point_1 = require("../../Nodes/Graphics/Point");
    const Vec2_1 = require("../../DataTypes/Vec2");
    const Button_1 = require("../../Nodes/UIElements/Button");
    const Label_1 = require("../../Nodes/UIElements/Label");
    const Slider_1 = require("../../Nodes/UIElements/Slider");
    const TextInput_1 = require("../../Nodes/UIElements/TextInput");
    const Rect_1 = require("../../Nodes/Graphics/Rect");
    const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
    const Line_1 = require("../../Nodes/Graphics/Line");
    const Particle_1 = require("../../Nodes/Graphics/Particle");
    // @ignorePage
    /**
     * A factory that abstracts adding @reference[CanvasNode]s to the @reference[Scene].
     * Access methods in this factory through Scene.add.[methodName]().
     */
    class CanvasNodeFactory {
        constructor() {
            /**
             * Adds an instance of a UIElement to the current scene - i.e. any class that extends UIElement
             * @param type The type of UIElement to add
             * @param layerName The layer to add the UIElement to
             * @param options Any additional arguments to feed to the constructor
             * @returns A new UIElement
             */
            this.addUIElement = (type, layerName, options) => {
                // Get the layer
                let layer = this.scene.getLayer(layerName);
                let instance;
                switch (type) {
                    case UIElementTypes_1.UIElementType.BUTTON:
                        instance = this.buildButton(options);
                        break;
                    case UIElementTypes_1.UIElementType.LABEL:
                        instance = this.buildLabel(options);
                        break;
                    case UIElementTypes_1.UIElementType.SLIDER:
                        instance = this.buildSlider(options);
                        break;
                    case UIElementTypes_1.UIElementType.TEXT_INPUT:
                        instance = this.buildTextInput(options);
                        break;
                    default:
                        throw `UIElementType '${type}' does not exist, or is registered incorrectly.`;
                }
                instance.setScene(this.scene);
                instance.id = this.scene.generateId();
                this.scene.getSceneGraph().addNode(instance);
                // Add instance to layer
                layer.addNode(instance);
                return instance;
            };
            /**
             * Adds a sprite to the current scene
             * @param key The key of the image the sprite will represent
             * @param layerName The layer on which to add the sprite
             * @returns A new Sprite
             */
            this.addSprite = (key, layerName) => {
                let layer = this.scene.getLayer(layerName);
                let instance = new Sprite_1.default(key);
                // Add instance to scene
                instance.setScene(this.scene);
                instance.id = this.scene.generateId();
                if (!(this.scene.isParallaxLayer(layerName) || this.scene.isUILayer(layerName))) {
                    this.scene.getSceneGraph().addNode(instance);
                }
                // Add instance to layer
                layer.addNode(instance);
                return instance;
            };
            /**
             * Adds an AnimatedSprite to the current scene
             * @param key The key of the image the sprite will represent
             * @param layerName The layer on which to add the sprite
             * @returns A new AnimatedSprite
             */
            this.addAnimatedSprite = (key, layerName) => {
                let layer = this.scene.getLayer(layerName);
                let spritesheet = this.resourceManager.getSpritesheet(key);
                let instance = new AnimatedSprite_1.default(spritesheet);
                // Add instance fo scene
                instance.setScene(this.scene);
                instance.id = this.scene.generateId();
                if (!(this.scene.isParallaxLayer(layerName) || this.scene.isUILayer(layerName))) {
                    this.scene.getSceneGraph().addNode(instance);
                }
                // Add instance to layer
                layer.addNode(instance);
                return instance;
            };
            /**
             * Adds a new graphic element to the current Scene
             * @param type The type of graphic to add
             * @param layerName The layer on which to add the graphic
             * @param options Any additional arguments to send to the graphic constructor
             * @returns A new Graphic
             */
            this.addGraphic = (type, layerName, options) => {
                // Get the layer
                let layer = this.scene.getLayer(layerName);
                let instance;
                switch (type) {
                    case GraphicTypes_1.GraphicType.POINT:
                        instance = this.buildPoint(options);
                        break;
                    case GraphicTypes_1.GraphicType.LINE:
                        instance = this.buildLine(options);
                        break;
                    case GraphicTypes_1.GraphicType.RECT:
                        instance = this.buildRect(options);
                        break;
                    case GraphicTypes_1.GraphicType.PARTICLE:
                        instance = this.buildParticle(options);
                        break;
                    default:
                        throw `GraphicType '${type}' does not exist, or is registered incorrectly.`;
                }
                // Add instance to scene
                instance.setScene(this.scene);
                instance.id = this.scene.generateId();
                if (!(this.scene.isParallaxLayer(layerName) || this.scene.isUILayer(layerName))) {
                    this.scene.getSceneGraph().addNode(instance);
                }
                // Add instance to layer
                layer.addNode(instance);
                return instance;
            };
        }
        init(scene) {
            this.scene = scene;
            this.resourceManager = ResourceManager_1.default.getInstance();
        }
        /* ---------- BUILDERS ---------- */
        buildButton(options) {
            this.checkIfPropExists("Button", options, "position", Vec2_1.default, "Vec2");
            this.checkIfPropExists("Button", options, "text", "string");
            return new Button_1.default(options.position, options.text);
        }
        buildLabel(options) {
            this.checkIfPropExists("Label", options, "position", Vec2_1.default, "Vec2");
            this.checkIfPropExists("Label", options, "text", "string");
            return new Label_1.default(options.position, options.text);
        }
        buildSlider(options) {
            this.checkIfPropExists("Slider", options, "position", Vec2_1.default, "Vec2");
            let initValue = 0;
            if (options.value !== undefined) {
                initValue = options.value;
            }
            return new Slider_1.default(options.position, initValue);
        }
        buildTextInput(options) {
            this.checkIfPropExists("TextInput", options, "position", Vec2_1.default, "Vec2");
            return new TextInput_1.default(options.position);
        }
        buildPoint(options) {
            this.checkIfPropExists("Point", options, "position", Vec2_1.default, "Vec2");
            return new Point_1.default(options.position);
        }
        buildParticle(options) {
            this.checkIfPropExists("Particle", options, "position", Vec2_1.default, "Vec2");
            this.checkIfPropExists("Particle", options, "size", Vec2_1.default, "Vec2");
            this.checkIfPropExists("Particle", options, "mass", "number", "number");
            //Changed for testing
            return new Particle_1.default(options.position, options.size, options.mass);
        }
        buildLine(options) {
            this.checkIfPropExists("Line", options, "start", Vec2_1.default, "Vec2");
            this.checkIfPropExists("Line", options, "end", Vec2_1.default, "Vec2");
            return new Line_1.default(options.start, options.end);
        }
        buildRect(options) {
            this.checkIfPropExists("Rect", options, "position", Vec2_1.default, "Vec2");
            this.checkIfPropExists("Rect", options, "size", Vec2_1.default, "Vec2");
            return new Rect_1.default(options.position, options.size);
        }
        /* ---------- ERROR HANDLING ---------- */
        checkIfPropExists(objectName, options, prop, type, typeName) {
            if (!options || options[prop] === undefined) {
                // Check that the options object has the property
                throw `${objectName} object requires argument ${prop} of type ${typeName}, but none was provided.`;
            }
            else {
                // Check that the property has the correct type
                if ((typeof type) === "string") {
                    if (!(typeof options[prop] === type)) {
                        throw `${objectName} object requires argument ${prop} of type ${type}, but provided ${prop} was not of type ${type}.`;
                    }
                }
                else if (type instanceof Function) {
                    // If type is a constructor, check against that
                    if (!(options[prop] instanceof type)) {
                        throw `${objectName} object requires argument ${prop} of type ${typeName}, but provided ${prop} was not of type ${typeName}.`;
                    }
                }
                else {
                    throw `${objectName} object requires argument ${prop} of type ${typeName}, but provided ${prop} was not of type ${typeName}.`;
                }
            }
        }
    }
    exports.default = CanvasNodeFactory;
    },{"../../DataTypes/Vec2":32,"../../Nodes/Graphics/GraphicTypes":50,"../../Nodes/Graphics/Line":51,"../../Nodes/Graphics/Particle":52,"../../Nodes/Graphics/Point":53,"../../Nodes/Graphics/Rect":54,"../../Nodes/Sprites/AnimatedSprite":55,"../../Nodes/Sprites/Sprite":56,"../../Nodes/UIElements/Button":60,"../../Nodes/UIElements/Label":61,"../../Nodes/UIElements/Slider":62,"../../Nodes/UIElements/TextInput":63,"../../Nodes/UIElements/UIElementTypes":64,"../../ResourceManager/ResourceManager":93}],98:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const CanvasNodeFactory_1 = require("./CanvasNodeFactory");
    const TilemapFactory_1 = require("./TilemapFactory");
    /**
     * The manager of all factories used for adding @reference[GameNode]s to the @reference[Scene].
     */
    class FactoryManager {
        constructor(scene, tilemaps) {
            // Constructors are called here to allow assignment of their functions to functions in this class
            this.canvasNodeFactory = new CanvasNodeFactory_1.default();
            this.tilemapFactory = new TilemapFactory_1.default();
            this.canvasNodeFactory.init(scene);
            this.tilemapFactory.init(scene, tilemaps);
        }
        // Expose all of the factories through the factory manager
        /**
         * Adds an instance of a UIElement to the current scene - i.e. any class that extends UIElement
         * @param type The type of UIElement to add
         * @param layerName The layer to add the UIElement to
         * @param options Any additional arguments to feed to the constructor
         * @returns A new UIElement
         */
        uiElement(type, layerName, options) {
            return this.canvasNodeFactory.addUIElement(type, layerName, options);
        }
        /**
         * Adds a sprite to the current scene
         * @param key The key of the image the sprite will represent
         * @param layerName The layer on which to add the sprite
         * @returns A new Sprite
         */
        sprite(key, layerName) {
            return this.canvasNodeFactory.addSprite(key, layerName);
        }
        /**
         * Adds an AnimatedSprite to the current scene
         * @param key The key of the image the sprite will represent
         * @param layerName The layer on which to add the sprite
         * @returns A new AnimatedSprite
         */
        animatedSprite(key, layerName) {
            return this.canvasNodeFactory.addAnimatedSprite(key, layerName);
        }
        /**
         * Adds a new graphic element to the current Scene
         * @param type The type of graphic to add
         * @param layerName The layer on which to add the graphic
         * @param options Any additional arguments to send to the graphic constructor
         * @returns A new Graphic
         */
        graphic(type, layerName, options) {
            return this.canvasNodeFactory.addGraphic(type, layerName, options);
        }
        /**
         * Adds a tilemap to the scene
         * @param key The key of the loaded tilemap to load
         * @param constr The constructor of the desired tilemap
         * @param args Additional arguments to send to the tilemap constructor
         * @returns An array of Layers, each of which contains a layer of the tilemap as its own Tilemap instance.
         */
        tilemap(key, scale) {
            return this.tilemapFactory.add(key, scale);
        }
    }
    exports.default = FactoryManager;
    },{"./CanvasNodeFactory":97,"./TilemapFactory":99}],99:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
    const OrthogonalTilemap_1 = require("../../Nodes/Tilemaps/OrthogonalTilemap");
    const Tileset_1 = require("../../DataTypes/Tilesets/Tileset");
    const Vec2_1 = require("../../DataTypes/Vec2");
    const PositionGraph_1 = require("../../DataTypes/Graphs/PositionGraph");
    const Navmesh_1 = require("../../Pathfinding/Navmesh");
    // @ignorePage
    /**
     * A factory that abstracts adding @reference[Tilemap]s to the @reference[Scene].
     * Access methods in this factory through Scene.add.[methodName]().
     */
    class TilemapFactory {
        constructor() {
            // TODO - This is specifically catered to Tiled tilemaps right now. In the future,
            // it would be good to have a "parseTilemap" function that would convert the tilemap
            // data into a standard format. This could allow for support from other programs
            // or the development of an internal level builder tool
            /**
             * Adds a tilemap to the scene
             * @param key The key of the loaded tilemap to load
             * @param constr The constructor of the desired tilemap
             * @param args Additional arguments to send to the tilemap constructor
             * @returns An array of Layers, each of which contains a layer of the tilemap as its own Tilemap instance.
             */
            this.add = (key, scale = new Vec2_1.default(1, 1)) => {
                // Get Tilemap Data
                let tilemapData = this.resourceManager.getTilemap(key);
                // Set the constructor for this tilemap to either be orthographic or isometric
                let constr;
                if (tilemapData.orientation === "orthographic") {
                    constr = OrthogonalTilemap_1.default;
                }
                else {
                    // No isometric tilemap support right now, so Orthographic tilemap
                    constr = OrthogonalTilemap_1.default;
                }
                // Initialize the return value array
                let sceneLayers = new Array();
                // Create all of the tilesets for this tilemap
                let tilesets = new Array();
                let collectionTiles = new Array();
                for (let tileset of tilemapData.tilesets) {
                    if (tileset.image) {
                        // If this is a standard tileset and not a collection, create a tileset for it.
                        // TODO - We are ignoring collection tilesets for now. This is likely not a great idea in practice,
                        // as theoretically someone could want to use one for a standard tilemap. We are assuming for now
                        // that we only want to use them for object layers
                        tilesets.push(new Tileset_1.default(tileset));
                    }
                    else {
                        tileset.tiles.forEach(tile => tile.id += tileset.firstgid);
                        collectionTiles.push(...tileset.tiles);
                    }
                }
                // Loop over the layers of the tilemap and create tiledlayers or object layers
                for (let layer of tilemapData.layers) {
                    let sceneLayer;
                    let isParallaxLayer = false;
                    let depth = 0;
                    if (layer.properties) {
                        for (let prop of layer.properties) {
                            if (prop.name === "Parallax") {
                                isParallaxLayer = prop.value;
                            }
                            else if (prop.name === "Depth") {
                                depth = prop.value;
                            }
                        }
                    }
                    if (isParallaxLayer) {
                        sceneLayer = this.scene.addParallaxLayer(layer.name, new Vec2_1.default(1, 1), depth);
                    }
                    else {
                        sceneLayer = this.scene.addLayer(layer.name, depth);
                    }
                    if (layer.type === "tilelayer") {
                        // Create a new tilemap object for the layer
                        let tilemap = new constr(tilemapData, layer, tilesets, scale);
                        tilemap.id = this.scene.generateId();
                        tilemap.setScene(this.scene);
                        // Add tilemap to scene
                        this.tilemaps.push(tilemap);
                        sceneLayer.addNode(tilemap);
                        // Register tilemap with physics if it's collidable
                        if (tilemap.isCollidable) {
                            tilemap.addPhysics();
                            if (layer.properties) {
                                for (let item of layer.properties) {
                                    if (item.name === "Group") {
                                        tilemap.setGroup(item.value);
                                    }
                                }
                            }
                        }
                    }
                    else {
                        let isNavmeshPoints = false;
                        let navmeshName;
                        let edges;
                        if (layer.properties) {
                            for (let prop of layer.properties) {
                                if (prop.name === "NavmeshPoints") {
                                    isNavmeshPoints = true;
                                }
                                else if (prop.name === "name") {
                                    navmeshName = prop.value;
                                }
                                else if (prop.name === "edges") {
                                    edges = prop.value;
                                }
                            }
                        }
                        if (isNavmeshPoints) {
                            let g = new PositionGraph_1.default();
                            for (let obj of layer.objects) {
                                g.addPositionedNode(new Vec2_1.default(obj.x, obj.y));
                            }
                            for (let edge of edges) {
                                g.addEdge(edge.from, edge.to);
                            }
                            this.scene.getNavigationManager().addNavigableEntity(navmeshName, new Navmesh_1.default(g));
                            continue;
                        }
                        // Layer is an object layer, so add each object as a sprite to a new layer
                        for (let obj of layer.objects) {
                            // Check if obj is collidable
                            let hasPhysics = false;
                            let isCollidable = false;
                            let isTrigger = false;
                            let onEnter = null;
                            let onExit = null;
                            let triggerGroup = null;
                            let group = "";
                            if (obj.properties) {
                                for (let prop of obj.properties) {
                                    if (prop.name === "HasPhysics") {
                                        hasPhysics = prop.value;
                                    }
                                    else if (prop.name === "Collidable") {
                                        isCollidable = prop.value;
                                    }
                                    else if (prop.name === "Group") {
                                        group = prop.value;
                                    }
                                    else if (prop.name === "IsTrigger") {
                                        isTrigger = prop.value;
                                    }
                                    else if (prop.name === "TriggerGroup") {
                                        triggerGroup = prop.value;
                                    }
                                    else if (prop.name === "TriggerOnEnter") {
                                        onEnter = prop.value;
                                    }
                                    else if (prop.name === "TriggerOnExit") {
                                        onExit = prop.value;
                                    }
                                }
                            }
                            let sprite;
                            // Check if obj is a tile from a tileset
                            for (let tileset of tilesets) {
                                if (tileset.hasTile(obj.gid)) {
                                    // The object is a tile from this set
                                    let imageKey = tileset.getImageKey();
                                    let offset = tileset.getImageOffsetForTile(obj.gid);
                                    sprite = this.scene.add.sprite(imageKey, layer.name);
                                    let size = tileset.getTileSize().clone();
                                    sprite.position.set((obj.x + size.x / 2) * scale.x, (obj.y - size.y / 2) * scale.y);
                                    sprite.setImageOffset(offset);
                                    sprite.size.copy(size);
                                    sprite.scale.set(scale.x, scale.y);
                                }
                            }
                            // Not in a tileset, must correspond to a collection
                            if (!sprite) {
                                for (let tile of collectionTiles) {
                                    if (obj.gid === tile.id) {
                                        let imageKey = tile.image;
                                        sprite = this.scene.add.sprite(imageKey, layer.name);
                                        sprite.position.set((obj.x + tile.imagewidth / 2) * scale.x, (obj.y - tile.imageheight / 2) * scale.y);
                                        sprite.scale.set(scale.x, scale.y);
                                    }
                                }
                            }
                            // Now we have sprite. Associate it with our physics object if there is one
                            if (hasPhysics) {
                                // Make the sprite a static physics object
                                sprite.addPhysics(sprite.boundary.clone(), Vec2_1.default.ZERO, isCollidable, true);
                                sprite.setGroup(group);
                                if (isTrigger && triggerGroup !== null) {
                                    sprite.setTrigger(triggerGroup, onEnter, onExit);
                                }
                            }
                        }
                    }
                    // Update the return value
                    sceneLayers.push(sceneLayer);
                }
                return sceneLayers;
            };
        }
        init(scene, tilemaps) {
            this.scene = scene;
            this.tilemaps = tilemaps;
            this.resourceManager = ResourceManager_1.default.getInstance();
        }
    }
    exports.default = TilemapFactory;
    },{"../../DataTypes/Graphs/PositionGraph":16,"../../DataTypes/Tilesets/Tileset":31,"../../DataTypes/Vec2":32,"../../Nodes/Tilemaps/OrthogonalTilemap":58,"../../Pathfinding/Navmesh":67,"../../ResourceManager/ResourceManager":93}],100:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const MathUtils_1 = require("../Utils/MathUtils");
    /**
     * A layer in the scene. Layers are used for sorting @reference[GameNode]s by depth.
     */
    class Layer {
        /**
         * Creates a new layer. To do this in a game, use the addLayer() method in @refrence[Scene]
         * @param scene The scene to add the layer to
         * @param name The name of the layer
         */
        constructor(scene, name) {
            this.scene = scene;
            this.name = name;
            this.paused = false;
            this.hidden = false;
            this.alpha = 1;
            this.items = new Array();
            this.ySort = false;
            this.depth = 0;
        }
        /**
         * Retreives the name of the layer
         * @returns The name of the layer
         */
        getName() {
            return this.name;
        }
        /**
         * Pauses/Unpauses the layer. Affects all elements in this layer
         * @param pauseValue True if the layer should be paused, false if not
         */
        setPaused(pauseValue) {
            this.paused = pauseValue;
        }
        /**
         * Returns whether or not the layer is paused
         */
        isPaused() {
            return this.paused;
        }
        /**
         * Sets the opacity of the layer
         * @param alpha The new opacity value in the range [0, 1]
         */
        setAlpha(alpha) {
            this.alpha = MathUtils_1.default.clamp(alpha, 0, 1);
        }
        /**
         * Gets the opacity of the layer
         * @returns The opacity
         */
        getAlpha() {
            return this.alpha;
        }
        /**
         * Sets the layer's hidden value. If hidden, a layer will not be rendered, but will still update
         * @param hidden The hidden value of the layer
         */
        setHidden(hidden) {
            this.hidden = hidden;
        }
        /**
         * Returns the hideen value of the lyaer
         * @returns True if the scene is hidden, false otherwise
         */
        isHidden() {
            return this.hidden;
        }
        /** Pauses this scene and hides it */
        disable() {
            this.paused = true;
            this.hidden = true;
        }
        /** Unpauses this layer and makes it visible */
        enable() {
            this.paused = false;
            this.hidden = false;
        }
        /**
         * Sets whether or not the scene will ySort automatically.
         * ySorting means that CanvasNodes on this layer will have their depth sorted depending on their y-value.
         * This means that if an object is "higher" in the scene, it will sort behind objects that are "lower".
         * This is useful for 3/4 view games, or similar situations, where you sometimes want to be in front of objects,
         * and other times want to be behind the same objects.
         * @param ySort True if ySorting should be active, false if not
         */
        setYSort(ySort) {
            this.ySort = ySort;
        }
        /**
         * Gets the ySort status of the scene
         * @returns True if ySorting is occurring, false otherwise
         */
        getYSort() {
            return this.ySort;
        }
        /**
         * Sets the depth of the layer compared to other layers. A larger number means the layer will be closer to the screen.
         * @param depth The depth of the layer.
         */
        setDepth(depth) {
            this.depth = depth;
        }
        /**
         * Retrieves the depth of the layer.
         * @returns The depth
         */
        getDepth() {
            return this.depth;
        }
        /**
         * Adds a node to this layer
         * @param node The node to add to this layer.
         */
        addNode(node) {
            this.items.push(node);
            node.setLayer(this);
        }
        /**
         * Removes a node from this layer
         * @param node The node to remove
         * @returns true if the node was removed, false otherwise
         */
        removeNode(node) {
            // Find and remove the node
            let index = this.items.indexOf(node);
            if (index !== -1) {
                this.items.splice(index, 1);
                node.setLayer(undefined);
            }
        }
        /**
         * Retreives all GameNodes from this layer
         * @returns an Array that contains all of the GameNodes in this layer.
         */
        getItems() {
            return this.items;
        }
    }
    exports.default = Layer;
    },{"../Utils/MathUtils":112}],101:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Layer_1 = require("../Layer");
    /**
     * An extension of a Layer that has a parallax value.
     */
    class ParallaxLayer extends Layer_1.default {
        /**
         * Creates a new ParallaxLayer.
         * Use addParallaxLayer() in @reference[Scene] to add a layer of this type to your game.
         * @param scene The Scene to add this ParallaxLayer to
         * @param name The name of the ParallaxLayer
         * @param parallax The parallax level
         */
        constructor(scene, name, parallax) {
            super(scene, name);
            this.parallax = parallax;
        }
    }
    exports.default = ParallaxLayer;
    },{"../Layer":100}],102:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Vec2_1 = require("../../DataTypes/Vec2");
    const ParallaxLayer_1 = require("./ParallaxLayer");
    /**
     * A Layer strictly to be used for managing UIElements.
     * This is intended to be a Layer that always stays in the same place,
     * and thus renders things like a HUD or an inventory without taking into consideration the \reference[Viewport] scroll.
     */
    class UILayer extends ParallaxLayer_1.default {
        /**
         * Creates a new UILayer.
         * Use addUILayer() in @reference[Scene] to add a layer of this type to your game.
         * @param scene The Scene to add this UILayer to
         * @param name The name of the UILayer
         */
        constructor(scene, name) {
            super(scene, name, Vec2_1.default.ZERO);
        }
    }
    exports.default = UILayer;
    },{"../../DataTypes/Vec2":32,"./ParallaxLayer":101}],103:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Layer_1 = require("./Layer");
    const Vec2_1 = require("../DataTypes/Vec2");
    const BasicPhysicsManager_1 = require("../Physics/BasicPhysicsManager");
    const SceneGraphArray_1 = require("../SceneGraph/SceneGraphArray");
    const FactoryManager_1 = require("./Factories/FactoryManager");
    const ResourceManager_1 = require("../ResourceManager/ResourceManager");
    const Receiver_1 = require("../Events/Receiver");
    const Emitter_1 = require("../Events/Emitter");
    const NavigationManager_1 = require("../Pathfinding/NavigationManager");
    const AIManager_1 = require("../AI/AIManager");
    const Map_1 = require("../DataTypes/Map");
    const ParallaxLayer_1 = require("./Layers/ParallaxLayer");
    const UILayer_1 = require("./Layers/UILayer");
    const CanvasNode_1 = require("../Nodes/CanvasNode");
    const SceneOptions_1 = require("./SceneOptions");
    const Debug_1 = require("../Debug/Debug");
    const TimerManager_1 = require("../Timing/TimerManager");
    const TweenManager_1 = require("../Rendering/Animations/TweenManager");
    const ParticleSystemManager_1 = require("../Rendering/Animations/ParticleSystemManager");
    /**
     * Scenes are the main container in the game engine.
     * Your main scene is the current level or menu of the game, and will contain all of the GameNodes needed.
     * Scenes provide an easy way to load assets, add assets to the game world, and unload assets,
     * and have lifecycle methods exposed for these functions.
     */
    class Scene {
        /**
         * Creates a new Scene. To add a new Scene in your game, use changeToScene() in @reference[SceneManager]
         * @param viewport The viewport of the game
         * @param sceneManager The SceneManager that owns this Scene
         * @param renderingManager The RenderingManager that will handle this Scene's rendering
         * @param game The instance of the Game
         * @param options The options for Scene initialization
         */
        constructor(viewport, sceneManager, renderingManager, options) {
            this.sceneOptions = SceneOptions_1.default.parse(options === undefined ? {} : options);
            this.worldSize = new Vec2_1.default(500, 500);
            this.viewport = viewport;
            this.viewport.setBounds(0, 0, 2560, 1280);
            this.running = false;
            this.sceneManager = sceneManager;
            this.receiver = new Receiver_1.default();
            this.emitter = new Emitter_1.default();
            this.tilemaps = new Array();
            this.sceneGraph = new SceneGraphArray_1.default(this.viewport, this);
            this.layers = new Map_1.default();
            this.uiLayers = new Map_1.default();
            this.parallaxLayers = new Map_1.default();
            this.physicsManager = new BasicPhysicsManager_1.default(this.sceneOptions.physics);
            this.navManager = new NavigationManager_1.default();
            this.aiManager = new AIManager_1.default();
            this.renderingManager = renderingManager;
            this.add = new FactoryManager_1.default(this, this.tilemaps);
            this.load = ResourceManager_1.default.getInstance();
            this.resourceManager = this.load;
            // Get the timer manager and clear any existing timers
            TimerManager_1.default.getInstance().clearTimers();
        }
        /** A lifecycle method that gets called immediately after a new scene is created, before anything else. */
        initScene(init) { }
        /** A lifecycle method that gets called when a new scene is created. Load all files you wish to access in the scene here. */
        loadScene() { }
        /** A lifecycle method called strictly after loadScene(). Create any game objects you wish to use in the scene here. */
        startScene() { }
        /**
         * A lifecycle method called every frame of the game. This is where you can dynamically do things like add in new enemies
         * @param delta The time this frame represents
         */
        updateScene(deltaT) { }
        /** A lifecycle method that gets called on scene destruction. Specify which files you no longer need for garbage collection. */
        unloadScene() { }
        update(deltaT) {
            this.updateScene(deltaT);
            // Do time updates
            TimerManager_1.default.getInstance().update(deltaT);
            // Do all AI updates
            this.aiManager.update(deltaT);
            // Update all physics objects
            this.physicsManager.update(deltaT);
            // Update all canvas objects
            this.sceneGraph.update(deltaT);
            // Update all tilemaps
            this.tilemaps.forEach(tilemap => {
                if (!tilemap.getLayer().isPaused()) {
                    tilemap.update(deltaT);
                }
            });
            // Update all tweens
            TweenManager_1.default.getInstance().update(deltaT);
            // Update all particle systems
            ParticleSystemManager_1.default.getInstance().update(deltaT);
            // Update viewport
            this.viewport.update(deltaT);
        }
        /**
         * Collects renderable sets and coordinates with the RenderingManager to draw the Scene
         */
        render() {
            // Get the visible set of nodes
            let visibleSet = this.sceneGraph.getVisibleSet();
            // Add parallax layer items to the visible set (we're rendering them all for now)
            this.parallaxLayers.forEach(key => {
                let pLayer = this.parallaxLayers.get(key);
                for (let node of pLayer.getItems()) {
                    if (node instanceof CanvasNode_1.default) {
                        visibleSet.push(node);
                    }
                }
            });
            // Send the visible set, tilemaps, and uiLayers to the renderer
            this.renderingManager.render(visibleSet, this.tilemaps, this.uiLayers);
            let nodes = this.sceneGraph.getAllNodes();
            this.tilemaps.forEach(tilemap => tilemap.visible ? nodes.push(tilemap) : 0);
            Debug_1.default.setNodes(nodes);
        }
        /**
         * Sets the scene as running or not
         * @param running True if the Scene should be running, false if not
         */
        setRunning(running) {
            this.running = running;
        }
        /**
         * Returns whether or not the Scene is running
         * @returns True if the scene is running, false otherwise
         */
        isRunning() {
            return this.running;
        }
        /**
         * Removes a node from this Scene
         * @param node The node to remove
         */
        remove(node) {
            // Remove from the scene graph
            if (node instanceof CanvasNode_1.default) {
                this.sceneGraph.removeNode(node);
            }
        }
        /** Destroys this scene and all nodes in it */
        destroy() {
            for (let node of this.sceneGraph.getAllNodes()) {
                node.destroy();
            }
            for (let tilemap of this.tilemaps) {
                tilemap.destroy();
            }
            this.receiver.destroy();
            delete this.sceneGraph;
            delete this.physicsManager;
            delete this.navManager;
            delete this.aiManager;
            delete this.receiver;
        }
        /**
         * Adds a new layer to the scene and returns it
         * @param name The name of the new layer
         * @param depth The depth of the layer
         * @returns The newly created Layer
         */
        addLayer(name, depth) {
            if (this.layers.has(name) || this.parallaxLayers.has(name) || this.uiLayers.has(name)) {
                throw `Layer with name ${name} already exists`;
            }
            let layer = new Layer_1.default(this, name);
            this.layers.add(name, layer);
            if (depth) {
                layer.setDepth(depth);
            }
            return layer;
        }
        /**
         * Adds a new parallax layer to this scene and returns it
         * @param name The name of the parallax layer
         * @param parallax The parallax level
         * @param depth The depth of the layer
         * @returns The newly created ParallaxLayer
         */
        addParallaxLayer(name, parallax, depth) {
            if (this.layers.has(name) || this.parallaxLayers.has(name) || this.uiLayers.has(name)) {
                throw `Layer with name ${name} already exists`;
            }
            let layer = new ParallaxLayer_1.default(this, name, parallax);
            this.parallaxLayers.add(name, layer);
            if (depth) {
                layer.setDepth(depth);
            }
            return layer;
        }
        /**
         * Adds a new UILayer to the scene
         * @param name The name of the new UIlayer
         * @returns The newly created UILayer
         */
        addUILayer(name) {
            if (this.layers.has(name) || this.parallaxLayers.has(name) || this.uiLayers.has(name)) {
                throw `Layer with name ${name} already exists`;
            }
            let layer = new UILayer_1.default(this, name);
            this.uiLayers.add(name, layer);
            return layer;
        }
        /**
         * Gets a layer from the scene by name if it exists.
         * This can be a Layer or any of its subclasses
         * @param name The name of the layer
         * @returns The Layer found with that name
         */
        getLayer(name) {
            if (this.layers.has(name)) {
                return this.layers.get(name);
            }
            else if (this.parallaxLayers.has(name)) {
                return this.parallaxLayers.get(name);
            }
            else if (this.uiLayers.has(name)) {
                return this.uiLayers.get(name);
            }
            else {
                throw `Requested layer ${name} does not exist.`;
            }
        }
        /**
         * Returns true if this layer is a ParallaxLayer
         * @param name The name of the layer
         * @returns True if this layer is a ParallaxLayer
         */
        isParallaxLayer(name) {
            return this.parallaxLayers.has(name);
        }
        /**
         * Returns true if this layer is a UILayer
         * @param name The name of the layer
         * @returns True if this layer is ParallaxLayer
         */
        isUILayer(name) {
            return this.uiLayers.has(name);
        }
        /**
         * Returns the translation of this node with respect to camera space (due to the viewport moving).
         * This value is affected by the parallax level of the @reference[Layer] the node is on.
         * @param node The node to check the viewport with respect to
         * @returns A Vec2 containing the translation of viewport with respect to this node.
         */
        getViewTranslation(node) {
            let layer = node.getLayer();
            if (layer instanceof ParallaxLayer_1.default || layer instanceof UILayer_1.default) {
                return this.viewport.getOrigin().mult(layer.parallax);
            }
            else {
                return this.viewport.getOrigin();
            }
        }
        /**
         * Returns the scale level of the view
         * @returns The zoom level of the viewport
        */
        getViewScale() {
            return this.viewport.getZoomLevel();
        }
        /**
         * Returns the Viewport associated with this scene
         * @returns The current Viewport
         */
        getViewport() {
            return this.viewport;
        }
        /**
         * Gets the world size of this Scene
         * @returns The world size in a Vec2
         */
        getWorldSize() {
            return this.worldSize;
        }
        /**
         * Gets the SceneGraph associated with this Scene
         * @returns The SceneGraph
         */
        getSceneGraph() {
            return this.sceneGraph;
        }
        /**
         * Gets the PhysicsManager associated with this Scene
         * @returns The PhysicsManager
         */
        getPhysicsManager() {
            return this.physicsManager;
        }
        /**
         * Gets the NavigationManager associated with this Scene
         * @returns The NavigationManager
         */
        getNavigationManager() {
            return this.navManager;
        }
        /**
         * Gets the AIManager associated with this Scene
         * @returns The AIManager
         */
        getAIManager() {
            return this.aiManager;
        }
        /**
         * Generates an ID for a GameNode
         * @returns The new ID
         */
        generateId() {
            return this.sceneManager.generateId();
        }
        /**
         * Retrieves a Tilemap in this Scene
         * @param name The name of the Tilemap
         * @returns The Tilemap, if one this name exists, otherwise null
         */
        getTilemap(name) {
            for (let tilemap of this.tilemaps) {
                if (tilemap.name === name) {
                    return tilemap;
                }
            }
            return null;
        }
    }
    exports.default = Scene;
    },{"../AI/AIManager":1,"../DataTypes/Map":19,"../DataTypes/Vec2":32,"../Debug/Debug":33,"../Events/Emitter":35,"../Events/Receiver":39,"../Nodes/CanvasNode":47,"../Pathfinding/NavigationManager":65,"../Physics/BasicPhysicsManager":68,"../Rendering/Animations/ParticleSystemManager":78,"../Rendering/Animations/TweenManager":80,"../ResourceManager/ResourceManager":93,"../SceneGraph/SceneGraphArray":95,"../Timing/TimerManager":108,"./Factories/FactoryManager":98,"./Layer":100,"./Layers/ParallaxLayer":101,"./Layers/UILayer":102,"./SceneOptions":105}],104:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const ResourceManager_1 = require("../ResourceManager/ResourceManager");
    /**
     * The SceneManager acts as an interface to create Scenes, and handles the lifecycle methods of Scenes.
     * It gives Scenes access to information they need from the @reference[Game] class while keeping a layer of separation.
     */
    class SceneManager {
        /**
         * Creates a new SceneManager
         * @param viewport The Viewport of the game
         * @param game The Game instance
         * @param renderingManager The RenderingManager of the game
         */
        constructor(viewport, renderingManager) {
            this.resourceManager = ResourceManager_1.default.getInstance();
            this.viewport = viewport;
            this.renderingManager = renderingManager;
            this.idCounter = 0;
            this.pendingScene = null;
        }
        /**
         * Add a scene as the main scene.
         * Use this method if you've created a subclass of Scene, and you want to add it as the main Scene.
         * @param constr The constructor of the scene to add
         * @param init An object to pass to the init function of the new scene
         */
        changeToScene(constr, init, options) {
            console.log("Creating the new scene - change is pending until next update");
            this.pendingScene = new constr(this.viewport, this, this.renderingManager, options);
            this.pendingSceneInit = init;
        }
        doSceneChange() {
            console.log("Performing scene change");
            this.viewport.setCenter(this.viewport.getHalfSize().x, this.viewport.getHalfSize().y);
            if (this.currentScene) {
                console.log("Unloading old scene");
                this.currentScene.unloadScene();
                console.log("Destroying old scene");
                this.currentScene.destroy();
            }
            console.log("Unloading old resources...");
            this.resourceManager.unloadAllResources();
            // Make the pending scene the current one
            this.currentScene = this.pendingScene;
            // Make the pending scene null
            this.pendingScene = null;
            // Init the scene
            this.currentScene.initScene(this.pendingSceneInit);
            // Enqueue all scene asset loads
            this.currentScene.loadScene();
            // Load all assets
            console.log("Starting Scene Load");
            this.resourceManager.loadResourcesFromQueue(() => {
                console.log("Starting Scene");
                this.currentScene.startScene();
                this.currentScene.setRunning(true);
            });
            this.renderingManager.setScene(this.currentScene);
        }
        /**
         * Generates a unique ID
         * @returns A new ID
         */
        generateId() {
            return this.idCounter++;
        }
        /**
         * Renders the current Scene
         */
        render() {
            if (this.currentScene) {
                this.currentScene.render();
            }
        }
        /**
         * Updates the current Scene
         * @param deltaT The timestep of the Scene
         */
        update(deltaT) {
            if (this.pendingScene !== null) {
                this.doSceneChange();
            }
            if (this.currentScene && this.currentScene.isRunning()) {
                this.currentScene.update(deltaT);
            }
        }
    }
    exports.default = SceneManager;
    },{"../ResourceManager/ResourceManager":93}],105:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // @ignorePage
    /**
     * The options to give a @reference[Scene] for initialization
     */
    class SceneOptions {
        static parse(options) {
            let sOpt = new SceneOptions();
            if (options.physics === undefined) {
                sOpt.physics = { groups: undefined, collisions: undefined };
            }
            else {
                sOpt.physics = options.physics;
            }
            return sOpt;
        }
    }
    exports.default = SceneOptions;
    },{}],106:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MAX_AUDIO_CHANNELS = exports.AudioChannelType = void 0;
    const Map_1 = require("../DataTypes/Map");
    const Receiver_1 = require("../Events/Receiver");
    const ResourceManager_1 = require("../ResourceManager/ResourceManager");
    const GameEventType_1 = require("../Events/GameEventType");
    /**
     * Manages any sounds or music needed for the game.
     * Through the EventQueue, exposes interface to play sounds so GameNodes can activate sounds without
     * needing direct references to the audio system
     */
    class AudioManager {
        constructor() {
            this.initAudio();
            this.receiver = new Receiver_1.default();
            this.receiver.subscribe([
                GameEventType_1.GameEventType.PLAY_SOUND,
                GameEventType_1.GameEventType.STOP_SOUND,
                GameEventType_1.GameEventType.PLAY_MUSIC,
                GameEventType_1.GameEventType.PLAY_SFX,
                GameEventType_1.GameEventType.MUTE_CHANNEL,
                GameEventType_1.GameEventType.UNMUTE_CHANNEL
            ]);
            this.currentSounds = new Map_1.default();
            this.gainNodes = new Array(exports.MAX_AUDIO_CHANNELS);
            this.initGainNodes();
        }
        /**
         * Get the instance of the AudioManager class or create a new one if none exists
         * @returns The AudioManager
         */
        static getInstance() {
            if (!this.instance) {
                this.instance = new AudioManager();
            }
            return this.instance;
        }
        /**
         * Initializes the webAudio context
         */
        initAudio() {
            try {
                window.AudioContext = window.AudioContext; // || window.webkitAudioContext; 
                this.audioCtx = new AudioContext();
                console.log('Web Audio API successfully loaded');
            }
            catch (e) {
                console.warn('Web Audio API is not supported in this browser');
            }
        }
        initGainNodes() {
            for (let i = 0; i < exports.MAX_AUDIO_CHANNELS; i++) {
                this.gainNodes[i] = this.audioCtx.createGain();
            }
        }
        /**
         * Returns the current audio context
         * @returns The AudioContext
         */
        getAudioContext() {
            return this.audioCtx;
        }
        /*
            According to the MDN, create a new sound for every call:
    
            An AudioBufferSourceNode can only be played once; after each call to start(), you have to create a new node
            if you want to play the same sound again. Fortunately, these nodes are very inexpensive to create, and the
            actual AudioBuffers can be reused for multiple plays of the sound. Indeed, you can use these nodes in a
            "fire and forget" manner: create the node, call start() to begin playing the sound, and don't even bother to
            hold a reference to it. It will automatically be garbage-collected at an appropriate time, which won't be
            until sometime after the sound has finished playing.
        */
        /**
         * Creates a new sound from the key of a loaded audio file
         * @param key The key of the loaded audio file to create a new sound for
         * @returns The newly created AudioBuffer
         */
        createSound(key, holdReference, channel, options) {
            // Get audio buffer
            let buffer = ResourceManager_1.default.getInstance().getAudio(key);
            // Create a sound source
            var source = this.audioCtx.createBufferSource();
            // Tell the source which sound to play
            source.buffer = buffer;
            // Add any additional nodes
            const nodes = [source];
            // Do any additional nodes here?
            // Of course, there aren't any supported yet...
            // Add the gain node for this channel
            nodes.push(this.gainNodes[channel]);
            // Connect any nodes along the path
            for (let i = 1; i < nodes.length; i++) {
                nodes[i - 1].connect(nodes[i]);
            }
            // Connect the source to the context's destination
            nodes[nodes.length - 1].connect(this.audioCtx.destination);
            return source;
        }
        /**
         * Play the sound specified by the key
         * @param key The key of the sound to play
         * @param loop A boolean for whether or not to loop the sound
         * @param holdReference A boolean for whether or not we want to hold on to a reference of the audio node. This is good for playing music on a loop that will eventually need to be stopped.
         */
        playSound(key, loop, holdReference, channel, options) {
            let sound = this.createSound(key, holdReference, channel, options);
            if (loop) {
                sound.loop = true;
            }
            // Add a reference of the new sound to a map. This will allow us to stop a looping or long sound at a later time
            if (holdReference) {
                this.currentSounds.add(key, sound);
            }
            sound.start();
        }
        /**
         * Stop the sound specified by the key
         */
        stopSound(key) {
            let sound = this.currentSounds.get(key);
            if (sound) {
                sound.stop();
                this.currentSounds.delete(key);
            }
        }
        muteChannel(channel) {
            this.gainNodes[channel].gain.setValueAtTime(0, this.audioCtx.currentTime);
        }
        unmuteChannel(channel) {
            this.gainNodes[channel].gain.setValueAtTime(1, this.audioCtx.currentTime);
        }
        /**
         * Sets the volume of a channel using the GainNode for that channel. For more
         * information on GainNodes, see https://developer.mozilla.org/en-US/docs/Web/API/GainNode
         * @param channel The audio channel to set the volume for
         * @param volume The volume of the channel. 0 is muted. Values below zero will be set to zero.
         */
        static setVolume(channel, volume) {
            if (volume < 0) {
                volume = 0;
            }
            const am = AudioManager.getInstance();
            am.gainNodes[channel].gain.setValueAtTime(volume, am.audioCtx.currentTime);
        }
        /**
         * Returns the GainNode for this channel.
         * Learn more about GainNodes here https://developer.mozilla.org/en-US/docs/Web/API/GainNode
         * DON'T USE THIS UNLESS YOU KNOW WHAT YOU'RE DOING
         * @param channel The channel
         * @returns The GainNode for the specified channel
         */
        getChannelGainNode(channel) {
            return this.gainNodes[channel];
        }
        update(deltaT) {
            // Play each audio clip requested
            // TODO - Add logic to merge sounds if there are multiple of the same key
            while (this.receiver.hasNextEvent()) {
                let event = this.receiver.getNextEvent();
                if (event.type === GameEventType_1.GameEventType.PLAY_SOUND || event.type === GameEventType_1.GameEventType.PLAY_MUSIC || event.type === GameEventType_1.GameEventType.PLAY_SFX) {
                    let soundKey = event.data.get("key");
                    let loop = event.data.get("loop");
                    let holdReference = event.data.get("holdReference");
                    let channel = AudioChannelType.DEFAULT;
                    if (event.type === GameEventType_1.GameEventType.PLAY_MUSIC) {
                        channel = AudioChannelType.MUSIC;
                    }
                    else if (GameEventType_1.GameEventType.PLAY_SFX) {
                        channel = AudioChannelType.SFX;
                    }
                    else if (event.data.has("channel")) {
                        channel = event.data.get("channel");
                    }
                    this.playSound(soundKey, loop, holdReference, channel, event.data);
                }
                if (event.type === GameEventType_1.GameEventType.STOP_SOUND) {
                    let soundKey = event.data.get("key");
                    this.stopSound(soundKey);
                }
                if (event.type === GameEventType_1.GameEventType.MUTE_CHANNEL) {
                    this.muteChannel(event.data.get("channel"));
                }
                if (event.type === GameEventType_1.GameEventType.UNMUTE_CHANNEL) {
                    this.unmuteChannel(event.data.get("channel"));
                }
            }
        }
    }
    exports.default = AudioManager;
    var AudioChannelType;
    (function (AudioChannelType) {
        AudioChannelType[AudioChannelType["DEFAULT"] = 0] = "DEFAULT";
        AudioChannelType[AudioChannelType["SFX"] = 1] = "SFX";
        AudioChannelType[AudioChannelType["MUSIC"] = 2] = "MUSIC";
        AudioChannelType[AudioChannelType["CUSTOM_1"] = 3] = "CUSTOM_1";
        AudioChannelType[AudioChannelType["CUSTOM_2"] = 4] = "CUSTOM_2";
        AudioChannelType[AudioChannelType["CUSTOM_3"] = 5] = "CUSTOM_3";
        AudioChannelType[AudioChannelType["CUSTOM_4"] = 6] = "CUSTOM_4";
        AudioChannelType[AudioChannelType["CUSTOM_5"] = 7] = "CUSTOM_5";
        AudioChannelType[AudioChannelType["CUSTOM_6"] = 8] = "CUSTOM_6";
        AudioChannelType[AudioChannelType["CUSTOM_7"] = 9] = "CUSTOM_7";
        AudioChannelType[AudioChannelType["CUSTOM_8"] = 10] = "CUSTOM_8";
        AudioChannelType[AudioChannelType["CUSTOM_9"] = 11] = "CUSTOM_9";
    })(AudioChannelType = exports.AudioChannelType || (exports.AudioChannelType = {}));
    exports.MAX_AUDIO_CHANNELS = 12;
    },{"../DataTypes/Map":19,"../Events/GameEventType":38,"../Events/Receiver":39,"../ResourceManager/ResourceManager":93}],107:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TimerState = void 0;
    const MathUtils_1 = require("../Utils/MathUtils");
    const TimerManager_1 = require("./TimerManager");
    /** */
    class Timer {
        constructor(time, onEnd, loop = false) {
            // Register this timer
            TimerManager_1.default.getInstance().addTimer(this);
            this.totalTime = time;
            this.timeLeft = 0;
            this.onEnd = onEnd;
            this.loop = loop;
            this.state = TimerState.STOPPED;
            this.numRuns = 0;
        }
        isStopped() {
            return this.state === TimerState.STOPPED;
        }
        isPaused() {
            return this.state === TimerState.PAUSED;
        }
        /**
         * Returns whether or not this timer has been run before
         * @returns true if it has been run at least once (after the latest reset), and false otherwise
         */
        hasRun() {
            return this.numRuns > 0;
        }
        start(time) {
            if (time !== undefined) {
                this.totalTime = time;
            }
            this.state = TimerState.ACTIVE;
            this.timeLeft = this.totalTime;
        }
        /** Resets this timer. Sets the progress back to zero, and sets the number of runs back to zero */
        reset() {
            this.timeLeft = this.totalTime;
            this.numRuns = 0;
        }
        pause() {
            this.state = TimerState.PAUSED;
        }
        update(deltaT) {
            if (this.state === TimerState.ACTIVE) {
                this.timeLeft -= deltaT * 1000;
                if (this.timeLeft <= 0) {
                    this.timeLeft = MathUtils_1.default.clampLow0(this.timeLeft);
                    this.end();
                }
            }
        }
        end() {
            // Update the state
            this.state = TimerState.STOPPED;
            this.numRuns += 1;
            // Call the end function if there is one
            if (this.onEnd) {
                this.onEnd();
            }
            // Loop if we want to
            if (this.loop) {
                this.state = TimerState.ACTIVE;
                this.timeLeft = this.totalTime;
            }
        }
        toString() {
            return "Timer: " + this.state + " - Time Left: " + this.timeLeft + "ms of " + this.totalTime + "ms";
        }
    }
    exports.default = Timer;
    var TimerState;
    (function (TimerState) {
        TimerState["ACTIVE"] = "ACTIVE";
        TimerState["PAUSED"] = "PAUSED";
        TimerState["STOPPED"] = "STOPPED";
    })(TimerState = exports.TimerState || (exports.TimerState = {}));
    },{"../Utils/MathUtils":112,"./TimerManager":108}],108:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class TimerManager {
        constructor() {
            this.timers = new Array();
        }
        static getInstance() {
            if (!this.instance) {
                this.instance = new TimerManager();
            }
            return this.instance;
        }
        addTimer(timer) {
            this.timers.push(timer);
        }
        clearTimers() {
            this.timers = new Array();
        }
        update(deltaT) {
            this.timers.forEach(timer => timer.update(deltaT));
        }
    }
    exports.default = TimerManager;
    },{}],109:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const MathUtils_1 = require("./MathUtils");
    // TODO: This should be moved to the datatypes folder
    /**
     * A Color util class that keeps track of colors like a vector, but can be converted into a string format
     */
    class Color {
        /**
         * Creates a new color
         * @param r Red
         * @param g Green
         * @param b Blue
         * @param a Alpha
         */
        constructor(r = 0, g = 0, b = 0, a = 1) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
        }
        /**
         * Transparent color
         * @returns rgba(0, 0, 0, 0)
         */
        static get TRANSPARENT() {
            return new Color(0, 0, 0, 0);
        }
        /**
         * Red color
         * @returns rgb(255, 0, 0)
         */
        static get RED() {
            return new Color(255, 0, 0, 1);
        }
        /**
         * Green color
         * @returns rgb(0, 255, 0)
         */
        static get GREEN() {
            return new Color(0, 255, 0, 1);
        }
        /**
         * Blue color
         * @returns rgb(0, 0, 255)
         */
        static get BLUE() {
            return new Color(0, 0, 255, 1);
        }
        /**
         * Yellow color
         * @returns rgb(255, 255, 0)
         */
        static get YELLOW() {
            return new Color(255, 255, 0, 1);
        }
        /**
         * Magenta color
         * @returns rgb(255, 0, 255)
         */
        static get MAGENTA() {
            return new Color(255, 0, 255, 1);
        }
        /**
         * Cyan color
         * @returns rgb(0, 255, 255)
         */
        static get CYAN() {
            return new Color(0, 255, 255, 1);
        }
        /**
         * White color
         * @returns rgb(255, 255, 255)
         */
        static get WHITE() {
            return new Color(255, 255, 255, 1);
        }
        /**
         * Black color
         * @returns rgb(0, 0, 0)
         */
        static get BLACK() {
            return new Color(0, 0, 0, 1);
        }
        /**
         * Orange color
         * @returns rgb(255, 100, 0)
         */
        static get ORANGE() {
            return new Color(255, 100, 0, 1);
        }
        /**
         * Sets the color to the values provided
         * @param r Red
         * @param g Green
         * @param b Blue
         * @param a Alpha
         */
        set(r, g, b, a = 1) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
        }
        /**
         * Returns a new color slightly lighter than the current color
         * @returns A new lighter Color
         */
        lighten() {
            return new Color(MathUtils_1.default.clamp(this.r + 40, 0, 255), MathUtils_1.default.clamp(this.g + 40, 0, 255), MathUtils_1.default.clamp(this.b + 40, 0, 255), MathUtils_1.default.clamp(this.a + 10, 0, 255));
        }
        /**
         * Returns a new color slightly darker than the current color
         * @returns A new darker Color
         */
        darken() {
            return new Color(MathUtils_1.default.clamp(this.r - 40, 0, 255), MathUtils_1.default.clamp(this.g - 40, 0, 255), MathUtils_1.default.clamp(this.b - 40, 0, 255), MathUtils_1.default.clamp(this.a + 10, 0, 255));
        }
        /**
         * Returns this color as an array
         * @returns [r, g, b, a]
         */
        toArray() {
            return [this.r, this.g, this.b, this.a];
        }
        /**
         * Returns the color as a string of the form #RRGGBB
         * @returns #RRGGBB
         */
        toString() {
            return "#" + MathUtils_1.default.toHex(this.r, 2) + MathUtils_1.default.toHex(this.g, 2) + MathUtils_1.default.toHex(this.b, 2);
        }
        /**
         * Returns the color as a string of the form rgb(r, g, b)
         * @returns rgb(r, g, b)
         */
        toStringRGB() {
            return "rgb(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ")";
        }
        /**
         * Returns the color as a string of the form rgba(r, g, b, a)
         * @returns rgba(r, g, b, a)
         */
        toStringRGBA() {
            if (this.a === 0) {
                return this.toStringRGB();
            }
            return "rgba(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ", " + this.a.toString() + ")";
        }
        /**
         * Turns this color into a float32Array and changes color range to [0.0, 1.0]
         * @returns a Float32Array containing the color
         */
        toWebGL() {
            return new Float32Array([
                this.r / 255,
                this.g / 255,
                this.b / 255,
                this.a
            ]);
        }
        static fromStringHex(str) {
            let i = 0;
            if (str.charAt(0) == "#")
                i += 1;
            let r = MathUtils_1.default.fromHex(str.substring(i, i + 2));
            let g = MathUtils_1.default.fromHex(str.substring(i + 2, i + 4));
            let b = MathUtils_1.default.fromHex(str.substring(i + 4, i + 6));
            return new Color(r, g, b);
        }
    }
    exports.default = Color;
    },{"./MathUtils":112}],110:[function(require,module,exports){
    "use strict";
    // @ignorePage
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EaseFunctionType = void 0;
    class EaseFunctions {
        static easeInOutSine(x) {
            return -(Math.cos(Math.PI * x) - 1) / 2;
        }
        static easeOutInSine(x) {
            return x < 0.5 ? -Math.cos(Math.PI * (x + 0.5)) / 2 : -Math.cos(Math.PI * (x - 0.5)) / 2 + 1;
        }
        static easeOutSine(x) {
            return Math.sin((x * Math.PI) / 2);
        }
        static easeInSine(x) {
            return 1 - Math.cos((x * Math.PI) / 2);
        }
        static easeInOutQuint(x) {
            return x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2;
        }
        static easeInOutQuad(x) {
            return x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2;
        }
        static easeOutInQuad(x) {
            return x < 0.5 ? this.easeOutIn_OutPow(x, 2) : this.easeOutIn_InPow(x, 2);
        }
        static easeOutIn_OutPow(x, pow) {
            return 0.5 - Math.pow(-2 * x + 1, pow) / 2;
        }
        static easeOutIn_InPow(x, pow) {
            return 0.5 + Math.pow(2 * x - 1, pow) / 2;
        }
    }
    exports.default = EaseFunctions;
    var EaseFunctionType;
    (function (EaseFunctionType) {
        // SINE
        EaseFunctionType["IN_OUT_SINE"] = "easeInOutSine";
        EaseFunctionType["OUT_IN_SINE"] = "easeOutInSine";
        EaseFunctionType["IN_SINE"] = "easeInSine";
        EaseFunctionType["OUT_SINE"] = "easeOutSine";
        // QUAD
        EaseFunctionType["IN_OUT_QUAD"] = "easeInOutQuad";
        EaseFunctionType["OUT_IN_QUAD"] = "easeOutInQuad";
        // QUINT
        EaseFunctionType["IN_OUT_QUINT"] = "easeInOutQuint";
    })(EaseFunctionType = exports.EaseFunctionType || (exports.EaseFunctionType = {}));
    },{}],111:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /** A class to provides some utility functions for graphs */
    class GraphUtils {
        /**
         * An implementation of Djikstra's shortest path algorithm based on the one described in The Algorithm Design Manual.
         * @param g The graph
         * @param start The number to start the shortest path from
         * @returns An array containing the parent of each node of the Graph in the shortest path.
         */
        static djikstra(g, start) {
            let i; // Counter
            let p; // Pointer to edgenode
            let inTree = new Array(g.numVertices);
            let distance = new Array(g.numVertices);
            let parent = new Array(g.numVertices);
            let v; // Current vertex to process
            let w; // Candidate for next vertex
            let weight; // Edge weight
            let dist; // Best current distance from start
            for (i = 0; i < g.numVertices; i++) {
                inTree[i] = false;
                distance[i] = Infinity;
                parent[i] = -1;
            }
            distance[start] = 0;
            v = start;
            while (!inTree[v]) {
                inTree[v] = true;
                p = g.edges[v];
                while (p !== null) {
                    w = p.y;
                    weight = p.weight;
                    if (distance[w] > distance[v] + weight) {
                        distance[w] = distance[v] + weight;
                        parent[w] = v;
                    }
                    p = p.next;
                }
                v = 0;
                dist = Infinity;
                for (i = 0; i <= g.numVertices; i++) {
                    if (!inTree[i] && dist > distance[i]) {
                        dist = distance;
                        v = i;
                    }
                }
            }
            return parent;
        }
    }
    exports.default = GraphUtils;
    },{}],112:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /** A class containing some utility functions for math operations */
    class MathUtils {
        /**
         * Returns the sign of the value provided
         * @param x The value to extract the sign from
         * @returns -1 if the number is less than 0, 1 otherwise
         */
        static sign(x) {
            return x < 0 ? -1 : 1;
        }
        /**
         * Returns whether or not x is between a and b
         * @param a The min bound
         * @param b The max bound
         * @param x The value to check
         * @param exclusive Whether or not a and b are exclusive bounds
         * @returns True if x is between a and b, false otherwise
         */
        static between(a, b, x, exclusive) {
            if (exclusive) {
                return (a < x) && (x < b);
            }
            else {
                return (a <= x) && (x <= b);
            }
        }
        /**
         * Clamps the value x to the range [min, max], rounding up or down if needed
         * @param x The value to be clamped
         * @param min The min of the range
         * @param max The max of the range
         * @returns x, if it is between min and max, or min/max if it exceeds their bounds
         */
        static clamp(x, min, max) {
            if (x < min)
                return min;
            if (x > max)
                return max;
            return x;
        }
        /**
         * Clamps the value x to the range between 0 and 1
         * @param x The value to be clamped
         * @returns x, if it is between 0 and 1, or 0/1 if it exceeds their bounds
         */
        static clamp01(x) {
            return MathUtils.clamp(x, 0, 1);
        }
        /**
         * Clamps the lower end of the value of x to the range to min
         * @param x The value to be clamped
         * @param min The minimum allowed value of x
         * @returns x, if it is greater than min, otherwise min
         */
        static clampLow(x, min) {
            return x < min ? min : x;
        }
        /**
         * Clamps the lower end of the value of x to zero
         * @param x The value to be clamped
         * @returns x, if it is greater than 0, otherwise 0
         */
        static clampLow0(x) {
            return MathUtils.clampLow(x, 0);
        }
        static clampMagnitude(v, m) {
            if (v.magSq() > m * m) {
                return v.scaleTo(m);
            }
            else {
                return v;
            }
        }
        static changeRange(x, min, max, newMin, newMax) {
            return this.lerp(newMin, newMax, this.invLerp(min, max, x));
        }
        /**
         * Linear Interpolation
         * @param a The first value for the interpolation bound
         * @param b The second value for the interpolation bound
         * @param t The time we are interpolating to
         * @returns The value between a and b at time t
         */
        static lerp(a, b, t) {
            return a + t * (b - a);
        }
        /**
         * Inverse Linear Interpolation. Finds the time at which a value between a and b would occur
         * @param a The first value for the interpolation bound
         * @param b The second value for the interpolation bound
         * @param value The current value
         * @returns The time at which the current value occurs between a and b
         */
        static invLerp(a, b, value) {
            return (value - a) / (b - a);
        }
        /**
         * Cuts off decimal points of a number after a specified place
         * @param num The number to floor
         * @param place The last decimal place of the new number
         * @returns The floored number
         */
        static floorToPlace(num, place) {
            if (place === 0) {
                return Math.floor(num);
            }
            let factor = 10;
            while (place > 1) {
                factor != 10;
                place--;
            }
            return Math.floor(num * factor) / factor;
        }
        /**
         * Returns a number from a hex string
         * @param str the string containing the hex number
         * @returns the number in decimal represented by the hex string
         */
        static fromHex(str) {
            return parseInt(str, 16);
        }
        /**
         * Returns the number as a hexadecimal
         * @param num The number to convert to hex
         * @param minLength The length of the returned hex string (adds zero padding if needed)
         * @returns The hex representation of the number as a string
         */
        static toHex(num, minLength = null) {
            let factor = 1;
            while (factor * 16 < num) {
                factor *= 16;
            }
            let hexStr = "";
            while (factor >= 1) {
                let digit = Math.floor(num / factor);
                hexStr += MathUtils.toHexDigit(digit);
                num -= digit * factor;
                factor /= 16;
            }
            if (minLength !== null) {
                while (hexStr.length < minLength) {
                    hexStr = "0" + hexStr;
                }
            }
            return hexStr;
        }
        /**
         * Converts a digit to hexadecimal. In this case, a digit is between 0 and 15 inclusive
         * @param num The digit to convert to hexadecimal
         * @returns The hex representation of the digit as a string
         */
        static toHexDigit(num) {
            if (num < 10) {
                return "" + num;
            }
            else {
                return String.fromCharCode(65 + num - 10);
            }
        }
    }
    exports.default = MathUtils;
    },{}],113:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const MathUtils_1 = require("./MathUtils");
    class RenderingUtils {
        static toWebGLCoords(point, origin, worldSize) {
            return new Float32Array([
                MathUtils_1.default.changeRange(point.x, origin.x, origin.x + worldSize.x, -1, 1),
                MathUtils_1.default.changeRange(point.y, origin.y, origin.y + worldSize.y, 1, -1)
            ]);
        }
        static toWebGLScale(size, worldSize) {
            return new Float32Array([
                2 * size.x / worldSize.x,
                2 * size.y / worldSize.y,
            ]);
        }
        static toWebGLColor(color) {
            return new Float32Array([
                MathUtils_1.default.changeRange(color.r, 0, 255, 0, 1),
                MathUtils_1.default.changeRange(color.g, 0, 255, 0, 1),
                MathUtils_1.default.changeRange(color.b, 0, 255, 0, 1),
                color.a
            ]);
        }
    }
    exports.default = RenderingUtils;
    },{"./MathUtils":112}],114:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /** Some utility functions for dealing with strings */
    class StringUtils {
        /**
         * Extracts the path from a filepath that includes the file
         * @param filePath the filepath to extract the path from
         * @returns The path portion of the filepath provided
         */
        static getPathFromFilePath(filePath) {
            let splitPath = filePath.split("/");
            splitPath.pop();
            splitPath.push("");
            return splitPath.join("/");
        }
    }
    exports.default = StringUtils;
    },{}],115:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hw4_Statuses = exports.hw4_Events = exports.hw4_Names = void 0;
    var hw4_Names;
    (function (hw4_Names) {
        hw4_Names["NAVMESH"] = "navmesh";
    })(hw4_Names = exports.hw4_Names || (exports.hw4_Names = {}));
    var hw4_Events;
    (function (hw4_Events) {
        hw4_Events["SHOT_FIRED"] = "SHOT_FIRED";
        hw4_Events["UNLOAD_ASSET"] = "UNLOAD_ASSET";
        hw4_Events["SWAP_PLAYER"] = "SWAP_PLAYER";
        hw4_Events["REACHED_CHECKPOINT"] = "REACHED_CHECKPOINT";
    })(hw4_Events = exports.hw4_Events || (exports.hw4_Events = {}));
    var hw4_Statuses;
    (function (hw4_Statuses) {
        hw4_Statuses["IN_RANGE"] = "IN_RANGE";
        hw4_Statuses["LOW_HEALTH"] = "LOW_HEALTH";
        hw4_Statuses["CAN_RETREAT"] = "CAN_RETREAT";
        hw4_Statuses["CAN_BERSERK"] = "CAN_BERSERK";
        hw4_Statuses["REACHED_GOAL"] = "GOAL";
    })(hw4_Statuses = exports.hw4_Statuses || (exports.hw4_Statuses = {}));
    },{}],116:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Game_1 = require("./Wolfie2D/Loop/Game");
    const RegistryManager_1 = require("./Wolfie2D/Registry/RegistryManager");
    const WeaponRegistry_1 = require("./Wolfie2D/Registry/WeaponRegistry");
    const WeaponTypeRegistry_1 = require("./Wolfie2D/Registry/WeaponTypeRegistry");
    const MainMenu_1 = require("./mayhemFiles/Scene/MainMenu");
    // The main function is your entrypoint into Wolfie2D. Specify your first scene and any options here.
    (function main() {
        // Run any tests
        runTests();
        // Set up options for our game
        let options = {
            canvasSize: { x: 1200, y: 800 },
            clearColor: { r: 0.1, g: 0.1, b: 0.1 },
            inputs: [
                { name: "forward", keys: ["w"] },
                { name: "backward", keys: ["s"] },
                { name: "left", keys: ["a"] },
                { name: "right", keys: ["d"] },
                { name: "pickup", keys: ["e"] },
                { name: "drop", keys: ["q"] },
                { name: "slot1", keys: ["1"] },
                { name: "slot2", keys: ["2"] },
            ],
            useWebGL: false,
            showDebug: false // Whether to show debug messages. You can change this to true if you want
        };
        // Set up custom registries
        let weaponTemplateRegistry = new WeaponRegistry_1.default();
        RegistryManager_1.default.addCustomRegistry("weaponTemplates", weaponTemplateRegistry);
        let weaponTypeRegistry = new WeaponTypeRegistry_1.default();
        RegistryManager_1.default.addCustomRegistry("weaponTypes", weaponTypeRegistry);
        // Create a game with the options specified
        const game = new Game_1.default(options);
        // Start our game
        game.start(MainMenu_1.default, {});
    })();
    function runTests() {
    }
    ;
    },{"./Wolfie2D/Loop/Game":44,"./Wolfie2D/Registry/RegistryManager":73,"./Wolfie2D/Registry/WeaponRegistry":74,"./Wolfie2D/Registry/WeaponTypeRegistry":75,"./mayhemFiles/Scene/MainMenu":135}],117:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EnemyStates = void 0;
    const GoapActionPlanner_1 = require("../../Wolfie2D/AI/GoapActionPlanner");
    const StateMachineGoapAI_1 = require("../../Wolfie2D/AI/StateMachineGoapAI");
    const AABB_1 = require("../../Wolfie2D/DataTypes/Shapes/AABB");
    const Stack_1 = require("../../Wolfie2D/DataTypes/Stack");
    const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
    const constants_1 = require("../../Wolfie2D/constants");
    const Alert_1 = require("../../Wolfie2D/AI/EnemyStates/Alert");
    const Active_1 = require("../../Wolfie2D/AI/EnemyStates/Active");
    const Guard_1 = require("../../Wolfie2D/AI/EnemyStates/Guard");
    const Patrol_1 = require("../../Wolfie2D/AI/EnemyStates/Patrol");
    class EnemyAI extends StateMachineGoapAI_1.default {
        constructor() {
            super(...arguments);
            /** The default movement speed of this AI */
            this.speed = 20;
        }
        initializeAI(owner, options) {
            this.owner = owner;
            if (options.defaultMode === "guard") {
                // Guard mode
                this.addState(EnemyStates.DEFAULT, new Guard_1.default(this, owner, options.guardPosition));
            }
            else {
                // Patrol mode
                this.addState(EnemyStates.DEFAULT, new Patrol_1.default(this, owner, options.patrolRoute));
            }
            this.addState(EnemyStates.ALERT, new Alert_1.default(this, owner));
            this.addState(EnemyStates.TARGETING, new Active_1.default(this, owner));
            this.maxHealth = options.health;
            this.health = options.health;
            this.weapon = options.weapon;
            this.player1 = options.player1;
            this.inRange = options.inRange;
            this.goal = options.goal;
            this.currentStatus = options.status;
            this.possibleActions = options.actions;
            this.plan = new Stack_1.default();
            this.planner = new GoapActionPlanner_1.default();
            // Initialize to the default state
            this.initialize(EnemyStates.DEFAULT);
            this.getPlayerPosition();
        }
        activate(options) { }
        damage(damage) {
            this.health -= damage;
            // If we're low enough, add Low Health status to enemy
            if (this.health <= Math.floor(this.maxHealth / 2)) {
                if (this.currentStatus.indexOf(constants_1.hw4_Statuses.LOW_HEALTH) === -1) {
                    this.currentStatus.push(constants_1.hw4_Statuses.LOW_HEALTH);
                }
            }
            // If health goes below 0, disable AI and fire enemyDied event
            if (this.health <= 0) {
                this.owner.setAIActive(false, {});
                this.owner.isCollidable = false;
                this.owner.visible = false;
                this.emitter.fireEvent("enemyDied", { enemy: this.owner });
                // if (Math.random() < 0.2) {
                //     // Spawn a healthpack
                //     this.emitter.fireEvent("healthpack", { position: this.owner.position });
                //
                // }
            }
        }
        isPlayerVisible(pos) {
            //Check if one player is visible, taking into account walls
            // Get the new player location
            let start = this.owner.position.clone();
            let delta = pos.clone().sub(start);
            // Iterate through the tilemap region until we find a collision
            let minX = Math.min(start.x, pos.x);
            let maxX = Math.max(start.x, pos.x);
            let minY = Math.min(start.y, pos.y);
            let maxY = Math.max(start.y, pos.y);
            // Get the wall tilemap
            let walls = this.owner.getScene().getLayer("Wall").getItems()[0];
            let minIndex = walls.getColRowAt(new Vec2_1.default(minX, minY));
            let maxIndex = walls.getColRowAt(new Vec2_1.default(maxX, maxY));
            let tileSize = walls.getTileSize();
            for (let col = minIndex.x; col <= maxIndex.x; col++) {
                for (let row = minIndex.y; row <= maxIndex.y; row++) {
                    if (walls.isTileCollidable(col, row)) {
                        // Get the position of this tile
                        let tilePos = new Vec2_1.default(col * tileSize.x + tileSize.x / 2, row * tileSize.y + tileSize.y / 2);
                        // Create a collider for this tile
                        let collider = new AABB_1.default(tilePos, tileSize.scaled(1 / 2));
                        let hit = collider.intersectSegment(start, delta, Vec2_1.default.ZERO);
                        if (hit !== null && start.distanceSqTo(hit.pos) < start.distanceSqTo(pos)) {
                            // We hit a wall, we can't see the player
                            return null;
                        }
                    }
                }
            }
            return pos;
        }
        getPlayerPosition() {
            //Get the position of the closest player in sight
            let pos = this.player1.position;
            let position1 = this.isPlayerVisible(pos);
            // Determine which player position to return
            if (position1 == null) {
                return null;
            }
            return position1;
        }
        update(deltaT) {
            super.update(deltaT);
            // This is the plan that is executed in the Active state, so whenever we don't have a plan, acquire a new one given the current statuses the enemy has
            if (this.plan.isEmpty()) {
                //get a new plan
                this.plan = this.planner.plan(constants_1.hw4_Statuses.REACHED_GOAL, this.possibleActions, this.currentStatus, null);
            }
        }
    }
    exports.default = EnemyAI;
    var EnemyStates;
    (function (EnemyStates) {
        EnemyStates["DEFAULT"] = "default";
        EnemyStates["ALERT"] = "alert";
        EnemyStates["TARGETING"] = "targeting";
        EnemyStates["PREVIOUS"] = "previous";
    })(EnemyStates = exports.EnemyStates || (exports.EnemyStates = {}));
    },{"../../Wolfie2D/AI/EnemyStates/Active":6,"../../Wolfie2D/AI/EnemyStates/Alert":7,"../../Wolfie2D/AI/EnemyStates/Guard":9,"../../Wolfie2D/AI/EnemyStates/Patrol":10,"../../Wolfie2D/AI/GoapActionPlanner":11,"../../Wolfie2D/AI/StateMachineGoapAI":12,"../../Wolfie2D/DataTypes/Shapes/AABB":25,"../../Wolfie2D/DataTypes/Stack":28,"../../Wolfie2D/DataTypes/Vec2":32,"../../Wolfie2D/constants":115}],118:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
    const Input_1 = require("../../Wolfie2D/Input/Input");
    const Timer_1 = require("../../Wolfie2D/Timing/Timer");
    const Healthpack_1 = require("../GameSystems/items/Healthpack");
    const constants_1 = require("../../Wolfie2D/constants");
    const MaxHealth_1 = require("../GameSystems/items/MaxHealth");
    const AttackDamage_1 = require("../GameSystems/items/AttackDamage");
    const AttackSpeed_1 = require("../GameSystems/items/AttackSpeed");
    const Speed_1 = require("../GameSystems/items/Speed");
    const Checkpoint_1 = require("../GameSystems/items/Checkpoint");
    const CheckpointCleared_1 = require("../GameSystems/items/CheckpointCleared");
    const StateMachineGoapAI_1 = require("../../Wolfie2D/AI/StateMachineGoapAI");
    class PlayerController extends StateMachineGoapAI_1.default {
        initializeAI(owner, options) {
            this.owner = owner;
            this.lookDirection = Vec2_1.default.ZERO;
            this.speed = options.speed;
            this.health = options.health;
            this.maxHealth = options.maxHealth;
            this.inputEnabled = options.inputEnabled;
            this.range = options.range;
            this.items = options.items;
            this.inventory = options.inventory;
            //defined by dao
            this.weapon = options.weapon;
            this.shootingTimer = this.weapon.cooldownTimer;
        }
        activate(options) { }
        handleEvent(event) {
            // If our id matches this player, set boolean and update inventory UI
            if (event.type === constants_1.hw4_Events.SWAP_PLAYER) {
                if (event.data.get("id") === this.owner.id) {
                    this.inputEnabled = true;
                    this.inventory.setActive(true);
                }
                else {
                    this.inputEnabled = false;
                    this.inventory.setActive(false);
                }
            }
        }
        //   this is use to shoot
        handleUseItem() {
            let item = this.inventory.getItem();
            // If there is an item in the current slot, use it
            if (item) {
                item.use(this.owner, "player", this.lookDirection);
                if (this.lookDirection.x > 0) {
                    this.owner.animation.play("face_right");
                }
                else {
                    this.owner.animation.play("face_left");
                }
            }
        }
        ///after picking up apply the buff and destroy the item
        handleApplyBuffEffect(item) {
            if (item instanceof Healthpack_1.default) {
                this.owner._ai.maxHealth += 5;
                this.owner._ai.health += 5;
            }
            if (item instanceof AttackDamage_1.default) {
                this.weapon.type.damage += 5;
            }
            if (item instanceof AttackSpeed_1.default) {
                this.weapon.cooldownTimer = new Timer_1.default(this.weapon.cooldownTimer.totalTime * 0.8);
            }
            if (item instanceof Speed_1.default) {
                this.speed += 40;
            }
            if (item instanceof MaxHealth_1.default) {
                this.owner._ai.health += 5;
                if (this.owner._ai.health >
                    this.owner._ai.maxHealth) {
                    this.owner._ai.health = (this.owner._ai).maxHealth;
                }
            }
            if (item instanceof Checkpoint_1.default) {
                this.emitter.fireEvent("checkpoint_cleared", {
                    position: new Vec2_1.default(item.sprite.position.x, item.sprite.position.y),
                });
            }
            else {
                this.emitter.fireEvent("newbuff", { buff: item });
            }
            if (!(item instanceof CheckpointCleared_1.default)) {
                item.moveSprite(new Vec2_1.default(9999, 9999));
            }
        }
        handlePickUpItem() {
            for (let item of this.items) {
                if (this.owner.collisionShape.overlaps(item.sprite.boundary)) {
                    {
                        this.handleApplyBuffEffect(item);
                        break;
                    }
                }
            }
        }
        update(deltaT) {
            while (this.receiver.hasNextEvent()) {
                this.handleEvent(this.receiver.getNextEvent());
            }
            if (this.inputEnabled && this.health > 0) {
                if (Input_1.default.isMousePressed(0)) {
                    if (this.weapon.cooldownTimer.isStopped()) {
                        this.lookDirection = this.owner.position.dirTo(Input_1.default.getGlobalMousePosition());
                        this.handleUseItem();
                        this.weapon.cooldownTimer.start();
                    }
                }
                if (Input_1.default.isMouseJustPressed(2)) {
                    this.owner.position = Input_1.default.getGlobalMousePosition();
                    //this.path = this.owner.getScene().getNavigationManager().getPath(hw4_Names.NAVMESH, this.owner.position, Input.getGlobalMousePosition(), true);
                }
                if (
                // Input.isMouseJustPressed(0)
                Input_1.default.isKeyPressed("a") ||
                    Input_1.default.isKeyPressed("w") ||
                    Input_1.default.isKeyPressed("s") ||
                    Input_1.default.isKeyPressed("d")) {
                    let playerPos = this.owner.position.clone();
                    this.direction = Vec2_1.default.ZERO;
                    this.direction.x =
                        (Input_1.default.isKeyPressed("a") ? -1 : 0) +
                            (Input_1.default.isKeyPressed("d") ? 1 : 0);
                    this.direction.y =
                        (Input_1.default.isKeyPressed("w") ? -1 : 0) +
                            (Input_1.default.isKeyPressed("s") ? 1 : 0);
                    this.direction.x *= this.speed;
                    this.direction.y *= this.speed;
                    this.direction.normalize();
                    if (Input_1.default.isKeyJustPressed("d")) {
                        this.owner.animation.play("run_right", true);
                    }
                    if (Input_1.default.isKeyJustPressed("a")) {
                        this.owner.animation.play("run_left", true);
                    }
                    let newPos = playerPos.clone().add(this.direction.scale(3));
                    this.path = this.owner
                        .getScene()
                        .getNavigationManager()
                        .getPath(constants_1.hw4_Names.NAVMESH, this.owner.position, newPos, true);
                }
                else {
                    this.owner.animation.stop();
                    if (this.direction) {
                        if (this.direction.x > 0) {
                            this.owner.animation.play("face_right");
                        }
                        else {
                            this.owner.animation.play("face_left");
                        }
                    }
                }
                // Check for slot change
                if (Input_1.default.isJustPressed("slot1")) {
                    this.inventory.changeSlot(0);
                }
                else if (Input_1.default.isJustPressed("slot2")) {
                    this.inventory.changeSlot(1);
                }
            }
            //Move on path if selected
            if (this.path != null) {
                if (this.path.isDone()) {
                    this.path = null;
                }
                else {
                    this.owner.moveOnPath(this.speed * deltaT, this.path);
                    // this.owner.rotation = Vec2.UP.angleToCCW(
                    //   this.path.getMoveDirection(this.owner)
                    // );
                }
                this.handlePickUpItem();
            }
            else {
                //Target an enemy and attack
                if (this.target != null) {
                    this.lookDirection = this.owner.position.dirTo(this.target);
                    // this.handleUseItem();
                }
            }
        }
        damage(damage) {
            this.health -= damage;
        }
        destroy() { }
    }
    exports.default = PlayerController;
    },{"../../Wolfie2D/AI/StateMachineGoapAI":12,"../../Wolfie2D/DataTypes/Vec2":32,"../../Wolfie2D/Input/Input":40,"../../Wolfie2D/Timing/Timer":107,"../../Wolfie2D/constants":115,"../GameSystems/items/AttackDamage":121,"../GameSystems/items/AttackSpeed":122,"../GameSystems/items/Checkpoint":123,"../GameSystems/items/CheckpointCleared":124,"../GameSystems/items/Healthpack":125,"../GameSystems/items/MaxHealth":127,"../GameSystems/items/Speed":128}],119:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class BattleManager {
        handleInteraction(attackerType, weapon) {
            if (attackerType === "player") {
                // Check for collisions with enemies
                for (let enemy of this.enemies) {
                    if (weapon.hits(enemy.owner)) {
                        enemy.damage(weapon.type.damage);
                    }
                }
            }
            else {
                // Check for collision with player
                for (let player of this.players) {
                    if (weapon.hits(player.owner)) {
                        player.damage(weapon.type.damage);
                    }
                }
            }
        }
        setPlayers(player) {
            this.players = player;
        }
        setEnemies(enemies) {
            this.enemies = enemies;
        }
    }
    exports.default = BattleManager;
    },{}],120:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
    const GraphicTypes_1 = require("../../Wolfie2D/Nodes/Graphics/GraphicTypes");
    const Color_1 = require("../../Wolfie2D/Utils/Color");
    class InventoryManager {
        constructor(scene, size, inventorySlot, position, padding, slotLayer, itemLayer) {
            this.items = new Array(size);
            this.inventorySlots = new Array(size);
            this.padding = padding;
            this.position = position;
            this.currentSlot = 0;
            // Add layers
            this.slotLayer = slotLayer;
            scene.addUILayer(this.slotLayer).setDepth(100);
            this.itemLayer = itemLayer;
            scene.addUILayer(this.itemLayer).setDepth(101);
            // Create the inventory slots
            for (let i = 0; i < size; i++) {
                this.inventorySlots[i] = scene.add.sprite(inventorySlot, this.slotLayer);
            }
            this.slotSize = this.inventorySlots[0].size.clone();
            // Position the inventory slots
            for (let i = 0; i < size; i++) {
                this.inventorySlots[i].position.set(position.x + i * (this.slotSize.x + this.padding), position.y);
            }
            // Add a rect for the selected slot
            this.selectedSlot = (scene.add.graphic(GraphicTypes_1.GraphicType.RECT, slotLayer, {
                position: this.position.clone(),
                size: this.slotSize.clone().inc(-2),
            }));
            this.selectedSlot.color = Color_1.default.WHITE;
            this.selectedSlot.color.a = 0.2;
        }
        getItem() {
            return this.items[this.currentSlot];
        }
        /**
         * Changes the currently selected slot
         */
        changeSlot(slot) {
            this.currentSlot = slot;
            this.selectedSlot.position.copy(this.inventorySlots[slot].position);
        }
        /**
         * Gets the currently selected slot
         */
        getSlot() {
            return this.currentSlot;
        }
        /**
         * Adds an item to the currently selected slot
         */
        addItem(item) {
            if (!this.items[this.currentSlot]) {
                // Add the item to the inventory
                this.items[this.currentSlot] = item;
                // Update the gui
                item.moveSprite(new Vec2_1.default(this.position.x + this.currentSlot * (this.slotSize.x + this.padding), this.position.y), this.itemLayer);
                return true;
            }
            // Failed to add item, something was already in the slot
            return false;
        }
        /**
         * Removes and returns an item from the the currently selected slot, if possible
         */
        removeItem() {
            let item = this.items[this.currentSlot];
            this.items[this.currentSlot] = null;
            if (item) {
                return item;
            }
            else {
                return null;
            }
        }
        getSize() {
            return this.items.length;
        }
        setActive(active) {
            if (active) {
                this.inventorySlots.forEach((slot) => (slot.alpha = 1.0));
            }
            else {
                this.inventorySlots.forEach((slot) => (slot.alpha = 0.5));
            }
        }
    }
    exports.default = InventoryManager;
    },{"../../Wolfie2D/DataTypes/Vec2":32,"../../Wolfie2D/Nodes/Graphics/GraphicTypes":50,"../../Wolfie2D/Utils/Color":109}],121:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Item_1 = require("./Item");
    class AttackDamage extends Item_1.default {
        use(user, ...args) {
            throw new Error("Method not implemented.");
        }
    }
    exports.default = AttackDamage;
    },{"./Item":126}],122:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Item_1 = require("./Item");
    class AttackSpeed extends Item_1.default {
        use(user, ...args) {
            throw new Error("Method not implemented.");
        }
    }
    exports.default = AttackSpeed;
    },{"./Item":126}],123:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Item_1 = require("./Item");
    class Checkpoint extends Item_1.default {
        use(user, ...args) {
            throw new Error("Method not implemented.");
        }
    }
    exports.default = Checkpoint;
    },{"./Item":126}],124:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Item_1 = require("./Item");
    class CheckpointCleared extends Item_1.default {
        use(user, ...args) {
            throw new Error("Method not implemented.");
        }
    }
    exports.default = CheckpointCleared;
    },{"./Item":126}],125:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Item_1 = require("./Item");
    class Healthpack extends Item_1.default {
    }
    exports.default = Healthpack;
    },{"./Item":126}],126:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Item {
        constructor(sprite) {
            this.sprite = sprite;
        }
        use(owner, arg1, lookDirection) {
            throw new Error("Method not implemented.");
        }
        moveSprite(position, layer) {
            // Change the layer if needed
            if (layer) {
                let currentLayer = this.sprite.getLayer();
                currentLayer.removeNode(this.sprite);
                let newLayer = this.sprite.getScene().getLayer(layer);
                newLayer.addNode(this.sprite);
                this.sprite.setLayer(newLayer);
            }
            // Move the sprite
            this.sprite.position.copy(position);
        }
    }
    exports.default = Item;
    },{}],127:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Item_1 = require("./Item");
    class MaxHealth extends Item_1.default {
    }
    exports.default = MaxHealth;
    },{"./Item":126}],128:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Item_1 = require("./Item");
    class Speed extends Item_1.default {
        use(user, ...args) {
            throw new Error("Method not implemented.");
        }
    }
    exports.default = Speed;
    },{"./Item":126}],129:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Emitter_1 = require("../../../Wolfie2D/Events/Emitter");
    const Timer_1 = require("../../../Wolfie2D/Timing/Timer");
    const Item_1 = require("./Item");
    class Weapon extends Item_1.default {
        constructor(sprite, type, battleManager) {
            super(sprite);
            // Set the weapon type
            this.type = type.clone();
            // Keep a reference to the sprite of this weapon
            this.sprite = sprite;
            // Create an event emitter
            this.emitter = new Emitter_1.default();
            // Save a reference to the battler manager
            this.battleManager = battleManager;
            // Create the cooldown timer
            this.cooldownTimer = new Timer_1.default(type.cooldown);
        }
        // @override
        /**
         * Uses this weapon in the specified direction.
         * This only works if the cooldown timer has ended
         */
        use(user, userType, direction) {
            // If the cooldown timer is still running, we can't use the weapon
            if (!this.cooldownTimer.isStopped()) {
                return false;
            }
            // Rely on the weapon type to create any necessary assets
            this.assets = this.type.createRequiredAssets(this.sprite.getScene());
            // Do a type specific weapon animation
            this.type.doAnimation(user, direction, ...this.assets);
            // Apply damage
            this.battleManager.handleInteraction(userType, this);
            // Reset the cooldown timer
            this.cooldownTimer.start();
            return true;
        }
        /**
         * A check for whether or not this weapon hit a node
         */
        hits(node) {
            return this.type.hits(node, ...this.assets);
        }
    }
    exports.default = Weapon;
    },{"../../../Wolfie2D/Events/Emitter":35,"../../../Wolfie2D/Timing/Timer":107,"./Item":126}],130:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const AABB_1 = require("../../../../Wolfie2D/DataTypes/Shapes/AABB");
    const Vec2_1 = require("../../../../Wolfie2D/DataTypes/Vec2");
    const GameNode_1 = require("../../../../Wolfie2D/Nodes/GameNode");
    const GraphicTypes_1 = require("../../../../Wolfie2D/Nodes/Graphics/GraphicTypes");
    const Color_1 = require("../../../../Wolfie2D/Utils/Color");
    const EaseFunctions_1 = require("../../../../Wolfie2D/Utils/EaseFunctions");
    const constants_1 = require("../../../../Wolfie2D/constants");
    const WeaponType_1 = require("./WeaponType");
    class LaserGun extends WeaponType_1.default {
        initialize(options) {
            this.damage = options.damage;
            this.cooldown = options.cooldown;
            this.hexColor = options.color;
            this.color = Color_1.default.fromStringHex(options.color);
            this.displayName = options.displayName;
            this.spriteKey = options.spriteKey;
            this.useVolume = options.useVolume;
        }
        doAnimation(shooter, direction, line) {
            let start = shooter.position.clone();
            let end = shooter.position.clone().add(direction.scaled(900));
            let delta = end.clone().sub(start);
            // Iterate through the tilemap region until we find a collision
            let minX = Math.min(start.x, end.x);
            let maxX = Math.max(start.x, end.x);
            let minY = Math.min(start.y, end.y);
            let maxY = Math.max(start.y, end.y);
            // Get the wall tilemap
            let walls = shooter.getScene().getLayer("Wall").getItems()[0];
            let minIndex = walls.getColRowAt(new Vec2_1.default(minX, minY));
            let maxIndex = walls.getColRowAt(new Vec2_1.default(maxX, maxY));
            let tileSize = walls.getTileSize();
            for (let col = minIndex.x; col <= maxIndex.x; col++) {
                for (let row = minIndex.y; row <= maxIndex.y; row++) {
                    if (walls.isTileCollidable(col, row)) {
                        // Get the position of this tile
                        let tilePos = new Vec2_1.default(col * tileSize.x + tileSize.x / 2, row * tileSize.y + tileSize.y / 2);
                        // Create a collider for this tile
                        let collider = new AABB_1.default(tilePos, tileSize.scaled(1 / 2));
                        let hit = collider.intersectSegment(start, delta, Vec2_1.default.ZERO);
                        if (hit !== null && start.distanceSqTo(hit.pos) < start.distanceSqTo(end)) {
                            console.log("Found hit");
                            end = hit.pos;
                        }
                    }
                }
            }
            line.start = start;
            line.end = end;
            line.tweens.play("fade");
        }
        createRequiredAssets(scene) {
            let line = scene.add.graphic(GraphicTypes_1.GraphicType.LINE, "primary", { start: new Vec2_1.default(-1, 1), end: new Vec2_1.default(-1, -1) });
            line.color = this.color;
            line.tweens.add("fade", {
                startDelay: 0,
                duration: 300,
                effects: [
                    {
                        property: GameNode_1.TweenableProperties.alpha,
                        start: 1,
                        end: 0,
                        ease: EaseFunctions_1.EaseFunctionType.OUT_SINE
                    }
                ],
                onEnd: constants_1.hw4_Events.UNLOAD_ASSET
            });
            return [line];
        }
        hits(node, line) {
            return node.collisionShape.getBoundingRect().intersectSegment(line.start, line.end.clone().sub(line.start)) !== null;
        }
        clone() {
            let newType = new LaserGun();
            newType.initialize({ damage: this.damage, color: this.hexColor, cooldown: this.cooldown, displayName: this.displayName, spriteKey: this.spriteKey, useVolume: this.useVolume });
            return newType;
        }
    }
    exports.default = LaserGun;
    },{"../../../../Wolfie2D/DataTypes/Shapes/AABB":25,"../../../../Wolfie2D/DataTypes/Vec2":32,"../../../../Wolfie2D/Nodes/GameNode":48,"../../../../Wolfie2D/Nodes/Graphics/GraphicTypes":50,"../../../../Wolfie2D/Utils/Color":109,"../../../../Wolfie2D/Utils/EaseFunctions":110,"../../../../Wolfie2D/constants":115,"./WeaponType":133}],131:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const AABB_1 = require("../../../../Wolfie2D/DataTypes/Shapes/AABB");
    const Vec2_1 = require("../../../../Wolfie2D/DataTypes/Vec2");
    const GameNode_1 = require("../../../../Wolfie2D/Nodes/GameNode");
    const GraphicTypes_1 = require("../../../../Wolfie2D/Nodes/Graphics/GraphicTypes");
    const Color_1 = require("../../../../Wolfie2D/Utils/Color");
    const EaseFunctions_1 = require("../../../../Wolfie2D/Utils/EaseFunctions");
    const constants_1 = require("../../../../Wolfie2D/constants");
    const WeaponType_1 = require("./WeaponType");
    class SemiAutoGun extends WeaponType_1.default {
        initialize(options) {
            this.damage = options.damage;
            this.cooldown = options.cooldown;
            this.hexColor = options.color;
            this.color = Color_1.default.fromStringHex(options.color);
            this.displayName = options.displayName;
            this.spriteKey = options.spriteKey;
            this.useVolume = options.useVolume;
        }
        doAnimation(shooter, direction, line) {
            let start = shooter.position.clone();
            let end = shooter.position.clone().add(direction.scaled(900));
            let delta = end.clone().sub(start);
            // Iterate through the tilemap region until we find a collision
            let minX = Math.min(start.x, end.x);
            let maxX = Math.max(start.x, end.x);
            let minY = Math.min(start.y, end.y);
            let maxY = Math.max(start.y, end.y);
            // Get the wall tilemap
            let walls = shooter.getScene().getLayer("Wall").getItems()[0];
            let minIndex = walls.getColRowAt(new Vec2_1.default(minX, minY));
            let maxIndex = walls.getColRowAt(new Vec2_1.default(maxX, maxY));
            let tileSize = walls.getTileSize();
            for (let col = minIndex.x; col <= maxIndex.x; col++) {
                for (let row = minIndex.y; row <= maxIndex.y; row++) {
                    if (walls.isTileCollidable(col, row)) {
                        // Get the position of this tile
                        let tilePos = new Vec2_1.default(col * tileSize.x + tileSize.x / 2, row * tileSize.y + tileSize.y / 2);
                        // Create a collider for this tile
                        let collider = new AABB_1.default(tilePos, tileSize.scaled(1 / 2));
                        let hit = collider.intersectSegment(start, delta, Vec2_1.default.ZERO);
                        if (hit !== null && start.distanceSqTo(hit.pos) < start.distanceSqTo(end)) {
                            //onsole.log("Found hit");
                            end = hit.pos;
                        }
                    }
                }
            }
            line.start = start;
            line.end = end;
            line.tweens.play("fade");
            line.color = Color_1.default.WHITE;
        }
        createRequiredAssets(scene) {
            let line = scene.add.graphic(GraphicTypes_1.GraphicType.LINE, "primary", { start: new Vec2_1.default(-1, 1), end: new Vec2_1.default(-1, -1) });
            line.color = this.color;
            line.tweens.add("fade", {
                startDelay: 0,
                duration: 300,
                effects: [
                    {
                        property: GameNode_1.TweenableProperties.alpha,
                        start: 1,
                        end: 0,
                        ease: EaseFunctions_1.EaseFunctionType.OUT_SINE
                    }
                ],
                onEnd: constants_1.hw4_Events.UNLOAD_ASSET
            });
            return [line];
        }
        hits(node, line) {
            let boo = node.collisionShape.getBoundingRect().intersectSegment(line.start.clone(), line.end.clone().sub(line.start.clone())) !== null;
            // console.log(boo)
            return boo;
        }
        clone() {
            let newType = new SemiAutoGun();
            newType.initialize({ color: this.hexColor, damage: this.damage, cooldown: this.cooldown, displayName: this.displayName, spriteKey: this.spriteKey, useVolume: this.useVolume });
            return newType;
        }
    }
    exports.default = SemiAutoGun;
    },{"../../../../Wolfie2D/DataTypes/Shapes/AABB":25,"../../../../Wolfie2D/DataTypes/Vec2":32,"../../../../Wolfie2D/Nodes/GameNode":48,"../../../../Wolfie2D/Nodes/Graphics/GraphicTypes":50,"../../../../Wolfie2D/Utils/Color":109,"../../../../Wolfie2D/Utils/EaseFunctions":110,"../../../../Wolfie2D/constants":115,"./WeaponType":133}],132:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const WeaponType_1 = require("./WeaponType");
    class Slice extends WeaponType_1.default {
        initialize(options) {
            this.damage = options.damage;
            this.cooldown = options.cooldown;
            this.displayName = options.displayName;
            this.spriteKey = options.spriteKey;
            this.useVolume = options.useVolume;
        }
        doAnimation(attacker, direction, sliceSprite) {
            // Rotate this with the game node
            sliceSprite.rotation = attacker.rotation;
            // Move the slice out from the player
            sliceSprite.position = attacker.position.clone().add(direction.scaled(16));
            // Play the slice animation w/o loop, but queue the normal animation
            sliceSprite.animation.play("SLICE");
            sliceSprite.animation.queue("NORMAL", true);
        }
        createRequiredAssets(scene) {
            let slice = scene.add.animatedSprite("slice", "primary");
            slice.animation.play("NORMAL", true);
            return [slice];
        }
        hits(node, sliceSprite) {
            return sliceSprite.boundary.overlaps(node.collisionShape);
        }
        clone() {
            let newType = new Slice();
            newType.initialize({ damage: this.damage, cooldown: this.cooldown, displayName: this.displayName, spriteKey: this.spriteKey, useVolume: this.useVolume });
            return newType;
        }
    }
    exports.default = Slice;
    },{"./WeaponType":133}],133:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class WeaponType {
    }
    exports.default = WeaponType;
    },{}],134:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
    const UIElementTypes_1 = require("../../Wolfie2D/Nodes/UIElements/UIElementTypes");
    const Scene_1 = require("../../Wolfie2D/Scene/Scene");
    const Color_1 = require("../../Wolfie2D/Utils/Color");
    class GameOver extends Scene_1.default {
        startScene() {
            const center = this.viewport.getCenter();
            this.addUILayer("primary");
            const gameOver = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "primary", { position: new Vec2_1.default(center.x, center.y), text: "Game Over" });
            gameOver.textColor = Color_1.default.WHITE;
        }
    }
    exports.default = GameOver;
    },{"../../Wolfie2D/DataTypes/Vec2":32,"../../Wolfie2D/Nodes/UIElements/UIElementTypes":64,"../../Wolfie2D/Scene/Scene":103,"../../Wolfie2D/Utils/Color":109}],135:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
    const UIElementTypes_1 = require("../../Wolfie2D/Nodes/UIElements/UIElementTypes");
    const Scene_1 = require("../../Wolfie2D/Scene/Scene");
    const Color_1 = require("../../Wolfie2D/Utils/Color");
    const MainScene_1 = require("./MainScene");
    class MainMenu extends Scene_1.default {
        loadScene() {
            this.load.image("splash", "mayhemAssets/background/splash.jpg ");
        }
        startScene() {
            const center = this.viewport.getCenter();
            ////################## The Splash Screen
            this.splashScreen = this.addUILayer("splashScreen");
            this.addParallaxLayer("bg", new Vec2_1.default(0.5, 1), -1);
            this.bg = this.add.sprite("splash", "bg");
            this.bg.size = new Vec2_1.default(1200, 800);
            this.bg.position.set(this.viewport.getHalfSize().x, this.viewport.getHalfSize().y);
            //Button for clicking to menu
            const mainMenu = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "splashScreen", {
                position: new Vec2_1.default(center.x, center.y + 250),
                text: "Click to Play",
            });
            mainMenu.size.set(200, 50);
            mainMenu.borderWidth = 2;
            mainMenu.borderColor = Color_1.default.TRANSPARENT;
            mainMenu.backgroundColor = Color_1.default.TRANSPARENT;
            mainMenu.onClickEventId = "menu";
            //*################# TODO: dao added this, quick play, remove later// starts at first level immediately
            const quickPlay = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "splashScreen", {
                position: new Vec2_1.default(center.x, center.y),
                text: "Quick Start to LV 1",
            });
            quickPlay.size.set(200, 50);
            quickPlay.borderWidth = 2;
            quickPlay.borderColor = Color_1.default.WHITE;
            quickPlay.backgroundColor = Color_1.default.TRANSPARENT;
            quickPlay.onClickEventId = "chooselevel";
            //################The Menu Screen
            this.mainMenu = this.addUILayer("mainMenu");
            this.mainMenu.setHidden(true);
            //Header for Main Menu
            const mainmenuhead = "Main Menu";
            const mainMenuheader = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "mainMenu", {
                position: new Vec2_1.default(center.x, center.y - 250),
                text: mainmenuhead,
            });
            mainMenuheader.textColor = Color_1.default.WHITE;
            mainMenuheader.backgroundColor = Color_1.default.TRANSPARENT;
            mainMenuheader.fontSize = 50;
            // Add play button, and give it an event to emit on press
            const selectLevel = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "mainMenu", {
                position: new Vec2_1.default(center.x, center.y - 100),
                text: "Select Level",
            });
            selectLevel.size.set(200, 50);
            selectLevel.borderWidth = 2;
            selectLevel.borderColor = Color_1.default.TRANSPARENT;
            selectLevel.backgroundColor = Color_1.default.TRANSPARENT;
            selectLevel.onClickEventId = "selectlevel";
            // Add help button
            const help = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "mainMenu", {
                position: new Vec2_1.default(center.x, center.y + 200),
                text: "Help",
            });
            help.size.set(200, 50);
            help.borderWidth = 2;
            help.borderColor = Color_1.default.TRANSPARENT;
            help.backgroundColor = Color_1.default.TRANSPARENT;
            help.onClickEventId = "help";
            // //THIS IS OUR controls button in the mains screen of the game
            const control = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "mainMenu", {
                position: new Vec2_1.default(center.x, center.y + 50),
                text: "Controls",
            });
            control.size.set(200, 50);
            control.borderWidth = 2;
            control.borderColor = Color_1.default.TRANSPARENT;
            control.backgroundColor = Color_1.default.TRANSPARENT;
            control.onClickEventId = "control";
            /* ########## HELP SCREEN ########## */
            this.help = this.addUILayer("help");
            this.help.setHidden(true);
            const helpHeader = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "help", {
                position: new Vec2_1.default(center.x, center.y - 250),
                text: "Help",
            });
            helpHeader.textColor = Color_1.default.WHITE;
            helpHeader.fontSize = 50;
            const text1header = "Backstory";
            const text1 = "You’re a retired veteran. You found out that your dearest comrade-in-arms has committed a misunderstood sin and ends up in hell";
            const text12 = "Knowing this, you end up trying to break through the barriers of hell to find Jackson and drag him out";
            const text13 = "As you kill more demon spawns from hell, the barrier into hell weakens, allowing you to progress through hell and getting you closer to your comrade";
            const text2header = "Developers";
            const text2 = "Lin Ni";
            const text22 = "Daoqin Gao";
            const text23 = "Robert Rolsenic";
            const text3header = "Cheat Codes";
            const text3 = "INVINCIBLE SKIP [NUMBER] UPGRADE [BUFF]";
            const line1header = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "help", {
                position: new Vec2_1.default(center.x, center.y - 160),
                text: text1header,
            });
            const line1 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "help", {
                position: new Vec2_1.default(center.x, center.y - 120),
                text: text1,
            });
            const line12 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "help", {
                position: new Vec2_1.default(center.x, center.y - 100),
                text: text12,
            });
            const line13 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "help", {
                position: new Vec2_1.default(center.x, center.y - 80),
                text: text13,
            });
            const line2header = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "help", {
                position: new Vec2_1.default(center.x, center.y - 10),
                text: text2header,
            });
            const line2 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "help", {
                position: new Vec2_1.default(center.x, center.y + 30),
                text: text2,
            });
            const line22 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "help", {
                position: new Vec2_1.default(center.x, center.y + 60),
                text: text22,
            });
            const line23 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "help", {
                position: new Vec2_1.default(center.x, center.y + 90),
                text: text23,
            });
            const line3header = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "help", {
                position: new Vec2_1.default(center.x, center.y + 140),
                text: text3header,
            });
            const line3 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "help", {
                position: new Vec2_1.default(center.x, center.y + 180),
                text: text3,
            });
            line1.textColor = Color_1.default.WHITE;
            line12.textColor = Color_1.default.WHITE;
            line13.textColor = Color_1.default.WHITE;
            line1.fontSize = 16;
            line12.fontSize = 16;
            line13.fontSize = 16;
            line2.textColor = Color_1.default.WHITE;
            line22.textColor = Color_1.default.WHITE;
            line23.textColor = Color_1.default.WHITE;
            line3.textColor = Color_1.default.WHITE;
            line3.fontSize = 20;
            line2.fontSize = 18;
            line22.fontSize = 18;
            line23.fontSize = 18;
            line3.fontSize = 18;
            line1header.textColor = Color_1.default.WHITE;
            line2header.textColor = Color_1.default.WHITE;
            line3header.textColor = Color_1.default.WHITE;
            line1.font = "Cursive";
            line12.font = "Cursive";
            line13.font = "Cursive";
            line2.font = "Cursive";
            line22.font = "Cursive";
            line23.font = "Cursive";
            line3.font = "Cursive";
            const helpBack = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "help", {
                position: new Vec2_1.default(center.x, center.y + 300),
                text: "Back",
            });
            helpBack.size.set(200, 50);
            helpBack.borderWidth = 2;
            helpBack.borderColor = Color_1.default.WHITE;
            helpBack.backgroundColor = Color_1.default.TRANSPARENT;
            helpBack.onClickEventId = "menu";
            helpBack.font = "Fantasy";
            /* ########## CONTROL SCREEN ########## */
            this.control = this.addUILayer("control");
            this.control.setHidden(true);
            const controlHeader = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "control", {
                position: new Vec2_1.default(center.x, center.y - 250),
                text: "Controls",
            });
            controlHeader.textColor = Color_1.default.WHITE;
            controlHeader.fontSize = 50;
            controlHeader.font = "Fantasy";
            const controlText1 = "WASD to move";
            const controlText2 = "Left Click to Shoot";
            const controlLine1 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "control", {
                position: new Vec2_1.default(center.x, center.y - 50),
                text: controlText1,
            });
            const controlLine2 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "control", {
                position: new Vec2_1.default(center.x, center.y + 50),
                text: controlText2,
            });
            controlLine1.textColor = Color_1.default.WHITE;
            controlLine2.textColor = Color_1.default.WHITE;
            const controlBack = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "control", {
                position: new Vec2_1.default(center.x, center.y + 250),
                text: "Back",
            });
            controlBack.size.set(200, 50);
            controlBack.borderWidth = 2;
            controlBack.borderColor = Color_1.default.WHITE;
            controlBack.backgroundColor = Color_1.default.TRANSPARENT;
            controlBack.onClickEventId = "menu";
            //###########Select Levels Screen
            this.selectLevelScreen = this.addUILayer("selectLevelScreen");
            this.selectLevelScreen.setHidden(true);
            //add button to go back
            const selectLevelBack = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "selectLevelScreen", {
                position: new Vec2_1.default(center.x, center.y + 250),
                text: "Back",
            });
            selectLevelBack.size.set(200, 50);
            selectLevelBack.borderWidth = 2;
            selectLevelBack.borderColor = Color_1.default.WHITE;
            selectLevelBack.backgroundColor = Color_1.default.TRANSPARENT;
            selectLevelBack.onClickEventId = "menu";
            ///header for select level
            const selectHeader = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "selectLevelScreen", {
                position: new Vec2_1.default(center.x, center.y - 250),
                text: "Select Level",
            });
            selectHeader.textColor = Color_1.default.WHITE;
            selectHeader.fontSize = 50;
            ///buttons for all the levels
            const level1 = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "selectLevelScreen", {
                position: new Vec2_1.default(center.x, center.y - 150),
                text: "Level 1",
            });
            level1.size.set(200, 50);
            level1.borderWidth = 2;
            level1.borderColor = Color_1.default.WHITE;
            level1.backgroundColor = Color_1.default.TRANSPARENT;
            level1.onClickEventId = "chooselevel";
            const level2 = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "selectLevelScreen", {
                position: new Vec2_1.default(center.x + 100, center.y - 90),
                text: "Level 2",
            });
            level2.size.set(200, 50);
            level2.borderWidth = 2;
            level2.borderColor = Color_1.default.WHITE;
            level2.backgroundColor = Color_1.default.TRANSPARENT;
            level2.onClickEventId = "chooselevel";
            const level3 = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "selectLevelScreen", {
                position: new Vec2_1.default(center.x + 200, center.y - 30),
                text: "Level 3",
            });
            level3.size.set(200, 50);
            level3.borderWidth = 2;
            level3.borderColor = Color_1.default.WHITE;
            level3.backgroundColor = Color_1.default.TRANSPARENT;
            level3.onClickEventId = "chooselevel";
            const level4 = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "selectLevelScreen", {
                position: new Vec2_1.default(center.x + 150, center.y + 30),
                text: "Level 4",
            });
            level4.size.set(200, 50);
            level4.borderWidth = 2;
            level4.borderColor = Color_1.default.WHITE;
            level4.backgroundColor = Color_1.default.TRANSPARENT;
            level4.onClickEventId = "chooselevel";
            const level5 = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "selectLevelScreen", {
                position: new Vec2_1.default(center.x + 100, center.y + 90),
                text: "Level 5",
            });
            level5.size.set(200, 50);
            level5.borderWidth = 2;
            level5.borderColor = Color_1.default.WHITE;
            level5.backgroundColor = Color_1.default.TRANSPARENT;
            level5.onClickEventId = "chooselevel";
            const level6 = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "selectLevelScreen", {
                position: new Vec2_1.default(center.x - 100, center.y + 90),
                text: "Level 6",
            });
            level6.size.set(200, 50);
            level6.borderWidth = 2;
            level6.borderColor = Color_1.default.WHITE;
            level6.backgroundColor = Color_1.default.TRANSPARENT;
            level6.onClickEventId = "chooselevel";
            const level7 = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "selectLevelScreen", {
                position: new Vec2_1.default(center.x - 150, center.y + 30),
                text: "Level 7",
            });
            level7.size.set(200, 50);
            level7.borderWidth = 2;
            level7.borderColor = Color_1.default.WHITE;
            level7.backgroundColor = Color_1.default.TRANSPARENT;
            level7.onClickEventId = "chooselevel";
            const level8 = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "selectLevelScreen", {
                position: new Vec2_1.default(center.x - 200, center.y - 30),
                text: "Level 8",
            });
            level8.size.set(200, 50);
            level8.borderWidth = 2;
            level8.borderColor = Color_1.default.WHITE;
            level8.backgroundColor = Color_1.default.TRANSPARENT;
            level8.onClickEventId = "chooselevel";
            const level9 = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "selectLevelScreen", {
                position: new Vec2_1.default(center.x - 100, center.y - 90),
                text: "Level 9",
            });
            level9.size.set(200, 50);
            level9.borderWidth = 2;
            level9.borderColor = Color_1.default.WHITE;
            level9.backgroundColor = Color_1.default.TRANSPARENT;
            level9.onClickEventId = "chooselevel";
            // Subscribe to the button events
            this.receiver.subscribe("play");
            this.receiver.subscribe("help");
            this.receiver.subscribe("menu");
            this.receiver.subscribe("control");
            this.receiver.subscribe("clicktoplay");
            this.receiver.subscribe("selectlevel");
            this.receiver.subscribe("chooselevel");
        }
        updateScene() {
            //TODO: going to about to back makes the screen frozen
            while (this.receiver.hasNextEvent()) {
                let event = this.receiver.getNextEvent();
                console.log(event);
                if (event.type === "selectlevel") {
                    // this.sceneManager.changeToScene(mainScene, {});
                    this.mainMenu.setHidden(true);
                    this.selectLevelScreen.setHidden(false);
                }
                if (event.type === "chooselevel") {
                    this.sceneManager.changeToScene(MainScene_1.default, {});
                }
                if (event.type === "help") {
                    this.help.setHidden(false);
                    this.mainMenu.setHidden(true);
                }
                if (event.type === "menu") {
                    console.log("logging menu");
                    this.mainMenu.setHidden(false);
                    this.help.setHidden(true);
                    this.control.setHidden(true);
                    this.splashScreen.setHidden(true);
                    this.selectLevelScreen.setHidden(true);
                    this.bg.visible = false;
                }
                if (event.type === "control") {
                    this.mainMenu.setHidden(true);
                    this.control.setHidden(false);
                }
            }
        }
    }
    exports.default = MainMenu;
    },{"../../Wolfie2D/DataTypes/Vec2":32,"../../Wolfie2D/Nodes/UIElements/UIElementTypes":64,"../../Wolfie2D/Scene/Scene":103,"../../Wolfie2D/Utils/Color":109,"./MainScene":136}],136:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const PlayerController_1 = require("../AI/PlayerController");
    const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
    const Scene_1 = require("../../Wolfie2D/Scene/Scene");
    const GraphicTypes_1 = require("../../Wolfie2D/Nodes/Graphics/GraphicTypes");
    const PositionGraph_1 = require("../../Wolfie2D/DataTypes/Graphs/PositionGraph");
    const Navmesh_1 = require("../../Wolfie2D/Pathfinding/Navmesh");
    const constants_1 = require("../../Wolfie2D/constants");
    const EnemyAI_1 = require("../AI/EnemyAI");
    const RegistryManager_1 = require("../../Wolfie2D/Registry/RegistryManager");
    const Weapon_1 = require("../GameSystems/items/Weapon");
    const Healthpack_1 = require("../GameSystems/items/Healthpack");
    const InventoryManager_1 = require("../GameSystems/InventoryManager");
    const AABB_1 = require("../../Wolfie2D/DataTypes/Shapes/AABB");
    const BattleManager_1 = require("../GameSystems/BattleManager");
    const UIElementTypes_1 = require("../../Wolfie2D/Nodes/UIElements/UIElementTypes");
    const Color_1 = require("../../Wolfie2D/Utils/Color");
    const Input_1 = require("../../Wolfie2D/Input/Input");
    const GameOver_1 = require("./GameOver");
    const AttackAction_1 = require("../../Wolfie2D/AI/EnemyActions/AttackAction");
    const Move_1 = require("../../Wolfie2D/AI/EnemyActions/Move");
    const Retreat_1 = require("../../Wolfie2D/AI/EnemyActions/Retreat");
    const Berserk_1 = require("../../Wolfie2D/AI/EnemyActions/Berserk");
    const MaxHealth_1 = require("../GameSystems/items/MaxHealth");
    const Speed_1 = require("../GameSystems/items/Speed");
    const AttackSpeed_1 = require("../GameSystems/items/AttackSpeed");
    const AttackDamage_1 = require("../GameSystems/items/AttackDamage");
    const Checkpoint_1 = require("../GameSystems/items/Checkpoint");
    const CheckpointCleared_1 = require("../GameSystems/items/CheckpointCleared");
    const NextLevel_1 = require("./NextLevel");
    class mainScene extends Scene_1.default {
        constructor() {
            super(...arguments);
            this.attackDamageBuff = 0;
            this.attackSpeedBuff = 0;
            this.speedBuff = 0;
            this.healthupBuff = 0;
            this.totalEnemiesKilled = 0;
            this.actionKnife = [
                new AttackAction_1.default(3, [constants_1.hw4_Statuses.IN_RANGE], [constants_1.hw4_Statuses.REACHED_GOAL]),
                new Move_1.default(2, [], [constants_1.hw4_Statuses.IN_RANGE], { inRange: 20 }),
            ];
            this.actionsGun = [
                new AttackAction_1.default(3, [constants_1.hw4_Statuses.IN_RANGE], [constants_1.hw4_Statuses.REACHED_GOAL]),
                new Move_1.default(2, [], [constants_1.hw4_Statuses.IN_RANGE], { inRange: 100 }),
                new Retreat_1.default(1, [constants_1.hw4_Statuses.LOW_HEALTH, constants_1.hw4_Statuses.CAN_RETREAT], [constants_1.hw4_Statuses.REACHED_GOAL, constants_1.hw4_Statuses.CAN_BERSERK], { retreatDistance: 200 }),
                new Berserk_1.default(1, [constants_1.hw4_Statuses.LOW_HEALTH, constants_1.hw4_Statuses.CAN_BERSERK], [constants_1.hw4_Statuses.REACHED_GOAL]),
            ];
        }
        loadScene() {
            // Load the player and enemy spritesheets
            //there will only be one player
            this.load.spritesheet("mainplayer", "mayhemAssets/spritesheets/mainplayer.json");
            this.load.spritesheet("imp", "mayhemAssets/spritesheets/imp.json");
            this.load.spritesheet("slice", "mayhemAssets/spritesheets/slice.json");
            this.load.tilemap("level", "mayhemAssets/tilemaps/mayhemTileJson.json");
            this.load.object("weaponData", "mayhemAssets/data/weaponData.json");
            this.load.object("navmesh", "mayhemAssets/data/navmesh.json");
            this.load.object("enemyData", "mayhemAssets/data/enemy.json");
            this.load.object("itemData", "mayhemAssets/data/items.json");
            //buffs
            this.load.image("healthpack", "mayhemAssets/sprites/healthpack.png");
            this.load.image("healthmax", "mayhemAssets/sprites/healthmax.png");
            this.load.image("attackspeed", "mayhemAssets/sprites/attackspeed.png");
            this.load.image("attackdamage", "mayhemAssets/sprites/attackdamage.png");
            this.load.image("speed", "mayhemAssets/sprites/speed.png");
            this.load.image("checkpoint", "mayhemAssets/sprites/checkpoint.png");
            this.load.image("checkpointcleared", "mayhemAssets/sprites/checkpointcleared.png");
            this.load.image("healthbarEmpty", "mayhemAssets/sprites/healthbarEmpty.png");
            this.load.image("healthbarGreen", "mayhemAssets/sprites/healthbarGreen.png");
            this.load.image("inventorySlot", "mayhemAssets/sprites/inventory.png");
            this.load.image("knife", "mayhemAssets/sprites/knife.png");
            this.load.image("laserGun", "mayhemAssets/sprites/laserGun.png");
            this.load.image("pistol", "mayhemAssets/sprites/pistol.png");
        }
        startScene() {
            // HOMEWORK 4 - TODO
            /*
                    Modify this line if needed.
        
                    This line is just getting the wall layer of your tilemap to use for some calculations.
                    Make sure it is still doing so.
        
                    What the line is saying is to get the first level from the bottom (tilemapLayers[1]),
                    which in my case was the Walls layer.
        
                    Also, your tilemap will be made with 32x32 tiles while the example map is made with 16x16 tiles.
                    You'll need to scale it down for our 16x16 players and enemy sprites. The code for this
                    is listed below, it's just a scaling down by 1/2 for the tilemap size.
                */
            // Add in the tilemap
            let tilemapLayers = this.add.tilemap("level", new Vec2_1.default(0.5, 0.5));
            // Get the wall layer
            this.walls = tilemapLayers[1].getItems()[0];
            // Set the viewport bounds to the tilemap
            let tilemapSize = this.walls.size.scaled(0.5);
            this.tileMapMaxSize = tilemapSize;
            this.viewport.setBounds(0, 0, tilemapSize.x, tilemapSize.y);
            this.addLayer("primary", 10);
            // Create the battle manager
            this.battleManager = new BattleManager_1.default();
            this.initializeWeapons();
            // Initialize the items array - this represents items that are in the game world
            this.items = [];
            // Create the player
            this.initializePlayer();
            // Make the viewport follow the player
            this.viewport.follow(this.mainPlayer);
            // Zoom in to a reasonable level
            this.viewport.enableZoom();
            this.viewport.setZoomLevel(4);
            // Create the navmesh
            this.createNavmesh();
            // Initialize all enemies
            this.initializeEnemies();
            // Send the player and enemies to the battle manager
            this.battleManager.setPlayers([this.mainPlayer._ai]);
            this.battleManager.setEnemies(this.enemies.map((enemy) => enemy._ai));
            // Subscribe to relevant events
            this.receiver.subscribe("healthpack");
            this.receiver.subscribe("enemyDied");
            this.receiver.subscribe("checkpoint_cleared");
            this.receiver.subscribe("newbuff");
            // this.receiver.subscribe(hw4_Events.UNLOAD_ASSET);
            // Spawn items into the world
            this.spawnItems();
            ///adding healthbar
            this.addUILayer("healthbar");
            var healthbar = this.add.sprite("healthbarEmpty", "healthbar");
            healthbar.position.set(100, 16);
            this.healthbargreen = this.add.sprite("healthbarGreen", "healthbar");
            this.healthbargreen.position.set(100, 16);
            ///(<PlayerController>this.mainPlayer._ai).health
            this.healthbargreen.size.set(this.mainPlayer._ai.health, 16);
            // Add a UI for health
            this.addUILayer("health");
            this.healthDisplays = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "health", {
                position: new Vec2_1.default(60, 16),
                text: "Health: " + this.mainPlayer._ai.health,
            });
            this.healthDisplays.textColor = Color_1.default.WHITE;
            this.addUILayer("maxhealth");
            this.maxhealthDisplays = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "maxhealth", {
                position: new Vec2_1.default(130, 16),
                text: "Max Health: " + this.mainPlayer._ai.maxHealth,
            });
            this.maxhealthDisplays.textColor = Color_1.default.WHITE;
            this.addUILayer("attack");
            this.attackDisplays = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "attack", {
                position: new Vec2_1.default(190, 16),
                text: "Attack: " +
                    this.mainPlayer._ai.weapon.type.damage,
            });
            this.attackDisplays.textColor = Color_1.default.WHITE;
            this.addUILayer("pause");
            this.addUILayer("play");
            this.pauseButton = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "pause", {
                position: new Vec2_1.default(260, 16),
                text: "Pause",
            });
            this.pauseButton.size.set(200, 50);
            this.pauseButton.borderColor = Color_1.default.TRANSPARENT;
            this.pauseButton.backgroundColor = Color_1.default.TRANSPARENT;
            this.pauseButton.onClickEventId = "pause";
            this.playButton = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "play", {
                position: new Vec2_1.default(230, 16),
                text: "Play",
            });
            this.playButton.size.set(200, 50);
            this.playButton.borderColor = Color_1.default.TRANSPARENT;
            this.playButton.backgroundColor = Color_1.default.TRANSPARENT;
            this.playButton.onClickEventId = "play";
            this.receiver.subscribe("pause");
            this.receiver.subscribe("play");
            this.addUILayer("attackdamage");
            this.addUILayer("attackspeed");
            this.addUILayer("speed");
            this.addUILayer("healthup");
            this.addUILayer("buffspicture").setDepth(100);
            var attackdamagepic = this.add.sprite("attackdamage", "buffspicture");
            attackdamagepic.position.set(280, 30);
            var attackspeedpic = this.add.sprite("attackspeed", "buffspicture");
            attackspeedpic.position.set(280, 50);
            var speedpic = this.add.sprite("speed", "buffspicture");
            speedpic.position.set(280, 70);
            var healthpic = this.add.sprite("healthmax", "buffspicture");
            healthpic.position.set(280, 90);
            this.attackDamageBuffLabel = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "attackdamage", {
                position: new Vec2_1.default(295, 30),
                text: "" + this.attackDamageBuff,
            });
            this.attackDamageBuffLabel.textColor = Color_1.default.WHITE;
            this.attackSpeedBuffLabel = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "attackspeed", {
                position: new Vec2_1.default(295, 50),
                text: "" + this.attackSpeedBuff,
            });
            this.attackSpeedBuffLabel.textColor = Color_1.default.WHITE;
            this.speedBuffLabel = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "speed", {
                position: new Vec2_1.default(295, 70),
                text: "" + this.speedBuff,
            });
            this.speedBuffLabel.textColor = Color_1.default.WHITE;
            this.healthupBuffLabel = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "healthup", {
                position: new Vec2_1.default(295, 90),
                text: "" + this.healthupBuff,
            });
            this.healthupBuffLabel.textColor = Color_1.default.WHITE;
        }
        lootGenerate(pos) {
            if (Math.random() < 0.4) {
                // Spawn a healthpack
                let min = 1;
                let max = 4;
                let lootType = Math.floor(Math.random() * (max - min) + min);
                // this.emitter.fireEvent("healthpack", { pos});
                if (lootType === 1) {
                    this.createAttackDamage(pos);
                }
                if (lootType === 2) {
                    this.createAttackspeed(pos);
                }
                if (lootType === 3) {
                    // this.createHealthpack(pos)
                }
                if (lootType === 4) {
                    this.createMaxhealth(pos);
                }
            }
        }
        updateScene(deltaT) {
            while (this.receiver.hasNextEvent()) {
                let event = this.receiver.getNextEvent();
                if (event.isType("healthpack")) {
                    this.createHealthpack(event.data.get("position"));
                }
                if (event.isType("enemyDied")) {
                    for (let i = 0; i < this.enemies.length; i++) {
                        if (this.enemies[i] === event.data.get("enemy")) {
                            this.enemies[i].hpDisplay.destroy();
                        }
                    }
                    this.lootGenerate(event.data.get("enemy").position.clone());
                    this.enemies = this.enemies.filter((enemy) => enemy !== event.data.get("enemy"));
                    this.battleManager.enemies = this.battleManager.enemies.filter((enemy) => enemy !== event.data.get("enemy")._ai);
                    this.totalEnemiesKilled++;
                    this.spawnRandomEnemy();
                    this.spawnRandomEnemy();
                }
                if (event.isType("checkpoint_cleared")) {
                    let sprite = this.add.sprite("checkpointcleared", "primary");
                    let checkpointcleared = new CheckpointCleared_1.default(sprite);
                    checkpointcleared.moveSprite(event.data.get("position"));
                    this.mainPlayer.visible = false;
                    this.sceneManager.changeToScene(NextLevel_1.default);
                }
                if (event.isType("pause")) {
                    console.log("Pausing Game");
                }
                if (event.isType("play")) {
                    console.log("Resume Game");
                }
                if (event.isType("newbuff")) {
                    var buff = event.data.get("buff");
                    if (buff instanceof AttackDamage_1.default) {
                        this.attackDamageBuff += 1;
                        this.attackDamageBuffLabel.text = "" + this.attackDamageBuff;
                    }
                    if (buff instanceof AttackSpeed_1.default) {
                        this.attackSpeedBuff += 1;
                        this.attackSpeedBuffLabel.text = "" + this.attackSpeedBuff;
                    }
                    if (buff instanceof Speed_1.default) {
                        this.speedBuff += 1;
                        this.speedBuffLabel.text = "" + this.speedBuff;
                    }
                    if (buff instanceof MaxHealth_1.default) {
                        this.healthupBuff += 1;
                        this.healthupBuffLabel.text = "" + this.healthupBuff;
                    }
                }
                if (event.isType(constants_1.hw4_Events.UNLOAD_ASSET)) {
                    let asset = this.sceneGraph.getNode(event.data.get("node"));
                    asset.destroy();
                }
            }
            // check health of each player
            let health = this.mainPlayer._ai.health;
            //If both are dead, game over
            if (health <= 0) {
                this.mainPlayer.position = new Vec2_1.default(-1000, -1000);
                this.mainPlayer.visible = false;
                this.sceneManager.changeToScene(GameOver_1.default);
            }
            // Update health gui
            this.healthDisplays.text = "Health: " + health;
            this.attackDisplays.text =
                "Attack: " + this.mainPlayer._ai.weapon.type.damage;
            this.maxhealthDisplays.text =
                "Max Health: " + this.mainPlayer._ai.maxHealth;
            //update enemy hp
            for (let i = 0; i < this.enemies.length; i++) {
                if (this.enemies[i]) {
                    // (<GameNode>data.hpdisplay).destroy();
                    this.enemies[i].hpDisplay.setPosition(new Vec2_1.default(this.enemies[i].position.x, this.enemies[i].position.y));
                    this.enemies[i].hpDisplay.text =
                        "" + this.enemies[i]._ai.health;
                }
                // data.hpdisplay= <Label>this.add.uiElement(
                //   UIElementType.LABEL,
                //   "primary",
                //   {
                //     position: new Vec2(this.enemies[i].position.x ,this.enemies[i].position.y),
                //     text: "" + data.health
                //   }
                // );
            }
            var currenthp = this.mainPlayer._ai.health;
            var maxhp = this.mainPlayer._ai.maxHealth;
            this.healthbargreen.size.set((currenthp / maxhp) * 128, 16);
            // Debug mode graph
            if (Input_1.default.isKeyJustPressed("g")) {
                this.getLayer("graph").setHidden(!this.getLayer("graph").isHidden());
            }
        }
        // HOMEWORK 4 - TODO
        /**
         * This function spawns in all of the items in "items.json"
         *
         * You shouldn't have to put any new code here, however, you will have to modify items.json.
         *
         * Make sure you are spawning in 5 pistols and 5 laser guns somewhere (accessible) in your world.
         *
         * You'll notice that right now, some healthpacks are also spawning in. These also drop from guards.
         * Feel free to spawn some healthpacks if you want, or you can just let the player suffer >:)
         */
        spawnItems() {
            // Get the item data
            let itemData = this.load.getObject("itemData");
            for (let item of itemData.items) {
                if (item.type === "healthpack") {
                    // Create a healthpack
                    this.createHealthpack(new Vec2_1.default(item.position[0] / 2, item.position[1] / 2));
                }
                else if (item.type === "healthmax") {
                    this.createMaxhealth(new Vec2_1.default(item.position[0] / 2, item.position[1] / 2));
                }
                else if (item.type === "attackspeed") {
                    this.createAttackspeed(new Vec2_1.default(item.position[0] / 2, item.position[1] / 2));
                }
                else if (item.type === "attackdamage") {
                    this.createAttackDamage(new Vec2_1.default(item.position[0] / 2, item.position[1] / 2));
                }
                else if (item.type === "speed") {
                    this.createSpeed(new Vec2_1.default(item.position[0] / 2, item.position[1] / 2));
                }
                else if (item.type === "checkpoint") {
                    this.createCheckpoint(new Vec2_1.default(item.position[0] / 2, item.position[1] / 2));
                }
            }
        }
        /**
         *
         * Creates and returns a new weapon
         * @param type The weaponType of the weapon, as a string
         */
        createWeapon(type) {
            let weaponType = (RegistryManager_1.default.getRegistry("weaponTypes").get(type));
            let sprite = this.add.sprite(weaponType.spriteKey, "primary");
            return new Weapon_1.default(sprite, weaponType, this.battleManager);
        }
        /**
         * Creates a healthpack at a certain position in the world
         * @param position
         */
        createHealthpack(position) {
            let sprite = this.add.sprite("healthpack", "primary");
            let healthpack = new Healthpack_1.default(sprite);
            healthpack.moveSprite(position);
            this.items.push(healthpack);
        }
        createMaxhealth(position) {
            let sprite = this.add.sprite("healthmax", "primary");
            let maxhealth = new MaxHealth_1.default(sprite);
            maxhealth.moveSprite(position);
            this.items.push(maxhealth);
        }
        createSpeed(position) {
            let sprite = this.add.sprite("speed", "primary");
            let speed = new Speed_1.default(sprite);
            speed.moveSprite(position);
            this.items.push(speed);
        }
        createAttackDamage(position) {
            let sprite = this.add.sprite("attackdamage", "primary");
            let attackdamage = new AttackDamage_1.default(sprite);
            attackdamage.moveSprite(position);
            this.items.push(attackdamage);
        }
        createAttackspeed(position) {
            let sprite = this.add.sprite("attackspeed", "primary");
            let attackspeed = new AttackSpeed_1.default(sprite);
            attackspeed.moveSprite(position);
            this.items.push(attackspeed);
        }
        createCheckpoint(position) {
            let sprite = this.add.sprite("checkpoint", "primary");
            let checkpoint = new Checkpoint_1.default(sprite);
            checkpoint.moveSprite(position);
            this.items.push(checkpoint);
        }
        /**
         * Initalizes all weapon types based of data from weaponData.json
         */
        initializeWeapons() {
            let weaponData = this.load.getObject("weaponData");
            for (let i = 0; i < weaponData.numWeapons; i++) {
                let weapon = weaponData.weapons[i];
                // Get the constructor of the prototype
                let constr = RegistryManager_1.default.getRegistry("weaponTemplates").get(weapon.weaponType);
                // Create a weapon type
                let weaponType = new constr();
                // Initialize the weapon type
                weaponType.initialize(weapon);
                // Register the weapon type
                RegistryManager_1.default.getRegistry("weaponTypes").registerItem(weapon.name, weaponType);
            }
        }
        // HOMEWORK 4 - TODO
        /**
         * Change positions of the player characters to whatever fits your map
         */
        initializePlayer() {
            // Create the inventory
            let inventory = new InventoryManager_1.default(this, 1, "inventorySlot", new Vec2_1.default(16, 16), 2, "slots1", "items1");
            let startingWeapon = this.createWeapon("weak_pistol");
            inventory.addItem(startingWeapon);
            // Create the players
            this.mainPlayer = this.add.animatedSprite("mainplayer", "primary");
            this.mainPlayer.position.set(4 * 8, 62 * 8);
            this.mainPlayer.addPhysics(new AABB_1.default(Vec2_1.default.ZERO, new Vec2_1.default(8, 8)));
            //First thislayeree based, starts off with a knife and is short ranged
            this.mainPlayer.addAI(PlayerController_1.default, {
                speed: 100,
                health: 128,
                maxHealth: 128,
                inventory: inventory,
                items: this.items,
                inputEnabled: true,
                range: 150,
                weapon: startingWeapon,
            });
            this.mainPlayer.animation.play("face_right");
            this.mainPlayer._ai.inventory.setActive(true);
        }
        /**
         * // HOMEWORK 4 - TODO
         * This function creates the navmesh for the game world.
         *
         * It reads in information in the navmesh.json file.
         * The format of the navmesh.json file is as follows
         *
         * {
         *  // An array of positions on the tilemap. You can see the position of your mouse in [row, col]
         *  // while editing a map in Tiled, and can just multiply those values by the tile size, 16x16
         *      "nodes": [[100, 200], [50, 400], ...]
         *
         *  // An array of edges between nodes. The numbers here correspond to indices in the "nodes" array above.
         *  // Note that edges are not directed here. An edge [0, 1] foes in both directions.
         *      "edges": [[0, 1], [2, 4], ...]
         * }
         *
         * The navmesh you create should be distinctly different from the one given as an example.
         */
        createNavmesh() {
            // Add a layer to display the graph
            let gLayer = this.addLayer("graph");
            gLayer.setHidden(true);
            let navmeshData = this.load.getObject("navmesh");
            // Create the graph
            this.graph = new PositionGraph_1.default();
            // Add all nodes to our graph
            for (let node of navmeshData.nodes) {
                this.graph.addPositionedNode(new Vec2_1.default(node[0] / 2, node[1] / 2));
                this.add.graphic(GraphicTypes_1.GraphicType.POINT, "graph", {
                    position: new Vec2_1.default(node[0] / 2, node[1] / 2),
                });
            }
            // Add all edges to our graph
            for (let edge of navmeshData.edges) {
                this.graph.addEdge(edge[0], edge[1]);
                this.add.graphic(GraphicTypes_1.GraphicType.LINE, "graph", {
                    start: this.graph.getNodePosition(edge[0]),
                    end: this.graph.getNodePosition(edge[1]),
                });
            }
            // Set this graph as a navigable entity
            let navmesh = new Navmesh_1.default(this.graph);
            this.navManager.addNavigableEntity(constants_1.hw4_Names.NAVMESH, navmesh);
        }
        spawnEnemy(data, pos) {
            if (this.enemies.length >= 100) {
                return; //hard limit on the max enemies there can be in this game
            }
            // Create an enemy
            this.enemies.push(this.add.animatedSprite(data.type, "primary"));
            let lastIndex = this.enemies.length - 1;
            this.enemies[lastIndex].position.set(data.position[0] / 2, data.position[1] / 2);
            this.enemies[lastIndex].animation.play("face_right");
            this.enemies[lastIndex].addPhysics(new AABB_1.default(Vec2_1.default.ZERO, new Vec2_1.default(8, 8)));
            if (data.route) {
                data.route = data.route.map((index) => this.graph.getNodePosition(index));
            }
            if (data.guardPosition) {
                data.guardPosition = new Vec2_1.default(data.guardPosition[0] / 2, data.guardPosition[1] / 2);
            }
            /*initalize status and actions for each enemy. This can be edited if you want your custom enemies to start out with
                  different statuses, but dont remove these statuses for the original two enemies*/
            let statusArray = [
                constants_1.hw4_Statuses.CAN_RETREAT,
                constants_1.hw4_Statuses.CAN_BERSERK,
            ];
            let weapon;
            let actions;
            let range;
            if (data.type === "gun_enemy") {
                weapon = this.createWeapon("weak_pistol");
                actions = this.actionsGun;
                range = 100;
            }
            else if (data.type === "imp") {
                weapon = this.createWeapon("knife");
                actions = this.actionKnife;
                range = 20;
                //ADD CODE HERE
            }
            var enemyhp = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "primary", {
                position: new Vec2_1.default(data.position[0] / 2, data.position[1] / 2),
                text: "" + data.health,
            });
            enemyhp.textColor = Color_1.default.WHITE;
            this.enemies[lastIndex].hpDisplay = enemyhp;
            let enemyOptions = {
                defaultMode: data.mode,
                patrolRoute: data.route,
                guardPosition: data.guardPosition,
                health: data.health,
                player1: this.mainPlayer,
                weapon: weapon,
                goal: constants_1.hw4_Statuses.REACHED_GOAL,
                status: statusArray,
                actions: actions,
                inRange: range,
            };
            this.enemies[lastIndex].addAI(EnemyAI_1.default, enemyOptions);
            if (pos !== null) {
                this.enemies[lastIndex].position = pos.clone();
            }
            this.battleManager.setEnemies(this.enemies.map((enemy) => enemy._ai));
        }
        initializeEnemies() {
            this.enemies = new Array(0);
            const enemyData = this.load.getObject("enemyData");
            for (let i = 0; i < enemyData.numEnemies; i++) {
                let data = enemyData.enemies[i];
                this.spawnEnemy(JSON.parse(JSON.stringify(data)), null);
            }
        }
        //this spawns in the last enemy of the enemy.json
        spawnImp(pos) {
            const enemyData = this.load.getObject("enemyData");
            let data = enemyData.enemies[20];
            this.spawnEnemy(JSON.parse(JSON.stringify(data)), pos);
        }
        spawnRandomEnemy() {
            let x = Math.random() * this.tileMapMaxSize.x;
            let y = Math.random() * this.tileMapMaxSize.y;
            let newPos = new Vec2_1.default(x, y);
            this.spawnImp(newPos);
        }
    }
    exports.default = mainScene;
    },{"../../Wolfie2D/AI/EnemyActions/AttackAction":2,"../../Wolfie2D/AI/EnemyActions/Berserk":3,"../../Wolfie2D/AI/EnemyActions/Move":4,"../../Wolfie2D/AI/EnemyActions/Retreat":5,"../../Wolfie2D/DataTypes/Graphs/PositionGraph":16,"../../Wolfie2D/DataTypes/Shapes/AABB":25,"../../Wolfie2D/DataTypes/Vec2":32,"../../Wolfie2D/Input/Input":40,"../../Wolfie2D/Nodes/Graphics/GraphicTypes":50,"../../Wolfie2D/Nodes/UIElements/UIElementTypes":64,"../../Wolfie2D/Pathfinding/Navmesh":67,"../../Wolfie2D/Registry/RegistryManager":73,"../../Wolfie2D/Scene/Scene":103,"../../Wolfie2D/Utils/Color":109,"../../Wolfie2D/constants":115,"../AI/EnemyAI":117,"../AI/PlayerController":118,"../GameSystems/BattleManager":119,"../GameSystems/InventoryManager":120,"../GameSystems/items/AttackDamage":121,"../GameSystems/items/AttackSpeed":122,"../GameSystems/items/Checkpoint":123,"../GameSystems/items/CheckpointCleared":124,"../GameSystems/items/Healthpack":125,"../GameSystems/items/MaxHealth":127,"../GameSystems/items/Speed":128,"../GameSystems/items/Weapon":129,"./GameOver":134,"./NextLevel":137}],137:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
    const UIElementTypes_1 = require("../../Wolfie2D/Nodes/UIElements/UIElementTypes");
    const Scene_1 = require("../../Wolfie2D/Scene/Scene");
    const Color_1 = require("../../Wolfie2D/Utils/Color");
    class NextLevel extends Scene_1.default {
        startScene() {
            const center = this.viewport.getCenter();
            this.addUILayer("primary");
            const nextlevel = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "primary", { position: new Vec2_1.default(center.x, center.y), text: "Next Level" });
            nextlevel.textColor = Color_1.default.WHITE;
        }
    }
    exports.default = NextLevel;
    },{"../../Wolfie2D/DataTypes/Vec2":32,"../../Wolfie2D/Nodes/UIElements/UIElementTypes":64,"../../Wolfie2D/Scene/Scene":103,"../../Wolfie2D/Utils/Color":109}]},{},[116])
    //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvV29sZmllMkQvQUkvQUlNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL0FJL0VuZW15QWN0aW9ucy9BdHRhY2tBY3Rpb24udHMiLCJzcmMvV29sZmllMkQvQUkvRW5lbXlBY3Rpb25zL0JlcnNlcmsudHMiLCJzcmMvV29sZmllMkQvQUkvRW5lbXlBY3Rpb25zL01vdmUudHMiLCJzcmMvV29sZmllMkQvQUkvRW5lbXlBY3Rpb25zL1JldHJlYXQudHMiLCJzcmMvV29sZmllMkQvQUkvRW5lbXlTdGF0ZXMvQWN0aXZlLnRzIiwic3JjL1dvbGZpZTJEL0FJL0VuZW15U3RhdGVzL0FsZXJ0LnRzIiwic3JjL1dvbGZpZTJEL0FJL0VuZW15U3RhdGVzL0VuZW15U3RhdGUudHMiLCJzcmMvV29sZmllMkQvQUkvRW5lbXlTdGF0ZXMvR3VhcmQudHMiLCJzcmMvV29sZmllMkQvQUkvRW5lbXlTdGF0ZXMvUGF0cm9sLnRzIiwic3JjL1dvbGZpZTJEL0FJL0dvYXBBY3Rpb25QbGFubmVyLnRzIiwic3JjL1dvbGZpZTJEL0FJL1N0YXRlTWFjaGluZUdvYXBBSS50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvRnVuY3Rpb25zL051bGxGdW5jLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9HcmFwaHMvRWRnZU5vZGUudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL0dyYXBocy9HcmFwaC50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvR3JhcGhzL1Bvc2l0aW9uR3JhcGgudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL0ludGVyZmFjZXMvR29hcEFjdGlvbi50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvSW50ZXJmYWNlcy9SZWdpb24udHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL01hcC50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvTWF0NHg0LnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9QaHlzaWNzL0FyZWFDb2xsaXNpb24udHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL1BoeXNpY3MvSGl0LnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9RdWV1ZS50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvUmVuZGVyaW5nL1dlYkdMUHJvZ3JhbVR5cGUudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL1NoYXBlcy9BQUJCLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9TaGFwZXMvQ2lyY2xlLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9TaGFwZXMvU2hhcGUudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL1N0YWNrLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9TdGF0ZS9TdGF0ZS50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvU3RhdGUvU3RhdGVNYWNoaW5lLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlc2V0LnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyLnRzIiwic3JjL1dvbGZpZTJEL0RlYnVnL0RlYnVnLnRzIiwic3JjL1dvbGZpZTJEL0RlYnVnL1N0YXRzLnRzIiwic3JjL1dvbGZpZTJEL0V2ZW50cy9FbWl0dGVyLnRzIiwic3JjL1dvbGZpZTJEL0V2ZW50cy9FdmVudFF1ZXVlLnRzIiwic3JjL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnQudHMiLCJzcmMvV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFR5cGUudHMiLCJzcmMvV29sZmllMkQvRXZlbnRzL1JlY2VpdmVyLnRzIiwic3JjL1dvbGZpZTJEL0lucHV0L0lucHV0LnRzIiwic3JjL1dvbGZpZTJEL0lucHV0L0lucHV0SGFuZGxlci50cyIsInNyYy9Xb2xmaWUyRC9Mb29wL0Vudmlyb25tZW50SW5pdGlhbGl6ZXIudHMiLCJzcmMvV29sZmllMkQvTG9vcC9GaXhlZFVwZGF0ZUdhbWVMb29wLnRzIiwic3JjL1dvbGZpZTJEL0xvb3AvR2FtZS50cyIsInNyYy9Xb2xmaWUyRC9Mb29wL0dhbWVMb29wLnRzIiwic3JjL1dvbGZpZTJEL0xvb3AvR2FtZU9wdGlvbnMudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvQ2FudmFzTm9kZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL0dyYXBoaWNUeXBlcy50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9MaW5lLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL1BhcnRpY2xlLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL1BvaW50LnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL1JlY3QudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9UaWxlbWFwLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudC50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL0J1dHRvbi50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvU2xpZGVyLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvVGV4dElucHV0LnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvVUlFbGVtZW50VHlwZXMudHMiLCJzcmMvV29sZmllMkQvUGF0aGZpbmRpbmcvTmF2aWdhdGlvbk1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvUGF0aGZpbmRpbmcvTmF2aWdhdGlvblBhdGgudHMiLCJzcmMvV29sZmllMkQvUGF0aGZpbmRpbmcvTmF2bWVzaC50cyIsInNyYy9Xb2xmaWUyRC9QaHlzaWNzL0Jhc2ljUGh5c2ljc01hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvUGh5c2ljcy9QaHlzaWNzTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9QbGF5YmFjay9SZWNvcmRlci50cyIsInNyYy9Xb2xmaWUyRC9SZWdpc3RyeS9SZWdpc3RyaWVzL1JlZ2lzdHJ5LnRzIiwic3JjL1dvbGZpZTJEL1JlZ2lzdHJ5L1JlZ2lzdHJpZXMvU2hhZGVyUmVnaXN0cnkudHMiLCJzcmMvV29sZmllMkQvUmVnaXN0cnkvUmVnaXN0cnlNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1JlZ2lzdHJ5L1dlYXBvblJlZ2lzdHJ5LnRzIiwic3JjL1dvbGZpZTJEL1JlZ2lzdHJ5L1dlYXBvblR5cGVSZWdpc3RyeS50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvQW5pbWF0aW9ucy9BbmltYXRpb25NYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9BbmltYXRpb25zL0FuaW1hdGlvblR5cGVzLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9BbmltYXRpb25zL1BhcnRpY2xlU3lzdGVtTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvQW5pbWF0aW9ucy9Ud2VlbkNvbnRyb2xsZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0FuaW1hdGlvbnMvVHdlZW5NYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9DYW52YXNSZW5kZXJlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvQ2FudmFzUmVuZGVyaW5nL0dyYXBoaWNSZW5kZXJlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvQ2FudmFzUmVuZGVyaW5nL1RpbGVtYXBSZW5kZXJlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvQ2FudmFzUmVuZGVyaW5nL1VJRWxlbWVudFJlbmRlcmVyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9SZW5kZXJpbmdNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9XZWJHTFJlbmRlcmVyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9MYWJlbFNoYWRlclR5cGUudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL1BvaW50U2hhZGVyVHlwZS50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZXMvUXVhZFNoYWRlclR5cGUudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL1JlY3RTaGFkZXJUeXBlLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9TcHJpdGVTaGFkZXJUeXBlLnRzIiwic3JjL1dvbGZpZTJEL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvU2NlbmVHcmFwaC9TY2VuZUdyYXBoLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lR3JhcGgvU2NlbmVHcmFwaEFycmF5LnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lR3JhcGgvVmlld3BvcnQudHMiLCJzcmMvV29sZmllMkQvU2NlbmUvRmFjdG9yaWVzL0NhbnZhc05vZGVGYWN0b3J5LnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL0ZhY3Rvcmllcy9GYWN0b3J5TWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9GYWN0b3JpZXMvVGlsZW1hcEZhY3RvcnkudHMiLCJzcmMvV29sZmllMkQvU2NlbmUvTGF5ZXIudHMiLCJzcmMvV29sZmllMkQvU2NlbmUvTGF5ZXJzL1BhcmFsbGF4TGF5ZXIudHMiLCJzcmMvV29sZmllMkQvU2NlbmUvTGF5ZXJzL1VJTGF5ZXIudHMiLCJzcmMvV29sZmllMkQvU2NlbmUvU2NlbmUudHMiLCJzcmMvV29sZmllMkQvU2NlbmUvU2NlbmVNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL1NjZW5lT3B0aW9ucy50cyIsInNyYy9Xb2xmaWUyRC9Tb3VuZC9BdWRpb01hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvVGltaW5nL1RpbWVyLnRzIiwic3JjL1dvbGZpZTJEL1RpbWluZy9UaW1lck1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvVXRpbHMvQ29sb3IudHMiLCJzcmMvV29sZmllMkQvVXRpbHMvRWFzZUZ1bmN0aW9ucy50cyIsInNyYy9Xb2xmaWUyRC9VdGlscy9HcmFwaFV0aWxzLnRzIiwic3JjL1dvbGZpZTJEL1V0aWxzL01hdGhVdGlscy50cyIsInNyYy9Xb2xmaWUyRC9VdGlscy9SZW5kZXJpbmdVdGlscy50cyIsInNyYy9Xb2xmaWUyRC9VdGlscy9TdHJpbmdVdGlscy50cyIsInNyYy9Xb2xmaWUyRC9jb25zdGFudHMudHMiLCJzcmMvbWFpbi50cyIsInNyYy9tYXloZW1GaWxlcy9BSS9FbmVteUFJLnRzIiwic3JjL21heWhlbUZpbGVzL0FJL1BsYXllckNvbnRyb2xsZXIudHMiLCJzcmMvbWF5aGVtRmlsZXMvR2FtZVN5c3RlbXMvQmF0dGxlTWFuYWdlci50cyIsInNyYy9tYXloZW1GaWxlcy9HYW1lU3lzdGVtcy9JbnZlbnRvcnlNYW5hZ2VyLnRzIiwic3JjL21heWhlbUZpbGVzL0dhbWVTeXN0ZW1zL2l0ZW1zL0F0dGFja0RhbWFnZS50cyIsInNyYy9tYXloZW1GaWxlcy9HYW1lU3lzdGVtcy9pdGVtcy9BdHRhY2tTcGVlZC50cyIsInNyYy9tYXloZW1GaWxlcy9HYW1lU3lzdGVtcy9pdGVtcy9DaGVja3BvaW50LnRzIiwic3JjL21heWhlbUZpbGVzL0dhbWVTeXN0ZW1zL2l0ZW1zL0NoZWNrcG9pbnRDbGVhcmVkLnRzIiwic3JjL21heWhlbUZpbGVzL0dhbWVTeXN0ZW1zL2l0ZW1zL0hlYWx0aHBhY2sudHMiLCJzcmMvbWF5aGVtRmlsZXMvR2FtZVN5c3RlbXMvaXRlbXMvSXRlbS50cyIsInNyYy9tYXloZW1GaWxlcy9HYW1lU3lzdGVtcy9pdGVtcy9NYXhIZWFsdGgudHMiLCJzcmMvbWF5aGVtRmlsZXMvR2FtZVN5c3RlbXMvaXRlbXMvU3BlZWQudHMiLCJzcmMvbWF5aGVtRmlsZXMvR2FtZVN5c3RlbXMvaXRlbXMvV2VhcG9uLnRzIiwic3JjL21heWhlbUZpbGVzL0dhbWVTeXN0ZW1zL2l0ZW1zL1dlYXBvblR5cGVzL0xhc2VyR3VuLnRzIiwic3JjL21heWhlbUZpbGVzL0dhbWVTeXN0ZW1zL2l0ZW1zL1dlYXBvblR5cGVzL1NlbWlBdXRvR3VuLnRzIiwic3JjL21heWhlbUZpbGVzL0dhbWVTeXN0ZW1zL2l0ZW1zL1dlYXBvblR5cGVzL1NsaWNlLnRzIiwic3JjL21heWhlbUZpbGVzL0dhbWVTeXN0ZW1zL2l0ZW1zL1dlYXBvblR5cGVzL1dlYXBvblR5cGUudHMiLCJzcmMvbWF5aGVtRmlsZXMvU2NlbmUvR2FtZU92ZXIudHMiLCJzcmMvbWF5aGVtRmlsZXMvU2NlbmUvTWFpbk1lbnUudHMiLCJzcmMvbWF5aGVtRmlsZXMvU2NlbmUvTWFpblNjZW5lLnRzIiwic3JjL21heWhlbUZpbGVzL1NjZW5lL05leHRMZXZlbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FDSUEsMENBQW1DO0FBRW5DOzs7R0FHRztBQUNILE1BQXFCLFNBQVM7SUFNN0I7UUFDQyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7UUFDMUIsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLGFBQUcsRUFBRSxDQUFDO0lBQy9CLENBQUM7SUFFRDs7O09BR0c7SUFDSCxhQUFhLENBQUMsS0FBWTtRQUN6QixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN6QixDQUFDO0lBRUQsV0FBVyxDQUFDLEtBQVk7UUFDdkIsSUFBSSxLQUFL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RyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSztZQUN0SCxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLO1lBQ2hILElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUs7WUFDbEgsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8s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SSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQzFCLE9BQU8sSUFBSSxDQUFDO0lBQ2IsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxZQUFZLENBQUMsS0FBVztRQUN2QixPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdEYsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxVQUFVLENBQUMsS0FBVztRQUNyQixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQzVDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsR0FBRyxDQUFDLEtBQVc7UUFDZCxPQUFPLElBQUksQ0FBQyxDQUFDLEdBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxVQUFVLENBQUMsS0FBVztRQUNyQixJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzFCLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDMUMsSUFBSSxLQUFLLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUVsQyxJQUFHLEtBQUssR0FBRyxDQUFDLEVBQUM7WUFDWixLQUFLLElBQUksQ0FBQyxHQUFDLElBQUksQ0FBQyxF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V0FBVyxHQUFHLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUMxRCxJQUFJLENBQUMscUJBQXFCLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDdkMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQzNFLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUN2QyxJQUFJLENBQUMscUJBQXFCLENBQUMsTUFBTSxFQUFFLENBQUM7U0FDcEM7UUFFRCxJQUFJLENBQUMscUJBQXFCLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQztJQUNoRCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxNQUFNLENBQUMsT0FBTyxDQUFDLElBQVUsRUFBRSxFQUFRLEVBQUUsS0FBWTtRQUNoRCxJQUFJLENBQUMscUJBQXFCLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQztRQUN6QyxJQUFJLENBQUMscUJBQXFCLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUUxRCxJQUFJLENBQUMscUJBQXFCLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDdkMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNsRCxJQUFJLENBQUMscUJBQXFCLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzlDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUN2QyxJQUFJLENBQUMscUJBQXFCLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxNQUFNLENBQUMsU0FBUyxDQUFDLEdBQVMsRUFBRSxLQUFZO1FBQ3ZD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R0FBRyxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQzFDLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsR0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxHQUFDLElBQUksRUFDaEUsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxDQUFDO0lBQzFDLENBQUM7SUFFRCxVQUFVLENBQUMsSUFBVSxFQUFFLE1BQVksRUFBRSxJQUFZO1FBQzdDLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDakQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztRQUNwQyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN0QixJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUMsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsQ0FBQztRQUNwRixJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDdEIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxV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QUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsbUJBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLG1CQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQzFLLENBQUM7SUFFRDs7O09BR0c7SUFDSCxNQUFNO1FBQ0wsT0FBTyxJQUFJLEtBQUssQ0FBQyxtQkFBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsbUJBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLG1CQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRSxtQkFBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUMxSyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsT0FBTztRQUNOLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDekMsQ0FBQztJQUVEOzs7T0FHRztJQUNILFFBQVE7UUFDUCxPQUFPLEdBQUcsR0FBRyxtQkFBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLG1CQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsbUJBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFD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Q0FBQyxHQUFHLEdBQUcsQ0FBQztZQUM1QyxJQUFJLEVBQUUsV0FBVztTQUNsQixDQUFDLENBQUM7UUFDSCxNQUFNLEtBQUssR0FBVSxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyw4QkFBYSxDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUU7WUFDbkUsUUFBUSxFQUFFLElBQUksY0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7WUFDNUMsSUFBSSxFQUFFLEtBQUs7U0FDWixDQUFDLENBQUM7UUFDSCxNQUFNLE1BQU0sR0FBVSxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyw4QkFBYSxDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUU7WUFDcEUsUUFBUSxFQUFFLElBQUksY0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7WUFDNUMsSUFBSSxFQUFFLE1BQU07U0FDYixDQUFDLENBQUM7UUFDSCxNQUFNLE1BQU0sR0FBVSxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyw4QkFBYSxDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUU7WUFDcEUsUUFBUSxFQUFFLElBQUksY0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDM0MsSUFBSSxFQUFFLE1BQU07U0FDYixDQUFDLENBQUM7UUFDSCxNQUFNLFdBQVcsR0FBVSxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyw4QkFBYSxDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUU7WUFDekUsUUFBUSxFQUFFLElBQUksY0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDM0MsSUFBSSxFQUFFLFdBQVc7U0FDbEIsQ0FBQyxDQUFDO1FBQ0gsTUFBTSxLQUFLLEdBQVUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMs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SSxDQUFDLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDO1FBQzlDLElBQUksTUFBTSxHQUFHLElBQUksY0FBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUM1QixJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3hCLENBQUM7Q0FDRjtBQXp2QkQsNEJBeXZCQzs7OztBQ2h5QkQsd0RBQWlEO0FBRWpELG1GQUErRTtBQUMvRSxzREFBK0M7QUFDL0Msc0RBQStDO0FBRS9DLE1BQXFCLFNBQVUsU0FBUSxlQUFLO0lBRXhDLFVBQVU7UUFDTixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBRXpDLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFM0IsTUFBTSxTQUFTLEdBQVUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsOEJBQWEsQ0FBQyxLQUFLLEVBQUUsU0FBUyxFQUFFLEVBQUMsUUFBUSxFQUFFLElBQUksY0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxZQUFZLEVBQUMsQ0FBQyxDQUFDO1FBQzFJLFNBQVMsQ0FBQyxTQUFTLEdBQUcsZUFBSyxDQUFDLEtBQUssQ0FBQztJQUN0QyxDQUFDO0NBQ0o7QUFWRCw0QkFVQyIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsImltcG9ydCBBY3RvciBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvQWN0b3JcIjtcbmltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VcGRhdGVhYmxlXCI7XG5pbXBvcnQgQUkgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL0FJXCI7XG5pbXBvcnQgR29hcEFJIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9Hb2FwQUlcIlxuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xuXG4vKipcbiAqIEEgbWFuYWdlciBjbGFzcyBmb3IgYWxsIG9mIHRoZSBBSSBpbiBhIHNjZW5lLlxuICogS2VlcHMgYSBsaXN0IG9mIHJlZ2lzdGVyZWQgYWN0b3JzIGFuZCBoYW5kbGVzIEFJIGdlbmVyYXRpb24gZm9yIGFjdG9ycy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQUlNYW5hZ2VyIGltcGxlbWVudHMgVXBkYXRlYWJsZSB7XG5cdC8qKiBUaGUgYXJyYXkgb2YgcmVnaXN0ZXJlZCBhY3RvcnMgKi9cblx0YWN0b3JzOiBBcnJheTxBY3Rvcj47XG5cdC8qKiBNYXBzIEFJIG5hbWVzIHRvIHRoZWlyIGNvbnN0cnVjdG9ycyAqL1xuXHRyZWdpc3RlcmVkQUk6IE1hcDxBSUNvbnN0cnVjdG9yPjtcblxuXHRjb25zdHJ1Y3Rvcigpe1xuXHRcdHRoaXMuYWN0b3JzID0gbmV3IEFycmF5KCk7XG5cdFx0dGhpcy5yZWdpc3RlcmVkQUkgPSBuZXcgTWFwKCk7XG5cdH1cblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIGFuIGFjdG9yIHdpdGggdGhlIEFJTWFuYWdlclxuXHQgKiBAcGFyYW0gYWN0b3IgVGhlIGFjdG9yIHRvIHJlZ2lzdGVyXG5cdCAqL1xuXHRyZWdpc3RlckFjdG9yKGFjdG9yOiBBY3Rvcik6IHZvaWQge1xuXHRcdHRoaXMuYWN0b3JzLnB1c2goYWN0b3IpO1xuXHR9XG5cblx0cmVtb3ZlQWN0b3IoYWN0b3I6IEFjdG9yKTogdm9pZCB7XG5cdFx0bGV0IGluZGV4ID0gdGhpcy5hY3RvcnMuaW5kZXhPZihhY3Rvcik7XG5cblx0XHRpZihpbmRleCAhPT0gLTEpe1xuXHRcdFx0dGhpcy5hY3RvcnMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIGFuIEFJIHdpdGggdGhlIEFJTWFuYWdlciBmb3IgdXNlIGxhdGVyIG9uXG5cdCAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBBSSB0byByZWdpc3RlclxuXHQgKiBAcGFyYW0gY29uc3RyIFRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIEFJXG5cdCAqL1xuXHRyZWdpc3RlckFJKG5hbWU6IHN0cmluZywgY29uc3RyOiBuZXcgPFQgZXh0ZW5kcyBBSSB8IEdvYXBBST4oKSA9PiBUICk6IHZvaWQge1xuXHRcdHRoaXMucmVnaXN0ZXJlZEFJLmFkZChuYW1lLCBjb25zdHIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyBhbiBBSSBpbnN0YW5jZSBmcm9tIGl0cyBuYW1lXG5cdCAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBBSSB0byBhZGRcblx0ICogQHJldHVybnMgQSBuZXcgQUkgaW5zdGFuY2Vcblx0ICovXG5cdGdlbmVyYXRlQUkobmFtZTogc3RyaW5nKTogQUkgfCBHb2FwQUkge1xuXHRcdGlmKHRoaXMucmVnaXN0ZXJlZEFJLmhhcyhuYW1lKSl7XG5cdFx0XHRyZXR1cm4gbmV3ICh0aGlzLnJlZ2lzdGVyZWRBSS5nZXQobmFtZSkpKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IGBDYW5ub3QgY3JlYXRlIEFJIHdpdGggbmFtZSAke25hbWV9LCBubyBBSSB3aXRoIHRoYXQgbmFtZSBpcyByZWdpc3RlcmVkYDtcblx0XHR9XG5cdH1cblxuXHR1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcblx0XHQvLyBSdW4gdGhlIGFpIGZvciBldmVyeSBhY3RpdmUgYWN0b3Jcblx0XHR0aGlzLmFjdG9ycy5mb3JFYWNoKGFjdG9yID0+IHsgaWYoYWN0b3IuYWlBY3RpdmUpIGFjdG9yLmFpLnVwZGF0ZShkZWx0YVQpIH0pO1xuXHR9XG59XG5cbnR5cGUgQUlDb25zdHJ1Y3RvciA9IG5ldyA8VCBleHRlbmRzIEFJPigpID0+IFQ7IiwiaW1wb3J0IFN0YXRlTWFjaGluZUdvYXBBSSBmcm9tIFwiLi4vU3RhdGVNYWNoaW5lR29hcEFJXCI7XHJcbmltcG9ydCBHb2FwQWN0aW9uIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9Hb2FwQWN0aW9uXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vLi4vRXZlbnRzL0VtaXR0ZXJcIjtcclxuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi8uLi9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgRW5lbXlBSSBmcm9tIFwiLi4vLi4vLi4vbWF5aGVtRmlsZXMvQUkvRW5lbXlBSVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXR0YWNrQWN0aW9uIGV4dGVuZHMgR29hcEFjdGlvbiB7XHJcbiAgcHJvdGVjdGVkIGVtaXR0ZXI6IEVtaXR0ZXI7XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgY29zdDogbnVtYmVyLFxyXG4gICAgcHJlY29uZGl0aW9uczogQXJyYXk8c3RyaW5nPixcclxuICAgIGVmZmVjdHM6IEFycmF5PHN0cmluZz4sXHJcbiAgICBvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55PlxyXG4gICkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMuY29zdCA9IGNvc3Q7XHJcbiAgICB0aGlzLnByZWNvbmRpdGlvbnMgPSBwcmVjb25kaXRpb25zO1xyXG4gICAgdGhpcy5lZmZlY3RzID0gZWZmZWN0cztcclxuICB9XHJcblxyXG4gIHBlcmZvcm1BY3Rpb24oXHJcbiAgICBzdGF0dXNlczogQXJyYXk8c3RyaW5nPixcclxuICAgIGFjdG9yOiBTdGF0ZU1hY2hpbmVHb2FwQUksXHJcbiAgICBkZWx0YVQ6IG51bWJlcixcclxuICAgIHRhcmdldD86IFN0YXRlTWFjaGluZUdvYXBBSVxyXG4gICk6IEFycmF5PHN0cmluZz4ge1xyXG4gICAgLy9DaGVjayBpZiBwcmVjb25kaXRpb25zIGFyZSBtZXQgZm9yIHRoaXMgYWN0aW9uIHRvIGJlIHBlcmZvcm1lZFxyXG4gICAgaWYgKHRoaXMuY2hlY2tQcmVjb25kaXRpb25zKHN0YXR1c2VzKSkge1xyXG4gICAgICBsZXQgZW5lbXkgPSA8RW5lbXlBST5hY3RvcjtcclxuXHJcbiAgICAgIC8vSWYgdGhlIHBsYXllciBpcyBvdXQgb2Ygc2lnaHQsIGRvbid0IGJvdGhlciBhdHRhY2tpbmdcclxuICAgICAgaWYgKGVuZW15LmdldFBsYXllclBvc2l0aW9uKCkgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvL1JhbmRvbWl6ZSBhdHRhY2sgZGlyZWN0aW9uLCBnaXZlcyB0aGUgZW5lbXkgZ3VuIHVzZXJzIHN0b3JtdHJvb3BlciBhaW1cclxuICAgICAgbGV0IGRpciA9IGVuZW15XHJcbiAgICAgICAgLmdldFBsYXllclBvc2l0aW9uKClcclxuICAgICAgICAuY2xvbmUoKVxyXG4gICAgICAgIC5zdWIoZW5lbXkub3duZXIucG9zaXRpb24pXHJcbiAgICAgICAgLm5vcm1hbGl6ZSgpO1xyXG4gICAgICBpZiAoZW5lbXkud2VhcG9uLnVzZShlbmVteS5vd25lciwgXCJlbmVteVwiLCBkaXIpKSB7XHJcbiAgICAgICAgLy8gSWYgd2UgZmlyZWQsIGZhY2UgdGhhdCBkaXJlY3Rpb25cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuZWZmZWN0cztcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlQ29zdChvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+KTogdm9pZCB7fVxyXG5cclxuICB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIFwiKEF0dGFja0FjdGlvbilcIjtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IFN0YXRlTWFjaGluZUdvYXBBSSBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvQUkvU3RhdGVNYWNoaW5lR29hcEFJXCI7XHJcbmltcG9ydCBHb2FwQWN0aW9uIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvSW50ZXJmYWNlcy9Hb2FwQWN0aW9uXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRXZlbnRzL0VtaXR0ZXJcIjtcclxuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgRW5lbXlBSSBmcm9tIFwiLi4vLi4vLi4vbWF5aGVtRmlsZXMvQUkvRW5lbXlBSVwiO1xyXG5pbXBvcnQgVGltZXIgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL1RpbWluZy9UaW1lclwiO1xyXG5cclxuXHJcbi8vIEhPTUVXT1JLIDQgLSBUT0RPXHJcbi8qKlxyXG4gKiBJbXBsZW1lbnQgYmVyc2VyayBhY3Rpb24gc28gdGhhdCB0aGUgZW5lbXkgZ2FpbnMgMS41eCBzcGVlZCwgMnggZGFtYWdlLCBhbmQgaGFzIGEgMnggbG93ZXIgY29vbGRvd24gb24gYXR0YWNraW5nLlxyXG4gKiBOb3RlIHRoYXQgeW91J2xsIGFsc28gbmVlZCB0byBtYW5hZ2UgaG93IGVuZW1pZXMgdXNlIHRoaXMgYWN0aW9uIGluIHRoZSBpbml0aWFsaXplRW5lbWllcyBtZXRob2QgaW4gaHc0X3NjZW5lLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmVyc2VyayBleHRlbmRzIEdvYXBBY3Rpb24ge1xyXG4gICAgcHJvdGVjdGVkIGVtaXR0ZXI6IEVtaXR0ZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3IoY29zdDogbnVtYmVyLCBwcmVjb25kaXRpb25zOiBBcnJheTxzdHJpbmc+LCBlZmZlY3RzOiBBcnJheTxzdHJpbmc+LCBvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5jb3N0ID0gY29zdDtcclxuICAgICAgICB0aGlzLnByZWNvbmRpdGlvbnMgPSBwcmVjb25kaXRpb25zO1xyXG4gICAgICAgIHRoaXMuZWZmZWN0cyA9IGVmZmVjdHM7XHJcbiAgICB9XHJcblxyXG4gICAgcGVyZm9ybUFjdGlvbihzdGF0dXNlczogQXJyYXk8c3RyaW5nPiwgYWN0b3I6IFN0YXRlTWFjaGluZUdvYXBBSSwgZGVsdGFUOiBudW1iZXIsIHRhcmdldD86IFN0YXRlTWFjaGluZUdvYXBBSSk6IEFycmF5PHN0cmluZz4ge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5jaGVja1ByZWNvbmRpdGlvbnMoc3RhdHVzZXMpKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJlbmVteSBnb2luZyBiZXJzZXJrXCIpO1xyXG4gICAgICAgICAgICBsZXQgZW5lbXkgPSA8RW5lbXlBST4gYWN0b3I7XHJcbiAgICAgICAgICAgIGxldCBuZXdUaW1lID0gZW5lbXkud2VhcG9uLnR5cGUuY29vbGRvd247XHJcbiAgICAgICAgICAgIGVuZW15LndlYXBvbi5jb29sZG93blRpbWVyID0gbmV3IFRpbWVyKG5ld1RpbWUqMC41KTsgLy8yeCBjZHIgLy9UT0RPOiB0byBzaG93IG9iaXZvdXMgYmVyc2Vyay8vIGNobmFnZSB0aGlzIGxhdGVyIHRvIDAuNVxyXG4gICAgICAgICAgICBlbmVteS53ZWFwb24udHlwZS5kYW1hZ2UgPSBlbmVteS53ZWFwb24udHlwZS5kYW1hZ2UqMjsgLy8yeCBkbWdcclxuICAgICAgICAgICAgZW5lbXkuc3BlZWQgPSBlbmVteS5zcGVlZCoyOyAvLzJ4IG1zXHJcbiAgICAgICAgICAgIC8vIGVuZW15LmN1cnJlbnRTdGF0dXMuZmlsdGVyKGZ1bmN0aW9uIChlKXtcclxuICAgICAgICAgICAgLy8gICAgIHJldHVybiBlIT09aHc0X1N0YXR1c2VzLkNBTl9CRVJTRVJLXHJcbiAgICAgICAgICAgIC8vIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWZmZWN0cztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZUNvc3Qob3B0aW9uczogUmVjb3JkPHN0cmluZywgbnVtYmVyPik6IHZvaWQge31cclxuXHJcbiAgICB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBcIihCZXJzZXJrKVwiO1xyXG4gICAgfVxyXG5cclxufSIsImltcG9ydCBTdGF0ZU1hY2hpbmVHb2FwQUkgZnJvbSBcIi4uL1N0YXRlTWFjaGluZUdvYXBBSVwiO1xyXG5pbXBvcnQgR29hcEFjdGlvbiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvR29hcEFjdGlvblwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEVtaXR0ZXIgZnJvbSBcIi4uLy4uL0V2ZW50cy9FbWl0dGVyXCI7XHJcbmltcG9ydCBOYXZpZ2F0aW9uUGF0aCBmcm9tIFwiLi4vLi4vUGF0aGZpbmRpbmcvTmF2aWdhdGlvblBhdGhcIjtcclxuaW1wb3J0IEVuZW15QUkgZnJvbSBcIi4uLy4uLy4uL21heWhlbUZpbGVzL0FJL0VuZW15QUlcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vdmUgZXh0ZW5kcyBHb2FwQWN0aW9uIHtcclxuICBwcml2YXRlIGluUmFuZ2U6IG51bWJlcjtcclxuXHJcbiAgcHJpdmF0ZSBwYXRoOiBOYXZpZ2F0aW9uUGF0aDtcclxuICBwcm90ZWN0ZWQgZW1pdHRlcjogRW1pdHRlcjtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBjb3N0OiBudW1iZXIsXHJcbiAgICBwcmVjb25kaXRpb25zOiBBcnJheTxzdHJpbmc+LFxyXG4gICAgZWZmZWN0czogQXJyYXk8c3RyaW5nPixcclxuICAgIG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+XHJcbiAgKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5jb3N0ID0gY29zdDtcclxuICAgIHRoaXMucHJlY29uZGl0aW9ucyA9IHByZWNvbmRpdGlvbnM7XHJcbiAgICB0aGlzLmVmZmVjdHMgPSBlZmZlY3RzO1xyXG4gICAgdGhpcy5sb29wQWN0aW9uID0gdHJ1ZTtcclxuICAgIHRoaXMuaW5SYW5nZSA9IG9wdGlvbnMuaW5SYW5nZTtcclxuICB9XHJcblxyXG4gIHBlcmZvcm1BY3Rpb24oXHJcbiAgICBzdGF0dXNlczogQXJyYXk8c3RyaW5nPixcclxuICAgIGFjdG9yOiBTdGF0ZU1hY2hpbmVHb2FwQUksXHJcbiAgICBkZWx0YVQ6IG51bWJlcixcclxuICAgIHRhcmdldD86IFN0YXRlTWFjaGluZUdvYXBBSVxyXG4gICk6IEFycmF5PHN0cmluZz4ge1xyXG4gICAgaWYgKHRoaXMuY2hlY2tQcmVjb25kaXRpb25zKHN0YXR1c2VzKSkge1xyXG4gICAgICAvL0NoZWNrIGRpc3RhbmNlIGZyb20gcGxheWVyXHJcbiAgICAgIGxldCBlbmVteSA9IDxFbmVteUFJPmFjdG9yO1xyXG4gICAgICBsZXQgcGxheWVyUG9zID0gZW5lbXkubGFzdFBsYXllclBvcztcclxuICAgICAgbGV0IGRpc3RhbmNlID0gZW5lbXkub3duZXIucG9zaXRpb24uZGlzdGFuY2VUbyhwbGF5ZXJQb3MpO1xyXG4gICAgICAvL0lmIGNsb3NlIGVub3VnaCwgd2UndmUgbW92ZWQgZmFyIGVub3VnaCBhbmQgdGhpcyBsb29wIGFjdGlvbiBpcyBkb25lXHJcbiAgICAgIGlmIChkaXN0YW5jZSA8PSB0aGlzLmluUmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lZmZlY3RzO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMucGF0aCA9IGVuZW15LnBhdGg7XHJcbiAgICAgIC8vT3RoZXJ3aXNlIG1vdmUgb24gcGF0aFxyXG4gICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5wYXRoLmdldE1vdmVEaXJlY3Rpb24oZW5lbXkub3duZXIpO1xyXG4gICAgICBpZiAoZGlyZWN0aW9uLnggPiAwKSB7XHJcbiAgICAgICAgZW5lbXkub3duZXIuYW5pbWF0aW9uLnBsYXlJZk5vdEFscmVhZHkoXCJydW5fcmlnaHRcIiwgdHJ1ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZW5lbXkub3duZXIuYW5pbWF0aW9uLnBsYXlJZk5vdEFscmVhZHkoXCJydW5fbGVmdFwiLCB0cnVlKTtcclxuICAgICAgfVxyXG4gICAgICBlbmVteS5vd25lci5tb3ZlT25QYXRoKGVuZW15LnNwZWVkICogZGVsdGFULCB0aGlzLnBhdGgpO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmVmZmVjdHM7XHJcbiAgfVxyXG5cclxuICB1cGRhdGVDb3N0KG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4pOiB2b2lkIHt9XHJcblxyXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gXCIoTW92ZSlcIjtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IFN0YXRlTWFjaGluZUdvYXBBSSBmcm9tIFwiLi4vU3RhdGVNYWNoaW5lR29hcEFJXCI7XG5pbXBvcnQgR29hcEFjdGlvbiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvR29hcEFjdGlvblwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vLi4vRXZlbnRzL0VtaXR0ZXJcIjtcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vLi4vTm9kZXMvR2FtZU5vZGVcIjtcbmltcG9ydCBOYXZpZ2F0aW9uUGF0aCBmcm9tIFwiLi4vLi4vUGF0aGZpbmRpbmcvTmF2aWdhdGlvblBhdGhcIjtcbmltcG9ydCB7IGh3NF9OYW1lcyB9IGZyb20gXCIuLi8uLi9jb25zdGFudHNcIjtcbmltcG9ydCBFbmVteUFJIGZyb20gXCIuLi8uLi8uLi9tYXloZW1GaWxlcy9BSS9FbmVteUFJXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJldHJlYXQgZXh0ZW5kcyBHb2FwQWN0aW9uIHtcbiAgICBwcml2YXRlIHJldHJlYXREaXN0YW5jZTogbnVtYmVyO1xuXG4gICAgcHJpdmF0ZSBwYXRoOiBOYXZpZ2F0aW9uUGF0aDtcbiAgICBwcm90ZWN0ZWQgZW1pdHRlcjogRW1pdHRlcjtcblxuICAgIGNvbnN0cnVjdG9yKGNvc3Q6IG51bWJlciwgcHJlY29uZGl0aW9uczogQXJyYXk8c3RyaW5nPiwgZWZmZWN0czogQXJyYXk8c3RyaW5nPiwgb3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb3N0ID0gY29zdDtcbiAgICAgICAgdGhpcy5wcmVjb25kaXRpb25zID0gcHJlY29uZGl0aW9ucztcbiAgICAgICAgdGhpcy5sb29wQWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lZmZlY3RzID0gZWZmZWN0cztcbiAgICAgICAgdGhpcy5yZXRyZWF0RGlzdGFuY2UgPSBvcHRpb25zLnJldHJlYXREaXN0YW5jZTtcbiAgICB9XG5cbiAgICAvLyBIT01FV09SSyA0IC0gVE9ET1xuICAgIC8qKlxuICAgICAqIEltcGxlbWVudCByZXRyZWF0IGFjdGlvbiBzbyB0aGF0IHRoZSBlbmVteSBjb25zdGFudGx5IG1vdmVzIGF3YXkgZnJvbSB0aGUgcGxheWVyIHVudGlsIHRoZXkgZ2V0IHBhc3QgdGhlIHJldHJlYXREaXN0YW5jZS4gSWYgdGhleSBzdWNjZXNmdWxseSBtb3ZlIFxuICAgICAqIGZhciBhd2F5IGVub3VnaCwgdGhleSBoZWFsIGJhY2sgdG8gdGhlaXIgbWF4IGhlYWx0aC4gVGhlIGxvdyBoZWFsdGggc3RhdHVzIHNob3VsZCBOT1QgYmUgcmVtb3ZlZCwgb25jZSBhbiBlbmVteSBpcyBsb3cgaGVhbHRoLCB0aGF0IHJlbWFpbnNcbiAgICAgKiBhcyBhIHN0YXR1cyBzaWduYWxpbmcgdGhlIGVuZW15IGhhcyBnb3R0ZW4gYmVsb3cgYSBjZXJ0YWluIGhlYWx0aCBvbmNlLlxuICAgICAqIFxuICAgICAqIExvb2sgYXQgb3RoZXIgYWN0aW9ucyBmb3IgaGludHMgYXMgdG8gaG93IHRoaXMgY2FuIGJlIGltcGxlbWVudGVkLCBhbmQga25vdyB0aGF0IHRoZXJlJ3MgYSBmdW5jdGlvbiBpbiBBY3RpdmUudHMgdGhhdCBpcyBuZWVkZWQgdG8gZnVsbHkgaW1wbGVtZW50XG4gICAgICogdGhpcy4gWW91J2xsIGtub3cgdGhpcyBhY3Rpb24gaWYgd29ya2luZyBjb3JyZWN0bHkgaWYgYSByZXRyZWF0aW5nIGVuZW15IGNoYW5nZXMgdGhlaXIgcmV0cmVhdCBkaXJlY3Rpb24gaWYgdGhlIHBsYXllciBtb3ZlcyBhcm91bmQsIHRyeWluZyB0byBnZXRcbiAgICAgKiBhcyBmYXIgYXdheSBhcyBwb3NzaWJsZS5cbiAgICAgKi9cbiAgICBwZXJmb3JtQWN0aW9uKHN0YXR1c2VzOiBBcnJheTxzdHJpbmc+LCBhY3RvcjogU3RhdGVNYWNoaW5lR29hcEFJLCBkZWx0YVQ6IG51bWJlciwgdGFyZ2V0PzogU3RhdGVNYWNoaW5lR29hcEFJKTogQXJyYXk8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHVwZGF0ZUNvc3Qob3B0aW9uczogUmVjb3JkPHN0cmluZywgbnVtYmVyPik6IHZvaWQge31cblxuICAgIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBcIihSZXRyZWF0KVwiO1xuICAgIH1cblxufSIsImltcG9ydCBBQUJCIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi8uLi9Ob2Rlcy9HYW1lTm9kZVwiO1xuaW1wb3J0IE9ydGhvZ29uYWxUaWxlbWFwIGZyb20gXCIuLi8uLi9Ob2Rlcy9UaWxlbWFwcy9PcnRob2dvbmFsVGlsZW1hcFwiO1xuaW1wb3J0IE5hdmlnYXRpb25QYXRoIGZyb20gXCIuLi8uLi9QYXRoZmluZGluZy9OYXZpZ2F0aW9uUGF0aFwiO1xuaW1wb3J0IFRpbWVyIGZyb20gXCIuLi8uLi9UaW1pbmcvVGltZXJcIjtcbmltcG9ydCB7IGh3NF9OYW1lcywgaHc0X1N0YXR1c2VzIH0gZnJvbSBcIi4uLy4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IEVuZW15QUksIHsgRW5lbXlTdGF0ZXMgfSBmcm9tIFwiLi4vLi4vLi4vbWF5aGVtRmlsZXMvQUkvRW5lbXlBSVwiO1xuaW1wb3J0IEVuZW15U3RhdGUgZnJvbSBcIi4vRW5lbXlTdGF0ZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBY3RpdmUgZXh0ZW5kcyBFbmVteVN0YXRlIHtcbiAgICAvLyBUaW1lcnMgZm9yIG1hbmFnaW5nIHRoaXMgc3RhdGVcbiAgICBwb2xsVGltZXI6IFRpbWVyO1xuICAgIGV4aXRUaW1lcjogVGltZXI7XG5cbiAgICAvLyBUaGUgcmV0dXJuIG9iamVjdCBmb3IgdGhpcyBzdGF0ZVxuICAgIHJldE9iajogUmVjb3JkPHN0cmluZywgYW55PjtcblxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogRW5lbXlBSSwgb3duZXI6IEdhbWVOb2RlKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgb3duZXIpO1xuXG4gICAgICAgIC8vIFJlZ3VsYXJseSB1cGRhdGUgdGhlIHBsYXllciBsb2NhdGlvblxuICAgICAgICB0aGlzLnBvbGxUaW1lciA9IG5ldyBUaW1lcigxMDApO1xuXG4gICAgICAgIHRoaXMuZXhpdFRpbWVyID0gbmV3IFRpbWVyKDEwMDApO1xuICAgIH1cblxuICAgIG9uRW50ZXIob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuICAgICAgICAvLyBSZXNldCB0aGUgcmV0dXJuIG9iamVjdFxuICAgICAgICB0aGlzLnJldE9iaiA9IHt9O1xuXG4gICAgICAgIC8vIENob29zZSBwYXRoIHRvIGxhc3Qgc2VlbiBwbGF5ZXIgcG9zaXRpb25cbiAgICAgICAgdGhpcy5yZXRPYmogPSB7IHRhcmdldDogdGhpcy5wYXJlbnQubGFzdFBsYXllclBvcyB9XG4gICAgICAgIHRoaXMucGFyZW50LnBhdGggPSB0aGlzLm93bmVyLmdldFNjZW5lKCkuZ2V0TmF2aWdhdGlvbk1hbmFnZXIoKS5nZXRQYXRoKGh3NF9OYW1lcy5OQVZNRVNILCB0aGlzLm93bmVyLnBvc2l0aW9uLCB0aGlzLnBhcmVudC5sYXN0UGxheWVyUG9zLCB0cnVlKTtcbiAgICAgICAgdGhpcy5waWNrUmV0cmVhdFBhdGgodGhpcy5wYXJlbnQucGF0aCk7XG4gICAgfVxuXG4gICAgaGFuZGxlSW5wdXQoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQgeyB9XG5cbiAgICAvLyBIT01FV09SSyA0IC0gVE9ET1xuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW5ldmVyIHdlJ3JlIGRlZmluaW5nIGEgcGF0aCB0b3dhcmRzIHRoZSBwbGF5ZXIsIGFuZCBpdCBzaG91bGQgY3JlYXRlIGEgcGF0aCB0aGF0IG1vdmVzXG4gICAgICogaW4gdGhlIGNvbXBsZXRlIG9wcG9zaXRlIGRpcmVjdGlvbi4gRm9yIGV4YW1wbGUsIGlmIHRoZSBwYXRoIHRvIHRoZSBwbGF5ZXIgaXMgbW92aW5nIHN0cmFpZ2h0IGxlZnQsIHRoaXMgbWV0aG9kIHNob3VsZCBjcmVhdGUgXG4gICAgICogYSByZXRyZWF0IHBhdGggdGhhdCBtb3ZlcyBzdHJhaWdodCByaWdodC4gVGhpcyBwYXRoIHNob3VsZCB0aGVuIGJlIHNldCB0byByZXRyZWF0UGF0aCBpbiBFbmVteUFJLlxuICAgICAqIFxuICAgICAqIFlvdSdsbCBoYXZlIHRvIGltcGxlbWVudCB0aGlzIGZ1bmN0aW9uIHNvIHlvdSBjYW4gdXNlIHJldHJlYXRQYXRoIGluIHRoZSBSZXRyZWF0IGFjdGlvbi5cbiAgICAgKi9cbiAgICBwaWNrUmV0cmVhdFBhdGgocGF0aFRvUGxheWVyOiBOYXZpZ2F0aW9uUGF0aCl7XG5cbiAgICB9XG5cbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgLy9Qb2xsIGZvciBwbGF5ZXIgcG9zaXRpb25cbiAgICAgICAgaWYgKHRoaXMucG9sbFRpbWVyLmlzU3RvcHBlZCgpKSB7XG4gICAgICAgICAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lclxuICAgICAgICAgICAgdGhpcy5wb2xsVGltZXIuc3RhcnQoKTtcblxuICAgICAgICAgICAgdGhpcy5wYXJlbnQucGxheWVyUG9zID0gdGhpcy5wYXJlbnQuZ2V0UGxheWVyUG9zaXRpb24oKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50LnBsYXllclBvcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIHNlZSBhIG5ldyBwbGF5ZXIgcG9zaXRpb24sIHVwZGF0ZSB0aGUgbGFzdCBwb3NpdGlvblxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnBhdGggPSB0aGlzLm93bmVyLmdldFNjZW5lKCkuZ2V0TmF2aWdhdGlvbk1hbmFnZXIoKS5nZXRQYXRoKGh3NF9OYW1lcy5OQVZNRVNILCB0aGlzLm93bmVyLnBvc2l0aW9uLCB0aGlzLnBhcmVudC5sYXN0UGxheWVyUG9zLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBpY2tSZXRyZWF0UGF0aCh0aGlzLnBhcmVudC5wYXRoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5sYXN0UGxheWVyUG9zID0gdGhpcy5wYXJlbnQucGxheWVyUG9zO1xuICAgICAgICAgICAgICAgIHRoaXMuZXhpdFRpbWVyLnN0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5leGl0VGltZXIuaXNTdG9wcGVkKCkpIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmVuJ3Qgc2VlbiB0aGUgcGxheWVyIGluIGEgd2hpbGUsIGdvIGNoZWNrIG91dCB3aGVyZSB3ZSBsYXN0IHNhdyB0aGVtLCBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Lmxhc3RQbGF5ZXJQb3MgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJldE9iaiA9IHsgdGFyZ2V0OiB0aGlzLnBhcmVudC5sYXN0UGxheWVyUG9zIH1cbiAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaGVkKEVuZW15U3RhdGVzLkFMRVJUKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5pc2hlZChFbmVteVN0YXRlcy5ERUZBVUxUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vQWRkIGluIHJhbmdlIHRvIHN0YXR1cyBpZiBjbG9zZSBlbm91Z2ggdG8gYSBwbGF5ZXJcbiAgICAgICAgaWYgKHRoaXMucGFyZW50LnBsYXllclBvcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGRpc3RhbmNlID0gdGhpcy5vd25lci5wb3NpdGlvbi5kaXN0YW5jZVRvKHRoaXMucGFyZW50LnBsYXllclBvcyk7XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiB0aGlzLnBhcmVudC5pblJhbmdlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5wYXJlbnQuY3VycmVudFN0YXR1cy5pbmRleE9mKGh3NF9TdGF0dXNlcy5JTl9SQU5HRSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmN1cnJlbnRTdGF0dXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL0Nob29zZSBuZXh0IGFjdGlvblxuICAgICAgICBsZXQgbmV4dEFjdGlvbiA9IHRoaXMucGFyZW50LnBsYW4ucGVlaygpO1xuXG4gICAgICAgIC8vUGVyZm9ybSB0aGUgYWN0aW9uXG4gICAgICAgIGxldCByZXN1bHQgPSBuZXh0QWN0aW9uLnBlcmZvcm1BY3Rpb24odGhpcy5wYXJlbnQuY3VycmVudFN0YXR1cywgdGhpcy5wYXJlbnQsIGRlbHRhVCk7XG5cbiAgICAgICAgLy9PdXIgYWN0aW9uIHdhcyBzdWNjZXNzZnVsXG4gICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vSWYgdGhlIGFjdGlvbiB3YXMgUmV0cmVhdCBvciBCZXJzZXJrLCByZW1vdmUgdGhlIENBTl9SRVRSRUFUIG9yIENBTl9CRVJTRVJLIHN0YXR1cyBmcm9tIHRoZSBlbmVteSwgdGhleSBjYW4gb25seSB1c2UgdGhlbSBvbmNlXG4gICAgICAgICAgICBpZiAobmV4dEFjdGlvbi50b1N0cmluZygpID09PSBcIihSZXRyZWF0KVwiKXtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLnBhcmVudC5jdXJyZW50U3RhdHVzLmluZGV4T2YoaHc0X1N0YXR1c2VzLkNBTl9SRVRSRUFUKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY3VycmVudFN0YXR1cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0QWN0aW9uLnRvU3RyaW5nKCkgPT09IFwiKEJlcnNlcmspXCIpe1xuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMucGFyZW50LmN1cnJlbnRTdGF0dXMuaW5kZXhPZihodzRfU3RhdHVzZXMuQ0FOX0JFUlNFUkspO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jdXJyZW50U3RhdHVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL1RoZSBhY3Rpb24gaGFzIG5vdCByZWFjaGVkIHRoZSBnb2FsIHlldCwgcGFzcyBhbG9uZyB0aGUgZWZmZWN0cyBvZiBvdXIgYWN0aW9uXG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5pbmNsdWRlcyhodzRfU3RhdHVzZXMuUkVBQ0hFRF9HT0FMKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmN1cnJlbnRTdGF0dXMgPSB0aGlzLnBhcmVudC5jdXJyZW50U3RhdHVzLmNvbmNhdCguLi5yZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wYXJlbnQucGxhbi5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE91ciBhY3Rpb24gd2FzIG5vdCBzdWNjZXNzZnVsLiBIb3dldmVyLCBpZiB0aGUgYWN0aW9uIHdhcyBhIGxvb3AgYWN0aW9uIGxpa2UgTW92ZSwgd2UgY29udGludWUgdG8gZG8gaXQgdW50aWwgaXQncyBzdWNjZXNmdWxcbiAgICAgICAgICAgIGlmICghbmV4dEFjdGlvbi5sb29wQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQucGxhbi5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgb25FeGl0KCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXRPYmo7XG4gICAgfVxuXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi8uLi9FdmVudHMvR2FtZUV2ZW50XCI7XG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uLy4uL05vZGVzL0dhbWVOb2RlXCI7XG5pbXBvcnQgTmF2aWdhdGlvblBhdGggZnJvbSBcIi4uLy4uL1BhdGhmaW5kaW5nL05hdmlnYXRpb25QYXRoXCI7XG5pbXBvcnQgVGltZXIgZnJvbSBcIi4uLy4uL1RpbWluZy9UaW1lclwiO1xuaW1wb3J0IHsgaHc0X05hbWVzIH0gZnJvbSBcIi4uLy4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IEVuZW15QUksIHsgRW5lbXlTdGF0ZXMgfSBmcm9tIFwiLi4vLi4vLi4vbWF5aGVtRmlsZXMvQUkvRW5lbXlBSVwiO1xuaW1wb3J0IEVuZW15U3RhdGUgZnJvbSBcIi4vRW5lbXlTdGF0ZVwiO1xuXG4vKiogV2hlbiBhbiBlbmVteSBoYXMgc2VlbiBhIHBsYXllciByZWNlbnRseSwgaXQgd2lsbCBtb3ZlIHRvIHRoZSBsYXN0IGtub3duIGxvY2F0aW9uIHRoZXkgc2F3IHRoZW0sIGdpdmluZyB1cCBhZnRlciBhIGNlcnRhaW4gdGltZSAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWxlcnQgZXh0ZW5kcyBFbmVteVN0YXRlIHtcbiAgICAvKiogVGhlIHBhdGggdG8gbW92ZSB0b3dhcmRzIHRoZSBhbGVydCBwb3NpdGlvbiBvbiAqL1xuICAgIHByaXZhdGUgcGF0aDogTmF2aWdhdGlvblBhdGg7XG5cbiAgICAvKiogQSB0aW1lciB0byB0ZWxsIHVzIGhvdyBsb25nIHRvIGJlIGFsZXJ0ZWQgZm9yICovXG4gICAgcHJpdmF0ZSBhbGVydFRpbWVyOiBUaW1lcjtcblxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogRW5lbXlBSSwgb3duZXI6IEdhbWVOb2RlKXtcbiAgICAgICAgc3VwZXIocGFyZW50LCBvd25lcik7XG5cbiAgICAgICAgdGhpcy5hbGVydFRpbWVyID0gbmV3IFRpbWVyKDEwMDAwKTtcbiAgICB9XG4gICAgXG4gICAgLy8gUmVjZWl2ZXMgb3B0aW9ucy50YXJnZXRcbiAgICBvbkVudGVyKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hbGVydFRpbWVyLnN0YXJ0KCk7XG4gICAgICAgIHRoaXMucGF0aCA9IHRoaXMub3duZXIuZ2V0U2NlbmUoKS5nZXROYXZpZ2F0aW9uTWFuYWdlcigpLmdldFBhdGgoaHc0X05hbWVzLk5BVk1FU0gsIHRoaXMub3duZXIucG9zaXRpb24sIG9wdGlvbnMudGFyZ2V0LCB0cnVlKTtcbiAgICB9XG5cbiAgICBoYW5kbGVJbnB1dChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XG5cbiAgICB9XG5cbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgaWYodGhpcy5hbGVydFRpbWVyLmlzU3RvcHBlZCgpKXtcbiAgICAgICAgICAgIC8vIFRoZSB0aW1lciBpcyB1cCwgcmV0dXJuIHRvIHRoZSBkZWZhdWx0IHN0YXRlXG4gICAgICAgICAgICB0aGlzLmZpbmlzaGVkKEVuZW15U3RhdGVzLkRFRkFVTFQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICB0aGlzLm93bmVyLm1vdmVPblBhdGgodGhpcy5wYXJlbnQuc3BlZWQgKiBkZWx0YVQsIHRoaXMucGF0aCk7XG4gICAgICAgICAgICB0aGlzLm93bmVyLnJvdGF0aW9uID0gVmVjMi5VUC5hbmdsZVRvQ0NXKHRoaXMucGF0aC5nZXRNb3ZlRGlyZWN0aW9uKHRoaXMub3duZXIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIHNlZSBvbmUgb2YgdGhlIHBsYXllcnMsIHRhcmdldCB0aGVtIGFuZCBtb3ZlIGludG8gYWN0aXZlIG1vZGVcbiAgICAgICAgdGhpcy5wYXJlbnQubGFzdFBsYXllclBvcyA9IHRoaXMucGFyZW50LmdldFBsYXllclBvc2l0aW9uKCk7XG4gICAgICAgIGlmKHRoaXMucGFyZW50Lmxhc3RQbGF5ZXJQb3MgIT09IG51bGwpe1xuICAgICAgICAgICAgdGhpcy5maW5pc2hlZChFbmVteVN0YXRlcy5UQVJHRVRJTkcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25FeGl0KCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuXG59IiwiaW1wb3J0IFN0YXRlIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvU3RhdGUvU3RhdGVcIjtcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vLi4vTm9kZXMvR2FtZU5vZGVcIjtcbmltcG9ydCBFbmVteUFJIGZyb20gXCIuLi8uLi8uLi9tYXloZW1GaWxlcy9BSS9FbmVteUFJXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIEVuZW15U3RhdGUgZXh0ZW5kcyBTdGF0ZSB7XG4gICAgcHJvdGVjdGVkIHBhcmVudDogRW5lbXlBSTtcbiAgICBwcm90ZWN0ZWQgb3duZXI6IEdhbWVOb2RlO1xuXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBFbmVteUFJLCBvd25lcjogR2FtZU5vZGUpe1xuICAgICAgc3VwZXIocGFyZW50KTtcbiAgICAgIHRoaXMub3duZXIgPSBvd25lcjtcbiAgICB9XG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi8uLi9FdmVudHMvR2FtZUV2ZW50XCI7XG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uLy4uL05vZGVzL0dhbWVOb2RlXCI7XG5pbXBvcnQgTmF2aWdhdGlvblBhdGggZnJvbSBcIi4uLy4uL1BhdGhmaW5kaW5nL05hdmlnYXRpb25QYXRoXCI7XG5pbXBvcnQgeyBodzRfRXZlbnRzLCBodzRfTmFtZXMgfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgRW5lbXlBSSwgeyBFbmVteVN0YXRlcyB9IGZyb20gXCIuLi8uLi8uLi9tYXloZW1GaWxlcy9BSS9FbmVteUFJXCI7XG5pbXBvcnQgRW5lbXlTdGF0ZSBmcm9tIFwiLi9FbmVteVN0YXRlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEd1YXJkIGV4dGVuZHMgRW5lbXlTdGF0ZSB7XG4gICAgcHJpdmF0ZSBndWFyZFBvc2l0aW9uOiBWZWMyO1xuXG4gICAgcHJpdmF0ZSBhd2F5RnJvbUd1YXJkUG9zaXRpb246IGJvb2xlYW47XG5cbiAgICBwcml2YXRlIHJvdXRlOiBOYXZpZ2F0aW9uUGF0aDtcblxuICAgIHByaXZhdGUgcmV0T2JqOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICAgIFxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogRW5lbXlBSSwgb3duZXI6IEdhbWVOb2RlLCBndWFyZFBvc2l0aW9uOiBWZWMyKXtcbiAgICAgICAgc3VwZXIocGFyZW50LCBvd25lcik7XG5cbiAgICAgICAgdGhpcy5ndWFyZFBvc2l0aW9uID0gZ3VhcmRQb3NpdGlvbjtcbiAgICB9XG5cbiAgICBvbkVudGVyKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcbiAgICAgICAgLy8gR28gdG8gdGhlIGd1YXJkIHBvc2l0aW9uIGlmIG5vdCBhbHJlYWR5IHRoZXJlXG4gICAgICAgIGlmKCEodGhpcy5vd25lci5wb3NpdGlvbi5kaXN0YW5jZVNxVG8odGhpcy5ndWFyZFBvc2l0aW9uKSA8IDgqOCkpe1xuICAgICAgICAgICAgLy8gV2UgbmVlZCBhIG5ldyByb3V0ZVxuICAgICAgICAgICAgdGhpcy5hd2F5RnJvbUd1YXJkUG9zaXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5vd25lci5wYXRoZmluZGluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnJvdXRlID0gdGhpcy5vd25lci5nZXRTY2VuZSgpLmdldE5hdmlnYXRpb25NYW5hZ2VyKCkuZ2V0UGF0aChodzRfTmFtZXMuTkFWTUVTSCwgdGhpcy5vd25lci5wb3NpdGlvbiwgdGhpcy5ndWFyZFBvc2l0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXdheUZyb21HdWFyZFBvc2l0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm93bmVyLnBhdGhmaW5kaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVJbnB1dChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7IH1cblxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBpZih0aGlzLmF3YXlGcm9tR3VhcmRQb3NpdGlvbil7XG4gICAgICAgICAgICAvLyBOYXZpZ2F0ZSBiYWNrIGhvbWVcbiAgICAgICAgICAgIGlmKHRoaXMucm91dGUuaXNEb25lKCkpe1xuICAgICAgICAgICAgICAgIHRoaXMuYXdheUZyb21HdWFyZFBvc2l0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5vd25lci5wYXRoZmluZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm93bmVyLm1vdmVPblBhdGgodGhpcy5wYXJlbnQuc3BlZWQgKiBkZWx0YVQsIHRoaXMucm91dGUpO1xuICAgICAgICAgICAgICAgIHRoaXMub3duZXIucm90YXRpb24gPSBWZWMyLlVQLmFuZ2xlVG9DQ1codGhpcy5yb3V0ZS5nZXRNb3ZlRGlyZWN0aW9uKHRoaXMub3duZXIpKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wYXJlbnQubGFzdFBsYXllclBvcyA9IHRoaXMucGFyZW50LmdldFBsYXllclBvc2l0aW9uKCk7XG4gICAgICAgIGlmKHRoaXMucGFyZW50Lmxhc3RQbGF5ZXJQb3MgIT09IG51bGwpe1xuICAgICAgICAgICAgdGhpcy5maW5pc2hlZChFbmVteVN0YXRlcy5UQVJHRVRJTkcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25FeGl0KCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXRPYmo7XG4gICAgfVxuXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi8uLi9FdmVudHMvR2FtZUV2ZW50XCI7XG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uLy4uL05vZGVzL0dhbWVOb2RlXCI7XG5pbXBvcnQgTmF2aWdhdGlvblBhdGggZnJvbSBcIi4uLy4uL1BhdGhmaW5kaW5nL05hdmlnYXRpb25QYXRoXCI7XG5pbXBvcnQgeyBodzRfRXZlbnRzLCBodzRfTmFtZXMgfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgRW5lbXlBSSwgeyBFbmVteVN0YXRlcyB9IGZyb20gXCIuLi8uLi8uLi9tYXloZW1GaWxlcy9BSS9FbmVteUFJXCI7XG5pbXBvcnQgRW5lbXlTdGF0ZSBmcm9tIFwiLi9FbmVteVN0YXRlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhdHJvbCBleHRlbmRzIEVuZW15U3RhdGUge1xuXG4gICAgLy8gVGhlIHJvdXRlIHRoaXMgQUkgdGFrZXMgd2hlbiBwYXRyb2xsaW5nXG4gICAgcHJvdGVjdGVkIHBhdHJvbFJvdXRlOiBBcnJheTxWZWMyPjtcblxuICAgIC8vIFRoZSBjdXJyZW50IHBhdHJvbFJvdXRlIGluZGV4XG4gICAgcHJvdGVjdGVkIHJvdXRlSW5kZXg6IG51bWJlcjtcblxuICAgIC8vIFRoZSBjdXJyZW50IHBhdGhcbiAgICBwcm90ZWN0ZWQgY3VycmVudFBhdGg6IE5hdmlnYXRpb25QYXRoO1xuXG4gICAgLy8gQSByZXR1cm4gb2JqZWN0IGZvciBleGl0aW5nIHRoaXMgc3RhdGVcbiAgICBwcm90ZWN0ZWQgcmV0T2JqOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBFbmVteUFJLCBvd25lcjogR2FtZU5vZGUsIHBhdHJvbFJvdXRlOiBBcnJheTxWZWMyPil7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgb3duZXIpO1xuXG4gICAgICAgIHRoaXMucGF0cm9sUm91dGUgPSBwYXRyb2xSb3V0ZTtcbiAgICAgICAgdGhpcy5yb3V0ZUluZGV4ID0gMDtcbiAgICB9XG5cbiAgICBvbkVudGVyKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jdXJyZW50UGF0aCA9IHRoaXMuZ2V0TmV4dFBhdGgoKTtcbiAgICB9XG5cbiAgICBoYW5kbGVJbnB1dChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7IH1cblxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICAvLyBJZiB0aGUgZW5lbXkgc2VlcyB0aGUgcGxheWVyLCBzdGFydCBhdHRhY2tpbmdcbiAgICAgICAgdGhpcy5wYXJlbnQubGFzdFBsYXllclBvcyA9IHRoaXMucGFyZW50LmdldFBsYXllclBvc2l0aW9uKCk7XG4gICAgICAgIGlmKHRoaXMucGFyZW50Lmxhc3RQbGF5ZXJQb3MgIT09IG51bGwpe1xuICAgICAgICAgICAgdGhpcy5maW5pc2hlZChFbmVteVN0YXRlcy5UQVJHRVRJTkcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICAvL01vdmUgYWxvbmcgcGF0cm9sIHBhdGhcbiAgICAgICAgICAgIGlmKHRoaXMuY3VycmVudFBhdGguaXNEb25lKCkpe1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGggPSB0aGlzLmdldE5leHRQYXRoKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub3duZXIubW92ZU9uUGF0aCh0aGlzLnBhcmVudC5zcGVlZCAqIGRlbHRhVCwgdGhpcy5jdXJyZW50UGF0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vd25lci5yb3RhdGlvbiA9IFZlYzIuVVAuYW5nbGVUb0NDVyh0aGlzLmN1cnJlbnRQYXRoLmdldE1vdmVEaXJlY3Rpb24odGhpcy5vd25lcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25FeGl0KCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXRPYmo7XG4gICAgfVxuXG4gICAgZ2V0TmV4dFBhdGgoKTogTmF2aWdhdGlvblBhdGgge1xuICAgICAgICBsZXQgcGF0aCA9IHRoaXMub3duZXIuZ2V0U2NlbmUoKS5nZXROYXZpZ2F0aW9uTWFuYWdlcigpLmdldFBhdGgoaHc0X05hbWVzLk5BVk1FU0gsIHRoaXMub3duZXIucG9zaXRpb24sIHRoaXMucGF0cm9sUm91dGVbdGhpcy5yb3V0ZUluZGV4XSk7XG4gICAgICAgIHRoaXMucm91dGVJbmRleCA9ICh0aGlzLnJvdXRlSW5kZXggKyAxKSV0aGlzLnBhdHJvbFJvdXRlLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuXG59IiwiaW1wb3J0IEdyYXBoIGZyb20gXCIuLi9EYXRhVHlwZXMvR3JhcGhzL0dyYXBoXCI7XG5pbXBvcnQgR29hcEFjdGlvbiBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvR29hcEFjdGlvblwiO1xuaW1wb3J0IEdvYXBBSSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvR29hcEFJXCI7XG5pbXBvcnQgUXVldWUgZnJvbSBcIi4uL0RhdGFUeXBlcy9RdWV1ZVwiO1xuaW1wb3J0IFN0YWNrIGZyb20gXCIuLi9EYXRhVHlwZXMvU3RhY2tcIjtcbmltcG9ydCBHcmFwaFV0aWxzIGZyb20gXCIuLi9VdGlscy9HcmFwaFV0aWxzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdvYXBBY3Rpb25QbGFubmVyIHtcbiAgICBtYXBwaW5nOiBNYXA8bnVtYmVyLEdvYXBBY3Rpb24gfCBzdHJpbmc+O1xuICAgIGdyYXBoOiBHcmFwaDtcbiAgICBwYXRoOiBBcnJheTxudW1iZXI+O1xuXG4gICAgcGxhbihnb2FsOiBzdHJpbmcsIHBvc3NpYmxlQWN0aW9uczogQXJyYXk8R29hcEFjdGlvbj4sIGN1cnJlbnRTdGF0dXM6IEFycmF5PHN0cmluZz4sIGFjdG9yOiBHb2FwQUkpOiBTdGFjazxHb2FwQWN0aW9uPiB7XG4gICAgICAgIHRoaXMuZ3JhcGggPSBuZXcgR3JhcGgodHJ1ZSk7XG4gICAgICAgIHRoaXMubWFwcGluZyA9IG5ldyBNYXAoKTtcblxuICAgICAgICAvLzAgaXMgb3VyIHJvb3RcbiAgICAgICAgdGhpcy5ncmFwaC5hZGROb2RlKCk7XG4gICAgICAgIHRoaXMubWFwcGluZy5zZXQoMCxcIlN0YXJ0XCIpO1xuICAgICAgICAvLzEgaXMgdGhlIGdvYWxcbiAgICAgICAgdGhpcy5ncmFwaC5hZGROb2RlKCk7XG4gICAgICAgIHRoaXMubWFwcGluZy5zZXQoMSxcIkdvYWxcIik7XG4gICAgICAgIHRoaXMuZ3JhcGguYWRkRWRnZSgxLDEsTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcblxuICAgICAgICAvL0J1aWxkIHRyZWUgZnJvbSAwIHRvIDFcbiAgICAgICAgdGhpcy5idWlsZFRyZWUoMCwgZ29hbCwgcG9zc2libGVBY3Rpb25zLCBjdXJyZW50U3RhdHVzKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLmdyYXBoLnRvU3RyaW5nKCkpO1xuXG4gICAgICAgIC8vUnVuIGRqaWtzdHJhIHRvIGZpbmQgc2hvcnRlc3QgcGF0aFxuICAgICAgICB0aGlzLnBhdGggPSBHcmFwaFV0aWxzLmRqaWtzdHJhKHRoaXMuZ3JhcGgsIDApO1xuXG4gICAgICAgIC8vUHVzaCBhbGwgZWxlbWVudHMgb2YgdGhlIHBsYW5cbiAgICAgICAgbGV0IHBsYW4gPSBuZXcgU3RhY2s8R29hcEFjdGlvbj4oKTtcblx0XHRcblx0XHRsZXQgaSA9IDE7XG5cdFx0d2hpbGUodGhpcy5wYXRoW2ldICE9PSAtMSl7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMucGF0aFtpXSk7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXRoW2ldICE9PSAwKXtcblx0XHRcdCAgICBwbGFuLnB1c2goPEdvYXBBY3Rpb24+dGhpcy5tYXBwaW5nLmdldCh0aGlzLnBhdGhbaV0pKTtcbiAgICAgICAgICAgIH1cblx0XHRcdGkgPSB0aGlzLnBhdGhbaV07XG5cdFx0fVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHBsYW47XG4gICAgfVxuXG4gICAgYnVpbGRUcmVlKHJvb3Q6IG51bWJlciwgZ29hbDpzdHJpbmcsIHBvc3NpYmxlQWN0aW9uczogQXJyYXk8R29hcEFjdGlvbj4sIGN1cnJlbnRTdGF0dXM6IEFycmF5PHN0cmluZz4pOiB2b2lkIHtcbiAgICAgICAgLy9Gb3IgZWFjaCBwb3NzaWJsZSBhY3Rpb24gXG4gICAgICAgIHBvc3NpYmxlQWN0aW9ucy5mb3JFYWNoKGFjdGlvbiA9PiB7XG4gICAgICAgICAgICAvKmNvbnNvbGUubG9nKFwicm9vdDpcIiArIHJvb3QgKyBcIixhY3Rpb24gcHJlY29uczpcIiArIGFjdGlvbi5wcmVjb25kaXRpb25zLnRvU3RyaW5nKCkgXG4gICAgICAgICAgICAgICAgKyBcIiwgYWN0aW9uIGVmZmVjdHM6XCIgKyBhY3Rpb24uZWZmZWN0cy50b1N0cmluZygpICsgXCIsIGN1cnJlbnQgU3RhdHVzOlwiICsgY3VycmVudFN0YXR1cy50b1N0cmluZygpKSovXG5cbiAgICAgICAgICAgIC8vQ2FuIGl0IGJlIHBlcmZvcm1lZD9cbiAgICAgICAgICAgIGlmIChhY3Rpb24uY2hlY2tQcmVjb25kaXRpb25zKGN1cnJlbnRTdGF0dXMpKXtcbiAgICAgICAgICAgICAgICAvL1RoaXMgYWN0aW9uIGNhbiBiZSBwZXJmb3JtZWRcbiAgICAgICAgICAgICAgICAvL0FkZCBlZmZlY3RzIHRvIGN1cnJlbnRTdGF0dXNcbiAgICAgICAgICAgICAgICBsZXQgbmV3U3RhdHVzID0gWy4uLmN1cnJlbnRTdGF0dXNdO1xuICAgICAgICAgICAgICAgIG5ld1N0YXR1cy5wdXNoKC4uLmFjdGlvbi5lZmZlY3RzKTtcblxuICAgICAgICAgICAgICAgIC8vQ2hlY2sgaWYgdGhlIG5ldyBub2RlIGlzIHRoZSBnb2FsXG4gICAgICAgICAgICAgICAgaWYgKG5ld1N0YXR1cy5pbmNsdWRlcyhnb2FsKSl7XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJBVCBHT0FMXCIpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3Tm9kZSA9IHRoaXMuZ3JhcGguYWRkTm9kZSgpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBwaW5nLnNldChuZXdOb2RlLCBhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyYXBoLmFkZEVkZ2Uocm9vdCwgbmV3Tm9kZSwgYWN0aW9uLmNvc3QpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyYXBoLmFkZEVkZ2UobmV3Tm9kZSwgMSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL0FkZCBub2RlIGFuZCBlZGdlIGZyb20gcm9vdFxuICAgICAgICAgICAgICAgIGxldCBuZXdOb2RlID0gdGhpcy5ncmFwaC5hZGROb2RlKCkgLSAxO1xuICAgICAgICAgICAgICAgIHRoaXMubWFwcGluZy5zZXQobmV3Tm9kZSwgYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoLmFkZEVkZ2Uocm9vdCwgbmV3Tm9kZSwgYWN0aW9uLmNvc3QpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vUmVjdXJzaXZlIGNhbGxcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHBvc3NpYmxlQWN0aW9ucy5pbmRleE9mKGFjdGlvbikpXG4gICAgICAgICAgICAgICAgbGV0IG5ld0FjdGlvbnMgPSBwb3NzaWJsZUFjdGlvbnMuZmlsdGVyKGFjdCA9PiBhY3QgIT09IGFjdGlvbilcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkVHJlZShuZXdOb2RlLCBnb2FsLCBuZXdBY3Rpb25zLCBhY3Rpb24uZWZmZWN0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn0iLCJpbXBvcnQgR29hcEFjdGlvbiBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvR29hcEFjdGlvblwiO1xyXG5pbXBvcnQgR29hcEFJIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9Hb2FwQUlcIjtcclxuaW1wb3J0IFF1ZXVlIGZyb20gXCIuLi9EYXRhVHlwZXMvUXVldWVcIjtcclxuaW1wb3J0IFN0YWNrIGZyb20gXCIuLi9EYXRhVHlwZXMvU3RhY2tcIjtcclxuaW1wb3J0IFN0YXRlTWFjaGluZSBmcm9tIFwiLi4vRGF0YVR5cGVzL1N0YXRlL1N0YXRlTWFjaGluZVwiO1xyXG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCBHb2FwQWN0aW9uUGxhbm5lciBmcm9tIFwiLi9Hb2FwQWN0aW9uUGxhbm5lclwiO1xyXG5cclxuLyoqXHJcbiAqIEEgdmVyc2lvbiBvZiBhIEByZWZlcmVuY2VbU3RhdGVNYWNoaW5lXSB0aGF0IGlzIGNvbmZpZ3VyZWQgdG8gd29yayBhcyBhbiBBSSBjb250cm9sbGVyIGZvciBhIEByZWZlcmVuY2VbR2FtZU5vZGVdXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0ZU1hY2hpbmVHb2FwQUkgZXh0ZW5kcyBTdGF0ZU1hY2hpbmUgaW1wbGVtZW50cyBHb2FwQUkge1xyXG4gIC8qKlx0VGhlIEdhbWVOb2RlIHRoYXQgdXNlcyB0aGlzIFN0YXRlTWFjaGluZSBmb3IgaXRzIEFJICovXHJcbiAgcHJvdGVjdGVkIG93bmVyOiBHYW1lTm9kZTtcclxuXHJcbiAgZ29hbDogc3RyaW5nO1xyXG5cclxuICBjdXJyZW50U3RhdHVzOiBBcnJheTxzdHJpbmc+O1xyXG5cclxuICBwb3NzaWJsZUFjdGlvbnM6IEFycmF5PEdvYXBBY3Rpb24+O1xyXG5cclxuICBwbGFuOiBTdGFjazxHb2FwQWN0aW9uPjtcclxuXHJcbiAgcGxhbm5lcjogR29hcEFjdGlvblBsYW5uZXI7XHJcblxyXG4gIC8vIEBpbXBsZW1lbnRlZFxyXG4gIGluaXRpYWxpemVBSShvd25lcjogR2FtZU5vZGUsIGNvbmZpZzogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge31cclxuXHJcbiAgLy8gQGltcGxlbWVudGVkXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIC8vIEdldCByaWQgb2Ygb3VyIHJlZmVyZW5jZSB0byB0aGUgb3duZXJcclxuICAgIGRlbGV0ZSB0aGlzLm93bmVyO1xyXG4gICAgdGhpcy5yZWNlaXZlci5kZXN0cm95KCk7XHJcbiAgfVxyXG5cclxuICAvLyBAaW1wbGVtZW50ZWRcclxuICBhY3RpdmF0ZShvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7fVxyXG5cclxuICBjaGFuZ2VHb2FsKGdvYWw6IHN0cmluZyk6IHZvaWQge31cclxufVxyXG4iLCIvLyBAaWdub3JlUGFnZVxuXG4vKipcbiAqIEEgcGxhY2Vob2xkZXIgZnVuY3Rpb24gZm9yIE5vIE9wZXJhdGlvbi4gRG9lcyBub3RoaW5nXG4gKi9cbmNvbnN0IE51bGxGdW5jID0gKCkgPT4ge307XG5cbmV4cG9ydCBkZWZhdWx0IE51bGxGdW5jOyIsIi8qKlxuICogQSBsaW5rZWQtbGlzdCBmb3IgdGhlIGVkZ2VzIGluIGEgQHJlZmVyZW5jZVtHcmFwaF0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVkZ2VOb2RlIHtcbiAgICAvKiogVGhlIG5vZGUgaW4gdGhlIEdyYXBoIHRoaXMgZWRnZSBjb25uZWN0cyB0byAqL1xuICAgIHk6IG51bWJlcjtcbiAgICAvKiogVGhlIHdlaWdodCBvZiB0aGlzIEVkZ2VOb2RlICovXG5cdHdlaWdodDogbnVtYmVyO1xuICAgIC8qKiBUaGUgbmV4dCBFZGdlTm9kZSBpbiB0aGUgbGlua2VkLWxpc3QgKi9cbiAgICBuZXh0OiBFZGdlTm9kZTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRWRnZU5vZGVcbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRoaXMgZWRnZSBjb25uZWN0cyB0b1xuICAgICAqIEBwYXJhbSB3ZWlnaHQgVGhlIHdlaWdodCBvZiB0aGlzIGVkZ2VcbiAgICAgKi9cblx0Y29uc3RydWN0b3IoaW5kZXg6IG51bWJlciwgd2VpZ2h0PzogbnVtYmVyKXtcblx0XHR0aGlzLnkgPSBpbmRleDtcblx0XHR0aGlzLm5leHQgPSBudWxsO1xuXHRcdHRoaXMud2VpZ2h0ID0gd2VpZ2h0ID8gd2VpZ2h0IDogMTtcblx0fVxufSIsImltcG9ydCBFZGdlTm9kZSBmcm9tIFwiLi9FZGdlTm9kZVwiO1xuXG5leHBvcnQgY29uc3QgTUFYX1YgPSAxMDA7XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgYSBncmFwaCBkYXRhIHN0cnVjdHVyZSB1c2luZyBlZGdlIGxpc3RzLiBJbnNwaXJlZCBieSBUaGUgQWxnb3JpdGhtIERlc2lnbiBNYW51YWwuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyYXBoIHtcblx0LyoqIEFuIGFycmF5IG9mIGVkZ2VzIGF0IHRoZSBub2RlIHNwZWNpZmllZCBieSB0aGUgaW5kZXggKi9cblx0ZWRnZXM6IEFycmF5PEVkZ2VOb2RlPjtcblx0LyoqIEFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgZGVncmVlIG9mIHRoZSBub2RlIHNwZWNpZmllZCBieSB0aGUgaW5kZXggKi9cblx0ZGVncmVlOiBBcnJheTxudW1iZXI+O1xuXHQvKiogVGhlIG51bWJlciBvZiB2ZXJ0aWNlcyBpbiB0aGUgZ3JhcGggKi9cblx0bnVtVmVydGljZXM6IG51bWJlcjtcblx0LyoqIFRoZSBudW1iZXIgb2YgZWRnZXMgaW4gdGhlIGdyYXBoICovXG5cdG51bUVkZ2VzOiBudW1iZXI7XG5cdC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ3JhcGggaXMgZGlyZWN0ZWQgKi9cblx0ZGlyZWN0ZWQ6IGJvb2xlYW47XG5cdC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ3JhcGggaXMgd2VpZ2h0ZWQgKi9cblx0d2VpZ2h0ZWQ6IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgZ3JhcGhcblx0ICogQHBhcmFtIGRpcmVjdGVkIFdoZXRoZXIgb3Igbm90IHRoaXMgZ3JhcGggaXMgZGlyZWN0ZWRcblx0ICovXG5cdGNvbnN0cnVjdG9yKGRpcmVjdGVkOiBib29sZWFuID0gZmFsc2Upe1xuXHRcdHRoaXMuZGlyZWN0ZWQgPSBkaXJlY3RlZDtcblx0XHR0aGlzLndlaWdodGVkID0gZmFsc2U7XG5cblx0XHR0aGlzLm51bVZlcnRpY2VzID0gMDtcblx0XHR0aGlzLm51bUVkZ2VzID0gMDtcblxuXHRcdHRoaXMuZWRnZXMgPSBuZXcgQXJyYXkoTUFYX1YpO1xuXHRcdHRoaXMuZGVncmVlID0gbmV3IEFycmF5KE1BWF9WKTtcblx0fVxuXG5cdC8qKiBBZGRzIGEgbm9kZSB0byB0aGlzIGdyYXBoIGFuZCByZXR1cm5zIHRoZSBpbmRleCBvZiBpdFxuXHQgKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIG5ldyBub2RlXG5cdCovXG5cdGFkZE5vZGUoKTogbnVtYmVyIHtcblx0XHR0aGlzLm51bVZlcnRpY2VzKys7XG5cdFx0cmV0dXJuIHRoaXMubnVtVmVydGljZXM7XG5cdH1cblxuXHQvKiogQWRkcyBhbiBlZGdlIGJldHdlZW4gbm9kZSB4IGFuZCB5LCB3aXRoIGFuIG9wdGlvbmFsIHdlaWdodFxuXHQgKiBAcGFyYW0geCBUaGUgaW5kZXggb2YgdGhlIHN0YXJ0IG9mIHRoZSBlZGdlXG5cdCAqIEBwYXJhbSB5IFRoZSBpbmRleCBvZiB0aGUgZW5kIG9mIHRoZSBlZGdlXG5cdCAqIEBwYXJhbSB3ZWlnaHQgVGhlIG9wdGlvbmFsIHdlaWdodCBvZiB0aGUgbmV3IGVkZ2Vcblx0Ki9cblx0YWRkRWRnZSh4OiBudW1iZXIsIHk6IG51bWJlciwgd2VpZ2h0PzogbnVtYmVyKTogdm9pZCB7XG5cdFx0bGV0IGVkZ2UgPSBuZXcgRWRnZU5vZGUoeSwgd2VpZ2h0KTtcblxuXG5cblx0XHRpZih0aGlzLmVkZ2VzW3hdKXtcblx0XHRcdGVkZ2UubmV4dCA9IHRoaXMuZWRnZXNbeF07XG5cdFx0fVxuXHRcdFxuXHRcdHRoaXMuZWRnZXNbeF0gPSBlZGdlO1xuXG5cdFx0aWYoIXRoaXMuZGlyZWN0ZWQpe1xuXHRcdFx0ZWRnZSA9IG5ldyBFZGdlTm9kZSh4LCB3ZWlnaHQpO1xuXG5cdFx0XHRpZih0aGlzLmVkZ2VzW3ldKXtcblx0XHRcdFx0ZWRnZS5uZXh0ID0gdGhpcy5lZGdlc1t5XTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhpcy5lZGdlc1t5XSA9IGVkZ2U7XG5cdFx0fVxuXG5cdFx0dGhpcy5udW1FZGdlcyArPSAxO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCBhbiBlZGdlIGV4aXN0cyBiZXR3ZWVuIHR3byBub2Rlcy5cblx0ICogVGhpcyBjaGVjayBpcyBkaXJlY3Rpb25hbCBpZiB0aGlzIGlzIGEgZGlyZWN0ZWQgZ3JhcGguXG5cdCAqIEBwYXJhbSB4IFRoZSBmaXJzdCBub2RlXG5cdCAqIEBwYXJhbSB5IFRoZSBzZWNvbmQgbm9kZVxuXHQgKiBAcmV0dXJucyB0cnVlIGlmIGFuIGVkZ2UgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdGVkZ2VFeGlzdHMoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBib29sZWFuIHtcblx0XHRsZXQgZWRnZSA9IHRoaXMuZWRnZXNbeF07XG5cblx0XHR3aGlsZShlZGdlICE9PSBudWxsKXtcblx0XHRcdGlmKGVkZ2UueSA9PT0geSl7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0ZWRnZSA9IGVkZ2UubmV4dDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgZWRnZSBsaXN0IGFzc29jaWF0ZWQgd2l0aCBub2RlIHhcblx0ICogQHBhcmFtIHggVGhlIGluZGV4IG9mIHRoZSBub2RlXG5cdCAqIEByZXR1cm5zIFRoZSBoZWFkIG9mIGEgbGlua2VkLWxpc3Qgb2YgZWRnZXNcblx0ICovXG5cdGdldEVkZ2VzKHg6IG51bWJlcik6IEVkZ2VOb2RlIHtcblx0XHRyZXR1cm4gdGhpcy5lZGdlc1t4XTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBkZWdyZWUgYXNzb2NpYXRlZCB3aXRoIG5vZGUgeFxuXHQgKiBAcGFyYW0geCBUaGUgaW5kZXggb2YgdGhlIG5vZGVcblx0ICovXG5cdGdldERlZ3JlZSh4OiBudW1iZXIpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLmRlZ3JlZVt4XTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGUgc3BlY2lmZWQgbm9kZSBpbnRvIGEgc3RyaW5nXG5cdCAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGUgdG8gY29udmVydCB0byBhIHN0cmluZ1xuXHQgKiBAcmV0dXJucyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBub2RlOiBcIk5vZGUgeFwiXG5cdCAqL1xuXHRwcm90ZWN0ZWQgbm9kZVRvU3RyaW5nKGluZGV4OiBudW1iZXIpOiBzdHJpbmcge1xuXHRcdHJldHVybiBcIk5vZGUgXCIgKyBpbmRleDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGUgR3JhcGggaW50byBhIHN0cmluZyBmb3JtYXRcblx0ICogQHJldHVybnMgVGhlIGdyYXBoIGFzIGEgc3RyaW5nXG5cdCAqL1xuXHR0b1N0cmluZygpOiBzdHJpbmcge1xuXHRcdGxldCByZXR2YWwgPSBcIlwiO1xuXG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHRoaXMubnVtVmVydGljZXM7IGkrKyl7XG5cdFx0XHRsZXQgZWRnZSA9IHRoaXMuZWRnZXNbaV07XG5cdFx0XHRsZXQgZWRnZVN0ciA9IFwiXCI7XG5cdFx0XHR3aGlsZShlZGdlICE9PSB1bmRlZmluZWQgJiYgZWRnZSAhPT0gbnVsbCl7XG5cdFx0XHRcdGVkZ2VTdHIgKz0gZWRnZS55LnRvU3RyaW5nKCk7XG5cdFx0XHRcdGlmKHRoaXMud2VpZ2h0ZWQpe1xuXHRcdFx0XHRcdGVkZ2VTdHIgKz0gXCIgKFwiICsgZWRnZS53ZWlnaHQgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihlZGdlLm5leHQgIT09IG51bGwpe1xuXHRcdFx0XHRcdGVkZ2VTdHIgKz0gXCIsIFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWRnZSA9IGVkZ2UubmV4dDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dmFsICs9IHRoaXMubm9kZVRvU3RyaW5nKGkpICsgXCI6IFwiICsgZWRnZVN0ciArIFwiXFxuXCI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldHZhbDtcblx0fVxufSIsImltcG9ydCBHcmFwaCwgeyBNQVhfViB9IGZyb20gXCIuL0dyYXBoXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vVmVjMlwiO1xuaW1wb3J0IERlYnVnUmVuZGVyYWJsZSBmcm9tIFwiLi4vSW50ZXJmYWNlcy9EZWJ1Z1JlbmRlcmFibGVcIjtcblxuLyoqXG4gKiBBbiBleHRlbnNpb24gb2YgR3JhcGggdGhhdCBoYXMgbm9kZXMgd2l0aCBwb3NpdGlvbnMgaW4gMkQgc3BhY2UuXG4gKiBUaGlzIGlzIGEgd2VpZ2h0ZWQgZ3JhcGggKHRob3VnaCBub3QgaW5oZXJlbnRseSBkaXJlY3RkKVxuKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvc2l0aW9uR3JhcGggZXh0ZW5kcyBHcmFwaCBpbXBsZW1lbnRzIERlYnVnUmVuZGVyYWJsZSB7XG5cdC8qKiBBbiBhcnJheSBvZiB0aGUgcG9zaXRpb25zIG9mIHRoZSBub2RlcyBpbiB0aGlzIGdyYXBoICovXG5cdHBvc2l0aW9uczogQXJyYXk8VmVjMj47XG5cblx0LyoqXG5cdCAqIENyZWF0ZWVzIGEgbmV3IFBvc2l0aW9uR3JhcGhcblx0ICogQHBhcmFtIGRpcmVjdGVkIFdoZXRoZXIgb3Igbm90IHRoaXMgZ3JhcGggaXMgZGlyZWN0ZWRcblx0ICovXG5cdGNvbnN0cnVjdG9yKGRpcmVjdGVkOiBib29sZWFuID0gZmFsc2Upe1xuXHRcdHN1cGVyKGRpcmVjdGVkKTtcblx0XHR0aGlzLnBvc2l0aW9ucyA9IG5ldyBBcnJheShNQVhfVik7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIHBvc2l0aW9uZWQgbm9kZSB0byB0aGlzIGdyYXBoXG5cdCAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgcG9zaXRpb24gb2YgdGhlIG5vZGUgdG8gYWRkXG5cdCAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgYWRkZWQgbm9kZVxuXHQgKi9cblx0YWRkUG9zaXRpb25lZE5vZGUocG9zaXRpb246IFZlYzIpOiBudW1iZXIge1xuXHRcdHRoaXMucG9zaXRpb25zW3RoaXMubnVtVmVydGljZXNdID0gcG9zaXRpb247XG5cdFx0cmV0dXJuIHRoaXMuYWRkTm9kZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoYW5nZXMgdGhlIHBvc2l0aW9uIG9mIGEgbm9kZS5cblx0ICogQXV0b21hdGljYWxseSBhZGp1c3RzIHRoZSB3ZWlnaHRzIG9mIHRoZSBncmFwaCB0aWVkIHRvIHRoaXMgbm9kZS5cblx0ICogQXMgc3VjaCwgYmUgd2FybmVkIHRoYXQgdGhpcyBmdW5jdGlvbiBoYXMgYW4gTyhuICsgbSkgcnVubmluZyB0aW1lLCBhbmQgdXNlIGl0IHNwYXJpbmdseS5cblx0ICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZVxuXHQgKiBAcGFyYW0gcG9zaXRpb24gVGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUgbm9kZVxuXHQgKi9cblx0c2V0Tm9kZVBvc2l0aW9uKGluZGV4OiBudW1iZXIsIHBvc2l0aW9uOiBWZWMyKTogdm9pZCB7XG5cdFx0dGhpcy5wb3NpdGlvbnNbaW5kZXhdID0gcG9zaXRpb247XG5cblx0XHQvLyBSZWNhbGN1bGF0ZSBhbGwgd2VpZ2h0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbmRleFxuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLm51bUVkZ2VzOyBpKyspe1xuXG5cdFx0XHRsZXQgZWRnZSA9IHRoaXMuZWRnZXNbaV07XG5cblx0XHRcdHdoaWxlKGVkZ2UgIT09IG51bGwpe1xuXHRcdFx0XHQvLyBJZiB0aGlzIG5vZGUgaXMgb24gZWl0aGVyIHNpZGUgb2YgdGhlIGVkZ2UsIHJlY2FsY3VsYXRlIHdlaWdodFxuXHRcdFx0XHRpZihpID09PSBpbmRleCB8fCBlZGdlLnkgPT09IGluZGV4KXtcblx0XHRcdFx0XHRlZGdlLndlaWdodCA9IHRoaXMucG9zaXRpb25zW2ldLmRpc3RhbmNlVG8odGhpcy5wb3NpdGlvbnNbZWRnZS55XSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlZGdlID0gZWRnZS5uZXh0O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBwb3NpdGlvbiBvZiBhIG5vZGVcblx0ICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZVxuXHQgKiBAcmV0dXJucyBUaGUgcG9zaXRpb24gb2YgdGhlIG5vZGVcblx0ICovXG5cdGdldE5vZGVQb3NpdGlvbihpbmRleDogbnVtYmVyKTogVmVjMiB7XG5cdFx0cmV0dXJuIHRoaXMucG9zaXRpb25zW2luZGV4XTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGFuIGVkZ2UgdG8gdGhpcyBncmFwaCBiZXR3ZWVuIG5vZGUgeCBhbmQgeS5cblx0ICogQXV0b21hdGljYWxseSBjYWxjdWxhdGVzIHRoZSB3ZWlnaHQgb2YgdGhlIGVkZ2UgYXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIG5vZGVzLlxuXHQgKiBAcGFyYW0geCBUaGUgYmVnaW5uaW5nIG9mIHRoZSBlZGdlXG5cdCAqIEBwYXJhbSB5IFRoZSBlbmQgb2YgdGhlIGVkZ2Vcblx0ICovXG5cdGFkZEVkZ2UoeDogbnVtYmVyLCB5OiBudW1iZXIpOiB2b2lkIHtcblx0XHRpZighdGhpcy5wb3NpdGlvbnNbeF0gfHwgIXRoaXMucG9zaXRpb25zW3ldKXtcblx0XHRcdHRocm93IFwiQ2FuJ3QgYWRkIGVkZ2UgdG8gdW4tcG9zaXRpb25lZCBub2RlIVwiO1xuXHRcdH1cblxuXHRcdC8vIFdlaWdodCBpcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbm9kZXNcblx0XHRsZXQgd2VpZ2h0ID0gdGhpcy5wb3NpdGlvbnNbeF0uZGlzdGFuY2VUbyh0aGlzLnBvc2l0aW9uc1t5XSk7XG5cblx0XHRzdXBlci5hZGRFZGdlKHgsIHksIHdlaWdodCk7XG5cdH1cblxuXHQvLyBAb3ZlcnJpZGVcblx0cHJvdGVjdGVkIG5vZGVUb1N0cmluZyhpbmRleDogbnVtYmVyKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gXCJOb2RlIFwiICsgaW5kZXggKyBcIiAtIFwiICsgdGhpcy5wb3NpdGlvbnNbaW5kZXhdLnRvU3RyaW5nKCk7XG5cdH1cblxuXHRkZWJ1Z1JlbmRlciA9ICgpOiB2b2lkID0+IHtcblx0XHQvLyBmb3IobGV0IHBvaW50IG9mIHRoaXMucG9zaXRpb25zKXtcblx0XHQvLyBcdGN0eC5maWxsUmVjdCgocG9pbnQueCAtIG9yaWdpbi54IC0gNCkqem9vbSwgKHBvaW50LnkgLSBvcmlnaW4ueSAtIDQpKnpvb20sIDgsIDgpO1xuXHRcdC8vIH1cblx0fVxufSIsImltcG9ydCBTdGF0ZU1hY2hpbmVHb2FwQUkgZnJvbSBcIi4uLy4uL0FJL1N0YXRlTWFjaGluZUdvYXBBSVwiO1xuXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBHb2FwQWN0aW9uIHtcbiAgICAvKiogQ29zdCBpdCB0YWtlcyB0byBjb21wbGV0ZSB0aGlzIGFjdGlvbiAqL1xuICAgIGNvc3Q6IG51bWJlcjtcblxuICAgIC8qKiBQcmVjb25kaXRpb25zIHRoYXQgaGF2ZSB0byBiZSBzYXRpc2ZpZWQgZm9yIGFuIGFjdGlvbiB0byBoYXBwZW4gKi9cbiAgICBwcmVjb25kaXRpb25zOiBBcnJheTxzdHJpbmc+O1xuXG4gICAgLyoqIFJlc3VsdGluZyBzdGF0dXNlcyBhZnRlciB0aGlzIGFjdGlvbiBjb21wbGV0ZXMgKi9cbiAgICBlZmZlY3RzOiBBcnJheTxzdHJpbmc+O1xuXG4gICAgLyoqIElmIHRoZSBhY3Rpb24gZmFpbHMsIGRvIHdlIGtlZXAgdHJ5aW5nIHVudGlsIHdlIHN1Y2NlZWQgKi9cbiAgICBsb29wQWN0aW9uOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byBwZXJmb3JtIGFuIGFjdGlvbiwgaWYgc3VjY2Vzc2Z1bCwgaXQgd2lsbCByZXR1cm4gYW4gYXJyYXkgb2YgdGhlIGV4cGVjdGVkIGVmZmVjdHMsIG90aGVyd2lzZSBpdCB3aWxsIHJldHVybiBudWxsXG4gICAgICogQHBhcmFtIHN0YXR1c2VzIEN1cnJlbnQgc3RhdHVzZXMgb2YgdGhlIGFjdG9yXG4gICAgICogQHBhcmFtIGFjdG9yIEdhbWVOb2RlIGZvciB0aGUgYWN0b3JcbiAgICAgKiBAcGFyYW0gZGVsdGFUIFRoZSB0aW1lIHNpbmUgdGhlIGxhc3QgdXBkYXRlXG4gICAgICogQHBhcmFtIHRhcmdldCBHYW1lTm9kZSBmb3IgYSBvcHRpb25hbCB0YXJnZXRcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBwZXJmb3JtQWN0aW9uKHN0YXR1c2VzOiBBcnJheTxzdHJpbmc+LCBhY3RvcjogU3RhdGVNYWNoaW5lR29hcEFJLCBkZWx0YVQ6IG51bWJlciwgdGFyZ2V0PzogU3RhdGVNYWNoaW5lR29hcEFJKTogQXJyYXk8c3RyaW5nPjtcblxuICAgIC8qKiBDaGVjayBwcmVjb25kaXRpb25zIHdpdGggY3VycmVudCBzdGF0dXNlcyB0byBzZWUgaWYgYWN0aW9uIGNhbiBiZSBwZXJmb3JtZWQgKi9cbiAgICBjaGVja1ByZWNvbmRpdGlvbnMoc3RhdHVzZXM6IEFycmF5PHN0cmluZz4pOiBib29sZWFuIHtcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBldmVyeSBlbGVtZW50IGluIHRoZSBwcmVjb25kaXRpb25zIGFycmF5IGlzIGZvdW5kIGluIHRoZSBzdGF0dXNlcyBhcnJheVxuICAgICAgICByZXR1cm4gKHRoaXMucHJlY29uZGl0aW9ucy5ldmVyeSgoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXN0YXR1c2VzLmluY2x1ZGVzKHN0YXR1cykpe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgLyoqIEFkZCBvbmUgb3IgbW9yZSBwcmVjb25kaXRpb25zIHRvIHRoaXMgYWN0aW9uICovXG4gICAgYWRkUHJlY29uZGl0aW9uKHByZWNvbmRpdGlvbnM6IHN0cmluZyB8IHN0cmluZ1tdKTogdm9pZCB7XG4gICAgICAgIHRoaXMucHJlY29uZGl0aW9ucy5wdXNoKC4uLnByZWNvbmRpdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKiBBZGQgb25lIG9yIG1vcmUgZWZmZWN0cyB0byB0aGlzIGFjdGlvbiAqL1xuICAgIGFkZEVmZmVjdChlZmZlY3RzOiBzdHJpbmcgfCBzdHJpbmdbXSk6IHZvaWQge1xuICAgICAgICB0aGlzLmVmZmVjdHMucHVzaCguLi5lZmZlY3RzKTtcbiAgICB9XG5cbiAgICAvKiogUmVtb3ZlcyBhbiBwcmVjb25kaXRpb24sIHJldHVybnMgdHJ1ZSBpZiBzdWNjZXNzZnVsICovXG4gICAgcmVtb3ZlUHJlY29uZGl0aW9uKHByZWNvbmRpdGlvbjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cbiAgICBcbiAgICAvKiogUmVtb3ZlcyBhbiBwcmVjb25kaXRpb24sIHJldHVybnMgdHJ1ZSBpZiBzdWNjZXNzZnVsICovXG4gICAgcmVtb3ZlRWZmZWN0KGVmZmVjdDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cblxuICAgIC8qKiBVcGRhdGUgdGhlIGNvc3Qgb2YgdGhpcyBhY3Rpb24gYmFzZWQgb24gb3B0aW9ucyAqL1xuICAgIGFic3RyYWN0IHVwZGF0ZUNvc3Qob3B0aW9uczogUmVjb3JkPHN0cmluZyxudW1iZXI+KTogdm9pZDtcblxuICAgIGFic3RyYWN0IHRvU3RyaW5nKCk6IHN0cmluZztcblxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9WZWMyXCI7XG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vU2hhcGVzL0FBQkJcIjtcblxuLyoqIEFuIG9iamVjdCB0aGF0IGlzIGEgcmVnaW9uLCB3aXRoIGEgc2l6ZSwgc2NhbGUsIGFuZCBib3VuZGFyeS4gKi9cbmV4cG9ydCBkZWZhdWx0IGludGVyZmFjZSBSZWdpb24ge1xuICAgIC8qKiBUaGUgc2l6ZSBvZiB0aGlzIG9iamVjdC4gKi9cbiAgICBzaXplOiBWZWMyO1xuXG4gICAgLyoqIFRoZSBzY2FsZSBvZiB0aGlzIG9iamVjdC4gKi9cbiAgICBzY2FsZTogVmVjMjtcblxuICAgIC8qKiBUaGUgc2l6ZSBvZiB0aGUgb2JqZWN0IHRha2luZyBpbnRvIGFjY291bnQgdGhlIHpvb20gYW5kIHNjYWxlICovXG4gICAgcmVhZG9ubHkgc2l6ZVdpdGhab29tOiBWZWMyO1xuXG4gICAgLyoqIFRoZSBib3VuZGluZyBib3ggb2YgdGhpcyBvYmplY3QuICovXG4gICAgYm91bmRhcnk6IEFBQkI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1JlZ2lvbihhcmc6IGFueSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBhcmcgJiYgYXJnLnNpemUgJiYgYXJnLnNjYWxlICYmIGFyZy5ib3VuZGFyeTtcbn0iLCJpbXBvcnQgQ29sbGVjdGlvbiBmcm9tIFwiLi9Db2xsZWN0aW9uXCI7XG5cbi8qKlxuICogQXNzb2NpYXRlcyBzdHJpbmdzIHdpdGggZWxlbWVudHMgb2YgdHlwZSBUXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hcDxUPiBpbXBsZW1lbnRzIENvbGxlY3Rpb24ge1xuXHRwcml2YXRlIG1hcDogUmVjb3JkPHN0cmluZywgVD47XG5cblx0LyoqIENyZWF0ZXMgYSBuZXcgbWFwICovXG5cdGNvbnN0cnVjdG9yKCl7XG5cdFx0dGhpcy5tYXAgPSB7fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgdmFsdWUgVCBzdG9yZWQgYXQgYSBrZXkuXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaXRlbSB0byBiZSBzdG9yZWRcblx0ICogQHBhcmFtIHZhbHVlIFRoZSBpdGVtIHRvIGJlIHN0b3JlZFxuXHQgKi9cblx0YWRkKGtleTogc3RyaW5nLCB2YWx1ZTogVCk6IHZvaWQge1xuXHRcdHRoaXMubWFwW2tleV0gPSB2YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBhIGtleS5cblx0ICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpdGVtXG5cdCAqIEByZXR1cm5zIFRoZSBpdGVtIGF0IHRoZSBrZXkgb3IgdW5kZWZpbmVkXG5cdCAqL1xuXHRnZXQoa2V5OiBzdHJpbmcpOiBUIHtcblx0XHRyZXR1cm4gdGhpcy5tYXBba2V5XTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBbiBhbGlhcyBvZiBhZGQuIFNldHMgdGhlIHZhbHVlIHN0b3JlZCBhdCBrZXkgdG8gdGhlIG5ldyBzcGVjaWZpZWQgdmFsdWVcblx0ICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIGJlIHN0b3JlZFxuXHQgKiBAcGFyYW0gdmFsdWUgVGhlIGl0ZW0gdG8gYmUgc3RvcmVkXG5cdCAqL1xuXHRzZXQoa2V5OiBzdHJpbmcsIHZhbHVlOiBUKTogdm9pZCB7XG5cdFx0dGhpcy5hZGQoa2V5LCB2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGEgdmFsdWUgc3RvcmVkIGF0IHRoZSBzcGVjaWZpZWQga2V5LCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBjaGVja1xuXHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoZXJlIGlzIGFuIGl0ZW0gYXQgdGhlIGdpdmVuIGtleS5cblx0ICovXG5cdGhhcyhrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLm1hcFtrZXldICE9PSB1bmRlZmluZWQ7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgb2YgdGhlIGtleXMgaW4gdGhpcyBtYXAuXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIGtleXMgaW4gdGhlIG1hcC5cblx0ICovXG5cdGtleXMoKTogQXJyYXk8c3RyaW5nPiB7XG5cdFx0cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMubWFwKTtcblx0fVxuXHRcblx0Ly8gQGltcGxlbWVudGVkXG5cdGZvckVhY2goZnVuYzogKGtleTogc3RyaW5nKSA9PiB2b2lkKTogdm9pZCB7XG5cdFx0T2JqZWN0LmtleXModGhpcy5tYXApLmZvckVhY2goa2V5ID0+IGZ1bmMoa2V5KSk7XG5cdH1cblxuXHQvKipcblx0ICogRGVsZXRlcyBhbiBpdGVtIGFzc29jaWF0ZWQgd2l0aCBhIGtleVxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgYXQgd2hpY2ggdG8gZGVsZXRlIGFuIGl0ZW1cblx0ICovXG5cdGRlbGV0ZShrZXk6IHN0cmluZyk6IHZvaWQge1xuXHRcdGRlbGV0ZSB0aGlzLm1hcFtrZXldO1xuXHR9XG5cblx0Ly8gQGltcGxlbWVudGVkXG5cdGNsZWFyKCk6IHZvaWQge1xuXHRcdHRoaXMuZm9yRWFjaChrZXkgPT4gZGVsZXRlIHRoaXMubWFwW2tleV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIHRoaXMgbWFwIHRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuXHQgKiBAcmV0dXJucyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbWFwLlxuXHQgKi9cblx0dG9TdHJpbmcoKTogc3RyaW5nIHtcblx0XHRsZXQgc3RyID0gXCJcIjtcblxuXHRcdHRoaXMuZm9yRWFjaCgoa2V5KSA9PiBzdHIgKz0ga2V5ICsgXCIgLT4gXCIgKyB0aGlzLmdldChrZXkpLnRvU3RyaW5nKCkgKyBcIlxcblwiKTtcblxuXHRcdHJldHVybiBzdHI7XG5cdH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi9WZWMyXCI7XG5cbi8qKiBBIDR4NCBtYXRyaXgwICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXQ0eDQge1xuXHRwcml2YXRlIG1hdDogRmxvYXQzMkFycmF5O1xuXG5cdGNvbnN0cnVjdG9yKCl7XG5cdFx0dGhpcy5tYXQgPSBuZXcgRmxvYXQzMkFycmF5KFtcblx0XHRcdDAsIDAsIDAsIDAsXG5cdFx0XHQwLCAwLCAwLCAwLFxuXHRcdFx0MCwgMCwgMCwgMCxcblx0XHRcdDAsIDAsIDAsIDBcblx0XHRdKTtcblx0fVxuXG5cdC8vIFN0YXRpYyBtZW1iZXJzXG5cdHN0YXRpYyBnZXQgSURFTlRJVFkoKTogTWF0NHg0IHtcblx0XHRyZXR1cm4gbmV3IE1hdDR4NCgpLmlkZW50aXR5KCk7XG5cdH1cblxuXHRzdGF0aWMgZ2V0IFpFUk8oKTogTWF0NHg0IHtcblx0XHRyZXR1cm4gbmV3IE1hdDR4NCgpLnplcm8oKTtcblx0fVxuXG5cdC8vIEFjY2Vzc29yc1xuXHRzZXQgXzAwKHg6IG51bWJlcikge1xuXHRcdHRoaXMubWF0WzBdID0geDtcblx0fVxuXG5cdHNldChjb2w6IG51bWJlciwgcm93OiBudW1iZXIsIHZhbHVlOiBudW1iZXIpOiBNYXQ0eDQge1xuXHRcdGlmKGNvbCA8IDAgfHwgY29sID4gMyB8fCByb3cgPCAwIHx8IHJvdyA+IDMpe1xuXHRcdFx0dGhyb3cgYEVycm9yIC0gaW5kZXggKCR7Y29sfSwgJHtyb3d9KSBpcyBvdXQgb2YgYm91bmRzIGZvciBNYXQ0eDRgXG5cdFx0fVxuXHRcdHRoaXMubWF0W3Jvdyo0ICsgY29sXSA9IHZhbHVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRnZXQoY29sOiBudW1iZXIsIHJvdzogbnVtYmVyKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5tYXRbcm93KjQgKyBjb2xdO1xuXHR9XG5cblx0c2V0QWxsKC4uLml0ZW1zOiBBcnJheTxudW1iZXI+KTogTWF0NHg0IHtcblx0XHR0aGlzLm1hdC5zZXQoaXRlbXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0aWRlbnRpdHkoKTogTWF0NHg0IHtcblx0XHRyZXR1cm4gdGhpcy5zZXRBbGwoXG5cdFx0XHQxLCAwLCAwLCAwLFxuXHRcdFx0MCwgMSwgMCwgMCxcblx0XHRcdDAsIDAsIDEsIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cdFx0KVxuXHR9XG5cblx0emVybygpOiBNYXQ0eDQge1xuXHRcdHJldHVybiB0aGlzLnNldEFsbChcblx0XHRcdDAsIDAsIDAsIDAsXG5cdFx0XHQwLCAwLCAwLCAwLFxuXHRcdFx0MCwgMCwgMCwgMCxcblx0XHRcdDAsIDAsIDAsIDBcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1ha2VzIHRoaXMgTWF0NHg0IGEgcm90YXRpb24gbWF0cml4IG9mIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHJhZGlhbnMgY2N3XG5cdCAqIEBwYXJhbSB6UmFkaWFucyBUaGUgbnVtYmVyIG9mIHJhZGlhbnMgdG8gcm90YXRlXG5cdCAqIEByZXR1cm5zIHRoaXMgTWF0NHg0XG5cdCAqL1xuXHRyb3RhdGUoelJhZGlhbnM6IG51bWJlcik6IE1hdDR4NCB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0QWxsKFxuXHRcdFx0TWF0aC5jb3MoelJhZGlhbnMpLCAtTWF0aC5zaW4oelJhZGlhbnMpLCBcdDAsIDAsXG5cdFx0XHRNYXRoLnNpbih6UmFkaWFucyksIE1hdGguY29zKHpSYWRpYW5zKSwgXHQwLCAwLFxuXHRcdFx0MCwgXHRcdFx0XHRcdDAsIFx0XHRcdFx0XHRcdDEsIDAsXG5cdFx0XHQwLCBcdFx0XHRcdFx0MCwgXHRcdFx0XHRcdFx0MCwgMVxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogVHVybnMgdGhpcyBNYXQ0eDQgaW50byBhIHRyYW5zbGF0aW9uIG1hdHJpeCBvZiB0aGUgc3BlY2lmaWVkIHRyYW5zbGF0aW9uXG5cdCAqIEBwYXJhbSB0cmFuc2xhdGlvbiBUaGUgdHJhbnNsYXRpb24gaW4geCBhbmQgeVxuXHQgKiBAcmV0dXJucyB0aGlzIE1hdDR4NFxuXHQgKi9cblx0dHJhbnNsYXRlKHRyYW5zbGF0aW9uOiBWZWMyIHwgRmxvYXQzMkFycmF5KTogTWF0NHg0IHtcblx0XHQvLyBJZiB0cmFuc2xhdGlvbiBpcyBhIHZlYywgZ2V0IGl0cyBhcnJheVxuXHRcdGlmKHRyYW5zbGF0aW9uIGluc3RhbmNlb2YgVmVjMil7XG5cdFx0XHR0cmFuc2xhdGlvbiA9IHRyYW5zbGF0aW9uLnRvQXJyYXkoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRBbGwoXG5cdFx0XHQxLCAwLCAwLCB0cmFuc2xhdGlvblswXSxcblx0XHRcdDAsIDEsIDAsIHRyYW5zbGF0aW9uWzFdLFxuXHRcdFx0MCwgMCwgMSwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblx0XHQpO1xuXHR9XG5cblx0c2NhbGUoc2NhbGU6IFZlYzIgfCBGbG9hdDMyQXJyYXkgfCBudW1iZXIpOiBNYXQ0eDQge1xuXHRcdC8vIE1ha2Ugc3VyZSBzY2FsZSBpcyBhIGZsb2F0MzJBcnJheVxuXHRcdGlmKHNjYWxlIGluc3RhbmNlb2YgVmVjMil7XG5cdFx0XHRzY2FsZSA9IHNjYWxlLnRvQXJyYXkoKTtcblx0XHR9IGVsc2UgaWYoIShzY2FsZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkpe1xuXHRcdFx0c2NhbGUgPSBuZXcgRmxvYXQzMkFycmF5KFtzY2FsZSwgc2NhbGVdKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRBbGwoXG5cdFx0XHRzY2FsZVswXSwgMCwgXHRcdDAsIDAsXG5cdFx0XHQwLCBcdFx0ICBzY2FsZVsxXSwgMCwgMCxcblx0XHRcdDAsIFx0XHQgIDAsXHRcdDEsIDAsXG5cdFx0XHQwLCBcdFx0ICAwLFx0XHQwLCAxXG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IE1hdDR4NCB0aGF0IHJlcHJlc2VudHMgdGhlIHJpZ2h0IHNpZGUgbXVsdGlwbGljYXRpb24gVEhJUyB4IE9USEVSXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgb3RoZXIgTWF0NHg0IHRvIG11bHRpcGx5IGJ5XG5cdCAqIEByZXR1cm5zIGEgbmV3IE1hdDR4NCBjb250YWluaW5nIHRoZSBwcm9kdWN0IG9mIHRoZXNlIHR3byBNYXQ0eDRzXG5cdCAqL1xuXHRtdWx0KG90aGVyOiBNYXQ0eDQsIG91dD86IE1hdDR4NCk6IE1hdDR4NCB7XG5cdFx0bGV0IHRlbXAgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcblxuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCA0OyBpKyspe1xuXHRcdFx0Zm9yKGxldCBqID0gMDsgaiA8IDQ7IGorKyl7XG5cdFx0XHRcdGxldCB2YWx1ZSA9IDA7XG5cdFx0XHRcdGZvcihsZXQgayA9IDA7IGsgPCA0OyBrKyspe1xuXHRcdFx0XHRcdHZhbHVlICs9IHRoaXMuZ2V0KGssIGkpICogb3RoZXIuZ2V0KGosIGspO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRlbXBbaio0ICsgaV0gID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYob3V0ICE9PSB1bmRlZmluZWQpe1xuXHRcdFx0cmV0dXJuIG91dC5zZXRBbGwoLi4udGVtcCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBuZXcgTWF0NHg0KCkuc2V0QWxsKC4uLnRlbXApO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBNdWx0aXBsaWVzIGFsbCBnaXZlbiBtYXRyaWNpZXMgaW4gb3JkZXIuIGUuZy4gTVVMVChBLCBCLCBDKSAtPiBBKkIqQ1xuXHQgKiBAcGFyYW0gbWF0cyBBIGxpc3Qgb2YgTWF0NHg0cyB0byBtdWx0aXBseSBpbiBvcmRlclxuXHQgKiBAcmV0dXJucyBBIG5ldyBNYXQ0eDQgaG9sZGluZyB0aGUgcmVzdWx0IG9mIHRoZSBvcGVyYXRpb25cblx0ICovXG5cdHN0YXRpYyBNVUxUKC4uLm1hdHM6IEFycmF5PE1hdDR4ND4pOiBNYXQ0eDQge1xuXHRcdC8vIENyZWF0ZSBhIG5ldyBhcnJheVxuXHRcdGxldCB0ZW1wID0gTWF0NHg0LklERU5USVRZO1xuXG5cdFx0Ly8gTXVsdGlwbHkgYnkgZXZlcnkgYXJyYXkgaW4gb3JkZXIsIGluIHBsYWNlXG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IG1hdHMubGVuZ3RoOyBpKyspe1xuXHRcdFx0dGVtcC5tdWx0KG1hdHNbaV0sIHRlbXApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0ZW1wO1xuXHR9XG5cblx0dG9BcnJheSgpOiBGbG9hdDMyQXJyYXkge1xuXHRcdHJldHVybiB0aGlzLm1hdDtcblx0fVxuXG5cdHRvU3RyaW5nKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuICBgfCR7dGhpcy5tYXRbMF0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbMV0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbMl0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbM10udG9GaXhlZCgyKX18XFxuYCArIFxuXHRcdFx0XHRgfCR7dGhpcy5tYXRbNF0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbNV0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbNl0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbN10udG9GaXhlZCgyKX18XFxuYCArXG5cdFx0XHRcdGB8JHt0aGlzLm1hdFs4XS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFs5XS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFsxMF0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbMTFdLnRvRml4ZWQoMil9fFxcbmAgK1xuXHRcdFx0XHRgfCR7dGhpcy5tYXRbMTJdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzEzXS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFsxNF0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbMTVdLnRvRml4ZWQoMil9fGA7XG5cdH1cbn0iLCJpbXBvcnQgUGh5c2ljYWwgZnJvbSBcIi4uL0ludGVyZmFjZXMvUGh5c2ljYWxcIjtcbmltcG9ydCBBQUJCIGZyb20gXCIuLi9TaGFwZXMvQUFCQlwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcbmltcG9ydCBIaXQgZnJvbSBcIi4vSGl0XCI7XG5cbi8qKlxuICogQSBjbGFzcyB0aGF0IGNvbnRhaW5zIHRoZSBhcmVhIG9mIG92ZXJsYXAgb2YgdHdvIGNvbGxpZGluZyBvYmplY3RzIHRvIGFsbG93IGZvciBzb3J0aW5nIGJ5IHRoZSBwaHlzaWNzIHN5c3RlbS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXJlYUNvbGxpc2lvbiB7XG4gICAgLyoqIFRoZSBhcmVhIG9mIHRoZSBvdmVybGFwIGZvciB0aGUgY29sbGlkaW5nIG9iamVjdHMgKi9cbiAgICBhcmVhOiBudW1iZXI7XG5cbiAgICAvKiogVGhlIEFBQkIgb2YgdGhlIG90aGVyIGNvbGxpZGVyIGluIHRoaXMgY29sbGlzaW9uICovXG4gICAgY29sbGlkZXI6IEFBQkI7XG5cbiAgICAvKiogVHlwZSBvZiB0aGUgY29sbGlzaW9uICovXG4gICAgdHlwZTogc3RyaW5nO1xuXG4gICAgLyoqIFRoZXIgb3RoZXIgb2JqZWN0IGluIHRoZSBjb2xsaXNpb24gKi9cbiAgICBvdGhlcjogUGh5c2ljYWw7XG5cbiAgICAvKiogVGhlIHRpbGUsIGlmIHRoaXMgd2FzIGEgdGlsZW1hcCBjb2xsaXNpb24gKi9cbiAgICB0aWxlOiBWZWMyO1xuXG4gICAgLyoqIFRoZSBwaHlzaWNzIGhpdCBmb3IgdGhpcyBvYmplY3QgKi9cbiAgICBoaXQ6IEhpdDtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQXJlYUNvbGxpc2lvbiBvYmplY3RcbiAgICAgKiBAcGFyYW0gYXJlYSBUaGUgYXJlYSBvZiB0aGUgY29sbGlzaW9uXG4gICAgICogQHBhcmFtIGNvbGxpZGVyIFRoZSBvdGhlciBjb2xsaWRlclxuICAgICAqL1xuXHRjb25zdHJ1Y3RvcihhcmVhOiBudW1iZXIsIGNvbGxpZGVyOiBBQUJCLCBvdGhlcjogUGh5c2ljYWwsIHR5cGU6IHN0cmluZywgdGlsZTogVmVjMil7XG5cdFx0dGhpcy5hcmVhID0gYXJlYTtcbiAgICAgICAgdGhpcy5jb2xsaWRlciA9IGNvbGxpZGVyO1xuICAgICAgICB0aGlzLm90aGVyID0gb3RoZXI7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMudGlsZSA9IHRpbGU7XG5cdH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vVmVjMlwiO1xuXG4vKipcbiAqIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGRhdGEgY29sbGVjdGVkIGZyb20gYSBwaHlzaWNzIGhpdCBiZXR3ZWVuIHR3byBnZW9tZXRyaWMgb2JqZWN0cy5cbiAqIEluc3BpcmVkIGJ5IHRoZSBoZWxwZnVsIGNvbGxpc2lvbiBkb2N1bWVudGF0aW9uIEBsaW5rKGhlcmUpKGh0dHBzOi8vbm9vbmF0LmdpdGh1Yi5pby9pbnRlcnNlY3QvKS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGl0IHtcbiAgICAvKiogVGhlIHRpbWUgb2YgdGhlIGNvbGxpc2lvbi4gT25seSBudW1iZXJzIDAgdGhyb3VnaCAxIGhhcHBlbiBpbiB0aGlzIGZyYW1lLiAqL1xuICAgIHRpbWU6IG51bWJlcjtcbiAgICAvKiogVGhlIG5lYXIgdGltZXMgb2YgdGhlIGNvbGxpc2lvbiAqL1xuICAgIG5lYXJUaW1lczogVmVjMiA9IFZlYzIuWkVSTztcbiAgICAvKiogVGhlIHBvc2l0aW9uIG9mIHRoZSBjb2xsaXNpb24gKi9cbiAgICBwb3M6IFZlYzIgPSBWZWMyLlpFUk87XG4gICAgLyoqIFRoZSBvdmVybGFwIGRpc3RhbmNlIG9mIHRoZSBoaXQgKi9cbiAgICBkZWx0YTogVmVjMiA9IFZlYzIuWkVSTztcbiAgICAvKiogVGhlIG5vcm1hbCB2ZWN0b3Igb2YgdGhlIGhpdCAqL1xuICAgIG5vcm1hbDogVmVjMiA9IFZlYzIuWkVSTztcbn0iLCJpbXBvcnQgQ29sbGVjdGlvbiBmcm9tIFwiLi9Db2xsZWN0aW9uXCI7XG5cbi8qKlxuICogQSBGSUZPIHF1ZXVlIHdpdGggZWxlbWVudHMgb2YgdHlwZSBUXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1ZXVlPFQ+IGltcGxlbWVudHMgQ29sbGVjdGlvbiB7XG4gICAgLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgUXVldWUgKi9cbiAgICBwcml2YXRlIHJlYWRvbmx5IE1BWF9FTEVNRU5UUzogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcXVldWUgKi9cbiAgICBwcml2YXRlIHE6IEFycmF5PFQ+O1xuICAgIFxuICAgIC8qKiBUaGUgaGVhZCBvZiB0aGUgcXVldWUgKi9cbiAgICBwcml2YXRlIGhlYWQ6IG51bWJlcjtcbiAgICBcbiAgICAvKiogVGhlIHRhaWwgb2YgdGhlIHF1ZXVlICovXG4gICAgcHJpdmF0ZSB0YWlsOiBudW1iZXI7XG5cbiAgICAvKiogVGhlIGN1cnJlbnQgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBxdWV1ZSAqL1xuICAgIHByaXZhdGUgc2l6ZTogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBxdWV1ZVxuICAgICAqIEBwYXJhbSBtYXhFbGVtZW50cyBUaGUgbWF4aW11bSBzaXplIG9mIHRoZSBzdGFja1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1heEVsZW1lbnRzOiBudW1iZXIgPSAxMDApe1xuICAgICAgICB0aGlzLk1BWF9FTEVNRU5UUyA9IG1heEVsZW1lbnRzO1xuICAgICAgICB0aGlzLnEgPSBuZXcgQXJyYXkodGhpcy5NQVhfRUxFTUVOVFMpO1xuICAgICAgICB0aGlzLmhlYWQgPSAwO1xuICAgICAgICB0aGlzLnRhaWwgPSAwO1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gaXRlbSB0byB0aGUgYmFjayBvZiB0aGUgcXVldWVcbiAgICAgKiBAcGFyYW0gaXRlbSBUaGUgaXRlbSB0byBhZGQgdG8gdGhlIGJhY2sgb2YgdGhlIHF1ZXVlXG4gICAgICovXG4gICAgZW5xdWV1ZShpdGVtOiBUKTogdm9pZHtcbiAgICAgICAgaWYoKHRoaXMudGFpbCArIDEpICUgdGhpcy5NQVhfRUxFTUVOVFMgPT09IHRoaXMuaGVhZCl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJRdWV1ZSBmdWxsIC0gY2Fubm90IGFkZCBlbGVtZW50XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zaXplICs9IDE7XG4gICAgICAgIHRoaXMucVt0aGlzLnRhaWxdID0gaXRlbTtcbiAgICAgICAgdGhpcy50YWlsID0gKHRoaXMudGFpbCArIDEpICUgdGhpcy5NQVhfRUxFTUVOVFM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFuIGl0ZW0gZnJvbSB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlXG4gICAgICogQHJldHVybnMgVGhlIGl0ZW0gYXQgdGhlIGZyb250IG9mIHRoZSBxdWV1ZVxuICAgICAqL1xuICAgIGRlcXVldWUoKTogVCB7XG4gICAgICAgIGlmKHRoaXMuaGVhZCA9PT0gdGhpcy50YWlsKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlF1ZXVlIGVtcHR5IC0gY2Fubm90IHJlbW92ZSBlbGVtZW50XCIpO1xuICAgICAgICB9XG5cblxuICAgICAgICB0aGlzLnNpemUgLT0gMTtcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLnFbdGhpcy5oZWFkXTtcbiAgICAgICAgLy8gTm93IGRlbGV0ZSB0aGUgaXRlbVxuICAgICAgICBkZWxldGUgdGhpcy5xW3RoaXMuaGVhZF07XG4gICAgICAgIHRoaXMuaGVhZCA9ICh0aGlzLmhlYWQgKyAxKSAlIHRoaXMuTUFYX0VMRU1FTlRTO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaXRlbSBhdCB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlLCBidXQgZG9lcyBub3QgcmVtb3ZlIGl0XG4gICAgICogQHJldHVybnMgVGhlIGl0ZW0gYXQgdGhlIGZyb250IG9mIHRoZSBxdWV1ZVxuICAgICAqL1xuICAgIHBlZWtOZXh0KCk6IFQge1xuICAgICAgICBpZih0aGlzLmhlYWQgPT09IHRoaXMudGFpbCl7XG4gICAgICAgICAgICB0aHJvdyBcIlF1ZXVlIGVtcHR5IC0gY2Fubm90IGdldCBlbGVtZW50XCJcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpdGVtID0gdGhpcy5xW3RoaXMuaGVhZF07XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHF1ZXVlIGhhcyBpdGVtcyBpbiBpdCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0aGlzIHF1ZXVlIGhhcyBpdGVtc1xuICAgICAqL1xuICAgIGhhc0l0ZW1zKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkICE9PSB0aGlzLnRhaWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBxdWV1ZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgc2l6ZSBvZiB0aGUgcXVldWVcbiAgICAgKi9cbiAgICBnZXRTaXplKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemU7XG4gICAgfVxuXG4gICAgLy8gQGltcGxlbWVudGVkXG4gICAgY2xlYXIoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IGRlbGV0ZSB0aGlzLnFbaW5kZXhdKTtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsO1xuICAgIH1cblxuICAgIC8vIEBpbXBsZW1lbnRlZFxuICAgIGZvckVhY2goZnVuYzogKGl0ZW06IFQsIGluZGV4PzogbnVtYmVyKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIGxldCBpID0gdGhpcy5oZWFkO1xuICAgICAgICB3aGlsZShpICE9PSB0aGlzLnRhaWwpe1xuICAgICAgICAgICAgZnVuYyh0aGlzLnFbaV0sIGkpO1xuICAgICAgICAgICAgaSA9IChpICsgMSkgJSB0aGlzLk1BWF9FTEVNRU5UUztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgcXVldWUgaW50byBhIHN0cmluZyBmb3JtYXRcbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhpcyBxdWV1ZVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgICAgIGxldCByZXR2YWwgPSBcIlwiO1xuXG4gICAgICAgIHRoaXMuZm9yRWFjaCggKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgc3RyID0gaXRlbS50b1N0cmluZygpXG4gICAgICAgICAgICBpZihpbmRleCAhPT0gMCl7XG4gICAgICAgICAgICAgICAgc3RyICs9IFwiIC0+IFwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR2YWwgPSBzdHIgKyByZXR2YWw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBcIlRvcCAtPiBcIiArIHJldHZhbDtcbiAgICB9XG59IiwiLyoqIEEgY29udGFpbmVyIGZvciBpbmZvIGFib3V0IGEgd2ViR0wgc2hhZGVyIHByb2dyYW0gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYkdMUHJvZ3JhbVR5cGUge1xuXHQvKiogQSB3ZWJHTCBwcm9ncmFtICovXG5cdHByb2dyYW06IFdlYkdMUHJvZ3JhbTtcblx0XG5cdC8qKiBBIHZlcnRleCBzaGFkZXIgKi9cblx0dmVydGV4U2hhZGVyOiBXZWJHTFNoYWRlcjtcblxuXHQvKiogQSBmcmFnbWVudCBzaGFkZXIgKi9cblx0ZnJhZ21lbnRTaGFkZXI6IFdlYkdMU2hhZGVyO1xuXG5cdC8qKlxuXHQgKiBEZWxldGVzIHRoaXMgc2hhZGVyIHByb2dyYW1cblx0ICovXG5cdGRlbGV0ZShnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0KTogdm9pZCB7XG5cdFx0Ly8gQ2xlYW4gdXAgYWxsIGFzcGVjdHMgb2YgdGhpcyBwcm9ncmFtXG5cdFx0aWYodGhpcy5wcm9ncmFtKXtcblx0XHRcdGdsLmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcblx0XHR9XG5cdFx0XHRcblx0XHRpZih0aGlzLnZlcnRleFNoYWRlcil7XG5cdFx0XHRnbC5kZWxldGVTaGFkZXIodGhpcy52ZXJ0ZXhTaGFkZXIpO1xuXHRcdH1cblxuXHRcdGlmKHRoaXMuZnJhZ21lbnRTaGFkZXIpe1xuXHRcdFx0Z2wuZGVsZXRlU2hhZGVyKHRoaXMuZnJhZ21lbnRTaGFkZXIpO1xuXHRcdH1cblx0fVxufSIsImltcG9ydCBTaGFwZSBmcm9tIFwiLi9TaGFwZVwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uLy4uL1V0aWxzL01hdGhVdGlsc1wiO1xuaW1wb3J0IENpcmNsZSBmcm9tIFwiLi9DaXJjbGVcIjtcbmltcG9ydCBIaXQgZnJvbSBcIi4uL1BoeXNpY3MvSGl0XCI7XG5cbi8qKlxuICogQW4gQXhpcy1BbGlnbmVkIEJvdW5kaW5nIEJveC4gSW4gb3RoZXIgd29yZHMsIGEgcmVjdGFuZ2xlIHRoYXQgaXMgYWx3YXlzIGFsaWduZWQgdG8gdGhlIHgteSBncmlkLlxuICogSW5zcGlyZWQgYnkgdGhlIGhlbHBmdWwgY29sbGlzaW9uIGRvY3VtZW50YXRpb24gQGxpbmsoaGVyZSkoaHR0cHM6Ly9ub29uYXQuZ2l0aHViLmlvL2ludGVyc2VjdC8pLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBQUJCIGV4dGVuZHMgU2hhcGUge1xuICAgIGNlbnRlcjogVmVjMjtcbiAgICBoYWxmU2l6ZTogVmVjMjtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQUFCQlxuICAgICAqIEBwYXJhbSBjZW50ZXIgVGhlIGNlbnRlciBvZiB0aGUgQUFCQlxuICAgICAqIEBwYXJhbSBoYWxmU2l6ZSBUaGUgaGFsZiBzaXplIG9mIHRoZSBBQUJCIC0gVGhlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciB0byBhbiBlZGdlIGluIHggYW5kIHlcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjZW50ZXI/OiBWZWMyLCBoYWxmU2l6ZT86IFZlYzIpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNlbnRlciA9IGNlbnRlciA/IGNlbnRlciA6IG5ldyBWZWMyKDAsIDApO1xuICAgICAgICB0aGlzLmhhbGZTaXplID0gaGFsZlNpemUgPyBoYWxmU2l6ZSA6IG5ldyBWZWMyKDAsIDApO1xuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIGEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIEFBQkIgKi9cbiAgICBnZXQgdG9wTGVmdCgpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMubGVmdCwgdGhpcy50b3ApXG4gICAgfVxuXG4gICAgLyoqIFJldHVybnMgYSBwb2ludCByZXByZXNlbnRpbmcgdGhlIHRvcCByaWdodCBjb3JuZXIgb2YgdGhlIEFBQkIgKi9cbiAgICBnZXQgdG9wUmlnaHQoKTogVmVjMiB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLnJpZ2h0LCB0aGlzLnRvcClcbiAgICB9XG5cbiAgICAvKiogUmV0dXJucyBhIHBvaW50IHJlcHJlc2VudGluZyB0aGUgYm90dG9tIGxlZnQgY29ybmVyIG9mIHRoZSBBQUJCICovXG4gICAgZ2V0IGJvdHRvbUxlZnQoKTogVmVjMiB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLmxlZnQsIHRoaXMuYm90dG9tKVxuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIGEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSBBQUJCICovXG4gICAgZ2V0IGJvdHRvbVJpZ2h0KCk6IFZlYzIge1xuICAgICAgICByZXR1cm4gbmV3IFZlYzIodGhpcy5yaWdodCwgdGhpcy5ib3R0b20pXG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgZ2V0Qm91bmRpbmdSZWN0KCk6IEFBQkIge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICAgIH1cblxuICAgIC8vIEBvdmVycmlkZVxuICAgIGdldEJvdW5kaW5nQ2lyY2xlKCk6IENpcmNsZSB7XG4gICAgICAgIGxldCByID0gTWF0aC5tYXgodGhpcy5odywgdGhpcy5oaClcbiAgICAgICAgcmV0dXJuIG5ldyBDaXJjbGUodGhpcy5jZW50ZXIuY2xvbmUoKSwgcik7XG4gICAgfVxuXG4gICAgLy8gQGRlcHJlY2F0ZWRcbiAgICBnZXRIYWxmU2l6ZSgpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFsZlNpemU7XG4gICAgfVxuXG4gICAgLy8gQGRlcHJlY2F0ZWRcbiAgICBzZXRIYWxmU2l6ZShoYWxmU2l6ZTogVmVjMik6IHZvaWQge1xuICAgICAgICB0aGlzLmhhbGZTaXplID0gaGFsZlNpemU7XG4gICAgfVxuXG4gICAgLy8gVE9ETyAtIG1vdmUgdGhlc2UgYWxsIHRvIHRoZSBTaGFwZSBjbGFzc1xuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIGJvb2xlYW4gY2hlY2sgb2Ygd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgYSBwb2ludFxuICAgICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgcG9pbnRcbiAgICAgKi9cbiAgICBjb250YWluc1BvaW50KHBvaW50OiBWZWMyKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBwb2ludC54ID49IHRoaXMueCAtIHRoaXMuaHcgJiYgcG9pbnQueCA8PSB0aGlzLnggKyB0aGlzLmh3XG4gICAgICAgICAgICAmJiBwb2ludC55ID49IHRoaXMueSAtIHRoaXMuaGggJiYgcG9pbnQueSA8PSB0aGlzLnkgKyB0aGlzLmhoXG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIGJvb2xlYW4gY2hlY2sgb2Ygd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgYSBwb2ludFxuICAgICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgcG9pbnRcbiAgICAgKi9cbiAgICBpbnRlcnNlY3RQb2ludChwb2ludDogVmVjMik6IGJvb2xlYW4ge1xuICAgICAgICBsZXQgZHggPSBwb2ludC54IC0gdGhpcy54O1xuICAgICAgICBsZXQgcHggPSB0aGlzLmh3IC0gTWF0aC5hYnMoZHgpO1xuICAgICAgICBcbiAgICAgICAgaWYocHggPD0gMCl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZHkgPSBwb2ludC55IC0gdGhpcy55O1xuICAgICAgICBsZXQgcHkgPSB0aGlzLmhoIC0gTWF0aC5hYnMoZHkpO1xuXG4gICAgICAgIGlmKHB5IDw9IDApe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBib29sZWFuIGNoZWNrIG9mIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIGEgcG9pbnQgd2l0aCBzb2Z0IGxlZnQgYW5kIHRvcCBib3VuZGFyaWVzLlxuICAgICAqIEluIG90aGVyIHdvcmRzLCBpZiB0aGUgdG9wIGxlZnQgaXMgKDAsIDApLCB0aGUgcG9pbnQgKDAsIDApIGlzIG5vdCBpbiB0aGUgQUFCQlxuICAgICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgcG9pbnRcbiAgICAgKi9cbiAgICBjb250YWluc1BvaW50U29mdChwb2ludDogVmVjMik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gcG9pbnQueCA+IHRoaXMueCAtIHRoaXMuaHcgJiYgcG9pbnQueCA8PSB0aGlzLnggKyB0aGlzLmh3XG4gICAgICAgICAgICAmJiBwb2ludC55ID4gdGhpcy55IC0gdGhpcy5oaCAmJiBwb2ludC55IDw9IHRoaXMueSArIHRoaXMuaGhcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRhdGEgZnJvbSB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoaXMgQUFCQiB3aXRoIGEgbGluZSBzZWdtZW50IGZyb20gYSBwb2ludCBpbiBhIGRpcmVjdGlvblxuICAgICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdGhhdCB0aGUgbGluZSBzZWdtZW50IHN0YXJ0cyBmcm9tXG4gICAgICogQHBhcmFtIGRlbHRhIFRoZSBkaXJlY3Rpb24gYW5kIGRpc3RhbmNlIG9mIHRoZSBzZWdtZW50XG4gICAgICogQHBhcmFtIHBhZGRpbmcgUGFkcyB0aGUgQUFCQiB0byBtYWtlIGl0IHdpZGVyIGZvciB0aGUgaW50ZXJzZWN0aW9uIHRlc3RcbiAgICAgKiBAcmV0dXJucyBUaGUgSGl0IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGludGVyc2VjdGlvbiwgb3IgbnVsbCBpZiB0aGVyZSB3YXMgbm8gaW50ZXJzZWN0aW9uXG4gICAgICovXG4gICAgaW50ZXJzZWN0U2VnbWVudChwb2ludDogVmVjMiwgZGVsdGE6IFZlYzIsIHBhZGRpbmc/OiBWZWMyKTogSGl0IHtcbiAgICAgICAgbGV0IHBhZGRpbmdYID0gcGFkZGluZyA/IHBhZGRpbmcueCA6IDA7XG4gICAgICAgIGxldCBwYWRkaW5nWSA9IHBhZGRpbmcgPyBwYWRkaW5nLnkgOiAwO1xuXG4gICAgICAgIGxldCBzY2FsZVggPSAxL2RlbHRhLng7XG4gICAgICAgIGxldCBzY2FsZVkgPSAxL2RlbHRhLnk7XG5cbiAgICAgICAgbGV0IHNpZ25YID0gTWF0aFV0aWxzLnNpZ24oc2NhbGVYKTtcbiAgICAgICAgbGV0IHNpZ25ZID0gTWF0aFV0aWxzLnNpZ24oc2NhbGVZKTtcblxuICAgICAgICBsZXQgdG5lYXJ4ID0gc2NhbGVYKih0aGlzLnggLSBzaWduWCoodGhpcy5odyArIHBhZGRpbmdYKSAtIHBvaW50LngpO1xuICAgICAgICBsZXQgdG5lYXJ5ID0gc2NhbGVZKih0aGlzLnkgLSBzaWduWSoodGhpcy5oaCArIHBhZGRpbmdZKSAtIHBvaW50LnkpO1xuICAgICAgICBsZXQgdGZhcnggPSBzY2FsZVgqKHRoaXMueCArIHNpZ25YKih0aGlzLmh3ICsgcGFkZGluZ1gpIC0gcG9pbnQueCk7XG4gICAgICAgIGxldCB0ZmFyeSA9IHNjYWxlWSoodGhpcy55ICsgc2lnblkqKHRoaXMuaGggKyBwYWRkaW5nWSkgLSBwb2ludC55KTtcbiAgICAgICAgXG4gICAgICAgIGlmKHRuZWFyeCA+IHRmYXJ5IHx8IHRuZWFyeSA+IHRmYXJ4KXtcbiAgICAgICAgICAgIC8vIFdlIGFyZW4ndCBjb2xsaWRpbmcgLSB3ZSBjbGVhciBvbmUgYXhpcyBiZWZvcmUgaW50ZXJzZWN0aW5nIGFub3RoZXJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHRuZWFyID0gTWF0aC5tYXgodG5lYXJ4LCB0bmVhcnkpO1xuXG4gICAgICAgIC8vIERvdWJsZSBjaGVjayBmb3IgTmFOc1xuICAgICAgICBpZih0bmVhcnggIT09IHRuZWFyeCl7XG4gICAgICAgICAgICB0bmVhciA9IHRuZWFyeTtcbiAgICAgICAgfSBlbHNlIGlmICh0bmVhcnkgIT09IHRuZWFyeSl7XG4gICAgICAgICAgICB0bmVhciA9IHRuZWFyeDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0ZmFyID0gTWF0aC5taW4odGZhcngsIHRmYXJ5KTtcblxuICAgICAgICBpZih0bmVhciA9PT0gLUluZmluaXR5KXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodG5lYXIgPj0gMSB8fCB0ZmFyIDw9IDApe1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBhcmUgY29sbGlkaW5nXG4gICAgICAgIGxldCBoaXQgPSBuZXcgSGl0KCk7XG4gICAgICAgIGhpdC50aW1lID0gTWF0aFV0aWxzLmNsYW1wMDEodG5lYXIpO1xuICAgICAgICBoaXQubmVhclRpbWVzLnggPSB0bmVhcng7XG4gICAgICAgIGhpdC5uZWFyVGltZXMueSA9IHRuZWFyeTtcblxuICAgICAgICBpZih0bmVhcnggPiB0bmVhcnkpe1xuICAgICAgICAgICAgLy8gV2UgaGl0IG9uIHRoZSBsZWZ0IG9yIHJpZ2h0IHNpemVcbiAgICAgICAgICAgIGhpdC5ub3JtYWwueCA9IC1zaWduWDtcbiAgICAgICAgICAgIGhpdC5ub3JtYWwueSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZihNYXRoLmFicyh0bmVhcnggLSB0bmVhcnkpIDwgMC4wMDAxKXtcbiAgICAgICAgICAgIC8vIFdlIGhpdCBvbiB0aGUgY29ybmVyXG4gICAgICAgICAgICBoaXQubm9ybWFsLnggPSAtc2lnblg7XG4gICAgICAgICAgICBoaXQubm9ybWFsLnkgPSAtc2lnblk7XG4gICAgICAgICAgICBoaXQubm9ybWFsLm5vcm1hbGl6ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UgaGl0IG9uIHRoZSB0b3Agb3IgYm90dG9tXG4gICAgICAgICAgICBoaXQubm9ybWFsLnggPSAwO1xuICAgICAgICAgICAgaGl0Lm5vcm1hbC55ID0gLXNpZ25ZO1xuICAgICAgICB9XG5cbiAgICAgICAgaGl0LmRlbHRhLnggPSAoMS4wIC0gaGl0LnRpbWUpICogLWRlbHRhLng7XG4gICAgICAgIGhpdC5kZWx0YS55ID0gKDEuMCAtIGhpdC50aW1lKSAqIC1kZWx0YS55O1xuICAgICAgICBoaXQucG9zLnggPSBwb2ludC54ICsgZGVsdGEueCAqIGhpdC50aW1lO1xuICAgICAgICBoaXQucG9zLnkgPSBwb2ludC55ICsgZGVsdGEueSAqIGhpdC50aW1lO1xuXG4gICAgICAgIHJldHVybiBoaXQ7XG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgb3ZlcmxhcHMob3RoZXI6IFNoYXBlKTogYm9vbGVhbiB7XG4gICAgICAgIGlmKG90aGVyIGluc3RhbmNlb2YgQUFCQil7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vdmVybGFwc0FBQkIob3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IFwiT3ZlcmxhcCBub3QgZGVmaW5lZCBiZXR3ZWVuIHRoZXNlIHNoYXBlcy5cIlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIGJvb2xlYW4gY2hlY2sgb2Ygd2hldGhlciB0aGlzIEFBQkIgb3ZlcmxhcHMgYW5vdGhlclxuICAgICAqIEBwYXJhbSBvdGhlciBUaGUgb3RoZXIgQUFCQiB0byBjaGVjayBhZ2FpbnN0XG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGlzIEFBQkIgb3ZlcmxhcHMgdGhlIG90aGVyLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgb3ZlcmxhcHNBQUJCKG90aGVyOiBBQUJCKTogYm9vbGVhbiB7XG4gICAgICAgIGxldCBkeCA9IG90aGVyLnggLSB0aGlzLng7XG4gICAgICAgIGxldCBweCA9IHRoaXMuaHcgKyBvdGhlci5odyAtIE1hdGguYWJzKGR4KTtcbiAgICAgICAgXG4gICAgICAgIGlmKHB4IDw9IDApe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGR5ID0gb3RoZXIueSAtIHRoaXMueTtcbiAgICAgICAgbGV0IHB5ID0gdGhpcy5oaCArIG90aGVyLmhoIC0gTWF0aC5hYnMoZHkpO1xuXG4gICAgICAgIGlmKHB5IDw9IDApe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZXNlIEFBQkJzIGFyZSBKVVNUIHRvdWNoaW5nIC0gbm90IG92ZXJsYXBwaW5nLlxuICAgICAqIFZlYzIueCBpcyAtMSBpZiB0aGUgb3RoZXIgaXMgdG8gdGhlIGxlZnQsIDEgaWYgdG8gdGhlIHJpZ2h0LlxuICAgICAqIExpa2V3aXNlLCBWZWMyLnkgaXMgLTEgaWYgdGhlIG90aGVyIGlzIG9uIHRvcCwgMSBpZiBvbiBib3R0b20uXG4gICAgICogQHBhcmFtIG90aGVyIFRoZSBvdGhlciBBQUJCIHRvIGNoZWNrXG4gICAgICogQHJldHVybnMgVGhlIGNvbGxpc2lvbiBzaWRlcyBzdG9yZWQgaW4gYSBWZWMyIGlmIHRoZSBBQUJCcyBhcmUgdG91Y2hpbmcsIG51bGwgb3RoZXJ3aXNlXG4gICAgICovXG4gICAgdG91Y2hlc0FBQkIob3RoZXI6IEFBQkIpOiBWZWMyIHtcbiAgICAgICAgbGV0IGR4ID0gb3RoZXIueCAtIHRoaXMueDtcbiAgICAgICAgbGV0IHB4ID0gdGhpcy5odyArIG90aGVyLmh3IC0gTWF0aC5hYnMoZHgpO1xuXG4gICAgICAgIGxldCBkeSA9IG90aGVyLnkgLSB0aGlzLnk7XG4gICAgICAgIGxldCBweSA9IHRoaXMuaGggKyBvdGhlci5oaCAtIE1hdGguYWJzKGR5KTtcblxuICAgICAgICAvLyBJZiBvbmUgYXhpcyBpcyBqdXN0IHRvdWNoaW5nIGFuZCB0aGUgb3RoZXIgaXMgb3ZlcmxhcHBpbmcsIHRydWVcbiAgICAgICAgaWYoKHB4ID09PSAwICYmIHB5ID49IDApIHx8IChweSA9PT0gMCAmJiBweCA+PSAwKSl7XG4gICAgICAgICAgICBsZXQgcmV0ID0gbmV3IFZlYzIoKTtcblxuICAgICAgICAgICAgaWYocHggPT09IDApe1xuICAgICAgICAgICAgICAgIHJldC54ID0gb3RoZXIueCA8IHRoaXMueCA/IC0xIDogMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYocHkgPT09IDApe1xuICAgICAgICAgICAgICAgIHJldC55ID0gb3RoZXIueSA8IHRoaXMueSA/IC0xIDogMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZXNlIEFBQkJzIGFyZSBKVVNUIHRvdWNoaW5nIC0gbm90IG92ZXJsYXBwaW5nLlxuICAgICAqIEFsc28sIGlmIHRoZXkgYXJlIG9ubHkgdG91Y2hpbmcgY29ybmVycywgdGhleSBhcmUgY29uc2lkZXJlZCBub3QgdG91Y2hpbmcuXG4gICAgICogVmVjMi54IGlzIC0xIGlmIHRoZSBvdGhlciBpcyB0byB0aGUgbGVmdCwgMSBpZiB0byB0aGUgcmlnaHQuXG4gICAgICogTGlrZXdpc2UsIFZlYzIueSBpcyAtMSBpZiB0aGUgb3RoZXIgaXMgb24gdG9wLCAxIGlmIG9uIGJvdHRvbS5cbiAgICAgKiBAcGFyYW0gb3RoZXIgVGhlIG90aGVyIEFBQkIgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyBUaGUgc2lkZSBvZiB0aGUgdG91Y2gsIHN0b3JlZCBhcyBhIFZlYzIsIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gdG91Y2hcbiAgICAgKi9cbiAgICB0b3VjaGVzQUFCQldpdGhvdXRDb3JuZXJzKG90aGVyOiBBQUJCKTogVmVjMiB7XG4gICAgICAgIGxldCBkeCA9IG90aGVyLnggLSB0aGlzLng7XG4gICAgICAgIGxldCBweCA9IHRoaXMuaHcgKyBvdGhlci5odyAtIE1hdGguYWJzKGR4KTtcblxuICAgICAgICBsZXQgZHkgPSBvdGhlci55IC0gdGhpcy55O1xuICAgICAgICBsZXQgcHkgPSB0aGlzLmhoICsgb3RoZXIuaGggLSBNYXRoLmFicyhkeSk7XG5cbiAgICAgICAgLy8gSWYgb25lIGF4aXMgaXMgdG91Y2hpbmcsIGFuZCB0aGUgb3RoZXIgaXMgc3RyaWN0bHkgb3ZlcmxhcHBpbmdcbiAgICAgICAgaWYoKHB4ID09PSAwICYmIHB5ID4gMCkgfHwgKHB5ID09PSAwICYmIHB4ID4gMCkpe1xuICAgICAgICAgICAgbGV0IHJldCA9IG5ldyBWZWMyKCk7XG5cbiAgICAgICAgICAgIGlmKHB4ID09PSAwKXtcbiAgICAgICAgICAgICAgICByZXQueCA9IG90aGVyLnggPCB0aGlzLnggPyAtMSA6IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldC55ID0gb3RoZXIueSA8IHRoaXMueSA/IC0xIDogMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBhcmVhIG9mIHRoZSBvdmVybGFwIGJldHdlZW4gdGhpcyBBQUJCIGFuZCBhbm90aGVyXG4gICAgICogQHBhcmFtIG90aGVyIFRoZSBvdGhlciBBQUJCXG4gICAgICogQHJldHVybnMgVGhlIGFyZWEgb2YgdGhlIG92ZXJsYXAgYmV0d2VlbiB0aGUgQUFCQnNcbiAgICAgKi9cbiAgICBvdmVybGFwQXJlYShvdGhlcjogQUFCQik6IG51bWJlciB7XG4gICAgICAgIGxldCBsZWZ0eCA9IE1hdGgubWF4KHRoaXMueCAtIHRoaXMuaHcsIG90aGVyLnggLSBvdGhlci5odyk7XG4gICAgICAgIGxldCByaWdodHggPSBNYXRoLm1pbih0aGlzLnggKyB0aGlzLmh3LCBvdGhlci54ICsgb3RoZXIuaHcpO1xuICAgICAgICBsZXQgZHggPSByaWdodHggLSBsZWZ0eDtcblxuICAgICAgICBsZXQgbGVmdHkgPSBNYXRoLm1heCh0aGlzLnkgLSB0aGlzLmhoLCBvdGhlci55IC0gb3RoZXIuaGgpO1xuICAgICAgICBsZXQgcmlnaHR5ID0gTWF0aC5taW4odGhpcy55ICsgdGhpcy5oaCwgb3RoZXIueSArIG90aGVyLmhoKTtcbiAgICAgICAgbGV0IGR5ID0gcmlnaHR5IC0gbGVmdHk7XG5cbiAgICAgICAgaWYoZHggPCAwIHx8IGR5IDwgMCkgcmV0dXJuIDA7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZHgqZHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYW5kIHJlc2l6ZXMgdGhpcyByZWN0IGZyb20gaXRzIGN1cnJlbnQgcG9zaXRpb24gdG8gdGhlIHBvc2l0aW9uIHNwZWNpZmllZFxuICAgICAqIEBwYXJhbSB2ZWxvY2l0eSBUaGUgbW92ZW1lbnQgb2YgdGhlIHJlY3QgZnJvbSBpdHMgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gZnJvbVBvc2l0aW9uIEEgcG9zaXRpb24gc3BlY2lmaWVkIHRvIGJlIHRoZSBzdGFydGluZyBwb2ludCBvZiBzd2VlcGluZ1xuICAgICAqIEBwYXJhbSBoYWxmU2l6ZSBUaGUgaGFsZlNpemUgb2YgdGhlIHN3ZWVwaW5nIHJlY3QgXG4gICAgICovXG4gICAgc3dlZXAodmVsb2NpdHk6IFZlYzIsIGZyb21Qb3NpdGlvbj86IFZlYzIsIGhhbGZTaXplPzogVmVjMik6IHZvaWQge1xuICAgICAgICBpZighZnJvbVBvc2l0aW9uKXtcbiAgICAgICAgICAgIGZyb21Qb3NpdGlvbiA9IHRoaXMuY2VudGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIWhhbGZTaXplKXtcbiAgICAgICAgICAgIGhhbGZTaXplID0gdGhpcy5oYWxmU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjZW50ZXJYID0gZnJvbVBvc2l0aW9uLnggKyB2ZWxvY2l0eS54LzI7XG4gICAgICAgIGxldCBjZW50ZXJZID0gZnJvbVBvc2l0aW9uLnkgKyB2ZWxvY2l0eS55LzI7XG5cbiAgICAgICAgbGV0IG1pblggPSBNYXRoLm1pbihmcm9tUG9zaXRpb24ueCAtIGhhbGZTaXplLngsIGZyb21Qb3NpdGlvbi54ICsgdmVsb2NpdHkueCAtIGhhbGZTaXplLngpO1xuICAgICAgICBsZXQgbWluWSA9IE1hdGgubWluKGZyb21Qb3NpdGlvbi55IC0gaGFsZlNpemUueSwgZnJvbVBvc2l0aW9uLnkgKyB2ZWxvY2l0eS55IC0gaGFsZlNpemUueSk7XG5cbiAgICAgICAgdGhpcy5jZW50ZXIuc2V0KGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgICB0aGlzLmhhbGZTaXplLnNldChjZW50ZXJYIC0gbWluWCwgY2VudGVyWSAtIG1pblkpO1xuICAgIH1cbiAgICBcbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBjbG9uZSgpOiBBQUJCIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBQUJCKHRoaXMuY2VudGVyLmNsb25lKCksIHRoaXMuaGFsZlNpemUuY2xvbmUoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyBBQUJCIHRvIGEgc3RyaW5nIGZvcm1hdFxuICAgICAqIEByZXR1cm5zIChjZW50ZXI6ICh4LCB5KSwgaGFsZlNpemU6ICh4LCB5KSlcbiAgICAgKi9cbiAgICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gXCIoY2VudGVyOiBcIiArIHRoaXMuY2VudGVyLnRvU3RyaW5nKCkgKyBcIiwgaGFsZi1zaXplOiBcIiArIHRoaXMuaGFsZlNpemUudG9TdHJpbmcoKSArIFwiKVwiXG4gICAgfVxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9WZWMyXCI7XG5pbXBvcnQgQUFCQiBmcm9tIFwiLi9BQUJCXCI7XG5pbXBvcnQgU2hhcGUgZnJvbSBcIi4vU2hhcGVcIjtcblxuLyoqXG4gKiBBIENpcmNsZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaXJjbGUgZXh0ZW5kcyBTaGFwZSB7XG5cdHByaXZhdGUgX2NlbnRlcjogVmVjMjtcblx0cmFkaXVzOiBudW1iZXI7XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyBDaXJjbGVcblx0ICogQHBhcmFtIGNlbnRlciBUaGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcblx0ICogQHBhcmFtIHJhZGl1cyBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcblx0ICovXG5cdGNvbnN0cnVjdG9yKGNlbnRlcjogVmVjMiwgcmFkaXVzOiBudW1iZXIpIHtcblx0XHRzdXBlcigpO1xuICAgICAgICB0aGlzLl9jZW50ZXIgPSBjZW50ZXIgPyBjZW50ZXIgOiBuZXcgVmVjMigwLCAwKTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSByYWRpdXMgPyByYWRpdXMgOiAwO1xuXHR9XG5cblx0Z2V0IGNlbnRlcigpOiBWZWMyIHtcblx0XHRyZXR1cm4gdGhpcy5fY2VudGVyO1xuXHR9XG5cblx0c2V0IGNlbnRlcihjZW50ZXI6IFZlYzIpIHtcblx0XHR0aGlzLl9jZW50ZXIgPSBjZW50ZXI7XG5cdH1cblxuXHRnZXQgaGFsZlNpemUoKTogVmVjMiB7XG5cdFx0cmV0dXJuIG5ldyBWZWMyKHRoaXMucmFkaXVzLCB0aGlzLnJhZGl1cyk7XG5cdH1cblxuXHRnZXQgcigpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLnJhZGl1cztcblx0fVxuXG5cdHNldCByKHJhZGl1czogbnVtYmVyKSB7XG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cdH1cblxuXHQvLyBAb3ZlcnJpZGVcblx0LyoqXG4gICAgICogQSBzaW1wbGUgYm9vbGVhbiBjaGVjayBvZiB3aGV0aGVyIHRoaXMgQUFCQiBjb250YWlucyBhIHBvaW50XG4gICAgICogQHBhcmFtIHBvaW50IFRoZSBwb2ludCB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgdGhlIHNwZWNpZmllZCBwb2ludFxuICAgICAqL1xuICAgIGNvbnRhaW5zUG9pbnQocG9pbnQ6IFZlYzIpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VudGVyLmRpc3RhbmNlU3FUbyhwb2ludCkgPD0gdGhpcy5yYWRpdXMqdGhpcy5yYWRpdXM7XG4gICAgfVxuXG5cdC8vIEBvdmVycmlkZVxuXHRnZXRCb3VuZGluZ1JlY3QoKTogQUFCQiB7XG5cdFx0cmV0dXJuIG5ldyBBQUJCKHRoaXMuX2NlbnRlci5jbG9uZSgpLCBuZXcgVmVjMih0aGlzLnJhZGl1cywgdGhpcy5yYWRpdXMpKTtcblx0fVxuXG5cdC8vIEBvdmVycmlkZVxuXHRnZXRCb3VuZGluZ0NpcmNsZSgpOiBDaXJjbGUge1xuXHRcdHJldHVybiB0aGlzLmNsb25lKCk7XG5cdH1cblxuXHQvLyBAb3ZlcnJpZGVcblx0b3ZlcmxhcHMob3RoZXI6IFNoYXBlKTogYm9vbGVhbiB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG5cdH1cblxuXHQvLyBAb3ZlcnJpZGVcblx0Y2xvbmUoKTogQ2lyY2xlIHtcblx0XHRyZXR1cm4gbmV3IENpcmNsZSh0aGlzLl9jZW50ZXIuY2xvbmUoKSwgdGhpcy5yYWRpdXMpO1xuXHR9XG5cblx0dG9TdHJpbmcoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gXCIoY2VudGVyOiBcIiArIHRoaXMuY2VudGVyLnRvU3RyaW5nKCkgKyBcIiwgcmFkaXVzOiBcIiArIHRoaXMucmFkaXVzICsgXCIpXCI7XG5cdH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vVmVjMlwiO1xuaW1wb3J0IEFBQkIgZnJvbSBcIi4vQUFCQlwiO1xuaW1wb3J0IENpcmNsZSBmcm9tIFwiLi9DaXJjbGVcIjtcblxuLyoqXG4gKiBBbiBhYnN0cmFjdCBTaGFwZSBjbGFzcyB0aGF0IGFjdHMgYXMgYW4gaW50ZXJmYWNlIGZvciBiZXR0ZXIgaW50ZXJhY3Rpb25zIHdpdGggc3ViY2xhc3Nlcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgU2hhcGUge1xuICAgIGFic3RyYWN0IGdldCBjZW50ZXIoKTogVmVjMjtcblxuICAgIGFic3RyYWN0IHNldCBjZW50ZXIoY2VudGVyOiBWZWMyKTtcblxuICAgIGFic3RyYWN0IGdldCBoYWxmU2l6ZSgpOiBWZWMyO1xuXG4gICAgZ2V0IHgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VudGVyLng7XG4gICAgfVxuXG4gICAgZ2V0IHkoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VudGVyLnk7XG4gICAgfVxuXG4gICAgZ2V0IGh3KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbGZTaXplLng7XG4gICAgfVxuXG4gICAgZ2V0IGhoKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbGZTaXplLnk7XG4gICAgfVxuXG4gICAgZ2V0IHRvcCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy55IC0gdGhpcy5oaDtcbiAgICB9XG5cbiAgICBnZXQgYm90dG9tKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLmhoO1xuICAgIH1cblxuICAgIGdldCBsZWZ0KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnggLSB0aGlzLmh3O1xuICAgIH1cblxuICAgIGdldCByaWdodCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy54ICsgdGhpcy5odztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgYm91bmRpbmcgcmVjdGFuZ2xlIGZvciB0aGlzIHNoYXBlLiBXYXJuaW5nIC0gbWF5IGJlIHRoZSBzYW1lIGFzIHRoaXMgU2hhcGUuXG4gICAgICogRm9yIGluc3RhbmNlLCB0aGUgYm91bmRpbmcgY2lyY2xlIG9mIGFuIEFBQkIgaXMgaXRzZWxmLiBVc2UgY2xvbmUoKSBpZiB5b3UgbmVlZCBhIG5ldyBzaGFwZS5cbiAgICAgKiBAcmV0dXJucyBBbiBBQUJCIHRoYXQgYm91bmRzIHRoaXMgc2hhcGVcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBnZXRCb3VuZGluZ1JlY3QoKTogQUFCQjtcblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBib3VuZGluZyBjaXJjbGUgZm9yIHRoaXMgc2hhcGUuIFdhcm5pbmcgLSBtYXkgYmUgdGhlIHNhbWUgYXMgdGhpcyBTaGFwZS5cbiAgICAgKiBGb3IgaW5zdGFuY2UsIHRoZSBib3VuZGluZyBjaXJjbGUgb2YgYSBDaXJjbGUgaXMgaXRzZWxmLiBVc2UgY2xvbmUoKSBpZiB5b3UgbmVlZCBhIG5ldyBzaGFwZS5cbiAgICAgKiBAcmV0dXJucyBBIENpcmNsZSB0aGF0IGJvdW5kcyB0aGlzIHNoYXBlXG4gICAgICovXG4gICAgYWJzdHJhY3QgZ2V0Qm91bmRpbmdDaXJjbGUoKTogQ2lyY2xlO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBTaGFwZVxuICAgICAqIEByZXR1cm5zIEEgbmV3IGNvcHkgb2YgdGhpcyBzaGFwZVxuICAgICAqL1xuICAgIGFic3RyYWN0IGNsb25lKCk6IFNoYXBlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoaXMgc2hhcGUgb3ZlcmxhcHMgYW5vdGhlclxuICAgICAqIEBwYXJhbSBvdGhlciBUaGUgb3RoZXIgc2hhcGUgdG8gY2hlY2sgYWdhaW5zdFxuICAgICAqIEByZXR1cm5zIGEgYm9vbGVhbiB0aGF0IHJlcHJlc2VudHMgd2hldGhlciB0aGlzIFNoYXBlIG92ZXJsYXBzIHRoZSBvdGhlciBvbmVcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBvdmVybGFwcyhvdGhlcjogU2hhcGUpOiBib29sZWFuO1xuXG4gICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIGJvb2xlYW4gY2hlY2sgb2Ygd2hldGhlciB0aGlzIFNoYXBlIGNvbnRhaW5zIGEgcG9pbnRcbiAgICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRvIGNoZWNrXG4gICAgICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIHRoaXMgU2hhcGUgY29udGFpbnMgdGhlIHNwZWNpZmllZCBwb2ludFxuICAgICAqL1xuICAgIGFic3RyYWN0IGNvbnRhaW5zUG9pbnQocG9pbnQ6IFZlYzIpOiBib29sZWFuO1xuXG4gICAgc3RhdGljIGdldFRpbWVPZkNvbGxpc2lvbihBOiBTaGFwZSwgdmVsQTogVmVjMiwgQjogU2hhcGUsIHZlbEI6IFZlYzIpOiBbVmVjMiwgVmVjMiwgYm9vbGVhbiwgYm9vbGVhbl0ge1xuXHRcdGlmKEEgaW5zdGFuY2VvZiBBQUJCICYmIEIgaW5zdGFuY2VvZiBBQUJCKXtcblx0XHRcdHJldHVybiBTaGFwZS5nZXRUaW1lT2ZDb2xsaXNpb25fQUFCQl9BQUJCKEEsIHZlbEEsIEIsIHZlbEIpO1xuXHRcdH1cbiAgICB9XG4gICAgXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0VGltZU9mQ29sbGlzaW9uX0FBQkJfQUFCQihBOiBBQUJCLCB2ZWxBOiBWZWMyLCBCOiBTaGFwZSwgdmVsQjogVmVjMik6IFtWZWMyLCBWZWMyLCBib29sZWFuLCBib29sZWFuXSB7XG4gICAgICAgIGxldCBwb3NTbWFsbGVyID0gQS5jZW50ZXI7XG4gICAgICAgIGxldCBwb3NMYXJnZXIgPSBCLmNlbnRlcjtcbiAgICAgICAgXG4gICAgICAgIGxldCBzaXplU21hbGxlciA9IEEuaGFsZlNpemU7XG4gICAgICAgIGxldCBzaXplTGFyZ2VyID0gQi5oYWxmU2l6ZTtcbiAgICBcbiAgICAgICAgbGV0IGZpcnN0Q29udGFjdCA9IG5ldyBWZWMyKDAsIDApO1xuICAgICAgICBsZXQgbGFzdENvbnRhY3QgPSBuZXcgVmVjMigwLCAwKTtcbiAgICBcbiAgICAgICAgbGV0IGNvbGxpZGluZ1ggPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvbGxpZGluZ1kgPSBmYWxzZTtcbiAgICBcbiAgICAgICAgLy8gU29ydCBieSBwb3NpdGlvblxuICAgICAgICBpZihwb3NMYXJnZXIueCA8IHBvc1NtYWxsZXIueCl7XG4gICAgICAgICAgICAvLyBTd2FwLCBiZWNhdXNlIHNtYWxsZXIgaXMgZnVydGhlciByaWdodCB0aGFuIGxhcmdlclxuICAgICAgICAgICAgbGV0IHRlbXA6IFZlYzI7XG4gICAgICAgICAgICB0ZW1wID0gc2l6ZVNtYWxsZXI7XG4gICAgICAgICAgICBzaXplU21hbGxlciA9IHNpemVMYXJnZXI7XG4gICAgICAgICAgICBzaXplTGFyZ2VyID0gdGVtcDtcbiAgICBcbiAgICAgICAgICAgIHRlbXAgPSBwb3NTbWFsbGVyO1xuICAgICAgICAgICAgcG9zU21hbGxlciA9IHBvc0xhcmdlcjtcbiAgICAgICAgICAgIHBvc0xhcmdlciA9IHRlbXA7XG4gICAgXG4gICAgICAgICAgICB0ZW1wID0gdmVsQTtcbiAgICAgICAgICAgIHZlbEEgPSB2ZWxCO1xuICAgICAgICAgICAgdmVsQiA9IHRlbXA7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gQSBpcyBsZWZ0LCBCIGlzIHJpZ2h0XG4gICAgICAgIGZpcnN0Q29udGFjdC54ID0gSW5maW5pdHk7XG4gICAgICAgIGxhc3RDb250YWN0LnggPSBJbmZpbml0eTtcbiAgICBcbiAgICAgICAgaWYgKHBvc0xhcmdlci54IC0gc2l6ZUxhcmdlci54ID49IHBvc1NtYWxsZXIueCArIHNpemVTbWFsbGVyLngpe1xuICAgICAgICAgICAgLy8gSWYgd2UgYXJlbid0IGN1cnJlbnRseSBjb2xsaWRpbmdcbiAgICAgICAgICAgIGxldCByZWxWZWwgPSB2ZWxBLnggLSB2ZWxCLng7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHJlbFZlbCA+IDApe1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXkgYXJlIG1vdmluZyB0b3dhcmRzIGVhY2ggb3RoZXJcbiAgICAgICAgICAgICAgICBmaXJzdENvbnRhY3QueCA9ICgocG9zTGFyZ2VyLnggLSBzaXplTGFyZ2VyLngpIC0gKHBvc1NtYWxsZXIueCArIHNpemVTbWFsbGVyLngpKS8ocmVsVmVsKTtcbiAgICAgICAgICAgICAgICBsYXN0Q29udGFjdC54ID0gKChwb3NMYXJnZXIueCArIHNpemVMYXJnZXIueCkgLSAocG9zU21hbGxlci54IC0gc2l6ZVNtYWxsZXIueCkpLyhyZWxWZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sbGlkaW5nWCA9IHRydWU7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgaWYocG9zTGFyZ2VyLnkgPCBwb3NTbWFsbGVyLnkpe1xuICAgICAgICAgICAgLy8gU3dhcCwgYmVjYXVzZSBzbWFsbGVyIGlzIGZ1cnRoZXIgdXAgdGhhbiBsYXJnZXJcbiAgICAgICAgICAgIGxldCB0ZW1wOiBWZWMyO1xuICAgICAgICAgICAgdGVtcCA9IHNpemVTbWFsbGVyO1xuICAgICAgICAgICAgc2l6ZVNtYWxsZXIgPSBzaXplTGFyZ2VyO1xuICAgICAgICAgICAgc2l6ZUxhcmdlciA9IHRlbXA7XG4gICAgXG4gICAgICAgICAgICB0ZW1wID0gcG9zU21hbGxlcjtcbiAgICAgICAgICAgIHBvc1NtYWxsZXIgPSBwb3NMYXJnZXI7XG4gICAgICAgICAgICBwb3NMYXJnZXIgPSB0ZW1wO1xuICAgIFxuICAgICAgICAgICAgdGVtcCA9IHZlbEE7XG4gICAgICAgICAgICB2ZWxBID0gdmVsQjtcbiAgICAgICAgICAgIHZlbEIgPSB0ZW1wO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIEEgaXMgdG9wLCBCIGlzIGJvdHRvbVxuICAgICAgICBmaXJzdENvbnRhY3QueSA9IEluZmluaXR5O1xuICAgICAgICBsYXN0Q29udGFjdC55ID0gSW5maW5pdHk7XG4gICAgXG4gICAgICAgIGlmIChwb3NMYXJnZXIueSAtIHNpemVMYXJnZXIueSA+PSBwb3NTbWFsbGVyLnkgKyBzaXplU21hbGxlci55KXtcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZW4ndCBjdXJyZW50bHkgY29sbGlkaW5nXG4gICAgICAgICAgICBsZXQgcmVsVmVsID0gdmVsQS55IC0gdmVsQi55O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihyZWxWZWwgPiAwKXtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGV5IGFyZSBtb3ZpbmcgdG93YXJkcyBlYWNoIG90aGVyXG4gICAgICAgICAgICAgICAgZmlyc3RDb250YWN0LnkgPSAoKHBvc0xhcmdlci55IC0gc2l6ZUxhcmdlci55KSAtIChwb3NTbWFsbGVyLnkgKyBzaXplU21hbGxlci55KSkvKHJlbFZlbCk7XG4gICAgICAgICAgICAgICAgbGFzdENvbnRhY3QueSA9ICgocG9zTGFyZ2VyLnkgKyBzaXplTGFyZ2VyLnkpIC0gKHBvc1NtYWxsZXIueSAtIHNpemVTbWFsbGVyLnkpKS8ocmVsVmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbGxpZGluZ1kgPSB0cnVlO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIHJldHVybiBbZmlyc3RDb250YWN0LCBsYXN0Q29udGFjdCwgY29sbGlkaW5nWCwgY29sbGlkaW5nWV07XG4gICAgfVxufSIsImltcG9ydCBDb2xsZWN0aW9uIGZyb20gXCIuL0NvbGxlY3Rpb25cIjtcblxuLyoqXG4gKiBBIExJRk8gc3RhY2sgd2l0aCBpdGVtcyBvZiB0eXBlIFRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhY2s8VD4gaW1wbGVtZW50cyBDb2xsZWN0aW9uIHtcbiAgICAvKiogVGhlIG1heGltdW0gbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBTdGFjayAqL1xuICAgIHByaXZhdGUgTUFYX0VMRU1FTlRTOiBudW1iZXI7XG4gICAgXG4gICAgLyoqIFRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3RhY2sgKi9cbiAgICBwcml2YXRlIHN0YWNrOiBBcnJheTxUPjtcbiAgICBcbiAgICAvKiogVGhlIGhlYWQgb2YgdGhlIHN0YWNrICovXG5cdHByaXZhdGUgaGVhZDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBzdGFja1xuICAgICAqIEBwYXJhbSBtYXhFbGVtZW50cyBUaGUgbWF4aW11bSBzaXplIG9mIHRoZSBzdGFja1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1heEVsZW1lbnRzOiBudW1iZXIgPSAxMDApe1xuICAgICAgICB0aGlzLk1BWF9FTEVNRU5UUyA9IG1heEVsZW1lbnRzO1xuICAgICAgICB0aGlzLnN0YWNrID0gbmV3IEFycmF5PFQ+KHRoaXMuTUFYX0VMRU1FTlRTKTtcbiAgICAgICAgdGhpcy5oZWFkID0gLTE7XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gaXRlbSB0byB0aGUgdG9wIG9mIHRoZSBzdGFja1xuICAgICAqIEBwYXJhbSBpdGVtIFRoZSBuZXcgaXRlbSB0byBhZGQgdG8gdGhlIHN0YWNrXG4gICAgICovXG4gICAgcHVzaChpdGVtOiBUKTogdm9pZCB7XG4gICAgICAgIGlmKHRoaXMuaGVhZCArIDEgPT09IHRoaXMuTUFYX0VMRU1FTlRTKXtcbiAgICAgICAgICAgIHRocm93IFwiU3RhY2sgZnVsbCAtIGNhbm5vdCBhZGQgZWxlbWVudFwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGVhZCArPSAxO1xuICAgICAgICB0aGlzLnN0YWNrW3RoaXMuaGVhZF0gPSBpdGVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4gICAgICogQHJldHVybnMgVGhlIGl0ZW0gYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2tcbiAgICAgKi9cbiAgICBwb3AoKTogVCB7XG4gICAgICAgIGlmKHRoaXMuaGVhZCA9PT0gLTEpe1xuICAgICAgICAgICAgdGhyb3cgXCJTdGFjayBlbXB0eSAtIGNhbm5vdCByZW1vdmUgZWxlbWVudFwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGVhZCAtPSAxO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLmhlYWQgKyAxXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50IGN1cnJlbnRseSBhdCB0aGUgdG9wIG9mIHRoZSBzdGFja1xuICAgICAqIEByZXR1cm5zIFRoZSBpdGVtIGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4gICAgICovXG4gICAgcGVlaygpOiBUIHtcbiAgICAgICAgaWYodGhpcy5oZWFkID09PSAtMSl7XG4gICAgICAgICAgICB0aHJvdyBcIlN0YWNrIGVtcHR5IC0gY2Fubm90IGdldCBlbGVtZW50XCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tbdGhpcy5oZWFkXTtcbiAgICB9XG5cbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoaXMgc3RhY2sgaXMgZW1wdHlcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gdGhhdCByZXByZXNlbnRzIHdoZXRoZXIgb3Igbm90IHRoZSBzdGFjayBpcyBlbXB0eVxuICAgICovXG4gICAgaXNFbXB0eSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZCA9PT0gLTE7XG4gICAgfVxuXG4gICAgLy8gQGltcGxlbWVudGVkXG4gICAgY2xlYXIoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IGRlbGV0ZSB0aGlzLnN0YWNrW2luZGV4XSk7XG4gICAgICAgIHRoaXMuaGVhZCA9IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBpdGVtcyBjdXJyZW50bHkgaW4gdGhlIHN0YWNrXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgc3RhY2tcbiAgICAgKi9cbiAgICBzaXplKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWQgKyAxO1xuICAgIH1cblxuICAgIC8vIEBpbXBsZW1lbnRlZFxuICAgIGZvckVhY2goZnVuYzogKGl0ZW06IFQsIGluZGV4PzogbnVtYmVyKSA9PiB2b2lkKTogdm9pZHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB3aGlsZShpIDw9IHRoaXMuaGVhZCl7XG4gICAgICAgICAgICBmdW5jKHRoaXMuc3RhY2tbaV0sIGkpO1xuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyBzdGFjayBpbnRvIGEgc3RyaW5nIGZvcm1hdFxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIHN0YWNrXG4gICAgICovXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IHJldHZhbCA9IFwiXCI7XG5cbiAgICAgICAgdGhpcy5mb3JFYWNoKCAoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBzdHIgPSBpdGVtLnRvU3RyaW5nKClcbiAgICAgICAgICAgIGlmKGluZGV4ICE9PSAwKXtcbiAgICAgICAgICAgICAgICBzdHIgKz0gXCIgLT4gXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHZhbCA9IHN0ciArIHJldHZhbDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIFwiVG9wIC0+IFwiICsgcmV0dmFsO1xuICAgIH1cbn0iLCJpbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vLi4vRXZlbnRzL0VtaXR0ZXJcIjtcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uLy4uL0V2ZW50cy9HYW1lRXZlbnRcIjtcbmltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcbmltcG9ydCBTdGF0ZU1hY2hpbmUgZnJvbSBcIi4vU3RhdGVNYWNoaW5lXCI7XG5cbi8qKlxuICogQW4gYWJzdHJhY3QgaW1wbGVtZW50YXRpb24gb2YgYSBzdGF0ZSBmb3IgYSBAcmVmZXJlbmNlW1N0YXRlTWFjaGluZV0uXG4gKiBUaGlzIGNsYXNzIHNob3VsZCBiZSBleHRlbmRlZCB0byBhbGxvdyBmb3IgY3VzdG9tIHN0YXRlIGJlaGF2aW9ycy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgU3RhdGUgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcbiAgICAvKiogVGhlIFN0YXRlTWFjaGluZSB0aGF0IHVzZXMgdGhpcyBTdGF0ZSAqL1xuICAgIHByb3RlY3RlZCBwYXJlbnQ6IFN0YXRlTWFjaGluZTtcblxuICAgIC8qKiBBbiBldmVudCBlbWl0dGVyICovXG4gICAgcHJvdGVjdGVkIGVtaXR0ZXI6IEVtaXR0ZXI7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFN0YXRlXG4gICAgICogQHBhcmFtIHBhcmVudCBUaGUgcGFyZW50IFN0YXRlTWFjaGluZSBvZiB0aGlzIHN0YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBTdGF0ZU1hY2hpbmUpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGlzIHN0YXRlIGlzIGVudGVyZWQuIFVzZSB0aGlzIHRvIGluaXRpYWxpemUgYW55IHZhcmlhYmxlcyBiZWZvcmUgdXBkYXRlcyBvY2N1ci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBJbmZvcm1hdGlvbiB0byBwYXNzIHRvIHRoaXMgc3RhdGVcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBvbkVudGVyKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogQSBsaWZlY3ljbGUgbWV0aG9kIHRoYXQgaGFuZGxlcyBhbiBpbnB1dCBldmVudCwgc3VjaCBhcyB0YWtpbmcgZGFtYWdlLlxuICAgICAqIEBwYXJhbSBldmVudCBUaGUgR2FtZUV2ZW50IHRvIHByb2Nlc3NcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBoYW5kbGVJbnB1dChldmVudDogR2FtZUV2ZW50KTogdm9pZDtcblxuICAgIC8vIEBpbXBsZW1lbnRlZFxuICAgIGFic3RyYWN0IHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBUZWxscyB0aGUgc3RhdGUgbWFjaGluZSB0aGF0IHRoaXMgc3RhdGUgaGFzIGVuZGVkLCBhbmQgbWFrZXMgaXQgdHJhbnNpdGlvbiB0byB0aGUgbmV3IHN0YXRlIHNwZWNpZmllZFxuICAgICAqIEBwYXJhbSBzdGF0ZU5hbWUgVGhlIG5hbWUgb2YgdGhlIHN0YXRlIHRvIHRyYW5zaXRpb24gdG9cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZmluaXNoZWQoc3RhdGVOYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuY2hhbmdlU3RhdGUoc3RhdGVOYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGxpZmVjeWNsZSBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlIHN0YXRlIGlzIGVuZGluZy5cbiAgICAgKiBAcmV0dXJucyBpbmZvIHRvIHBhc3MgdG8gdGhlIG5leHQgc3RhdGVcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBvbkV4aXQoKTogUmVjb3JkPHN0cmluZywgYW55Pjtcbn0iLCJpbXBvcnQgU3RhY2sgZnJvbSBcIi4uL1N0YWNrXCI7XG5pbXBvcnQgU3RhdGUgZnJvbSBcIi4vU3RhdGVcIjtcbmltcG9ydCBNYXAgZnJvbSBcIi4uL01hcFwiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuLi8uLi9FdmVudHMvUmVjZWl2ZXJcIjtcbmltcG9ydCBFbWl0dGVyIGZyb20gXCIuLi8uLi9FdmVudHMvRW1pdHRlclwiO1xuaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0ludGVyZmFjZXMvVXBkYXRlYWJsZVwiO1xuXG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGEgUHVzaCBEb3duIEF1dG9tYXRhIFN0YXRlIG1hY2hpbmUuIFN0YXRlcyBjYW4gYWxzbyBiZSBoaWVyYXJjaGljYWxcbiAqIGZvciBtb3JlIGZsZXhpYmlsaXR5LCBhcyBkZXNjcmliZWQgaW4gQGxpbmsoR2FtZSBQcm9ncmFtbWluZyBQYXR0ZXJucykoaHR0cHM6Ly9nYW1lcHJvZ3JhbW1pbmdwYXR0ZXJucy5jb20vc3RhdGUuaHRtbCkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXRlTWFjaGluZSBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xuICAgIC8qKiBBIHN0YWNrIG9mIHRoZSBjdXJyZW50IHN0YXRlcyAqL1xuICAgIHByb3RlY3RlZCBzdGFjazogU3RhY2s8U3RhdGU+O1xuICAgIC8qKiBBIG1hcGUgb2Ygc3RhdGUga2V5cyB0byBhY3R1YWwgc3RhdGUgaW5zdGFuY2VzICovXG4gICAgcHJvdGVjdGVkIHN0YXRlTWFwOiBNYXA8U3RhdGU+O1xuICAgIC8qKiBUaGUgY3VycmVudCBzdGF0ZSAqL1xuICAgIHByb3RlY3RlZCBjdXJyZW50U3RhdGU6IFN0YXRlO1xuICAgIC8qKiBBbiBldmVudCByZWNlaXZlciAqL1xuICAgIHByb3RlY3RlZCByZWNlaXZlcjogUmVjZWl2ZXI7XG4gICAgLyoqIEFuIGV2ZW50IGVtaXR0ZXIgKi9cbiAgICBwcm90ZWN0ZWQgZW1pdHRlcjogRW1pdHRlcjtcbiAgICAvKiogQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0aGlzIFN0YXRlTWFjaGluZSBpcyBjdXJyZW50bHkgYWN0aXZlICovXG4gICAgcHJvdGVjdGVkIGFjdGl2ZTogYm9vbGVhbjtcbiAgICAvKiogQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0aGlzIFN0YXRlTWFjaGluZSBzaG91bGQgZW1pdCBhbiBldmVudCBvbiBzdGF0ZSBjaGFuZ2UgKi9cbiAgICBwcm90ZWN0ZWQgZW1pdEV2ZW50T25TdGF0ZUNoYW5nZTogYm9vbGVhbjtcbiAgICAvKiogVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGJlIGVtaXR0ZWQgb24gc3RhdGUgY2hhbmdlICovXG4gICAgcHJvdGVjdGVkIHN0YXRlQ2hhbmdlRXZlbnROYW1lOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFN0YXRlTWFjaGluZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgICAgICAgdGhpcy5zdGF0ZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IG5ldyBSZWNlaXZlcigpO1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuICAgICAgICB0aGlzLmVtaXRFdmVudE9uU3RhdGVDaGFuZ2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhY3Rpdml0eSBzdGF0ZSBvZiB0aGlzIHN0YXRlIG1hY2hpbmVcbiAgICAgKiBAcGFyYW0gZmxhZyBUcnVlIGlmIHlvdSB3YW50IHRvIHNldCB0aGlzIG1hY2hpbmUgcnVubmluZywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgc2V0QWN0aXZlKGZsYWc6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmbGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoaXMgc3RhdGUgbWFjaGluZSBlbWl0IGFuIGV2ZW50IGFueSB0aW1lIGl0cyBzdGF0ZSBjaGFuZ2VzXG4gICAgICogQHBhcmFtIHN0YXRlQ2hhbmdlRXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBlbWl0XG4gICAgICovXG4gICAgc2V0RW1pdEV2ZW50T25TdGF0ZUNoYW5nZShzdGF0ZUNoYW5nZUV2ZW50TmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50T25TdGF0ZUNoYW5nZSA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VFdmVudE5hbWUgPSBzdGF0ZUNoYW5nZUV2ZW50TmFtZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9wcyB0aGlzIHN0YXRlIG1hY2hpbmUgZnJvbSBlbWl0dGluZyBldmVudHMgb24gc3RhdGUgY2hhbmdlLlxuICAgICAqL1xuICAgIGNhbmNlbEVtaXRFdmVudE9uU3RhdGVDaGFuZ2UoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50T25TdGF0ZUNoYW5nZSA9IGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGlzIHN0YXRlIG1hY2hpbmUgd2l0aCBhbiBpbml0aWFsIHN0YXRlIGFuZCBzZXRzIGl0IHJ1bm5pbmdcbiAgICAgKiBAcGFyYW0gaW5pdGlhbFN0YXRlIFRoZSBuYW1lIG9mIGluaXRpYWwgc3RhdGUgb2YgdGhlIHN0YXRlIG1hY2hpbmVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplKGluaXRpYWxTdGF0ZTogc3RyaW5nLCBvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGF0ZU1hcC5nZXQoaW5pdGlhbFN0YXRlKSk7XG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gdGhpcy5zdGFjay5wZWVrKCk7XG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlLm9uRW50ZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc2V0QWN0aXZlKHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzdGF0ZSB0byB0aGlzIHN0YXRlIG1hY2hpbmVcbiAgICAgKiBAcGFyYW0gc3RhdGVOYW1lIFRoZSBuYW1lIG9mIHRoZSBzdGF0ZSB0byBhZGRcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHRvIGFkZFxuICAgICAqL1xuICAgIGFkZFN0YXRlKHN0YXRlTmFtZTogc3RyaW5nLCBzdGF0ZTogU3RhdGUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zdGF0ZU1hcC5hZGQoc3RhdGVOYW1lLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgc3RhdGUgb2YgdGhpcyBzdGF0ZSBtYWNoaW5lIHRvIHRoZSBwcm92aWRlZCBzdHJpbmdcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0cmluZyBuYW1lIG9mIHRoZSBzdGF0ZSB0byBjaGFuZ2UgdG9cbiAgICAgKi9cbiAgICBjaGFuZ2VTdGF0ZShzdGF0ZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIC8vIEV4aXQgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB0aGlzLmN1cnJlbnRTdGF0ZS5vbkV4aXQoKTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGNvcnJlY3Qgc3RhdGUgaXMgYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2tcbiAgICAgICAgaWYoc3RhdGUgPT09IFwicHJldmlvdXNcIil7XG4gICAgICAgICAgICAvLyBQb3AgdGhlIGN1cnJlbnQgc3RhdGUgb2ZmIHRoZSBzdGFja1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJldHJpZXZlIHRoZSBuZXcgc3RhdGUgZnJvbSB0aGUgc3RhdGVtYXAgYW5kIHB1dCBpdCBhdCB0aGUgdG9wIG9mIHRoZSBzdGFja1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnN0YXRlTWFwLmdldChzdGF0ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV0cmVpdmUgdGhlIG5ldyBzdGF0ZSBmcm9tIHRoZSBzdGFja1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IHRoaXMuc3RhY2sucGVlaygpO1xuXG4gICAgICAgIC8vIEVtaXQgYW4gZXZlbnQgaWYgdHVybmVkIG9uXG4gICAgICAgIGlmKHRoaXMuZW1pdEV2ZW50T25TdGF0ZUNoYW5nZSl7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KHRoaXMuc3RhdGVDaGFuZ2VFdmVudE5hbWUsIHtzdGF0ZTogdGhpcy5jdXJyZW50U3RhdGV9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVudGVyIHRoZSBuZXcgc3RhdGVcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUub25FbnRlcihvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGlucHV0LiBUaGlzIGhhcHBlbnMgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIHRoaXMgc3RhdGUgbWFjaGluZSdzIHVwZGF0ZSBjeWNsZS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgVGhlIGdhbWUgZXZlbnQgdG8gcHJvY2Vzc1xuICAgICAqL1xuICAgIGhhbmRsZUV2ZW50KGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgaWYodGhpcy5hY3RpdmUpe1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUuaGFuZGxlSW5wdXQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQGltcGxlbWVudGVkXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIC8vIERpc3RyaWJ1dGUgZXZlbnRzXG4gICAgICAgIHdoaWxlKHRoaXMucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpe1xuICAgICAgICAgICAgbGV0IGV2ZW50ID0gdGhpcy5yZWNlaXZlci5nZXROZXh0RXZlbnQoKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVsZWdhdGUgdGhlIHVwZGF0ZSB0byB0aGUgY3VycmVudCBzdGF0ZVxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZS51cGRhdGUoZGVsdGFUKTtcbiAgICB9XG59IiwiaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcbmltcG9ydCB7IFRpbGVkVGlsZXNldERhdGEgfSBmcm9tIFwiLi9UaWxlZERhdGFcIjtcblxuLyoqXG4gKiBUaGUgZGF0YSByZXByZXNlbnRhdGlvbiBvZiBhIFRpbGVzZXQgZm9yIHRoZSBnYW1lIGVuZ2luZS4gVGhpcyByZXByZXNlbnRzIG9uZSBpbWFnZSxcbiAqIHdpdGggYSBzdGFydEluZGV4IGlmIHJlcXVpcmVkIChhcyBpdCBpcyB3aXRoIFRpbGVkIHVzaW5nIHR3byBpbWFnZXMgaW4gb25lIHRpbHNldCkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbGVzZXQge1xuICAgIC8qKiBUaGUga2V5IG9mIHRoZSBpbWFnZSB1c2VkIGJ5IHRoaXMgdGlsZXNldCAqL1xuICAgIHByb3RlY3RlZCBpbWFnZUtleTogc3RyaW5nO1xuICAgIC8qKiBUaGUgc2l6ZSBvZiB0aGUgdGlsZXNldCBpbWFnZSAqL1xuICAgIHByb3RlY3RlZCBpbWFnZVNpemU6IFZlYzI7XG4gICAgLyoqIFRoZSBpbmRleCBvZiAwdGggaW1hZ2Ugb2YgdGhpcyB0aWxlc2V0ICovXG4gICAgcHJvdGVjdGVkIHN0YXJ0SW5kZXg6IG51bWJlcjtcbiAgICAvKiogVGhlIGluZGV4IG9mIHRoZSBsYXN0IGltYWdlIG9mIHRoaXMgdGlsc2V0ICovXG4gICAgcHJvdGVjdGVkIGVuZEluZGV4OiBudW1iZXI7XG4gICAgLyoqIFRoZSBzaXplIG9mIHRoZSB0aWxlcyBpbiB0aGlzIHRpbGVzZXQgKi9cbiAgICBwcm90ZWN0ZWQgdGlsZVNpemU6IFZlYzI7XG4gICAgLyoqIFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGlzIHRpbGVzZXQgKi9cbiAgICBwcm90ZWN0ZWQgbnVtUm93czogbnVtYmVyO1xuICAgIC8qKiBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhpcyB0aWxlc2V0ICovXG4gICAgcHJvdGVjdGVkIG51bUNvbHM6IG51bWJlcjtcblxuICAgIC8vIFRPRE86IENoYW5nZSB0aGlzIHRvIGJlIG1vcmUgZ2VuZXJhbCBhbmQgd29yayB3aXRoIG90aGVyIHRpbGVzZXQgZm9ybWF0c1xuICAgIGNvbnN0cnVjdG9yKHRpbGVzZXREYXRhOiBUaWxlZFRpbGVzZXREYXRhKXtcbiAgICAgICAgLy8gRGVmZXIgaGFuZGxpbmcgb2YgdGhlIGRhdGEgdG8gYSBoZWxwZXIgY2xhc3NcbiAgICAgICAgdGhpcy5pbml0RnJvbVRpbGVkRGF0YSh0aWxlc2V0RGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgdGlsZXNldCBmcm9tIHRoZSBkYXRhIGZyb20gYSBUaWxlZCBqc29uIGZpbGVcbiAgICAgKiBAcGFyYW0gdGlsZWREYXRhIFRoZSBwYXJzZWQgb2JqZWN0IGZyb20gYSBUaWxlZCBqc29uIGZpbGVcbiAgICAgKi9cbiAgICBpbml0RnJvbVRpbGVkRGF0YSh0aWxlZERhdGE6IFRpbGVkVGlsZXNldERhdGEpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5udW1Sb3dzID0gdGlsZWREYXRhLnRpbGVjb3VudC90aWxlZERhdGEuY29sdW1ucztcbiAgICAgICAgdGhpcy5udW1Db2xzID0gdGlsZWREYXRhLmNvbHVtbnM7XG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IHRpbGVkRGF0YS5maXJzdGdpZDtcbiAgICAgICAgdGhpcy5lbmRJbmRleCA9IHRoaXMuc3RhcnRJbmRleCArIHRpbGVkRGF0YS50aWxlY291bnQgLSAxO1xuICAgICAgICB0aGlzLnRpbGVTaXplID0gbmV3IFZlYzIodGlsZWREYXRhLnRpbGV3aWR0aCwgdGlsZWREYXRhLnRpbGV3aWR0aCk7XG4gICAgICAgIHRoaXMuaW1hZ2VLZXkgPSB0aWxlZERhdGEuaW1hZ2U7XG4gICAgICAgIHRoaXMuaW1hZ2VTaXplID0gbmV3IFZlYzIodGlsZWREYXRhLmltYWdld2lkdGgsIHRpbGVkRGF0YS5pbWFnZWhlaWdodCk7XG4gICAgfVxuXG4gICAgLyoqIFxuICAgICAqIEdldHMgdGhlIGltYWdlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhpcyB0aWxlbWFwXG4gICAgICogQHJldHVybnMgVGhlIGltYWdlIGtleSBvZiB0aGlzIHRpbGVtYXBcbiAgICAgKi9cbiAgICBnZXRJbWFnZUtleSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZUtleTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgVmVjMiBjb250YWluaW5nIHRoZSBsZWZ0IGFuZCB0b3Agb2Zmc2V0IGZyb20gdGhlIGltYWdlIG9yaWdpbiBmb3IgdGhpcyB0aWxlLlxuICAgICAqIEBwYXJhbSB0aWxlSW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlIGZyb20gc3RhcnRJbmRleCB0byBlbmRJbmRleCBvZiB0aGlzIHRpbGVzZXRcbiAgICAgKiBAcmV0dXJucyBBIFZlYzIgY29udGFpbmluZyB0aGUgb2Zmc2V0IGZvciB0aGUgc3BlY2lmaWVkIHRpbGUuXG4gICAgICovXG4gICAgZ2V0SW1hZ2VPZmZzZXRGb3JUaWxlKHRpbGVJbmRleDogbnVtYmVyKTogVmVjMiB7XG4gICAgICAgIC8vIEdldCB0aGUgdHJ1ZSBpbmRleFxuICAgICAgICBsZXQgaW5kZXggPSB0aWxlSW5kZXggLSB0aGlzLnN0YXJ0SW5kZXg7XG4gICAgICAgIGxldCByb3cgPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5udW1Db2xzKTtcbiAgICAgICAgbGV0IGNvbCA9IGluZGV4ICUgdGhpcy5udW1Db2xzO1xuICAgICAgICBsZXQgd2lkdGggPSB0aGlzLnRpbGVTaXplLng7XG4gICAgICAgIGxldCBoZWlnaHQgPSB0aGlzLnRpbGVTaXplLnk7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiB0byBzdGFydCBhIGNyb3AgaW4gdGhlIHRpbGVzZXQgaW1hZ2VcbiAgICAgICAgbGV0IGxlZnQgPSBjb2wgKiB3aWR0aDtcbiAgICAgICAgbGV0IHRvcCA9IHJvdyAqIGhlaWdodDtcblxuICAgICAgICByZXR1cm4gbmV3IFZlYzIobGVmdCwgdG9wKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGFydCBpbmRleFxuICAgICAqIEByZXR1cm5zIFRoZSBzdGFydCBpbmRleFxuICAgICAqL1xuICAgIGdldFN0YXJ0SW5kZXgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRJbmRleDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB0aWxlIHNldFxuICAgICAqIEByZXR1cm5zIEEgVmVjMiBjb250YWluaW5nIHRoZSB0aWxlIHNpemVcbiAgICAgKi9cbiAgICBnZXRUaWxlU2l6ZSgpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZVNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIHRpbGVzZXRcbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIHJvd3NcbiAgICAgKi9cbiAgICBnZXROdW1Sb3dzKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bVJvd3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIHRpbHNldFxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgY29sdW1uc1xuICAgICAqL1xuICAgIGdldE51bUNvbHMoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtQ29scztcbiAgICB9XG5cbiAgICBnZXRUaWxlQ291bnQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kSW5kZXggLSB0aGlzLnN0YXJ0SW5kZXggKyAxO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIHRpbHNldCBjb250YWlucyB0aGUgc3BlY2lmaWVkIHRpbGUgaW5kZXguIFRoaXMgaXMgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB0aWxlSW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlIHRvIGNoZWNrXG4gICAgICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0aGlzIHRpbHNldCB1c2VzIHRoZSBzcGVjaWZpZWQgaW5kZXhcbiAgICAgKi9cbiAgICBoYXNUaWxlKHRpbGVJbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aWxlSW5kZXggPj0gdGhpcy5zdGFydEluZGV4ICYmIHRpbGVJbmRleCA8PSB0aGlzLmVuZEluZGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBhIHNpbmd1bGFyIHRpbGUgd2l0aCBpbmRleCB0aWxlSW5kZXggZnJvbSB0aGUgdGlsZXNldCBsb2NhdGVkIGF0IHBvc2l0aW9uIGRhdGFJbmRleFxuICAgICAqIEBwYXJhbSBjdHggVGhlIHJlbmRlcmluZyBjb250ZXh0XG4gICAgICogQHBhcmFtIHRpbGVJbmRleCBUaGUgdmFsdWUgb2YgdGhlIHRpbGUgdG8gcmVuZGVyXG4gICAgICogQHBhcmFtIGRhdGFJbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGUgaW4gdGhlIGRhdGEgYXJyYXlcbiAgICAgKiBAcGFyYW0gd29ybGRTaXplIFRoZSBzaXplIG9mIHRoZSB3b3JsZFxuICAgICAqIEBwYXJhbSBvcmlnaW4gVGhlIHZpZXdwb3J0IG9yaWdpbiBpbiB0aGUgY3VycmVudCBsYXllclxuICAgICAqIEBwYXJhbSBzY2FsZSBUaGUgc2NhbGUgb2YgdGhlIHRpbGVtYXBcbiAgICAgKi9cbiAgICByZW5kZXJUaWxlKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB0aWxlSW5kZXg6IG51bWJlciwgZGF0YUluZGV4OiBudW1iZXIsIG1heENvbHM6IG51bWJlciwgb3JpZ2luOiBWZWMyLCBzY2FsZTogVmVjMiwgem9vbTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGxldCBpbWFnZSA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLmdldEltYWdlKHRoaXMuaW1hZ2VLZXkpO1xuXG4gICAgICAgIC8vIEdldCB0aGUgdHJ1ZSBpbmRleFxuICAgICAgICBsZXQgaW5kZXggPSB0aWxlSW5kZXggLSB0aGlzLnN0YXJ0SW5kZXg7XG4gICAgICAgIGxldCByb3cgPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5udW1Db2xzKTtcbiAgICAgICAgbGV0IGNvbCA9IGluZGV4ICUgdGhpcy5udW1Db2xzO1xuICAgICAgICBsZXQgd2lkdGggPSB0aGlzLnRpbGVTaXplLng7XG4gICAgICAgIGxldCBoZWlnaHQgPSB0aGlzLnRpbGVTaXplLnk7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiB0byBzdGFydCBhIGNyb3AgaW4gdGhlIHRpbGVzZXQgaW1hZ2VcbiAgICAgICAgbGV0IGxlZnQgPSBjb2wgKiB3aWR0aDtcbiAgICAgICAgbGV0IHRvcCA9IHJvdyAqIGhlaWdodDtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHBvc2l0aW9uIGluIHRoZSB3b3JsZCB0byByZW5kZXIgdGhlIHRpbGVcbiAgICAgICAgbGV0IHggPSBNYXRoLmZsb29yKChkYXRhSW5kZXggJSBtYXhDb2xzKSAqIHdpZHRoICogc2NhbGUueCk7XG4gICAgICAgIGxldCB5ID0gTWF0aC5mbG9vcihNYXRoLmZsb29yKGRhdGFJbmRleCAvIG1heENvbHMpICogaGVpZ2h0ICogc2NhbGUueSk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCwgTWF0aC5mbG9vcigoeCAtIG9yaWdpbi54KSp6b29tKSwgTWF0aC5mbG9vcigoeSAtIG9yaWdpbi55KSp6b29tKSwgTWF0aC5jZWlsKHdpZHRoICogc2NhbGUueCAqIHpvb20pLCBNYXRoLmNlaWwoaGVpZ2h0ICogc2NhbGUueSAqIHpvb20pKTtcbiAgICB9XG59IiwiaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vVXRpbHMvTWF0aFV0aWxzXCI7XG5cbi8qKlxuICogQSB0d28tZGltZW5zaW9uYWwgdmVjdG9yICh4LCB5KVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZWMyIHtcblxuXHQvLyBTdG9yZSB4IGFuZCB5IGluIGFuIGFycmF5XG5cdC8qKiBUaGUgYXJyYXkgdGhhdCBzdG9yZXMgdGhlIGFjdHVhbCB2ZWN0b3IgdmFsdWVzIHggYW5kIHkgKi9cblx0cHJpdmF0ZSB2ZWM6IEZsb2F0MzJBcnJheTtcblxuXHQvKipcdFxuXHQgKiBXaGVuIHRoaXMgdmVjdG9yIGNoYW5nZXMgaXRzIHZhbHVlLCBkbyBzb21ldGhpbmdcblx0ICovXG5cdHByaXZhdGUgb25DaGFuZ2U6IEZ1bmN0aW9uID0gKCkgPT4ge307XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgVmVjMlxuXHQgKiBAcGFyYW0geCBUaGUgeCB2YWx1ZSBvZiB0aGUgdmVjdG9yXG5cdCAqIEBwYXJhbSB5IFRoZSB5IHZhbHVlIG9mIHRoZSB2ZWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKHg6IG51bWJlciA9IDAsIHk6IG51bWJlciA9IDApIHtcblx0XHR0aGlzLnZlYyA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XG5cdFx0dGhpcy52ZWNbMF0gPSB4O1xuXHRcdHRoaXMudmVjWzFdID0geTtcblx0fVxuXG5cdC8vIEV4cG9zZSB4IGFuZCB5IHdpdGggZ2V0dGVycyBhbmQgc2V0dGVyc1xuXHRnZXQgeCgpIHtcblx0XHRyZXR1cm4gdGhpcy52ZWNbMF07XG5cdH1cblxuXHRzZXQgeCh4OiBudW1iZXIpIHtcblx0XHR0aGlzLnZlY1swXSA9IHg7XG5cblx0XHRpZih0aGlzLm9uQ2hhbmdlKXtcblx0XHRcdHRoaXMub25DaGFuZ2UoKTtcblx0XHR9XG5cdH1cblxuXHRnZXQgeSgpIHtcblx0XHRyZXR1cm4gdGhpcy52ZWNbMV07XG5cdH1cblxuXHRzZXQgeSh5OiBudW1iZXIpIHtcblx0XHR0aGlzLnZlY1sxXSA9IHk7XG5cblx0XHRpZih0aGlzLm9uQ2hhbmdlKXtcblx0XHRcdHRoaXMub25DaGFuZ2UoKTtcblx0XHR9XG5cdH1cblxuXHRzdGF0aWMgZ2V0IFpFUk8oKSB7XG5cdFx0cmV0dXJuIG5ldyBWZWMyKDAsIDApO1xuXHR9XG5cblx0c3RhdGljIHJlYWRvbmx5IFpFUk9fU1RBVElDID0gbmV3IFZlYzIoMCwgMCk7XG5cblx0c3RhdGljIGdldCBJTkYoKSB7XG5cdFx0cmV0dXJuIG5ldyBWZWMyKEluZmluaXR5LCBJbmZpbml0eSk7XG5cdH1cblxuXHRzdGF0aWMgZ2V0IFVQKCkge1xuXHRcdHJldHVybiBuZXcgVmVjMigwLCAtMSk7XG5cdH1cblxuXHRzdGF0aWMgZ2V0IERPV04oKSB7XG5cdFx0cmV0dXJuIG5ldyBWZWMyKDAsIDEpO1xuXHR9XG5cblx0c3RhdGljIGdldCBMRUZUKCkge1xuXHRcdHJldHVybiBuZXcgVmVjMigtMSwgMCk7XG5cdH1cblxuXHRzdGF0aWMgZ2V0IFJJR0hUKCkge1xuXHRcdHJldHVybiBuZXcgVmVjMigxLCAwKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgc3F1YXJlZCBtYWduaXR1ZGUgb2YgdGhlIHZlY3Rvci4gVGhpcyB0ZW5kcyB0byBiZSBmYXN0ZXIsIHNvIHVzZSBpdCBpbiBzaXR1YXRpb25zIHdoZXJlIHRha2luZyB0aGVcblx0ICogc3F1YXJlIHJvb3QgZG9lc24ndCBtYXR0ZXIsIGxpa2UgZm9yIGNvbXBhcmluZyBkaXN0YW5jZXMuXG5cdCAqIEByZXR1cm5zIFRoZSBzcXVhcmVkIG1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yXG5cdCAqL1xuXHRtYWdTcSgpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLngqdGhpcy54ICsgdGhpcy55KnRoaXMueTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3IuXG5cdCAqIEByZXR1cm5zIFRoZSBtYWduaXR1ZGUgb2YgdGhlIHZlY3Rvci5cblx0ICovXG5cdG1hZygpOiBudW1iZXIge1xuXHRcdHJldHVybiBNYXRoLnNxcnQodGhpcy5tYWdTcSgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXZkZXMgeCBhbmQgeSBieSB0aGUgbWFnbml0dWRlIHRvIG9idGFpbiB0aGUgdW5pdCB2ZWN0b3IgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGlzIHZlY3Rvci5cblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYXMgYSB1bml0IHZlY3Rvci5cblx0ICovXG5cdG5vcm1hbGl6ZSgpOiBWZWMyIHtcblx0XHRpZih0aGlzLnggPT09IDAgJiYgdGhpcy55ID09PSAwKSByZXR1cm4gdGhpcztcblx0XHRsZXQgbWFnID0gdGhpcy5tYWcoKTtcblx0XHR0aGlzLnggLz0gbWFnO1xuXHRcdHRoaXMueSAvPSBtYWc7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogV29ya3MgbGlrZSBub3JtYWxpemUoKSwgYnV0IHJldHVybnMgYSBuZXcgVmVjMlxuXHQgKiBAcmV0dXJucyBBIG5ldyB2ZWN0b3IgdGhhdCBpcyB0aGUgdW5pdCB2ZWN0b3IgZm9yIHRoaXMgb25lXG5cdCAqL1xuXHRub3JtYWxpemVkKCk6IFZlYzIge1xuXHRcdGlmKHRoaXMuaXNaZXJvKCkpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdFxuXHRcdGxldCBtYWcgPSB0aGlzLm1hZygpO1xuXHRcdHJldHVybiBuZXcgVmVjMih0aGlzLngvbWFnLCB0aGlzLnkvbWFnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB4IGFuZCB5IGVsZW1lbnRzIG9mIHRoaXMgdmVjdG9yIHRvIHplcm8uXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yLCB3aXRoIHggYW5kIHkgc2V0IHRvIHplcm8uXG5cdCAqL1xuXHR6ZXJvKCk6IFZlYzIge1xuXHRcdHJldHVybiB0aGlzLnNldCgwLCAwKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2ZWN0b3IncyB4IGFuZCB5IGJhc2VkIG9uIHRoZSBhbmdsZSBwcm92aWRlZC4gR29lcyBjb3VudGVyIGNsb2Nrd2lzZS5cblx0ICogQHBhcmFtIGFuZ2xlIFRoZSBhbmdsZSBpbiByYWRpYW5zXG5cdCAqIEBwYXJhbSByYWRpdXMgVGhlIG1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yIGF0IHRoZSBzcGVjaWZpZWQgYW5nbGVcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRzZXRUb0FuZ2xlKGFuZ2xlOiBudW1iZXIsIHJhZGl1czogbnVtYmVyID0gMSk6IFZlYzIge1xuXHRcdHRoaXMueCA9IE1hdGhVdGlscy5mbG9vclRvUGxhY2UoTWF0aC5jb3MoYW5nbGUpKnJhZGl1cywgNSk7XG5cdFx0dGhpcy55ID0gTWF0aFV0aWxzLmZsb29yVG9QbGFjZSgtTWF0aC5zaW4oYW5nbGUpKnJhZGl1cywgNSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHZlY3RvciB0aGF0IHBvaW50IGZyb20gdGhpcyB2ZWN0b3IgdG8gYW5vdGhlciBvbmVcblx0ICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gcG9pbnQgdG9cblx0ICogQHJldHVybnMgQSBuZXcgVmVjMiB0aGF0IHBvaW50cyBmcm9tIHRoaXMgdmVjdG9yIHRvIHRoZSBvbmUgcHJvdmlkZWRcblx0ICovXG5cdHZlY1RvKG90aGVyOiBWZWMyKTogVmVjMiB7XG5cdFx0cmV0dXJuIG5ldyBWZWMyKG90aGVyLnggLSB0aGlzLngsIG90aGVyLnkgLSB0aGlzLnkpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIHZlY3RvciBjb250YWluaW5nIHRoZSBkaXJlY3Rpb24gZnJvbSB0aGlzIHZlY3RvciB0byBhbm90aGVyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIHBvaW50IHRvXG5cdCAqIEByZXR1cm5zIEEgbmV3IFZlYzIgdGhhdCBwb2ludHMgZnJvbSB0aGlzIHZlY3RvciB0byB0aGUgb25lIHByb3ZpZGVkLiBUaGlzIG5ldyBWZWMyIHdpbGwgYmUgYSB1bml0IHZlY3Rvci5cblx0ICovXG5cdGRpclRvKG90aGVyOiBWZWMyKTogVmVjMiB7XG5cdFx0cmV0dXJuIHRoaXMudmVjVG8ob3RoZXIpLm5vcm1hbGl6ZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEtlZXBzIHRoZSB2ZWN0b3IncyBkaXJlY3Rpb24sIGJ1dCBzZXRzIGl0cyBtYWduaXR1ZGUgdG8gYmUgdGhlIHByb3ZpZGVkIG1hZ25pdHVkZVxuXHQgKiBAcGFyYW0gbWFnbml0dWRlIFRoZSBtYWduaXR1ZGUgdGhlIHZlY3RvciBzaG91bGQgYmVcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3Igd2l0aCBpdHMgbWFnbml0dWRlIHNldCB0byB0aGUgbmV3IG1hZ25pdHVkZVxuXHQgKi9cblx0c2NhbGVUbyhtYWduaXR1ZGU6IG51bWJlcik6IFZlYzIge1xuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLnNjYWxlKG1hZ25pdHVkZSk7XG5cdH1cblxuXHQvKipcblx0ICogU2NhbGVzIHggYW5kIHkgYnkgdGhlIG51bWJlciBwcm92aWRlZCwgb3IgaWYgdHdvIG51bWJlciBhcmUgcHJvdmlkZWQsIHNjYWxlcyB0aGVtIGluZGl2aWR1YWxseS5cblx0ICogQHBhcmFtIGZhY3RvciBUaGUgc2NhbGluZyBmYWN0b3IgZm9yIHRoZSB2ZWN0b3IsIG9yIGZvciBvbmx5IHRoZSB4LWNvbXBvbmVudCBpZiB5RmFjdG9yIGlzIHByb3ZpZGVkXG5cdCAqIEBwYXJhbSB5RmFjdG9yIFRoZSBzY2FsaW5nIGZhY3RvciBmb3IgdGhlIHktY29tcG9uZW50IG9mIHRoZSB2ZWN0b3Jcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYWZ0ZXIgc2NhbGluZ1xuXHQgKi9cblx0c2NhbGUoZmFjdG9yOiBudW1iZXIsIHlGYWN0b3I6IG51bWJlciA9IG51bGwpOiBWZWMyIHtcblx0XHRpZih5RmFjdG9yICE9PSBudWxsKXtcblx0XHRcdHRoaXMueCAqPSBmYWN0b3I7XG5cdFx0XHR0aGlzLnkgKj0geUZhY3Rvcjtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHR0aGlzLnggKj0gZmFjdG9yO1xuXHRcdHRoaXMueSAqPSBmYWN0b3I7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHNjYWxlZCB2ZXJzaW9uIG9mIHRoaXMgdmVjdG9yIHdpdGhvdXQgbW9kaWZ5aW5nIGl0LlxuXHQgKiBAcGFyYW0gZmFjdG9yIFRoZSBzY2FsaW5nIGZhY3RvciBmb3IgdGhlIHZlY3Rvciwgb3IgZm9yIG9ubHkgdGhlIHgtY29tcG9uZW50IGlmIHlGYWN0b3IgaXMgcHJvdmlkZWRcblx0ICogQHBhcmFtIHlGYWN0b3IgVGhlIHNjYWxpbmcgZmFjdG9yIGZvciB0aGUgeS1jb21wb25lbnQgb2YgdGhlIHZlY3RvclxuXHQgKiBAcmV0dXJucyBBIG5ldyB2ZWN0b3IgdGhhdCBoYXMgdGhlIHZhbHVlcyBvZiB0aGlzIHZlY3RvciBhZnRlciBzY2FsaW5nXG5cdCAqL1xuXHRzY2FsZWQoZmFjdG9yOiBudW1iZXIsIHlGYWN0b3I6IG51bWJlciA9IG51bGwpOiBWZWMyIHtcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLnNjYWxlKGZhY3RvciwgeUZhY3Rvcik7XG5cdH1cblxuXHQvKipcblx0ICogUm90YXRlcyB0aGUgdmVjdG9yIGNvdW50ZXItY2xvY2t3aXNlIGJ5IHRoZSBhbmdsZSBhbW91bnQgc3BlY2lmaWVkXG5cdCAqIEBwYXJhbSBhbmdsZSBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5IGluIHJhZGlhbnNcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYWZ0ZXIgcm90YXRpb24uXG5cdCAqL1xuXHRyb3RhdGVDQ1coYW5nbGU6IG51bWJlcik6IFZlYzIge1xuXHRcdGxldCBjcyA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHRsZXQgc24gPSBNYXRoLnNpbihhbmdsZSk7XG5cdFx0bGV0IHRlbXBYID0gdGhpcy54KmNzIC0gdGhpcy55KnNuO1xuXHRcdGxldCB0ZW1wWSA9IHRoaXMueCpzbiArIHRoaXMueSpjcztcblx0XHR0aGlzLnggPSB0ZW1wWDtcblx0XHR0aGlzLnkgPSB0ZW1wWTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2ZWN0b3JzIGNvb3JkaW5hdGVzIHRvIGJlIHRoZSBvbmVzIHByb3ZpZGVkXG5cdCAqIEBwYXJhbSB4IFRoZSBuZXcgeCB2YWx1ZSBmb3IgdGhpcyB2ZWN0b3Jcblx0ICogQHBhcmFtIHkgVGhlIG5ldyB5IHZhbHVlIGZvciB0aGlzIHZlY3RvclxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvclxuXHQgKi9cblx0c2V0KHg6IG51bWJlciwgeTogbnVtYmVyKTogVmVjMiB7XG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvcGllcyB0aGUgdmFsdWVzIG9mIHRoZSBvdGhlciBWZWMyIGludG8gdGhpcyBvbmUuXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgVmVjMiB0byBjb3B5XG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIHdpdGggaXRzIHZhbHVlcyBzZXQgdG8gdGhlIHZlY3RvciBwcm92aWRlZFxuXHQgKi9cblx0Y29weShvdGhlcjogVmVjMik6IFZlYzIge1xuXHRcdHJldHVybiB0aGlzLnNldChvdGhlci54LCBvdGhlci55KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHRoaXMgdmVjdG9yIHRoZSBhbm90aGVyIHZlY3RvclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIFZlYzIgdG8gYWRkIHRvIHRoaXMgb25lXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIGFmdGVyIGFkZGluZyB0aGUgb25lIHByb3ZpZGVkXG5cdCAqL1xuXHRhZGQob3RoZXI6IFZlYzIpOiBWZWMyIHtcblx0XHR0aGlzLnggKz0gb3RoZXIueDtcblx0XHR0aGlzLnkgKz0gb3RoZXIueTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBJbmNyZW1lbnRzIHRoZSBmaWVsZHMgb2YgdGhpcyB2ZWN0b3IuIEJvdGggYXJlIGluY3JlbWVudGVkIHdpdGggYSwgaWYgb25seSBhIGlzIHByb3ZpZGVkLlxuXHQgKiBAcGFyYW0gYSBUaGUgZmlyc3QgbnVtYmVyIHRvIGluY3JlbWVudCBieVxuXHQgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIG51bWJlciB0byBpbmNyZW1lbnQgYnlcblx0ICogQHJldHVybnNzIFRoaXMgdmVjdG9yIGFmdGVyIGluY3JlbWVudGluZ1xuXHQgKi9cblx0aW5jKGE6IG51bWJlciwgYj86IG51bWJlcik6IFZlYzIge1xuXHRcdGlmKGIgPT09IHVuZGVmaW5lZCl7XG5cdFx0XHR0aGlzLnggKz0gYTtcblx0XHRcdHRoaXMueSArPSBhO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnggKz0gYTtcblx0XHRcdHRoaXMueSArPSBiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTdWJ0cmFjdHMgYW5vdGhlciB2ZWN0b3IgZnJvbSB0aGlzIHZlY3RvclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIFZlYzIgdG8gc3VidHJhY3QgZnJvbSB0aGlzIG9uZVxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhZnRlciBzdWJ0cmFjdGluZyB0aGUgb25lIHByb3ZpZGVkXG5cdCAqL1xuXHRzdWIob3RoZXI6IFZlYzIpOiBWZWMyIHtcblx0XHR0aGlzLnggLT0gb3RoZXIueDtcblx0XHR0aGlzLnkgLT0gb3RoZXIueTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBNdWx0aXBsaWVzIHRoaXMgdmVjdG9yIHdpdGggYW5vdGhlciB2ZWN0b3IgZWxlbWVudC13aXNlLiBJbiBvdGhlciB3b3JkcywgdGhpcy54ICo9IG90aGVyLnggYW5kIHRoaXMueSAqPSBvdGhlci55XG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgVmVjMiB0byBtdWx0aXBseSB0aGlzIG9uZSBieVxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhZnRlciBtdWx0aXBseWluZyBpdHMgY29tcG9uZW50cyBieSB0aGlzIG9uZVxuXHQgKi9cblx0bXVsdChvdGhlcjogVmVjMik6IFZlYzIge1xuXHRcdHRoaXMueCAqPSBvdGhlci54O1xuXHRcdHRoaXMueSAqPSBvdGhlci55O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIERpdmlkZXMgdGhpcyB2ZWN0b3Igd2l0aCBhbm90aGVyIHZlY3RvciBlbGVtZW50LXdpc2UuIEluIG90aGVyIHdvcmRzLCB0aGlzLnggLz0gb3RoZXIueCBhbmQgdGhpcy55IC89IG90aGVyLnlcblx0ICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gZGl2aWRlIHRoaXMgb25lIGJ5XG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIGFmdGVyIGRpdmlzaW9uXG5cdCAqL1xuXHRkaXYob3RoZXI6IFZlYzIpOiBWZWMyIHtcblx0XHRpZihvdGhlci54ID09PSAwIHx8IG90aGVyLnkgPT09IDApIHRocm93IFwiRGl2aWRlIGJ5IHplcm8gZXJyb3JcIjtcblx0XHR0aGlzLnggLz0gb3RoZXIueDtcblx0XHR0aGlzLnkgLz0gb3RoZXIueTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBEb2VzIGFuIGVsZW1lbnQgd2lzZSByZW1haW5kZXIgb3BlcmF0aW9uIG9uIHRoaXMgdmVjdG9yLiB0aGlzLnggJT0gb3RoZXIueCBhbmQgdGhpcy55ICU9IG90aGVyLnlcblx0ICogQHBhcmFtIG90aGVyIFRoZSBvdGhlciB2ZWN0b3Jcblx0ICogQHJldHVybnMgdGhpcyB2ZWN0b3Jcblx0ICovXG5cdHJlbWFpbmRlcihvdGhlcjogVmVjMik6IFZlYzIge1xuXHRcdHRoaXMueCA9IHRoaXMueCAlIG90aGVyLng7XG5cdFx0dGhpcy55ID0gdGhpcy55ICUgb3RoZXIueTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gdGhpcyB2ZWN0b3IgYW5kIGFub3RoZXIgdmVjdG9yXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIGNvbXB1dGUgZGlzdGFuY2Ugc3F1YXJlZCB0b1xuXHQgKiBAcmV0dXJucyBUaGUgc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIHRoaXMgdmVjdG9yIGFuZCB0aGUgb25lIHByb3ZpZGVkXG5cdCAqL1xuXHRkaXN0YW5jZVNxVG8ob3RoZXI6IFZlYzIpOiBudW1iZXIge1xuXHRcdHJldHVybiAodGhpcy54IC0gb3RoZXIueCkqKHRoaXMueCAtIG90aGVyLngpICsgKHRoaXMueSAtIG90aGVyLnkpKih0aGlzLnkgLSBvdGhlci55KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoaXMgdmVjdG9yIGFuZCBhbm90aGVyIHZlY3RvclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBjb21wdXRlIGRpc3RhbmNlIHRvXG5cdCAqIEByZXR1cm5zIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoaXMgdmVjdG9yIGFuZCB0aGUgb25lIHByb3ZpZGVkXG5cdCAqL1xuXHRkaXN0YW5jZVRvKG90aGVyOiBWZWMyKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VTcVRvKG90aGVyKSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZG90IHByb2R1Y3Qgb2YgdGhpcyB2ZWN0b3IgYW5kIGFub3RoZXJcblx0ICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gY29tcHV0ZSB0aGUgZG90IHByb2R1Y3Qgd2l0aFxuXHQgKiBAcmV0dXJucyBUaGUgZG90IHByb2R1Y3Qgb2YgdGhpcyB2ZWN0b3IgYW5kIHRoZSBvbmUgcHJvdmlkZWQuXG5cdCAqL1xuXHRkb3Qob3RoZXI6IFZlYzIpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLngqb3RoZXIueCArIHRoaXMueSpvdGhlci55O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGFuZ2xlIGNvdW50ZXItY2xvY2t3aXNlIGluIHJhZGlhbnMgZnJvbSB0aGlzIHZlY3RvciB0byBhbm90aGVyIHZlY3RvclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBjb21wdXRlIHRoZSBhbmdsZSB0b1xuXHQgKiBAcmV0dXJucyBUaGUgYW5nbGUsIHJvdGF0aW5nIENDVywgZnJvbSB0aGlzIHZlY3RvciB0byB0aGUgb3RoZXIgdmVjdG9yXG5cdCAqL1xuXHRhbmdsZVRvQ0NXKG90aGVyOiBWZWMyKTogbnVtYmVyIHtcblx0XHRsZXQgZG90ID0gdGhpcy5kb3Qob3RoZXIpO1xuXHRcdGxldCBkZXQgPSB0aGlzLngqb3RoZXIueSAtIHRoaXMueSpvdGhlci54O1xuXHRcdGxldCBhbmdsZSA9IC1NYXRoLmF0YW4yKGRldCwgZG90KTtcblxuXHRcdGlmKGFuZ2xlIDwgMCl7XG5cdFx0XHRhbmdsZSArPSAyKk1hdGguUEk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFuZ2xlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2ZWN0b3Igcm91bmRlZCB0byAxIGRlY2ltYWwgcG9pbnRcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYXMgYSBzdHJpbmdcblx0ICovXG5cdHRvU3RyaW5nKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIHRoaXMudG9GaXhlZCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2ZWN0b3Igcm91bmRlZCB0byB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBkZWNpbWFsIHBvaW50c1xuXHQgKiBAcGFyYW0gbnVtRGVjaW1hbFBvaW50cyBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzIHRvIGNyZWF0ZSBhIHN0cmluZyB0b1xuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhcyBhIHN0cmluZ1xuXHQgKi9cblx0dG9GaXhlZChudW1EZWNpbWFsUG9pbnRzOiBudW1iZXIgPSAxKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gXCIoXCIgKyB0aGlzLngudG9GaXhlZChudW1EZWNpbWFsUG9pbnRzKSArIFwiLCBcIiArIHRoaXMueS50b0ZpeGVkKG51bURlY2ltYWxQb2ludHMpICsgXCIpXCI7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIG5ldyB2ZWN0b3Igd2l0aCB0aGUgc2FtZSBjb29yZGluYXRlcyBhcyB0aGlzIG9uZS5cblx0ICogQHJldHVybnMgQSBuZXcgVmVjMiB3aXRoIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGlzIG9uZVxuXHQgKi9cblx0Y2xvbmUoKTogVmVjMiB7XG5cdFx0cmV0dXJuIG5ldyBWZWMyKHRoaXMueCwgdGhpcy55KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyB2ZWN0b3IgYW5kIG90aGVyIGhhdmUgdGhlIEVYQUNUIHNhbWUgeCBhbmQgeSAobm90IGFzc3VyZWQgdG8gYmUgc2FmZSBmb3IgZmxvYXRzKVxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBjaGVjayBhZ2FpbnN0XG5cdCAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIGVxdWFsaXR5IG9mIHRoZSB0d28gdmVjdG9yc1xuXHQgKi9cblx0c3RyaWN0RXF1YWxzKG90aGVyOiBWZWMyKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMueCA9PT0gb3RoZXIueCAmJiB0aGlzLnkgPT09IG90aGVyLnk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoaXMgdmVjdG9yIGFuZCBvdGhlciBoYXZlIHRoZSBzYW1lIHggYW5kIHlcblx0ICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gY2hlY2sgYWdhaW5zdFxuXHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSBlcXVhbGl0eSBvZiB0aGUgdHdvIHZlY3RvcnNcblx0ICovXG5cdGVxdWFscyhvdGhlcjogVmVjMik6IGJvb2xlYW4ge1xuXHRcdGxldCB4RXEgPSBNYXRoLmFicyh0aGlzLnggLSBvdGhlci54KSA8IDAuMDAwMDAwMTtcblx0XHRsZXQgeUVxID0gTWF0aC5hYnModGhpcy55IC0gb3RoZXIueSkgPCAwLjAwMDAwMDE7XG5cblx0XHRyZXR1cm4geEVxICYmIHlFcTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyB2ZWN0b3IgaXMgdGhlIHplcm8gdmVjdG9yIGV4YWN0bHkgKG5vdCBhc3N1cmVkIHRvIGJlIHNhZmUgZm9yIGZsb2F0cykuXG5cdCAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIGVxdWFsaXR5IG9mIHRoaXMgdmVjdG9yIGFuZCB0aGUgemVybyB2ZWN0b3Jcblx0ICovXG5cdHN0cmljdElzWmVybygpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy54ID09PSAwICYmIHRoaXMueSA9PT0gMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyB4IGFuZCB5IGZvciB0aGlzIHZlY3RvciBhcmUgYm90aCB6ZXJvLlxuXHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSBlcXVhbGl0eSBvZiB0aGlzIHZlY3RvciBhbmQgdGhlIHplcm8gdmVjdG9yXG5cdCAqL1xuXHRpc1plcm8oKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIE1hdGguYWJzKHRoaXMueCkgPCAwLjAwMDAwMDEgJiYgTWF0aC5hYnModGhpcy55KSA8IDAuMDAwMDAwMTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFNldHMgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW5ldmVyIHRoaXMgdmVjdG9yIGlzIGNoYW5nZWQuXG5cdCAqIEBwYXJhbSBmIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWRcblx0ICovXG5cdHNldE9uQ2hhbmdlKGY6IEZ1bmN0aW9uKTogdm9pZCB7XG5cdFx0dGhpcy5vbkNoYW5nZSA9IGY7XG5cdH1cblxuXHR0b0FycmF5KCk6IEZsb2F0MzJBcnJheSB7XG5cdFx0cmV0dXJuIHRoaXMudmVjO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBlcmZvcm1zIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlY3RvcnNcblx0ICogQHBhcmFtIGEgVGhlIGZpcnN0IHZlY3RvclxuXHQgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZlY3RvclxuXHQgKiBAcGFyYW0gdCBUaGUgdGltZSBvZiB0aGUgbGVycCwgd2l0aCAwIGJlaW5nIHZlY3RvciBBLCBhbmQgMSBiZWluZyB2ZWN0b3IgQlxuXHQgKiBAcmV0dXJucyBBIG5ldyBWZWMyIHJlcHJlc2VudGluZyB0aGUgbGVycCBiZXR3ZWVuIHZlY3RvciBhIGFuZCBiLlxuXHQgKi9cblx0c3RhdGljIGxlcnAoYTogVmVjMiwgYjogVmVjMiwgdDogbnVtYmVyKTogVmVjMiB7XG5cdFx0cmV0dXJuIG5ldyBWZWMyKE1hdGhVdGlscy5sZXJwKGEueCwgYi54LCB0KSwgTWF0aFV0aWxzLmxlcnAoYS55LCBiLnksIHQpKTtcblx0fVxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Ob2Rlcy9HYW1lTm9kZVwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xuXG4vKipcbiAqIEEgdXRpbCBjbGFzcyBmb3IgcmVuZGVyaW5nIERlYnVnIG1lc3NhZ2VzIHRvIHRoZSBjYW52YXMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlYnVnIHtcblxuXHQvKiogQSBtYXAgb2YgbG9nIG1lc3NhZ2VzIHRvIGRpc3BsYXkgb24gdGhlIHNjcmVlbiAqLyBcblx0cHJpdmF0ZSBzdGF0aWMgbG9nTWVzc2FnZXM6IE1hcDxzdHJpbmc+ID0gbmV3IE1hcCgpO1xuXG5cdC8qKiBBbiBhcnJheSBvZiBnYW1lIG5vZGVzIHRvIHJlbmRlciBkZWJ1ZyBpbmZvIGZvciAqL1xuXHRwcml2YXRlIHN0YXRpYyBub2RlczogQXJyYXk8R2FtZU5vZGU+O1xuXG5cdC8qKiBUaGUgcmVuZGVyaW5nIGNvbnRleHQgZm9yIGFueSBkZWJ1ZyBtZXNzYWdlcyAqL1xuXHRwcml2YXRlIHN0YXRpYyBkZWJ1Z1JlbmRlcmluZ0NvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcblxuXHQvKipcdFRoZSBzaXplIG9mIHRoZSBkZWJ1ZyBjYW52YXMgKi9cblx0cHJpdmF0ZSBzdGF0aWMgZGVidWdDYW52YXNTaXplOiBWZWMyO1xuXG5cdC8qKiBUaGUgcmVuZGVyaW5nIGNvbG9yIGZvciB0ZXh0ICovXG5cdHByaXZhdGUgc3RhdGljIGRlZmF1bHRUZXh0Q29sb3I6IENvbG9yID0gQ29sb3IuV0hJVEU7XG5cblx0LyoqXG5cdCAqIEFkZCBhIG1lc3NhZ2UgdG8gZGlzcGxheSBvbiB0aGUgZGVidWcgc2NyZWVuXG5cdCAqIEBwYXJhbSBpZCBBIHVuaXF1ZSBJRCBmb3IgdGhpcyBtZXNzYWdlXG5cdCAqIEBwYXJhbSBtZXNzYWdlcyBUaGUgbWVzc2FnZXMgdG8gcHJpbnQgdG8gdGhlIGRlYnVnIHNjcmVlblxuXHQgKi9cblx0c3RhdGljIGxvZyhpZDogc3RyaW5nLCAuLi5tZXNzYWdlczogYW55KTogdm9pZCB7XG5cdFx0Ly8gbGV0IG1lc3NhZ2UgPSBcIlwiO1xuXHRcdC8vIGZvcihsZXQgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKyl7XG5cdFx0Ly8gXHRtZXNzYWdlICs9IG1lc3NhZ2VzW2ldLnRvU3RyaW5nKCk7XG5cdFx0Ly8gfVxuXHRcdC8vIEpvaW4gYWxsIG1lc3NhZ2VzIHdpdGggc3BhY2VzXG5cdFx0bGV0IG1lc3NhZ2UgPSBtZXNzYWdlcy5tYXAoKG06IGFueSkgPT4gbS50b1N0cmluZygpKS5qb2luKFwiIFwiKTtcblx0XHR0aGlzLmxvZ01lc3NhZ2VzLmFkZChpZCwgbWVzc2FnZSk7XG5cdH1cblxuXHQvKipcblx0ICogRGVsZXRlcyBhIGEga2V5IGZyb20gdGhlIGxvZyBhbmQgc3RvcHMgaXQgZnJvbSBrZWVwaW5nIHVwIHNwYWNlIG9uIHRoZSBzY3JlZW5cblx0ICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgbG9nIGl0ZW0gdG8gY2xlYXJcblx0ICovXG5cdHN0YXRpYyBjbGVhckxvZ0l0ZW0oaWQ6IHN0cmluZyk6IHZvaWQge1xuXHRcdHRoaXMubG9nTWVzc2FnZXMuZGVsZXRlKGlkKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBsaXN0IG9mIG5vZGVzIHRvIHJlbmRlciB3aXRoIHRoZSBkZWJ1Z2dlclxuXHQgKiBAcGFyYW0gbm9kZXMgVGhlIG5ldyBsaXN0IG9mIG5vZGVzXG5cdCAqL1xuXHRzdGF0aWMgc2V0Tm9kZXMobm9kZXM6IEFycmF5PEdhbWVOb2RlPik6IHZvaWQge1xuXHRcdHRoaXMubm9kZXMgPSBub2Rlcztcblx0fVxuXG5cdC8qKlxuXHQgKiBEcmF3cyBhIGJveCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uXG5cdCAqIEBwYXJhbSBjZW50ZXIgVGhlIGNlbnRlciBvZiB0aGUgYm94XG5cdCAqIEBwYXJhbSBoYWxmU2l6ZSBUaGUgZGltZW5zaW9ucyBvZiB0aGUgYm94XG5cdCAqIEBwYXJhbSBmaWxsZWQgQSBib29sZWFuIGZvciB3aGV0aGVyIG9yIG5vdCB0aGUgYm94IGlzIGZpbGxlZFxuXHQgKiBAcGFyYW0gY29sb3IgVGhlIGNvbG9yIG9mIHRoZSBib3ggdG8gZHJhd1xuXHQgKi9cblx0c3RhdGljIGRyYXdCb3goY2VudGVyOiBWZWMyLCBoYWxmU2l6ZTogVmVjMiwgZmlsbGVkOiBib29sZWFuLCBjb2xvcjogQ29sb3IpOiB2b2lkIHtcblx0XHRsZXQgYWxwaGEgPSB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5nbG9iYWxBbHBoYTtcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5nbG9iYWxBbHBoYSA9IGNvbG9yLmE7XG5cblx0XHRpZihmaWxsZWQpe1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZmlsbFN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZpbGxSZWN0KGNlbnRlci54IC0gaGFsZlNpemUueCwgY2VudGVyLnkgLSBoYWxmU2l6ZS55LCBoYWxmU2l6ZS54KjIsIGhhbGZTaXplLnkqMik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxldCBsaW5lV2lkdGggPSAyO1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQubGluZVdpZHRoID0gbGluZVdpZHRoO1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuc3Ryb2tlUmVjdChjZW50ZXIueCAtIGhhbGZTaXplLngsIGNlbnRlci55IC0gaGFsZlNpemUueSwgaGFsZlNpemUueCoyLCBoYWxmU2l6ZS55KjIpO1xuXHRcdH1cblxuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0Lmdsb2JhbEFscGhhID0gYWxwaGE7XG5cdH1cblxuXHQvKipcblx0ICogRHJhd3MgYSBjaXJjbGUgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxuXHQgKiBAcGFyYW0gY2VudGVyIFRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZVxuXHQgKiBAcGFyYW0gcmFkaXVzIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBib3hcblx0ICogQHBhcmFtIGZpbGxlZCBBIGJvb2xlYW4gZm9yIHdoZXRoZXIgb3Igbm90IHRoZSBjaXJjbGUgaXMgZmlsbGVkXG5cdCAqIEBwYXJhbSBjb2xvciBUaGUgY29sb3Igb2YgdGhlIGNpcmNsZVxuXHQgKi9cblx0c3RhdGljIGRyYXdDaXJjbGUoY2VudGVyOiBWZWMyLCByYWRpdXM6IG51bWJlciwgZmlsbGVkOiBib29sZWFuLCBjb2xvcjogQ29sb3IpOiB2b2lkIHtcblx0XHRsZXQgYWxwaGEgPSB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5nbG9iYWxBbHBoYTtcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5nbG9iYWxBbHBoYSA9IGNvbG9yLmE7XG5cblx0XHRpZihmaWxsZWQpe1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZmlsbFN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmJlZ2luUGF0aCgpO1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuYXJjKGNlbnRlci54LCBjZW50ZXIueSwgcmFkaXVzLCAwLCAyICogTWF0aC5QSSk7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5jbG9zZVBhdGgoKTtcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZpbGwoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IGxpbmVXaWR0aCA9IDI7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5iZWdpblBhdGgoKTtcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmFyYyhjZW50ZXIueCwgY2VudGVyLnksIHJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuY2xvc2VQYXRoKCk7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5zdHJva2UoKTtcblx0XHR9XG5cblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuXHR9XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgcmF5IGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb25cblx0ICogQHBhcmFtIGZyb20gVGhlIHN0YXJ0aW5nIHBvc2l0aW9uIG9mIHRoZSByYXlcblx0ICogQHBhcmFtIHRvIFRoZSBlbmRpbmcgcG9zaXRpb24gb2YgdGhlIHJheVxuXHQgKiBAcGFyYW0gY29sb3IgVGhlIGNvbG9yIG9mIHRoZSByYXlcblx0ICovXG5cdHN0YXRpYyBkcmF3UmF5KGZyb206IFZlYzIsIHRvOiBWZWMyLCBjb2xvcjogQ29sb3IpOiB2b2lkIHtcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5saW5lV2lkdGggPSAyO1xuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcblxuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmJlZ2luUGF0aCgpO1xuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0Lm1vdmVUbyhmcm9tLngsIGZyb20ueSk7XG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQubGluZVRvKHRvLngsIHRvLnkpO1xuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmNsb3NlUGF0aCgpO1xuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LnN0cm9rZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgcG9pbnQgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxuXHQgKiBAcGFyYW0gcG9zIFRoZSBwb3NpdGlvbiBvZiB0aGUgcG9pbnRcblx0ICogQHBhcmFtIGNvbG9yIFRoZSBjb2xvciBvZiB0aGUgcG9pbnRcblx0ICovXG5cdHN0YXRpYyBkcmF3UG9pbnQocG9zOiBWZWMyLCBjb2xvcjogQ29sb3IpOiB2b2lkIHtcblx0XHRsZXQgcG9pbnRTaXplID0gNjtcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5maWxsU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZpbGxSZWN0KHBvcy54IC0gcG9pbnRTaXplLzIsIHBvcy55IC0gcG9pbnRTaXplLzIsIHBvaW50U2l6ZSwgcG9pbnRTaXplKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBkZWZhdWx0IHJlbmRlcmluZyBjb2xvciBmb3IgdGV4dCBmb3IgdGhlIGRlYnVnZ2VyXG5cdCAqIEBwYXJhbSBjb2xvciBUaGUgY29sb3IgdG8gcmVuZGVyIHRoZSB0ZXh0XG5cdCAqL1xuXHRzdGF0aWMgc2V0RGVmYXVsdFRleHRDb2xvcihjb2xvcjogQ29sb3IpOiB2b2lkIHtcblx0XHR0aGlzLmRlZmF1bHRUZXh0Q29sb3IgPSBjb2xvcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBQZXJmb3JtcyBhbnkgbmVjZXNzYXJ5IHNldHVwIG9wZXJhdGlvbnMgb24gdGhlIERlYnVnIGNhbnZhc1xuXHQgKiBAcGFyYW0gY2FudmFzIFRoZSBkZWJ1ZyBjYW52YXNcblx0ICogQHBhcmFtIHdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIGhlaWdodCBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcmV0dXJucyBUaGUgcmVuZGVyaW5nIGNvbnRleHQgZXh0cmFjdGVkIGZyb20gdGhlIGNhbnZhc1xuXHQgKi9cblx0c3RhdGljIGluaXRpYWxpemVEZWJ1Z0NhbnZhcyhjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuXHRcdGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0XG5cdFx0dGhpcy5kZWJ1Z0NhbnZhc1NpemUgPSBuZXcgVmVjMih3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0O1xuXHR9XG5cblx0LyoqIENsZWFycyB0aGUgZGVidWcgY2FudmFzICovXG5cdHN0YXRpYyBjbGVhckNhbnZhcygpOiB2b2lkIHtcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy5kZWJ1Z0NhbnZhc1NpemUueCwgdGhpcy5kZWJ1Z0NhbnZhc1NpemUueSk7XG5cdH1cblxuXHQvKiogUmVuZGVycyB0aGUgdGV4dCBhbmQgbm9kZXMgc2VudCB0byB0aGUgRGVidWcgc3lzdGVtICovXG5cdHN0YXRpYyByZW5kZXIoKTogdm9pZCB7XG5cdFx0dGhpcy5yZW5kZXJUZXh0KCk7XG5cdFx0dGhpcy5yZW5kZXJOb2RlcygpO1xuXHR9XG5cblx0LyoqIFJlbmRlcnMgdGhlIHRleHQgc2VudCB0byB0aGUgRGVidWcgY2FudmFzICovXG5cdHN0YXRpYyByZW5kZXJUZXh0KCk6IHZvaWQge1xuXHRcdGxldCB5ID0gMjA7XG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZm9udCA9IFwiMjBweCBBcmlhbFwiO1xuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuZGVmYXVsdFRleHRDb2xvci50b1N0cmluZygpO1xuXG5cdFx0Ly8gRHJhdyBhbGwgb2YgdGhlIHRleHRcblx0XHR0aGlzLmxvZ01lc3NhZ2VzLmZvckVhY2goKGtleTogc3RyaW5nKSA9PiB7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5maWxsVGV4dCh0aGlzLmxvZ01lc3NhZ2VzLmdldChrZXkpLCAxMCwgeSlcblx0XHRcdHkgKz0gMzA7XHRcblx0XHR9KTtcblx0fVxuXG5cdC8qKiBSZW5kZXJzIHRoZSBub2RlcyByZWdpc3RlcmVkIHdpdGggdGhlIGRlYnVnIGNhbnZhcyAqL1xuXHRzdGF0aWMgcmVuZGVyTm9kZXMoKTogdm9pZCB7XG5cdFx0aWYodGhpcy5ub2Rlcyl7XG5cdFx0XHR0aGlzLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG5cdFx0XHRcdG5vZGUuZGVidWdSZW5kZXIoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxufSIsImltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcblxuLy8gQGlnbm9yZVBhZ2VcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXRzIGV4dGVuZHMgT2JqZWN0IHtcbiAgICAvLyBUaGUgZnBzIG9mIHRoZSBnYW1lLlxuICAgIHByaXZhdGUgc3RhdGljIHByZXZmcHM6IEFycmF5PG51bWJlcj47XG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgTlVNX1BPSU5UUzogbnVtYmVyID0gNjA7XG4gICAgcHJpdmF0ZSBzdGF0aWMgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG4gICAgcHJpdmF0ZSBzdGF0aWMgQ0FOVkFTX1dJRFRIOiBudW1iZXIgPSAzMDA7XG4gICAgcHJpdmF0ZSBzdGF0aWMgQ0FOVkFTX0hFSUdIVDogbnVtYmVyID0gMzAwO1xuICAgIHByaXZhdGUgc3RhdGljIHN0YXRzRGl2OiBIVE1MRGl2RWxlbWVudDtcbiAgICBwcml2YXRlIHN0YXRpYyBncmFwaENob2ljZXM6IEhUTUxTZWxlY3RFbGVtZW50O1xuXG4gICAgLy8gUXVhZHRyZWUgc3RhdHNcbiAgICBwcml2YXRlIHN0YXRpYyBwcmV2Q2xlYXJUaW1lczogQXJyYXk8bnVtYmVyPjtcbiAgICBwcml2YXRlIHN0YXRpYyBTR0NsZWFyVGltZXM6IEFycmF5PG51bWJlcj47XG4gICAgcHJpdmF0ZSBzdGF0aWMgYXZnU0dDbGVhclRpbWU6IG51bWJlcjtcblxuICAgIHByaXZhdGUgc3RhdGljIHByZXZGaWxsVGltZXM6IEFycmF5PG51bWJlcj47XG4gICAgcHJpdmF0ZSBzdGF0aWMgU0dGaWxsVGltZXM6IEFycmF5PG51bWJlcj47XG4gICAgcHJpdmF0ZSBzdGF0aWMgYXZnU0dGaWxsVGltZTogbnVtYmVyO1xuXG4gICAgcHJpdmF0ZSBzdGF0aWMgcHJldlVwZGF0ZVRpbWVzOiBBcnJheTxudW1iZXI+O1xuICAgIHByaXZhdGUgc3RhdGljIFNHVXBkYXRlVGltZXM6IEFycmF5PG51bWJlcj47XG4gICAgcHJpdmF0ZSBzdGF0aWMgYXZnU0dVcGRhdGVUaW1lOiBudW1iZXI7XG5cbiAgICBwcml2YXRlIHN0YXRpYyBwcmV2UXVlcnlUaW1lczogQXJyYXk8bnVtYmVyPjtcbiAgICBwcml2YXRlIHN0YXRpYyBTR1F1ZXJ5VGltZXM6IEFycmF5PG51bWJlcj47XG4gICAgcHJpdmF0ZSBzdGF0aWMgYXZnU0dRdWVyeVRpbWU6IG51bWJlcjtcblxuICAgIHN0YXRpYyBpbml0U3RhdHMoKTogdm9pZCB7XG4gICAgICAgIGxldCBjYW52YXMgPSA8SFRNTENhbnZhc0VsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdGF0cy1jYW52YXNcIik7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMuQ0FOVkFTX1dJRFRIO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5DQU5WQVNfSEVJR0hUO1xuICAgICAgICB0aGlzLmN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICAgICAgdGhpcy5zdGF0c0RpdiA9IDxIVE1MRGl2RWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN0YXRzLWRpc3BsYXlcIik7XG5cbiAgICAgICAgdGhpcy5wcmV2ZnBzID0gbmV3IEFycmF5KCk7XG5cbiAgICAgICAgdGhpcy5wcmV2Q2xlYXJUaW1lcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLlNHQ2xlYXJUaW1lcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLmF2Z1NHQ2xlYXJUaW1lID0gMDtcblxuICAgICAgICB0aGlzLnByZXZGaWxsVGltZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5TR0ZpbGxUaW1lcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLmF2Z1NHRmlsbFRpbWUgPSAwO1xuXG4gICAgICAgIHRoaXMucHJldlVwZGF0ZVRpbWVzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMuU0dVcGRhdGVUaW1lcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLmF2Z1NHVXBkYXRlVGltZSA9IDA7XG5cbiAgICAgICAgdGhpcy5wcmV2UXVlcnlUaW1lcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLlNHUXVlcnlUaW1lcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLmF2Z1NHUXVlcnlUaW1lID0gMDtcblxuICAgICAgICBsZXQgY2xlYXJUaW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIGNsZWFyVGltZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInNnY2xlYXJcIik7XG4gICAgICAgIGxldCBmaWxsVGltZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBmaWxsVGltZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInNnZmlsbFwiKTtcbiAgICAgICAgbGV0IHVwZGF0ZVRpbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgdXBkYXRlVGltZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInNndXBkYXRlXCIpO1xuICAgICAgICBsZXQgcXVlcnlUaW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHF1ZXJ5VGltZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInNncXVlcnlcIik7XG4gICAgICAgIGxldCBicjEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIik7XG4gICAgICAgIGxldCBicjIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIik7XG4gICAgICAgIGxldCBicjMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIik7XG5cbiAgICAgICAgdGhpcy5zdGF0c0Rpdi5hcHBlbmQoY2xlYXJUaW1lLCBicjEsIGZpbGxUaW1lLCBicjIsIHVwZGF0ZVRpbWUsIGJyMywgcXVlcnlUaW1lKTtcblxuICAgICAgICB0aGlzLmdyYXBoQ2hvaWNlcyA9IDxIVE1MU2VsZWN0RWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNoYXJ0LW9wdGlvblwiKTtcbiAgICAgICAgbGV0IG9wdGlvbjEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICBvcHRpb24xLnZhbHVlID0gXCJwcmV2ZnBzXCI7XG4gICAgICAgIG9wdGlvbjEubGFiZWwgPSBcIkZQU1wiO1xuICAgICAgICBsZXQgb3B0aW9uMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgIG9wdGlvbjIudmFsdWUgPSBcInByZXZDbGVhclRpbWVzXCI7XG4gICAgICAgIG9wdGlvbjIubGFiZWwgPSBcIkNsZWFyIFRpbWVcIjtcbiAgICAgICAgbGV0IG9wdGlvbjMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICBvcHRpb24zLnZhbHVlID0gXCJwcmV2RmlsbFRpbWVzXCI7XG4gICAgICAgIG9wdGlvbjMubGFiZWwgPSBcIkZpbGwgdGltZVwiO1xuICAgICAgICBsZXQgb3B0aW9uNCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgIG9wdGlvbjQudmFsdWUgPSBcInByZXZVcGRhdGVUaW1lc1wiO1xuICAgICAgICBvcHRpb240LmxhYmVsID0gXCJVcGRhdGUgdGltZVwiO1xuICAgICAgICBsZXQgb3B0aW9uNSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgIG9wdGlvbjUudmFsdWUgPSBcInByZXZRdWVyeVRpbWVzXCI7XG4gICAgICAgIG9wdGlvbjUubGFiZWwgPSBcIlF1ZXJ5IFRpbWVcIjtcbiAgICAgICAgbGV0IG9wdGlvbkFsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgIG9wdGlvbkFsbC52YWx1ZSA9IFwiYWxsXCI7XG4gICAgICAgIG9wdGlvbkFsbC5sYWJlbCA9IFwiQWxsXCI7XG4gICAgICAgIHRoaXMuZ3JhcGhDaG9pY2VzLmFwcGVuZChvcHRpb24xLCBvcHRpb24yLCBvcHRpb24zLCBvcHRpb240LCBvcHRpb241LCBvcHRpb25BbGwpO1xuICAgIH1cblxuICAgIHN0YXRpYyB1cGRhdGVGUFMoZnBzOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wcmV2ZnBzLnB1c2goZnBzKTtcbiAgICAgICAgaWYodGhpcy5wcmV2ZnBzLmxlbmd0aCA+IFN0YXRzLk5VTV9QT0lOVFMpe1xuICAgICAgICAgICAgdGhpcy5wcmV2ZnBzLnNoaWZ0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLlNHQ2xlYXJUaW1lcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgIHRoaXMucHJldkNsZWFyVGltZXMucHVzaCh0aGlzLmF2Z1NHQ2xlYXJUaW1lKTtcbiAgICAgICAgICAgIGlmKHRoaXMucHJldkNsZWFyVGltZXMubGVuZ3RoID4gdGhpcy5OVU1fUE9JTlRTKXtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZDbGVhclRpbWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5TR0ZpbGxUaW1lcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgIHRoaXMucHJldkZpbGxUaW1lcy5wdXNoKHRoaXMuYXZnU0dGaWxsVGltZSk7XG4gICAgICAgICAgICBpZih0aGlzLnByZXZGaWxsVGltZXMubGVuZ3RoID4gdGhpcy5OVU1fUE9JTlRTKXtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZGaWxsVGltZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLlNHVXBkYXRlVGltZXMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICB0aGlzLnByZXZVcGRhdGVUaW1lcy5wdXNoKHRoaXMuYXZnU0dVcGRhdGVUaW1lKTtcbiAgICAgICAgICAgIGlmKHRoaXMucHJldlVwZGF0ZVRpbWVzLmxlbmd0aCA+IHRoaXMuTlVNX1BPSU5UUyl7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2VXBkYXRlVGltZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLlNHUXVlcnlUaW1lcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgIHRoaXMucHJldlF1ZXJ5VGltZXMucHVzaCh0aGlzLmF2Z1NHUXVlcnlUaW1lKTtcbiAgICAgICAgICAgIGlmKHRoaXMucHJldlF1ZXJ5VGltZXMubGVuZ3RoID4gdGhpcy5OVU1fUE9JTlRTKXtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZRdWVyeVRpbWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZVNHU3RhdHMoKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbG9nKGtleTogc3RyaW5nLCBkYXRhOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYoa2V5ID09PSBcInNnY2xlYXJcIil7XG4gICAgICAgICAgICB0aGlzLlNHQ2xlYXJUaW1lcy5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgaWYodGhpcy5TR0NsZWFyVGltZXMubGVuZ3RoID4gMTAwKXtcbiAgICAgICAgICAgICAgICB0aGlzLlNHQ2xlYXJUaW1lcy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoa2V5ID09PSBcInNnZmlsbFwiKXtcbiAgICAgICAgICAgIHRoaXMuU0dGaWxsVGltZXMucHVzaChkYXRhKTtcbiAgICAgICAgICAgIGlmKHRoaXMuU0dGaWxsVGltZXMubGVuZ3RoID4gMTAwKXtcbiAgICAgICAgICAgICAgICB0aGlzLlNHRmlsbFRpbWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZihrZXkgPT09IFwic2d1cGRhdGVcIil7XG4gICAgICAgICAgICB0aGlzLlNHVXBkYXRlVGltZXMucHVzaChkYXRhKTtcbiAgICAgICAgICAgIGlmKHRoaXMuU0dVcGRhdGVUaW1lcy5sZW5ndGggPiAxMDApe1xuICAgICAgICAgICAgICAgIHRoaXMuU0dVcGRhdGVUaW1lcy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoa2V5ID09PSBcInNncXVlcnlcIil7XG4gICAgICAgICAgICB0aGlzLlNHUXVlcnlUaW1lcy5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgaWYodGhpcy5TR1F1ZXJ5VGltZXMubGVuZ3RoID4gMTAwMCl7XG4gICAgICAgICAgICAgICAgdGhpcy5TR1F1ZXJ5VGltZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgc3RhdGljIHJlbmRlcigpOiB2b2lkIHtcbiAgICAgICAgLy8gRGlzcGxheSBzdGF0c1xuICAgICAgICB0aGlzLmRyYXdDaGFydHMoKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZHJhd0NoYXJ0cygpe1xuICAgICAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5DQU5WQVNfV0lEVEgsIHRoaXMuQ0FOVkFTX0hFSUdIVCk7XG5cbiAgICAgICAgbGV0IHBhcmFtU3RyaW5nID0gdGhpcy5ncmFwaENob2ljZXMudmFsdWU7XG5cbiAgICAgICAgaWYocGFyYW1TdHJpbmcgPT09IFwicHJldmZwc1wiIHx8IHBhcmFtU3RyaW5nID09PSBcImFsbFwiKXtcbiAgICAgICAgICAgIGxldCBwYXJhbSA9IHRoaXMucHJldmZwcztcbiAgICAgICAgICAgIGxldCBjb2xvciA9IENvbG9yLkJMVUUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhd0NoYXJ0KHBhcmFtLCBjb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYocGFyYW1TdHJpbmcgPT09IFwicHJldkNsZWFyVGltZXNcIiB8fCBwYXJhbVN0cmluZyA9PT0gXCJhbGxcIil7XG4gICAgICAgICAgICBsZXQgcGFyYW0gPSB0aGlzLnByZXZDbGVhclRpbWVzO1xuICAgICAgICAgICAgbGV0IGNvbG9yID0gQ29sb3IuUkVELnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLmRyYXdDaGFydChwYXJhbSwgY29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHBhcmFtU3RyaW5nID09PSBcInByZXZGaWxsVGltZXNcIiB8fCBwYXJhbVN0cmluZyA9PT0gXCJhbGxcIil7XG4gICAgICAgICAgICBsZXQgcGFyYW0gPSB0aGlzLnByZXZGaWxsVGltZXM7XG4gICAgICAgICAgICBsZXQgY29sb3IgPSBDb2xvci5HUkVFTi50b1N0cmluZygpO1xuICAgICAgICAgICAgdGhpcy5kcmF3Q2hhcnQocGFyYW0sIGNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZihwYXJhbVN0cmluZyA9PT0gXCJwcmV2VXBkYXRlVGltZXNcIiB8fCBwYXJhbVN0cmluZyA9PT0gXCJhbGxcIil7XG4gICAgICAgICAgICBsZXQgcGFyYW0gPSB0aGlzLnByZXZVcGRhdGVUaW1lcztcbiAgICAgICAgICAgIGxldCBjb2xvciA9IENvbG9yLkNZQU4udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhd0NoYXJ0KHBhcmFtLCBjb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYocGFyYW1TdHJpbmcgPT09IFwicHJldlF1ZXJ5VGltZXNcIiB8fCBwYXJhbVN0cmluZyA9PT0gXCJhbGxcIil7XG4gICAgICAgICAgICBsZXQgcGFyYW0gPSB0aGlzLnByZXZRdWVyeVRpbWVzO1xuICAgICAgICAgICAgbGV0IGNvbG9yID0gQ29sb3IuT1JBTkdFLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLmRyYXdDaGFydChwYXJhbSwgY29sb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGRyYXdDaGFydChwYXJhbTogQXJyYXk8bnVtYmVyPiwgY29sb3I6IHN0cmluZyl7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gQ29sb3IuQkxBQ0sudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuY3R4Lm1vdmVUbygxMCwgMTApO1xuICAgICAgICB0aGlzLmN0eC5saW5lVG8oMTAsIHRoaXMuQ0FOVkFTX0hFSUdIVCAtIDEwKTtcbiAgICAgICAgdGhpcy5jdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5jdHgubW92ZVRvKDEwLCB0aGlzLkNBTlZBU19IRUlHSFQgLSAxMCk7XG4gICAgICAgIHRoaXMuY3R4LmxpbmVUbyh0aGlzLkNBTlZBU19XSURUSCAtIDEwLCB0aGlzLkNBTlZBU19IRUlHSFQgLSAxMCk7XG4gICAgICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcblxuICAgICAgICBsZXQgbWF4ID0gTWF0aC5tYXgoLi4ucGFyYW0pO1xuICAgICAgICBsZXQgcHJldlggPSAxMDtcbiAgICAgICAgbGV0IHByZXZZID0gdGhpcy5DQU5WQVNfSEVJR0hUIC0gMTAgLSBwYXJhbVswXS9tYXgqKHRoaXMuQ0FOVkFTX0hFSUdIVC0yMCk7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG5cbiAgICAgICAgZm9yKGxldCBpID0gMTsgaSA8IHBhcmFtLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGxldCBmcHMgPSBwYXJhbVtpXTtcbiAgICAgICAgICAgIGxldCB4ID0gMTAgKyBpKih0aGlzLkNBTlZBU19XSURUSCAtIDIwKS90aGlzLk5VTV9QT0lOVFM7XG4gICAgICAgICAgICBsZXQgeSA9IHRoaXMuQ0FOVkFTX0hFSUdIVCAtIDEwIC0gZnBzL21heCoodGhpcy5DQU5WQVNfSEVJR0hULTIwKVxuICAgICAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICB0aGlzLmN0eC5tb3ZlVG8ocHJldlgsIHByZXZZKTtcbiAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgIHByZXZYID0geDtcbiAgICAgICAgICAgIHByZXZZID0geTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyB1cGRhdGVTR1N0YXRzKCl7XG4gICAgICAgIGlmKHRoaXMuU0dDbGVhclRpbWVzLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgdGhpcy5hdmdTR0NsZWFyVGltZSA9IHRoaXMuU0dDbGVhclRpbWVzLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCkvdGhpcy5TR0NsZWFyVGltZXMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5TR0ZpbGxUaW1lcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgIHRoaXMuYXZnU0dGaWxsVGltZSA9IHRoaXMuU0dGaWxsVGltZXMucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsKS90aGlzLlNHRmlsbFRpbWVzLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuU0dVcGRhdGVUaW1lcy5sZW5ndGggPiAwKXtcbiAgICAgICAgdGhpcy5hdmdTR1VwZGF0ZVRpbWUgPSB0aGlzLlNHVXBkYXRlVGltZXMucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsKS90aGlzLlNHVXBkYXRlVGltZXMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5TR1F1ZXJ5VGltZXMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICB0aGlzLmF2Z1NHUXVlcnlUaW1lID0gdGhpcy5TR1F1ZXJ5VGltZXMucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsKS90aGlzLlNHUXVlcnlUaW1lcy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNnY2xlYXJcIikuaW5uZXJIVE1MID0gXCJBdmcgU0cgY2xlYXIgdGltZTogXCIgKyB0aGlzLmF2Z1NHQ2xlYXJUaW1lO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNnZmlsbFwiKS5pbm5lckhUTUwgPSBcIkF2ZyBTRyBmaWxsIHRpbWU6IFwiICsgdGhpcy5hdmdTR0ZpbGxUaW1lO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNndXBkYXRlXCIpLmlubmVySFRNTCA9IFwiQXZnIFNHIHVwZGF0ZSB0aW1lOiBcIiArIHRoaXMuYXZnU0dVcGRhdGVUaW1lO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNncXVlcnlcIikuaW5uZXJIVE1MID0gXCJBdmcgU0cgcXVlcnkgdGltZTogXCIgKyB0aGlzLmF2Z1NHUXVlcnlUaW1lO1xuICAgIH1cbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XG5pbXBvcnQgRXZlbnRRdWV1ZSBmcm9tIFwiLi9FdmVudFF1ZXVlXCI7XG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuL0dhbWVFdmVudFwiO1xuXG4vKipcbiAqIEFuIGV2ZW50IGVtaXR0ZXIgb2JqZWN0IG90aGVyIHN5c3RlbXMgY2FuIHVzZSB0byBob29rIGludG8gdGhlIEV2ZW50UXVldWUuXG4gKiBQcm92aWRlcyBhbiBlYXN5IGludGVyZmFjZSBmb3IgZmlyaW5nIG9mZiBldmVudHMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVtaXR0ZXIge1xuXHQvKiogQSByZWZlcmVuY2UgdG8gdGhlIEV2ZW50UXVldWUgKi9cblx0cHJpdmF0ZSBldmVudFF1ZXVlOiBFdmVudFF1ZXVlO1xuXG5cdC8qKiBDcmVhdGVzIGEgbmV3IEVtaXR0ZXIgKi9cblx0Y29uc3RydWN0b3IoKXtcblx0XHR0aGlzLmV2ZW50UXVldWUgPSBFdmVudFF1ZXVlLmdldEluc3RhbmNlKCk7XG5cdH1cblxuXHQvKipcblx0ICogRW1pdCBhbmQgZXZlbnQgb2YgdHlwZSBldmVudFR5cGUgd2l0aCB0aGUgZGF0YSBwYWNrZXQgZGF0YVxuXHQgKiBAcGFyYW0gZXZlbnRUeXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBmaXJlIG9mZlxuXHQgKiBAcGFyYW0gZGF0YSBBIEByZWZlcmVuY2VbTWFwXSBvciByZWNvcmQgY29udGFpbmluZyBhbnkgZGF0YSBhYm91dCB0aGUgZXZlbnRcblx0ICovXG5cdGZpcmVFdmVudChldmVudFR5cGU6IHN0cmluZywgZGF0YTogTWFwPGFueT4gfCBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0gbnVsbCk6IHZvaWQge1xuXHRcdHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChuZXcgR2FtZUV2ZW50KGV2ZW50VHlwZSwgZGF0YSkpO1xuXHR9XG59IiwiaW1wb3J0IFF1ZXVlIGZyb20gXCIuLi9EYXRhVHlwZXMvUXVldWVcIjtcbmltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4vR2FtZUV2ZW50XCI7XG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4vUmVjZWl2ZXJcIjtcbmltcG9ydCB7IEdhbWVFdmVudFR5cGUgfSBmcm9tIFwiLi9HYW1lRXZlbnRUeXBlXCI7XG5cbi8qKlxuICogVGhlIG1haW4gZXZlbnQgc3lzdGVtIG9mIHRoZSBnYW1lIGVuZ2luZS5cbiAqIEV2ZW50cyBhcmUgc2VudCB0byB0aGUgRXZlbnRRdWV1ZSwgd2hpY2ggaGFuZGxlcyBkaXN0cmlidXRpb24gdG8gYW55IHN5c3RlbXMgdGhhdCBhcmUgbGlzdGVuaW5nIGZvciB0aG9zZSBldmVudHMuXG4gKiBUaGlzIGFsbG93cyBmb3IgaGFuZGxpbmcgb2YgaW5wdXQgd2l0aG91dCBoYXZpbmcgY2xhc3NlcyBkaXJlY3RseSBob29rIGludG8gamF2YXNjcmlwdCBldmVudCBoYW5kbGVzLCBcbiAqIGFuZCBhbGxvd3Mgb3RoZXJ3aXNlIHNlcGFyYXRlIGNsYXNzZXMgdG8gY29tbXVuaWNhdGUgd2l0aCBlYWNoIG90aGVyIGNsZWFubHksIHN1Y2ggYXMgYSBQbGF5ZXIgb2JqZWN0IFxuICogcmVxdWVzdGluZyBhIHNvdW5kIGJlIHBsYXllZCBieSB0aGUgYXVkaW8gc3lzdGVtLlxuICogXG4gKiBUaGUgZGlzdHJpYnV0aW9uIG9mIEByZWZlcmVuY2VbR2FtZUV2ZW50XXMgaGFwcGVucyBhcyBmb2xsb3dzOlxuICogXG4gKiBFdmVudHMgYXJlIHJlY2lldmVkIHRocm91Z2hvdXQgYSBmcmFtZSBhbmQgYXJlIHF1ZXVlZCB1cCBieSB0aGUgRXZlbnRRdWV1ZS5cbiAqIEF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5leHQgZnJhbWUsIGV2ZW50cyBhcmUgc2VudCBvdXQgdG8gYW55IHJlY2VpdmVycyB0aGF0IGFyZSBob29rZWQgaW50byB0aGUgZXZlbnQgdHlwZS5cbiAqIEByZWZlcmVuY2VbUmVjZWl2ZXJdcyBhcmUgdGhlbiBmcmVlIHRvIHByb2Nlc3MgZXZlbnRzIGFzIHRoZXkgc2VlIGZpdC5cbiAqIFxuICogT3ZlcmFsbCwgdGhlIEV2ZW50UXVldWUgY2FuIGJlIGNvbnNpZGVyZWQgYXMgc29tZXRoaW5nIHNpbWlsYXIgdG8gYW4gZW1haWwgc2VydmVyLFxuICogYW5kIHRoZSBAcmVmZXJlbmNlW1JlY2VpdmVyXXMgY2FuIGJlIGNvbnNpZGVyZWQgYXMgdGhlIGNsaWVudCBpbmJveGVzLlxuICogXG4gKiBTZWUgQGxpbmsoR2FtZSBQcm9ncmFtbWluZyBQYXR0ZXJucykoaHR0cHM6Ly9nYW1lcHJvZ3JhbW1pbmdwYXR0ZXJucy5jb20vZXZlbnQtcXVldWUuaHRtbCkgZm9yIG1vcmUgZGlzY3Vzc2lvbiBvbiBFdmVudFF1ZXVlc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFdmVudFF1ZXVlIHtcbiAgICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogRXZlbnRRdWV1ZSA9IG51bGw7XG4gICAgXG4gICAgLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBldmVudHMgdmlzaWJsZSAqL1xuICAgIHByaXZhdGUgcmVhZG9ubHkgTUFYX1NJWkU6IG51bWJlcjtcbiAgICBcbiAgICAvKiogVGhlIGFjdHVhbCBxdWV1ZSBvZiBldmVudHMgKi9cbiAgICBwcml2YXRlIHE6IFF1ZXVlPEdhbWVFdmVudD47XG4gICAgXG4gICAgLyoqIFRoZSBtYXAgb2YgcmVjZWl2ZXJzIHJlZ2lzdGVyZWQgZm9yIGFuIGV2ZW50IG5hbWUgKi9cblx0cHJpdmF0ZSByZWNlaXZlcnM6IE1hcDxBcnJheTxSZWNlaXZlcj4+O1xuXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLk1BWF9TSVpFID0gMTAwO1xuICAgICAgICB0aGlzLnEgPSBuZXcgUXVldWU8R2FtZUV2ZW50Pih0aGlzLk1BWF9TSVpFKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlcnMgPSBuZXcgTWFwPEFycmF5PFJlY2VpdmVyPj4oKTtcblx0fVxuICAgIFxuICAgIC8qKiBSZXRyaWV2ZXMgdGhlIGluc3RhbmNlIG9mIHRoZSBTaW5nbGV0b24gRXZlbnRRdWV1ZSAqL1xuXHRzdGF0aWMgZ2V0SW5zdGFuY2UoKTogRXZlbnRRdWV1ZSB7XG5cdFx0aWYodGhpcy5pbnN0YW5jZSA9PT0gbnVsbCl7XG5cdFx0XHR0aGlzLmluc3RhbmNlID0gbmV3IEV2ZW50UXVldWUoKTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2U7XG5cdH1cblxuICAgIC8qKiBBZGRzIGFuIGV2ZW50IHRvIHRoZSBFdmVudFF1ZXVlLlxuICAgICAqIFRoaXMgaXMgZXhwb3NlZCB0byB0aGUgcmVzdCBvZiB0aGUgZ2FtZSBlbmdpbmUgdGhyb3VnaCB0aGUgQHJlZmVyZW5jZVtFbWl0dGVyXSBjbGFzcyAqL1xuICAgIGFkZEV2ZW50KGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5xLmVucXVldWUoZXZlbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc29jaWF0ZXMgYSByZWNlaXZlciB3aXRoIGEgdHlwZSBvZiBldmVudC4gRXZlcnkgdGltZSB0aGlzIGV2ZW50IGFwcGVhcnMgaW4gdGhlIGZ1dHVyZSxcbiAgICAgKiBpdCB3aWxsIGJlIGdpdmVuIHRvIHRoZSByZWNlaXZlciAoYW5kIGFueSBvdGhlcnMgd2F0Y2hpbmcgdGhhdCB0eXBlKS5cbiAgICAgKiBUaGlzIGlzIGV4cG9zZWQgdG8gdGhlIHJlc3Qgb2YgdGhlIGdhbWUgZW5naW5lIHRocm91Z2ggdGhlIEByZWZlcmVuY2VbUmVjZWl2ZXJdIGNsYXNzXG4gICAgICogQHBhcmFtIHJlY2VpdmVyIFRoZSBldmVudCByZWNlaXZlclxuICAgICAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9yIHR5cGVzIG9mIGV2ZW50cyB0byBzdWJzY3JpYmUgdG9cbiAgICAgKi9cbiAgICBzdWJzY3JpYmUocmVjZWl2ZXI6IFJlY2VpdmVyLCB0eXBlOiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+KTogdm9pZCB7XG4gICAgICAgIGlmKHR5cGUgaW5zdGFuY2VvZiBBcnJheSl7XG4gICAgICAgICAgICAvLyBJZiBpdCBpcyBhbiBhcnJheSwgc3Vic2NyaWJlIHRvIGFsbCBldmVudCB0eXBlc1xuICAgICAgICAgICAgZm9yKGxldCB0IG9mIHR5cGUpe1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGlzdGVuZXIocmVjZWl2ZXIsIHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGRMaXN0ZW5lcihyZWNlaXZlciwgdHlwZSk7XG4gICAgICAgIH1cblx0fVxuXG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmVzIHRoZSBzcGVjaWZpZWQgcmVjZWl2ZXIgZnJvbSBhbGwgZXZlbnRzLCBvciBmcm9tIHdoYXRldmVyIGV2ZW50cyBhcmUgcHJvdmlkZWRcbiAgICAgKiBAcGFyYW0gcmVjZWl2ZXIgVGhlIHJlY2VpdmVyIHRvIHVuc3Vic2NyaWJlXG4gICAgICogQHBhcmFtIGtleXMgVGhlIGV2ZW50cyB0byB1bnN1YnNjcmliZSBmcm9tLiBJZiBub25lIGFyZSBwcm92aWRlZCwgdW5zdWJzY3JpYmUgZnJvbSBhbGxcbiAgICAgKi9cbiAgICB1bnN1YnNjcmliZShyZWNlaXZlcjogUmVjZWl2ZXIsIC4uLmV2ZW50czogQXJyYXk8c3RyaW5nPik6IHZvaWQge1xuICAgICAgICB0aGlzLnJlY2VpdmVycy5mb3JFYWNoKGV2ZW50TmFtZSA9PiB7XG4gICAgICAgICAgICAvLyBJZiBrZXlzIHdlcmUgcHJvdmlkZWQsIG9ubHkgY29udGludWUgaWYgdGhpcyBrZXkgaXMgb25lIG9mIHRoZW1cbiAgICAgICAgICAgIGlmKGV2ZW50cy5sZW5ndGggPiAwICYmIGV2ZW50cy5pbmRleE9mKGV2ZW50TmFtZSkgPT09IC0xKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGluZGV4IG9mIG91ciByZWNlaXZlciBmb3IgdGhpcyBrZXlcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMucmVjZWl2ZXJzLmdldChldmVudE5hbWUpLmluZGV4T2YocmVjZWl2ZXIpO1xuXG4gICAgICAgICAgICAvLyBJZiBhbiBpbmRleCB3YXMgZm91bmQsIHJlbW92ZSB0aGUgcmVjZWl2ZXJcbiAgICAgICAgICAgIGlmKGluZGV4ICE9PSAtMSl7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNlaXZlcnMuZ2V0KGV2ZW50TmFtZSkuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQXNzb2NpYXRlIHRoZSByZWNlaXZlciBhbmQgdGhlIHR5cGVcblx0cHJpdmF0ZSBhZGRMaXN0ZW5lcihyZWNlaXZlcjogUmVjZWl2ZXIsIHR5cGU6IHN0cmluZyk6IHZvaWQge1xuXHRcdGlmKHRoaXMucmVjZWl2ZXJzLmhhcyh0eXBlKSl7XG5cdFx0XHR0aGlzLnJlY2VpdmVycy5nZXQodHlwZSkucHVzaChyZWNlaXZlcik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucmVjZWl2ZXJzLmFkZCh0eXBlLCBbcmVjZWl2ZXJdKTtcblx0XHR9XG5cdH1cbiAgICBcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgd2hpbGUodGhpcy5xLmhhc0l0ZW1zKCkpe1xuICAgICAgICAgICAgLy8gUmV0cmlldmUgZWFjaCBldmVudFxuXHRcdFx0bGV0IGV2ZW50ID0gdGhpcy5xLmRlcXVldWUoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgYSByZWNlaXZlciBoYXMgdGhpcyBldmVudCB0eXBlLCBzZW5kIGl0IHRoZSBldmVudFxuICAgICAgICAgICAgaWYodGhpcy5yZWNlaXZlcnMuaGFzKGV2ZW50LnR5cGUpKXtcbiAgICAgICAgICAgICAgICBmb3IobGV0IHJlY2VpdmVyIG9mIHRoaXMucmVjZWl2ZXJzLmdldChldmVudC50eXBlKSl7XG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVyLnJlY2VpdmUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cblx0XHRcdH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgYSByZWNlaXZlciBpcyBzdWJzY3JpYmVkIHRvIGFsbCBldmVudHMsIHNlbmQgaXQgdGhlIGV2ZW50XG4gICAgICAgICAgICBpZih0aGlzLnJlY2VpdmVycy5oYXMoR2FtZUV2ZW50VHlwZS5BTEwpKXtcbiAgICAgICAgICAgICAgICBmb3IobGV0IHJlY2VpdmVyIG9mIHRoaXMucmVjZWl2ZXJzLmdldChHYW1lRXZlbnRUeXBlLkFMTCkpe1xuICAgICAgICAgICAgICAgICAgICByZWNlaXZlci5yZWNlaXZlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiXG5cbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhbiBpbi1nYW1lIGV2ZW50IHRoYXQgaXMgcGFzc2VkIHRocm91Z2ggdGhlIEByZWZlcmVuY2VbRXZlbnRRdWV1ZV1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2FtZUV2ZW50IHtcbiAgICAvKiogVGhlIHR5cGUgb2YgdGhlIGV2ZW50ICovXG4gICAgcHVibGljIHR5cGU6IHN0cmluZztcbiAgICAvKiogVGhlIGRhdGEgY29udGFpbmVkIGJ5IHRoZSBldmVudCAqL1xuICAgIHB1YmxpYyBkYXRhOiBNYXA8YW55PjtcbiAgICAvKiogVGhlIHRpbWUgb2YgdGhlIGV2ZW50IGluIG1zICovXG5cdHB1YmxpYyB0aW1lOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEdhbWVFdmVudC5cbiAgICAgKiBUaGlzIGlzIGhhbmRsZWQgaW1wbGljaXRseSB0aHJvdWdoIHRoZSBAcmVmZXJlbmNlW0VtaXR0ZXJdIGNsYXNzXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgdGhlIEdhbWVFdmVudFxuICAgICAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIGNvbnRhaW5lZCBieSB0aGUgR2FtZUV2ZW50XG4gICAgICovXG4gICAgY29uc3RydWN0b3IodHlwZTogc3RyaW5nLCBkYXRhOiBNYXA8YW55PiB8IFJlY29yZDxzdHJpbmcsIGFueT4gPSBudWxsKSB7XG4gICAgICAgIC8vIFBhcnNlIHRoZSBnYW1lIGV2ZW50IGRhdGFcbiAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBNYXA8YW55PigpO1xuICAgICAgICB9IGVsc2UgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIE1hcCkpe1xuICAgICAgICAgICAgLy8gZGF0YSBpcyBhIHJhdyBvYmplY3QsIHVucGFja1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IE1hcDxhbnk+KCk7XG4gICAgICAgICAgICBmb3IobGV0IGtleSBpbiBkYXRhKXtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuYWRkKGtleSwgZGF0YVtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnRpbWUgPSBEYXRlLm5vdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgdHlwZSBvZiB0aGUgR2FtZUV2ZW50XG4gICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBHYW1lRXZlbnQgaXMgdGhlIHNwZWNpZmllZCB0eXBlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNUeXBlKHR5cGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSB0eXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBHYW1lRXZlbnQgYXMgYSBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBHYW1lRXZlbnRcbiAgICAgKi9cbiAgICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlICsgXCI6IEBcIiArIHRoaXMudGltZTtcbiAgICB9XG59IiwiLy8gQGlnbm9yZVBhZ2VcblxuZXhwb3J0IGVudW0gR2FtZUV2ZW50VHlwZSB7XG5cdC8qKlxuXHQgKiBNb3VzZSBEb3duIGV2ZW50LiBIYXMgZGF0YToge3Bvc2l0aW9uOiBWZWMyIC0gTW91c2UgUG9zaXRpb259XG5cdCAqL1xuXHRNT1VTRV9ET1dOID0gXCJtb3VzZV9kb3duXCIsXG5cdC8qKlxuXHQgKiBNb3VzZSBVcCBldmVudC4gSGFzIGRhdGE6IHtwb3NpdGlvbjogVmVjMiAtIE1vdXNlIFBvc2l0aW9ufVxuXHQgKi9cblx0TU9VU0VfVVAgPSBcIm1vdXNlX3VwXCIsXG5cdC8qKlxuXHQgKiBNb3VzZSBNb3ZlIGV2ZW50LiBIYXMgZGF0YToge3Bvc2l0aW9uOiBWZWMyIC0gTW91c2UgUG9zaXRpb259XG5cdCAqL1xuXHRNT1VTRV9NT1ZFID0gXCJtb3VzZV9tb3ZlXCIsXG5cblx0LyoqXG5cdCAqIEtleSBEb3duIGV2ZW50LiBIYXMgZGF0YToge2tleTogc3RyaW5nIC0gVGhlIGtleSB0aGF0IGlzIGRvd259XG5cdCAqL1xuXHRLRVlfRE9XTiA9IFwia2V5X2Rvd25cIixcblxuXHQvKipcblx0ICogS2V5IFVwIGV2ZW50LiBIYXMgZGF0YToge2tleTogc3RyaW5nIC0gVGhlIGtleSB0aGF0IGlzIHVwfVxuXHQgKi9cblx0S0VZX1VQID0gXCJrZXlfdXBcIixcblxuXHQvKipcblx0ICogQ2FudmFzIEJsdXIgZXZlbnQuIEhhcyBkYXRhOiB7fVxuXHQgKi9cblx0Q0FOVkFTX0JMVVIgPSBcImNhbnZhc19ibHVyXCIsXG5cblx0LyoqXG5cdCAqIE1vdXNlIHdoZWVsIHVwIGV2ZW50LiBIYXMgZGF0YToge31cblx0ICovXG5cdFdIRUVMX1VQID0gXCJ3aGVlbF91cFwiLFxuXG5cdC8qKlxuXHQgKiBNb3VzZSB3aGVlbCBkb3duIGV2ZW50LiBIYXMgZGF0YToge31cblx0ICovXG5cdFdIRUVMX0RPV04gPSBcIndoZWVsX2Rvd25cIixcblxuXHQvKipcblx0ICogU3RhcnQgUmVjb3JkaW5nIGV2ZW50LiBIYXMgZGF0YToge31cblx0ICovXG5cdFNUQVJUX1JFQ09SRElORyA9IFwic3RhcnRfcmVjb3JkaW5nXCIsXG5cblx0LyoqXG5cdCAqIFN0b3AgUmVjb3JkaW5nIGV2ZW50LiBIYXMgZGF0YToge31cblx0ICovXG5cdFNUT1BfUkVDT1JESU5HID0gXCJzdG9wX3JlY29yZGluZ1wiLFxuXHRcblx0LyoqXG5cdCAqIFBsYXkgUmVjb3JkaW5nIGV2ZW50LiBIYXMgZGF0YToge31cblx0ICovXG5cdFBMQVlfUkVDT1JESU5HID0gXCJwbGF5X3JlY29yZGluZ1wiLFxuXG5cdC8qKlxuXHQgKiBQbGF5IFNvdW5kIGV2ZW50LiBIYXMgZGF0YToge2tleTogc3RyaW5nLCBsb29wOiBib29sZWFuLCBob2xkUmVmZXJlbmNlOiBib29sZWFuIH1cblx0ICovXG5cdFBMQVlfU09VTkQgPSBcInBsYXlfc291bmRcIixcblxuXHQvKipcblx0ICogUGxheSBTb3VuZCBldmVudC4gSGFzIGRhdGE6IHtrZXk6IHN0cmluZ31cblx0ICovXG5cdFNUT1BfU09VTkQgPSBcInN0b3Bfc291bmRcIixcblxuXHQvKipcblx0ICogUGxheSBTb3VuZCBldmVudC4gSGFzIGRhdGE6IHtrZXk6IHN0cmluZywgbG9vcDogYm9vbGVhbiwgaG9sZFJlZmVyZW5jZTogYm9vbGVhbiwgY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSB9XG5cdCAqL1xuIFx0UExBWV9TRlggPSBcInBsYXlfc2Z4XCIsXG5cbiBcdC8qKlxuXHQgKiBQbGF5IFNvdW5kIGV2ZW50LiBIYXMgZGF0YToge2tleTogc3RyaW5nLCBsb29wOiBib29sZWFuLCBob2xkUmVmZXJlbmNlOiBib29sZWFuIH1cblx0ICovXG4gIFx0UExBWV9NVVNJQyA9IFwicGxheV9tdXNpY1wiLFxuXG5cdC8qKlxuXHQgKiBNdXRlIGF1ZGlvIGNoYW5uZWwgZXZlbnQuIEhhcyBkYXRhOiB7Y2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZX1cblx0ICovXG5cdE1VVEVfQ0hBTk5FTCA9IFwibXV0ZV9jaGFubmVsXCIsXG5cblx0LyoqXG5cdCAqIFVubXV0ZSBhdWRpbyBjaGFubmVsIGV2ZW50LiBIYXMgZGF0YToge2NoYW5uZWw6IEF1ZGlvQ2hhbm5lbFR5cGV9XG5cdCAqL1xuXHRVTk1VVEVfQ0hBTk5FTCA9IFwidW5tdXRlX2NoYW5uZWxcIixcblxuXHQvKipcblx0ICogRW5jb21wYXNzZXMgYWxsIGV2ZW50IHR5cGVzLiBVc2VkIGZvciByZWNlaXZlcnMgb25seS5cblx0ICovXG5cdEFMTCA9IFwiYWxsXCIsXG59IiwiaW1wb3J0IFF1ZXVlIGZyb20gXCIuLi9EYXRhVHlwZXMvUXVldWVcIjtcbmltcG9ydCBFdmVudFF1ZXVlIGZyb20gXCIuL0V2ZW50UXVldWVcIjtcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4vR2FtZUV2ZW50XCI7XG5cbi8qKlxuICogUmVjZWl2ZXMgc3Vic2NyaWJlZCBldmVudHMgZnJvbSB0aGUgRXZlbnRRdWV1ZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVjZWl2ZXIge1xuXHQvKiogVGhlIG1heGltdW0gbnVtYmVyIG9mIGV2ZW50cyB0aGlzIFJlY2VpdmVyIGNhbiBob2xkIGF0IG9uZSB0aW1lICovXG5cdHJlYWRvbmx5IE1BWF9TSVpFOiBudW1iZXI7XG5cblx0LyoqIFRoZSBpbmJveCBvZiB0aGUgUmVjZWl2ZXIgKi9cblx0cHJpdmF0ZSBxOiBRdWV1ZTxHYW1lRXZlbnQ+O1xuXG5cdC8qKiBDcmVhdGVzIGEgbmV3IFJlY2VpdmVyICovXG5cdGNvbnN0cnVjdG9yKCl7XG5cdFx0dGhpcy5NQVhfU0laRSA9IDEwMDtcbiAgICAgICAgdGhpcy5xID0gbmV3IFF1ZXVlKHRoaXMuTUFYX1NJWkUpO1xuXHR9XG5cblx0ZGVzdHJveSgpe1xuXHRcdEV2ZW50UXVldWUuZ2V0SW5zdGFuY2UoKS51bnN1YnNjcmliZSh0aGlzKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEFkZHMgdGhlc2UgdHlwZXMgb2YgZXZlbnRzIHRvIHRoaXMgcmVjZWl2ZXIncyBxdWV1ZSBldmVyeSB1cGRhdGUuXG5cdCAqIEBwYXJhbSBldmVudFR5cGVzIFRoZSB0eXBlcyBvZiBldmVudHMgdGhpcyByZWNlaXZlciB3aWxsIGJlIHN1YnNjcmliZWQgdG9cblx0ICovXG5cdHN1YnNjcmliZShldmVudFR5cGVzOiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+KTogdm9pZCB7XG5cdFx0RXZlbnRRdWV1ZS5nZXRJbnN0YW5jZSgpLnN1YnNjcmliZSh0aGlzLCBldmVudFR5cGVzKTtcblx0XHR0aGlzLnEuY2xlYXIoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGFuIGV2ZW50IHRvIHRoZSBxdWV1ZSBvZiB0aGlzIHJlY2lldmVyLiBUaGlzIGlzIHVzZWQgYnkgdGhlIEByZWZlcmVuY2VbRXZlbnRRdWV1ZV0gdG8gZGlzdHJpYnV0ZSBldmVudHNcblx0ICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCB0byByZWNlaXZlXG5cdCAqL1xuXHRyZWNlaXZlKGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkIHtcblx0XHR0cnl7XG5cdFx0dGhpcy5xLmVucXVldWUoZXZlbnQpO1xuXHRcdH0gY2F0Y2goZSl7XG5cdFx0XHRjb25zb2xlLndhcm4oXCJSZWNlaXZlciBvdmVyZmxvdyBmb3IgZXZlbnQgXCIgKyBldmVudC50b1N0cmluZygpKTtcblx0XHRcdHRocm93IGU7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHJpZXZlcyB0aGUgbmV4dCBldmVudCBmcm9tIHRoZSByZWNlaXZlcidzIHF1ZXVlXG5cdCAqIEByZXR1cm5zIFRoZSBuZXh0IEdhbWVFdmVudFxuXHQgKi9cblx0Z2V0TmV4dEV2ZW50KCk6IEdhbWVFdmVudCB7XG5cdFx0cmV0dXJuIHRoaXMucS5kZXF1ZXVlKCk7XG5cdH1cblxuXHQvKipcblx0ICogTG9va3MgYXQgdGhlIG5leHQgZXZlbnQgaW4gdGhlIHJlY2VpdmVyJ3MgcXVldWUsIGJ1dCBkb2Vzbid0IHJlbW92ZSBpdCBmcm9tIHRoZSBxdWV1ZVxuXHQgKiBAcmV0dXJucyBUaGUgbmV4dCBHYW1lRXZlbnRcblx0ICovXG5cdHBlZWtOZXh0RXZlbnQoKTogR2FtZUV2ZW50IHtcblx0XHRyZXR1cm4gdGhpcy5xLnBlZWtOZXh0KClcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJlY2VpdmVyIGhhcyBhbnkgZXZlbnRzIGluIGl0cyBxdWV1ZVxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSByZWNlaXZlciBoYXMgYW5vdGhlciBldmVudCwgZmFsc2Ugb3RoZXJ3aXNlXG5cdCAqL1xuXHRoYXNOZXh0RXZlbnQoKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMucS5oYXNJdGVtcygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIElnbm9yZSBhbGwgZXZlbnRzIHRoaXMgZnJhbWVcblx0ICovXG5cdGlnbm9yZUV2ZW50cygpOiB2b2lkIHtcblx0XHR0aGlzLnEuY2xlYXIoKTtcblx0fVxufSIsImltcG9ydCBSZWNlaXZlciBmcm9tIFwiLi4vRXZlbnRzL1JlY2VpdmVyXCI7XG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBFdmVudFF1ZXVlIGZyb20gXCIuLi9FdmVudHMvRXZlbnRRdWV1ZVwiO1xuaW1wb3J0IFZpZXdwb3J0IGZyb20gXCIuLi9TY2VuZUdyYXBoL1ZpZXdwb3J0XCI7XG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi9FdmVudHMvR2FtZUV2ZW50XCI7XG5pbXBvcnQgeyBHYW1lRXZlbnRUeXBlIH0gZnJvbSBcIi4uL0V2ZW50cy9HYW1lRXZlbnRUeXBlXCI7XG5cbi8qKlxuICogUmVjZWl2ZXMgaW5wdXQgZXZlbnRzIGZyb20gdGhlIEByZWZlcmVuY2VbRXZlbnRRdWV1ZV0gYW5kIGFsbG93cyBmb3IgZWFzeSBhY2Nlc3Mgb2YgaW5mb3JtYXRpb24gYWJvdXQgaW5wdXQgYnkgb3RoZXIgc3lzdGVtc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnB1dCB7XG5cdHByaXZhdGUgc3RhdGljIG1vdXNlUHJlc3NlZDogYm9vbGVhbjtcblx0cHJpdmF0ZSBzdGF0aWMgbW91c2VKdXN0UHJlc3NlZDogYm9vbGVhbjtcblx0cHJpdmF0ZSBzdGF0aWMgbW91c2VCdXR0b25QcmVzc2VkOiBudW1iZXI7XG5cblx0cHJpdmF0ZSBzdGF0aWMga2V5SnVzdFByZXNzZWQ6IE1hcDxib29sZWFuPjtcblx0cHJpdmF0ZSBzdGF0aWMga2V5UHJlc3NlZDogTWFwPGJvb2xlYW4+O1xuXG5cdHByaXZhdGUgc3RhdGljIG1vdXNlUG9zaXRpb246IFZlYzI7XG5cdHByaXZhdGUgc3RhdGljIG1vdXNlUHJlc3NQb3NpdGlvbjogVmVjMjtcblxuXHRwcml2YXRlIHN0YXRpYyBzY3JvbGxEaXJlY3Rpb246IG51bWJlcjtcblx0cHJpdmF0ZSBzdGF0aWMganVzdFNjcm9sbGVkOiBib29sZWFuO1xuXG5cdHByaXZhdGUgc3RhdGljIGV2ZW50UXVldWU6IEV2ZW50UXVldWU7XG5cdHByaXZhdGUgc3RhdGljIHJlY2VpdmVyOiBSZWNlaXZlcjtcblx0cHJpdmF0ZSBzdGF0aWMgdmlld3BvcnQ6IFZpZXdwb3J0O1xuXG5cdHByaXZhdGUgc3RhdGljIGtleU1hcDogTWFwPEFycmF5PHN0cmluZz4+O1xuXG5cdHByaXZhdGUgc3RhdGljIGtleXNEaXNhYmxlZDogYm9vbGVhbjtcblx0cHJpdmF0ZSBzdGF0aWMgbW91c2VEaXNhYmxlZDogYm9vbGVhbjtcblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZXMgdGhlIElucHV0IG9iamVjdFxuXHQgKiBAcGFyYW0gdmlld3BvcnQgQSByZWZlcmVuY2UgdG8gdGhlIHZpZXdwb3J0IG9mIHRoZSBnYW1lXG5cdCAqL1xuXHRzdGF0aWMgaW5pdGlhbGl6ZSh2aWV3cG9ydDogVmlld3BvcnQsIGtleU1hcDogQXJyYXk8UmVjb3JkPHN0cmluZywgYW55Pj4pIHtcblx0XHRJbnB1dC52aWV3cG9ydCA9IHZpZXdwb3J0O1xuXHRcdElucHV0Lm1vdXNlUHJlc3NlZCA9IGZhbHNlO1xuXHRcdElucHV0Lm1vdXNlSnVzdFByZXNzZWQgPSBmYWxzZTtcblx0XHRJbnB1dC5yZWNlaXZlciA9IG5ldyBSZWNlaXZlcigpO1xuXHRcdElucHV0LmtleUp1c3RQcmVzc2VkID0gbmV3IE1hcDxib29sZWFuPigpO1xuXHRcdElucHV0LmtleVByZXNzZWQgPSBuZXcgTWFwPGJvb2xlYW4+KCk7XG5cdFx0SW5wdXQubW91c2VQb3NpdGlvbiA9IG5ldyBWZWMyKDAsIDApO1xuXHRcdElucHV0Lm1vdXNlUHJlc3NQb3NpdGlvbiA9IG5ldyBWZWMyKDAsIDApO1xuXHRcdElucHV0LnNjcm9sbERpcmVjdGlvbiA9IDA7XG5cdFx0SW5wdXQuanVzdFNjcm9sbGVkID0gZmFsc2U7XG5cdFx0SW5wdXQua2V5c0Rpc2FibGVkID0gZmFsc2U7XG5cdFx0SW5wdXQubW91c2VEaXNhYmxlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUga2V5bWFwXG5cdFx0SW5wdXQua2V5TWFwID0gbmV3IE1hcCgpO1xuXG5cdFx0Ly8gQWRkIGFsbCBrZXlzIHRvIHRoZSBrZXltYXBcblx0XHRmb3IgKGxldCBlbnRyeSBpbiBrZXlNYXApIHtcblx0XHRcdGxldCBuYW1lID0ga2V5TWFwW2VudHJ5XS5uYW1lO1xuXHRcdFx0bGV0IGtleXMgPSBrZXlNYXBbZW50cnldLmtleXM7XG5cdFx0XHRJbnB1dC5rZXlNYXAuYWRkKG5hbWUsIGtleXMpO1xuXHRcdH1cblxuXHRcdElucHV0LmV2ZW50UXVldWUgPSBFdmVudFF1ZXVlLmdldEluc3RhbmNlKCk7XG5cdFx0Ly8gU3Vic2NyaWJlIHRvIGFsbCBpbnB1dCBldmVudHNcblx0XHRJbnB1dC5ldmVudFF1ZXVlLnN1YnNjcmliZShJbnB1dC5yZWNlaXZlciwgW0dhbWVFdmVudFR5cGUuTU9VU0VfRE9XTiwgR2FtZUV2ZW50VHlwZS5NT1VTRV9VUCwgR2FtZUV2ZW50VHlwZS5NT1VTRV9NT1ZFLFxuXHRcdEdhbWVFdmVudFR5cGUuS0VZX0RPV04sIEdhbWVFdmVudFR5cGUuS0VZX1VQLCBHYW1lRXZlbnRUeXBlLkNBTlZBU19CTFVSLCBHYW1lRXZlbnRUeXBlLldIRUVMX1VQLCBHYW1lRXZlbnRUeXBlLldIRUVMX0RPV05dKTtcblx0fVxuXG5cdHN0YXRpYyB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcblx0XHQvLyBSZXNldCB0aGUganVzdFByZXNzZWQgdmFsdWVzIHRvIGZhbHNlXG5cdFx0SW5wdXQubW91c2VKdXN0UHJlc3NlZCA9IGZhbHNlO1xuXHRcdElucHV0LmtleUp1c3RQcmVzc2VkLmZvckVhY2goKGtleTogc3RyaW5nKSA9PiBJbnB1dC5rZXlKdXN0UHJlc3NlZC5zZXQoa2V5LCBmYWxzZSkpO1xuXHRcdElucHV0Lmp1c3RTY3JvbGxlZCA9IGZhbHNlO1xuXHRcdElucHV0LnNjcm9sbERpcmVjdGlvbiA9IDA7XG5cblx0XHR3aGlsZSAoSW5wdXQucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpIHtcblx0XHRcdGxldCBldmVudCA9IElucHV0LnJlY2VpdmVyLmdldE5leHRFdmVudCgpO1xuXG5cdFx0XHQvLyBIYW5kbGUgZWFjaCBldmVudCB0eXBlXG5cdFx0XHRpZiAoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5NT1VTRV9ET1dOKSB7XG5cdFx0XHRcdElucHV0Lm1vdXNlSnVzdFByZXNzZWQgPSB0cnVlO1xuXHRcdFx0XHRJbnB1dC5tb3VzZVByZXNzZWQgPSB0cnVlO1xuXHRcdFx0XHRJbnB1dC5tb3VzZVByZXNzUG9zaXRpb24gPSBldmVudC5kYXRhLmdldChcInBvc2l0aW9uXCIpO1xuXHRcdFx0XHRJbnB1dC5tb3VzZUJ1dHRvblByZXNzZWQgPSBldmVudC5kYXRhLmdldChcImJ1dHRvblwiKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuTU9VU0VfVVApIHtcblx0XHRcdFx0SW5wdXQubW91c2VQcmVzc2VkID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLk1PVVNFX01PVkUpIHtcblx0XHRcdFx0SW5wdXQubW91c2VQb3NpdGlvbiA9IGV2ZW50LmRhdGEuZ2V0KFwicG9zaXRpb25cIik7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLktFWV9ET1dOKSB7XG5cdFx0XHRcdGxldCBrZXkgPSBldmVudC5kYXRhLmdldChcImtleVwiKTtcblx0XHRcdFx0Ly8gSGFuZGxlIHNwYWNlIGJhclxuXHRcdFx0XHRpZiAoa2V5ID09PSBcIiBcIikge1xuXHRcdFx0XHRcdGtleSA9IFwic3BhY2VcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIUlucHV0LmtleVByZXNzZWQuZ2V0KGtleSkpIHtcblx0XHRcdFx0XHRJbnB1dC5rZXlKdXN0UHJlc3NlZC5zZXQoa2V5LCB0cnVlKTtcblx0XHRcdFx0XHRJbnB1dC5rZXlQcmVzc2VkLnNldChrZXksIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLktFWV9VUCkge1xuXHRcdFx0XHRsZXQga2V5ID0gZXZlbnQuZGF0YS5nZXQoXCJrZXlcIik7XG5cdFx0XHRcdC8vIEhhbmRsZSBzcGFjZSBiYXJcblx0XHRcdFx0aWYgKGtleSA9PT0gXCIgXCIpIHtcblx0XHRcdFx0XHRrZXkgPSBcInNwYWNlXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0SW5wdXQua2V5UHJlc3NlZC5zZXQoa2V5LCBmYWxzZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLkNBTlZBU19CTFVSKSB7XG5cdFx0XHRcdElucHV0LmNsZWFyS2V5UHJlc3NlcygpXG5cdFx0XHR9XG5cblx0XHRcdGlmIChldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLldIRUVMX1VQKSB7XG5cdFx0XHRcdElucHV0LnNjcm9sbERpcmVjdGlvbiA9IC0xO1xuXHRcdFx0XHRJbnB1dC5qdXN0U2Nyb2xsZWQgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIGlmIChldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLldIRUVMX0RPV04pIHtcblx0XHRcdFx0SW5wdXQuc2Nyb2xsRGlyZWN0aW9uID0gMTtcblx0XHRcdFx0SW5wdXQuanVzdFNjcm9sbGVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIHN0YXRpYyBjbGVhcktleVByZXNzZXMoKTogdm9pZCB7XG5cdFx0SW5wdXQua2V5SnVzdFByZXNzZWQuZm9yRWFjaCgoa2V5OiBzdHJpbmcpID0+IElucHV0LmtleUp1c3RQcmVzc2VkLnNldChrZXksIGZhbHNlKSk7XG5cdFx0SW5wdXQua2V5UHJlc3NlZC5mb3JFYWNoKChrZXk6IHN0cmluZykgPT4gSW5wdXQua2V5UHJlc3NlZC5zZXQoa2V5LCBmYWxzZSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgd2hldGhlciBvciBub3QgYSBrZXkgd2FzIG5ld2x5IHByZXNzZWQgSW5wdXQgZnJhbWUuXG5cdCAqIElmIHRoZSBrZXkgaXMgc3RpbGwgcHJlc3NlZCBmcm9tIGxhc3QgZnJhbWUgYW5kIHdhc24ndCByZS1wcmVzc2VkLCBJbnB1dCB3aWxsIHJldHVybiBmYWxzZS5cblx0ICogQHBhcmFtIGtleSBUaGUga2V5XG5cdCAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGtleSB3YXMganVzdCBwcmVzc2VkLCBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdHN0YXRpYyBpc0tleUp1c3RQcmVzc2VkKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG5cdFx0aWYgKElucHV0LmtleXNEaXNhYmxlZCkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0aWYgKElucHV0LmtleUp1c3RQcmVzc2VkLmhhcyhrZXkpKSB7XG5cdFx0XHRyZXR1cm4gSW5wdXQua2V5SnVzdFByZXNzZWQuZ2V0KGtleSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBvZiB0aGUga2V5cyB0aGF0IGFyZSBuZXdseSBwcmVzc2VkIElucHV0IGZyYW1lLlxuXHQgKiBJZiBhIGtleSBpcyBzdGlsbCBwcmVzc2VkIGZyb20gbGFzdCBmcmFtZSBhbmQgd2Fzbid0IHJlLXByZXNzZWQsIGl0IHdpbGwgbm90IGJlIGluIElucHV0IGxpc3QuXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGFsbCBvZiB0aGUgbmV3bHkgcHJlc3NlZCBrZXlzLlxuXHQgKi9cblx0c3RhdGljIGdldEtleXNKdXN0UHJlc3NlZCgpOiBBcnJheTxzdHJpbmc+IHtcblx0XHRpZiAoSW5wdXQua2V5c0Rpc2FibGVkKSByZXR1cm4gW107XG5cblx0XHRsZXQga2V5cyA9IEFycmF5PHN0cmluZz4oKTtcblx0XHRJbnB1dC5rZXlKdXN0UHJlc3NlZC5mb3JFYWNoKGtleSA9PiB7XG5cdFx0XHRpZiAoSW5wdXQua2V5SnVzdFByZXNzZWQuZ2V0KGtleSkpIHtcblx0XHRcdFx0a2V5cy5wdXNoKGtleSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIGtleXM7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhIGtleSBpcyBiZWluZyBwcmVzc2VkLlxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXlcblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUga2V5IGlzIGN1cnJlbnRseSBwcmVzc2VkLCBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdHN0YXRpYyBpc0tleVByZXNzZWQoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcblx0XHRpZiAoSW5wdXQua2V5c0Rpc2FibGVkKSByZXR1cm4gZmFsc2U7XG5cblx0XHRpZiAoSW5wdXQua2V5UHJlc3NlZC5oYXMoa2V5KSkge1xuXHRcdFx0cmV0dXJuIElucHV0LmtleVByZXNzZWQuZ2V0KGtleSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDaGFuZ2VzIHRoZSBiaW5kaW5nIG9mIGFuIGlucHV0IG5hbWUgdG8ga2V5c1xuXHQgKiBAcGFyYW0gaW5wdXROYW1lIFRoZSBuYW1lIG9mIHRoZSBpbnB1dFxuXHQgKiBAcGFyYW0ga2V5cyBUaGUgY29ycmVzcG9uZGluZyBrZXlzXG5cdCAqL1xuXHRzdGF0aWMgY2hhbmdlS2V5QmluZGluZyhpbnB1dE5hbWU6IHN0cmluZywga2V5czogQXJyYXk8c3RyaW5nPik6IHZvaWQge1xuXHRcdElucHV0LmtleU1hcC5zZXQoaW5wdXROYW1lLCBrZXlzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbGVhcnMgYWxsIGtleSBiaW5kaW5nc1xuXHQgKi9cblx0c3RhdGljIGNsZWFyQWxsS2V5QmluZGluZ3MoKTogdm9pZCB7XG5cdFx0SW5wdXQua2V5TWFwLmNsZWFyKCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhbiBpbnB1dCB3YXMganVzdCBwcmVzc2VkIHRoaXMgZnJhbWVcblx0ICogQHBhcmFtIGlucHV0TmFtZSBUaGUgbmFtZSBvZiB0aGUgaW5wdXRcblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgaW5wdXQgd2FzIGp1c3QgcHJlc3NlZCwgZmFsc2Ugb3RoZXJ3aXNlXG5cdCAqL1xuXHRzdGF0aWMgaXNKdXN0UHJlc3NlZChpbnB1dE5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuXHRcdGlmIChJbnB1dC5rZXlzRGlzYWJsZWQpIHJldHVybiBmYWxzZTtcblxuXHRcdGlmIChJbnB1dC5rZXlNYXAuaGFzKGlucHV0TmFtZSkpIHtcblx0XHRcdGNvbnN0IGtleXMgPSBJbnB1dC5rZXlNYXAuZ2V0KGlucHV0TmFtZSk7XG5cdFx0XHRsZXQganVzdFByZXNzZWQgPSBmYWxzZTtcblxuXHRcdFx0Zm9yIChsZXQga2V5IG9mIGtleXMpIHtcblx0XHRcdFx0anVzdFByZXNzZWQgPSBqdXN0UHJlc3NlZCB8fCBJbnB1dC5pc0tleUp1c3RQcmVzc2VkKGtleSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBqdXN0UHJlc3NlZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFuIGlucHV0IGlzIGN1cnJlbnRseSBwcmVzc2VkXG5cdCAqIEBwYXJhbSBpbnB1dE5hbWUgVGhlIG5hbWUgb2YgdGhlIGlucHV0XG5cdCAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGlucHV0IGlzIHByZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxuXHQgKi9cblx0c3RhdGljIGlzUHJlc3NlZChpbnB1dE5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuXHRcdGlmIChJbnB1dC5rZXlzRGlzYWJsZWQpIHJldHVybiBmYWxzZTtcblxuXHRcdGlmIChJbnB1dC5rZXlNYXAuaGFzKGlucHV0TmFtZSkpIHtcblx0XHRcdGNvbnN0IGtleXMgPSBJbnB1dC5rZXlNYXAuZ2V0KGlucHV0TmFtZSk7XG5cdFx0XHRsZXQgcHJlc3NlZCA9IGZhbHNlO1xuXG5cdFx0XHRmb3IgKGxldCBrZXkgb2Yga2V5cykge1xuXHRcdFx0XHRwcmVzc2VkID0gcHJlc3NlZCB8fCBJbnB1dC5pc0tleVByZXNzZWQoa2V5KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHByZXNzZWQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCAqIFxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtb3VzZSB3YXMgbmV3bHkgcHJlc3NlZCBJbnB1dCBmcmFtZS5cblx0ICogQHBhcmFtIG1vdXNlQnV0dG9uIE9wdGlvbmFsbHkgc3BlY2lmeSB3aGljaCBtb3VzZSBjbGljayB5b3Ugd2FudCB0byBrbm93IHdhcyBwcmVzc2VkLiBcblx0ICogMCBmb3IgbGVmdCBjbGljaywgMSBmb3IgbWlkZGxlIGNsaWNrLCAyIGZvciByaWdodCBjbGljay5cblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgbW91c2Ugd2FzIGp1c3QgcHJlc3NlZCwgZmFsc2Ugb3RoZXJ3aXNlXG5cdCAqL1xuXHRzdGF0aWMgaXNNb3VzZUp1c3RQcmVzc2VkKG1vdXNlQnV0dG9uPzogbnVtYmVyKTogYm9vbGVhbiB7XG5cdFx0aWYgKG1vdXNlQnV0dG9uKSB7XG5cdFx0XHRyZXR1cm4gSW5wdXQubW91c2VKdXN0UHJlc3NlZCAmJiAhSW5wdXQubW91c2VEaXNhYmxlZCAmJiBtb3VzZUJ1dHRvbiA9PSB0aGlzLm1vdXNlQnV0dG9uUHJlc3NlZDtcblx0XHR9XG5cdFx0cmV0dXJuIElucHV0Lm1vdXNlSnVzdFByZXNzZWQgJiYgIUlucHV0Lm1vdXNlRGlzYWJsZWQ7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbW91c2UgaXMgY3VycmVudGx5IHByZXNzZWRcblx0ICogQHBhcmFtIG1vdXNlQnV0dG9uIE9wdGlvbmFsbHkgc3BlY2lmeSB3aGljaCBtb3VzZSBjbGljayB5b3Ugd2FudCB0byBrbm93IHdhcyBwcmVzc2VkLiBcblx0ICogMCBmb3IgbGVmdCBjbGljaywgMSBmb3IgbWlkZGxlIGNsaWNrLCAyIGZvciByaWdodCBjbGljay5cblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgbW91c2UgaXMgY3VycmVudGx5IHByZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxuXHQgKi9cblx0c3RhdGljIGlzTW91c2VQcmVzc2VkKG1vdXNlQnV0dG9uPzogbnVtYmVyKTogYm9vbGVhbiB7XG5cdFx0aWYgKG1vdXNlQnV0dG9uKSB7XG5cdFx0XHRyZXR1cm4gSW5wdXQubW91c2VQcmVzc2VkICYmICFJbnB1dC5tb3VzZURpc2FibGVkICYmIG1vdXNlQnV0dG9uID09IHRoaXMubW91c2VCdXR0b25QcmVzc2VkO1xuXHRcdH1cblx0XHRyZXR1cm4gSW5wdXQubW91c2VQcmVzc2VkICYmICFJbnB1dC5tb3VzZURpc2FibGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgd2hldGhlciB0aGUgdXNlciBzY3JvbGxlZCBvciBub3Rcblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdXNlciBqdXN0IHNjcm9sbGVkIElucHV0IGZyYW1lLCBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdHN0YXRpYyBkaWRKdXN0U2Nyb2xsKCk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiBJbnB1dC5qdXN0U2Nyb2xsZWQgJiYgIUlucHV0Lm1vdXNlRGlzYWJsZWQ7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzY3JvbGxcblx0ICogQHJldHVybnMgLTEgaWYgdGhlIHVzZXIgc2Nyb2xsZWQgdXAsIDEgaWYgdGhleSBzY3JvbGxlZCBkb3duXG5cdCAqL1xuXHRzdGF0aWMgZ2V0U2Nyb2xsRGlyZWN0aW9uKCk6IG51bWJlciB7XG5cdFx0cmV0dXJuIElucHV0LnNjcm9sbERpcmVjdGlvbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcGxheWVyJ3MgbW91c2Vcblx0ICogQHJldHVybnMgVGhlIG1vdXNlIHBvc2l0aW9uIHN0b3JlZCBhcyBhIFZlYzJcblx0ICovXG5cdHN0YXRpYyBnZXRNb3VzZVBvc2l0aW9uKCk6IFZlYzIge1xuXHRcdHJldHVybiBJbnB1dC5tb3VzZVBvc2l0aW9uLnNjYWxlZCgxIC8gdGhpcy52aWV3cG9ydC5nZXRab29tTGV2ZWwoKSk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIHBsYXllcidzIG1vdXNlIGluIHRoZSBnYW1lIHdvcmxkLFxuXHQgKiB0YWtpbmcgaW50byBjb25zaWRlcmF0aW9uIHRoZSBzY3JvbGxpbmcgb2YgdGhlIHZpZXdwb3J0XG5cdCAqIEByZXR1cm5zIFRoZSBtb3VzZSBwb3NpdGlvbiBzdG9yZWQgYXMgYSBWZWMyXG5cdCAqL1xuXHRzdGF0aWMgZ2V0R2xvYmFsTW91c2VQb3NpdGlvbigpOiBWZWMyIHtcblx0XHRyZXR1cm4gSW5wdXQubW91c2VQb3NpdGlvbi5jbG9uZSgpLnNjYWxlKDEgLyB0aGlzLnZpZXdwb3J0LmdldFpvb21MZXZlbCgpKS5hZGQoSW5wdXQudmlld3BvcnQuZ2V0T3JpZ2luKCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBsYXN0IG1vdXNlIHByZXNzXG5cdCAqIEByZXR1cm5zIFRoZSBtb3VzZSBwb3NpdGlvbiBzdG9yZWQgYXMgYSBWZWMyXG5cdCAqL1xuXHRzdGF0aWMgZ2V0TW91c2VQcmVzc1Bvc2l0aW9uKCk6IFZlYzIge1xuXHRcdHJldHVybiBJbnB1dC5tb3VzZVByZXNzUG9zaXRpb247XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIGxhc3QgbW91c2UgcHJlc3MgaW4gdGhlIGdhbWUgd29ybGQsXG5cdCAqIHRha2luZyBpbnRvIGNvbnNpZGVyYXRpb24gdGhlIHNjcm9sbGluZyBvZiB0aGUgdmlld3BvcnRcblx0ICogQHJldHVybnMgVGhlIG1vdXNlIHBvc2l0aW9uIHN0b3JlZCBhcyBhIFZlYzJcblx0ICovXG5cdHN0YXRpYyBnZXRHbG9iYWxNb3VzZVByZXNzUG9zaXRpb24oKTogVmVjMiB7XG5cdFx0cmV0dXJuIElucHV0Lm1vdXNlUHJlc3NQb3NpdGlvbi5jbG9uZSgpLmFkZChJbnB1dC52aWV3cG9ydC5nZXRPcmlnaW4oKSk7XG5cdH1cblxuXHQvKipcblx0ICogRGlzYWJsZXMgYWxsIGtleXByZXNzIGFuZCBtb3VzZSBjbGljayBpbnB1dHNcblx0ICovXG5cdHN0YXRpYyBkaXNhYmxlSW5wdXQoKTogdm9pZCB7XG5cdFx0SW5wdXQua2V5c0Rpc2FibGVkID0gdHJ1ZTtcblx0XHRJbnB1dC5tb3VzZURpc2FibGVkID0gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbmFibGVzIGFsbCBrZXlwcmVzcyBhbmQgbW91c2UgY2xpY2sgaW5wdXRzXG5cdCAqL1xuXHRzdGF0aWMgZW5hYmxlSW5wdXQoKTogdm9pZCB7XG5cdFx0SW5wdXQua2V5c0Rpc2FibGVkID0gZmFsc2U7XG5cdFx0SW5wdXQubW91c2VEaXNhYmxlZCA9IGZhbHNlO1xuXHR9XG59IiwiaW1wb3J0IEV2ZW50UXVldWUgZnJvbSBcIi4uL0V2ZW50cy9FdmVudFF1ZXVlXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uL0V2ZW50cy9HYW1lRXZlbnRcIjtcbmltcG9ydCB7IEdhbWVFdmVudFR5cGUgfSBmcm9tIFwiLi4vRXZlbnRzL0dhbWVFdmVudFR5cGVcIjtcblxuLyoqXG4gKiBIYW5kbGVzIGNvbW11bmljYXRpb24gd2l0aCB0aGUgd2ViIGJyb3dzZXIgdG8gcmVjZWl2ZSBhc3luY2hyb25vdXMgZXZlbnRzIGFuZCBzZW5kIHRoZW0gdG8gdGhlIEByZWZlcmVuY2VbRXZlbnRRdWV1ZV1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5wdXRIYW5kbGVyIHtcblx0cHJpdmF0ZSBldmVudFF1ZXVlOiBFdmVudFF1ZXVlO1xuICAgICBcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElucHV0SGFuZGxlclxuICAgICAqIEBwYXJhbSBjYW52YXMgVGhlIGdhbWUgY2FudmFzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCl7XG5cdFx0dGhpcy5ldmVudFF1ZXVlID0gRXZlbnRRdWV1ZS5nZXRJbnN0YW5jZSgpO1xuXHRcdFxuICAgICAgICBjYW52YXMub25tb3VzZWRvd24gPSAoZXZlbnQpID0+IHRoaXMuaGFuZGxlTW91c2VEb3duKGV2ZW50LCBjYW52YXMpO1xuICAgICAgICBjYW52YXMub25tb3VzZXVwID0gKGV2ZW50KSA9PiB0aGlzLmhhbmRsZU1vdXNlVXAoZXZlbnQsIGNhbnZhcyk7XG4gICAgICAgIGNhbnZhcy5vbmNvbnRleHRtZW51ID0gdGhpcy5oYW5kbGVDb250ZXh0TWVudTtcbiAgICAgICAgY2FudmFzLm9ubW91c2Vtb3ZlID0gKGV2ZW50KSA9PiB0aGlzLmhhbmRsZU1vdXNlTW92ZShldmVudCwgY2FudmFzKTtcbiAgICAgICAgZG9jdW1lbnQub25rZXlkb3duID0gdGhpcy5oYW5kbGVLZXlEb3duO1xuICAgICAgICBkb2N1bWVudC5vbmtleXVwID0gdGhpcy5oYW5kbGVLZXlVcDtcbiAgICAgICAgZG9jdW1lbnQub25ibHVyID0gdGhpcy5oYW5kbGVCbHVyO1xuICAgICAgICBkb2N1bWVudC5vbmNvbnRleHRtZW51ID0gdGhpcy5oYW5kbGVCbHVyO1xuICAgICAgICBkb2N1bWVudC5vbndoZWVsID0gdGhpcy5oYW5kbGVXaGVlbDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhbmRsZU1vdXNlRG93biA9IChldmVudDogTW91c2VFdmVudCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IHZvaWQgPT4ge1xuXHRcdGxldCBwb3MgPSB0aGlzLmdldE1vdXNlUG9zaXRpb24oZXZlbnQsIGNhbnZhcyk7XG4gICAgICAgIGxldCBidXR0b24gPSBldmVudC5idXR0b247XG4gICAgICAgIGxldCBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuTU9VU0VfRE9XTiwge3Bvc2l0aW9uOiBwb3MsIGJ1dHRvbjogYnV0dG9ufSk7XG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChnYW1lRXZlbnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlTW91c2VVcCA9IChldmVudDogTW91c2VFdmVudCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IHZvaWQgPT4ge1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5nZXRNb3VzZVBvc2l0aW9uKGV2ZW50LCBjYW52YXMpO1xuICAgICAgICBsZXQgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLk1PVVNFX1VQLCB7cG9zaXRpb246IHBvc30pO1xuICAgICAgICB0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQoZ2FtZUV2ZW50KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhbmRsZU1vdXNlTW92ZSA9IChldmVudDogTW91c2VFdmVudCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IHZvaWQgPT4ge1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5nZXRNb3VzZVBvc2l0aW9uKGV2ZW50LCBjYW52YXMpO1xuICAgICAgICBsZXQgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLk1PVVNFX01PVkUsIHtwb3NpdGlvbjogcG9zfSk7XG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChnYW1lRXZlbnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlS2V5RG93biA9IChldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQgPT4ge1xuICAgICAgICBsZXQga2V5ID0gdGhpcy5nZXRLZXkoZXZlbnQpO1xuICAgICAgICBsZXQgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLktFWV9ET1dOLCB7a2V5OiBrZXl9KTtcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlLmFkZEV2ZW50KGdhbWVFdmVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVLZXlVcCA9IChldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQgPT4ge1xuICAgICAgICBsZXQga2V5ID0gdGhpcy5nZXRLZXkoZXZlbnQpO1xuICAgICAgICBsZXQgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLktFWV9VUCwge2tleToga2V5fSk7XG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChnYW1lRXZlbnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlQmx1ciA9IChldmVudDogRXZlbnQpOiB2b2lkID0+IHtcbiAgICAgICAgbGV0IGdhbWVFdmVudCA9IG5ldyBHYW1lRXZlbnQoR2FtZUV2ZW50VHlwZS5DQU5WQVNfQkxVUiwge30pO1xuICAgICAgICB0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQoZ2FtZUV2ZW50KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhbmRsZUNvbnRleHRNZW51ID0gKGV2ZW50OiBFdmVudCk6IHZvaWQgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhbmRsZVdoZWVsID0gKGV2ZW50OiBXaGVlbEV2ZW50KTogdm9pZCA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBcbiAgICAgICAgbGV0IGdhbWVFdmVudDogR2FtZUV2ZW50O1xuICAgICAgICBpZihldmVudC5kZWx0YVkgPCAwKXtcbiAgICAgICAgICAgIGdhbWVFdmVudCA9IG5ldyBHYW1lRXZlbnQoR2FtZUV2ZW50VHlwZS5XSEVFTF9VUCwge30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLldIRUVMX0RPV04sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQoZ2FtZUV2ZW50KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEtleShrZXlFdmVudDogS2V5Ym9hcmRFdmVudCl7XG4gICAgICAgIHJldHVybiBrZXlFdmVudC5rZXkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldE1vdXNlUG9zaXRpb24obW91c2VFdmVudDogTW91c2VFdmVudCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IFZlYzIge1xuICAgICAgICBsZXQgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IHggPSBtb3VzZUV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgICAgIGxldCB5ID0gbW91c2VFdmVudC5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgICAgIHJldHVybiBuZXcgVmVjMih4LCB5KTtcbiAgICB9XG59IiwiaW1wb3J0IHt9IGZyb20gXCIuLi8uLi9pbmRleFwiOyAgLy8gVGhpcyBpbXBvcnQgYWxsb3dzIHVzIHRvIG1vZGlmeSB0aGUgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHRvIGFkZCBleHRyYSBmdW5jdGlvbmFsaXR5XG4vLyBAaWdub3JlUGFnZVxuXG4vKipcbiAqIFNldHMgdXAgdGhlIGVudmlyb25tZW50IG9mIHRoZSBnYW1lIGVuZ2luZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbnZpcm9ubWVudEluaXRpYWxpemVyIHtcbiAgICBzdGF0aWMgc2V0dXAoKXtcbiAgICAgICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5yb3VuZGVkUmVjdCA9IGZ1bmN0aW9uKHg6IG51bWJlciwgeTogbnVtYmVyLCB3OiBudW1iZXIsIGg6IG51bWJlciwgcjogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgICAgICAvLyBDbGFtcCB0aGUgcmFkaXVzIGJldHdlZW4gMCBhbmQgdGhlIG1pbiBvZiB0aGUgd2lkdGggb3IgaGVpZ2h0XG4gICAgICAgICAgICBpZihyIDwgMCkgciA9IDA7XG4gICAgICAgICAgICBpZihyID4gTWF0aC5taW4odywgaCkpIHIgPSBNYXRoLm1pbih3LCBoKTtcbiAgICAgICAgXG4gICAgICAgICAgICAvLyBEcmF3IHRoZSByb3VuZGVkIHJlY3RcbiAgICAgICAgICAgIHRoaXMuYmVnaW5QYXRoKCk7XG4gICAgICAgIFxuICAgICAgICAgICAgLy8gVG9wXG4gICAgICAgICAgICB0aGlzLm1vdmVUbyh4ICsgciwgeSk7XG4gICAgICAgICAgICB0aGlzLmxpbmVUbyh4ICsgdyAtIHIsIHkpO1xuICAgICAgICAgICAgdGhpcy5hcmNUbyh4ICsgdywgeSwgeCArIHcsIHkgKyByLCByKTtcbiAgICAgICAgXG4gICAgICAgICAgICAvLyBSaWdodFxuICAgICAgICAgICAgdGhpcy5saW5lVG8oeCArIHcsIHkgKyBoIC0gcik7XG4gICAgICAgICAgICB0aGlzLmFyY1RvKHggKyB3LCB5ICsgaCwgeCArIHcgLSByLCB5ICsgaCwgcik7XG4gICAgICAgIFxuICAgICAgICAgICAgLy8gQm90dG9tXG4gICAgICAgICAgICB0aGlzLmxpbmVUbyh4ICsgciwgeSArIGgpO1xuICAgICAgICAgICAgdGhpcy5hcmNUbyh4LCB5ICsgaCwgeCwgeSArIGggLSByLCByKTtcbiAgICAgICAgXG4gICAgICAgICAgICAvLyBMZWZ0XG4gICAgICAgICAgICB0aGlzLmxpbmVUbyh4LCB5ICsgcik7XG4gICAgICAgICAgICB0aGlzLmFyY1RvKHgsIHksIHggKyByLCB5LCByKVxuICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuc3Ryb2tlUm91bmRlZFJlY3QgPSBmdW5jdGlvbih4LCB5LCB3LCBoLCByKXtcbiAgICAgICAgICAgIHRoaXMucm91bmRlZFJlY3QoeCwgeSwgdywgaCwgcik7XG4gICAgICAgICAgICB0aGlzLnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmZpbGxSb3VuZGVkUmVjdCA9IGZ1bmN0aW9uKHgsIHksIHcsIGgsIHIpe1xuICAgICAgICAgICAgdGhpcy5yb3VuZGVkUmVjdCh4LCB5LCB3LCBoLCByKTtcbiAgICAgICAgICAgIHRoaXMuZmlsbCgpO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCBHYW1lTG9vcCBmcm9tIFwiLi9HYW1lTG9vcFwiO1xuaW1wb3J0IERlYnVnIGZyb20gXCIuLi9EZWJ1Zy9EZWJ1Z1wiO1xuaW1wb3J0IFN0YXRzIGZyb20gXCIuLi9EZWJ1Zy9TdGF0c1wiO1xuXG4vKipcbiAqIEEgZ2FtZSBsb29wIHdpdGggYSBmaXhlZCB1cGRhdGUgdGltZSBhbmQgYSB2YXJpYWJsZSByZW5kZXIgdGltZS5cbiAqIEV2ZXJ5IGZyYW1lLCB0aGUgZ2FtZSB1cGRhdGVzIHVudGlsIGFsbCB0aW1lIHNpbmNlIHRoZSBsYXN0IGZyYW1lIGhhcyBiZWVuIHByb2Nlc3NlZC5cbiAqIElmIHRvbyBtdWNoIHRpbWUgaGFzIHBhc3NlZCwgc3VjaCBhcyBpZiB0aGUgbGFzdCB1cGRhdGUgd2FzIHRvbyBzbG93LCBcbiAqIG9yIGlmIHRoZSBicm93c2VyIHdhcyBwdXQgaW50byB0aGUgYmFja2dyb3VuZCwgdGhlIGxvb3Agd2lsbCBwYW5pYyBhbmQgZGlzY2FyZCB0aW1lLlxuICogQSByZW5kZXIgaGFwcGVucyBhdCB0aGUgZW5kIG9mIGV2ZXJ5IGZyYW1lLiBUaGlzIGhhcHBlbnMgYXMgZmFzdCBhcyBwb3NzaWJsZSB1bmxlc3Mgc3BlY2lmaWVkLlxuICogQSBsb29wIG9mIHRoaXMgdHlwZSBhbGxvd3MgZm9yIGRldGVybWluaXN0aWMgYmVoYXZpb3IgLSBObyBtYXR0ZXIgd2hhdCB0aGUgZnJhbWUgcmF0ZSBpcywgdGhlIHVwZGF0ZSBzaG91bGQgYmVoYXZlIHRoZSBzYW1lLCBcbiAqIGFzIGl0IGlzIG9jY3VyaW5nIGluIGEgZml4ZWQgaW50ZXJ2YWwuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpeGVkVXBkYXRlR2FtZUxvb3AgZXh0ZW5kcyBHYW1lTG9vcCB7XG5cblx0LyoqIFRoZSBtYXggYWxsb3dlZCB1cGRhdGUgZnBzLiovXG4gICAgcHJpdmF0ZSBtYXhVcGRhdGVGUFM6IG51bWJlcjtcbiAgICBcbiAgICAvKiogVGhlIHRpbWVzdGVwIGZvciBlYWNoIHVwZGF0ZS4gVGhpcyBpcyB0aGUgZGVsdGFUIHBhc3NlZCB0byB1cGRhdGUgY2FsbHMuICovXG5cdHByaXZhdGUgdXBkYXRlVGltZXN0ZXA6IG51bWJlcjtcblxuICAgIC8qKiBUaGUgYW1vdW50IG9mIHRpbWUgd2UgYXJlIHlldCB0byBzaW11bGF0ZS4gKi9cbiAgICBwcml2YXRlIGZyYW1lRGVsdGE6IG51bWJlcjtcblxuICAgIC8qKiBUaGUgdGltZSB3aGVuIHRoZSBsYXN0IGZyYW1lIHdhcyBkcmF3bi4gKi9cbiAgICBwcml2YXRlIGxhc3RGcmFtZVRpbWU6IG51bWJlcjtcbiAgICBcbiAgICAvKiogVGhlIG1pbmltdW0gdGltZSB3ZSB3YW50IHRvIHdhaXQgYmV0d2VlbiBnYW1lIGZyYW1lcy4gKi9cbiAgICBwcml2YXRlIG1pbkZyYW1lRGVsYXk6IG51bWJlcjtcblxuXHQvKiogVGhlIGN1cnJlbnQgZnJhbWUgb2YgdGhlIGdhbWUuICovXG5cdHByaXZhdGUgZnJhbWU6IG51bWJlcjtcblxuXHQvKiogVGhlIGFjdHVhbCBmcHMgb2YgdGhlIGdhbWUuICovXG4gICAgcHJpdmF0ZSBmcHM6IG51bWJlcjtcbiAgICBcbiAgICAvKiogVGhlIHRpbWUgYmV0d2VlbiBmcHMgbWVhc3VyZW1lbnQgdXBkYXRlcy4gKi9cbiAgICBwcml2YXRlIGZwc1VwZGF0ZUludGVydmFsOiBudW1iZXI7XG5cbiAgICAvKiogVGhlIHRpbWUgb2YgdGhlIGxhc3QgZnBzIHVwZGF0ZS4gKi9cbiAgICBwcml2YXRlIGxhc3RGcHNVcGRhdGU6IG51bWJlcjtcblxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIGZyYW1lcyBzaW5jZSB0aGUgbGFzdCBmcHMgdXBkYXRlIHdhcyBkb25lLiAqL1xuICAgIHByaXZhdGUgZnJhbWVzU2luY2VMYXN0RnBzVXBkYXRlOiBudW1iZXI7XG5cbiAgICAvKiogVGhlIHN0YXR1cyBvZiB3aGV0aGVyIG9yIG5vdCB0aGUgZ2FtZSBsb29wIGhhcyBzdGFydGVkLiAqL1xuICAgIHByaXZhdGUgc3RhcnRlZDogYm9vbGVhbjtcblxuICAgIC8qKiBUaGUgc3RhdHVzIG9mIHdoZXRoZXIgb3Igbm90IHRoZSBnYW1lIGxvb3AgaXMgcGF1c2VkICovXG4gICAgcHJpdmF0ZSBwYXVzZWQ6IGJvb2xlYW47XG4gICAgXG4gICAgLyoqIFRoZSBzdGF0dXMgb2Ygd2hldGhlciBvciBub3QgdGhlIGdhbWUgbG9vcCBpcyBjdXJyZW50bHkgcnVubmluZy4gKi9cbiAgICBwcml2YXRlIHJ1bm5pbmc6IGJvb2xlYW47XG5cbiAgICAvKiogVGhlIG51bWJlciBvZiB1cGRhdGUgc3RlcHMgdGhpcyBpdGVyYXRpb24gb2YgdGhlIGdhbWUgbG9vcC4gKi9cbiAgICBwcml2YXRlIG51bVVwZGF0ZVN0ZXBzOiBudW1iZXI7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcbiAgICAgICAgdGhpcy5tYXhVcGRhdGVGUFMgPSA2MDtcbiAgICAgICAgdGhpcy51cGRhdGVUaW1lc3RlcCA9IE1hdGguZmxvb3IoMTAwMC90aGlzLm1heFVwZGF0ZUZQUyk7XG4gICAgICAgIHRoaXMuZnJhbWVEZWx0YSA9IDA7XG4gICAgICAgIHRoaXMubGFzdEZyYW1lVGltZSA9IDA7XG4gICAgICAgIHRoaXMubWluRnJhbWVEZWxheSA9IDA7XG4gICAgICAgIHRoaXMuZnJhbWUgPSAwO1xuICAgICAgICB0aGlzLmZwcyA9IHRoaXMubWF4VXBkYXRlRlBTOyAgIC8vIEluaXRpYWxpemUgdGhlIGZwcyB0byB0aGUgbWF4IGFsbG93ZWQgZnBzXG4gICAgICAgIHRoaXMuZnBzVXBkYXRlSW50ZXJ2YWwgPSAxMDAwO1xuICAgICAgICB0aGlzLmxhc3RGcHNVcGRhdGUgPSAwO1xuICAgICAgICB0aGlzLmZyYW1lc1NpbmNlTGFzdEZwc1VwZGF0ZSA9IDA7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5udW1VcGRhdGVTdGVwcyA9IDA7XG5cdH1cblxuXHRnZXRGUFMoKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGZyYW1lIGNvdW50IGFuZCBzdW0gb2YgdGltZSBmb3IgdGhlIGZyYW1lcmF0ZSBvZiB0aGUgZ2FtZVxuICAgICAqIEBwYXJhbSB0aW1lc3RlcCBUaGUgY3VycmVudCB0aW1lIGluIG1zXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHVwZGF0ZUZQUyh0aW1lc3RhbXA6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLmZwcyA9IDAuOSAqIHRoaXMuZnJhbWVzU2luY2VMYXN0RnBzVXBkYXRlICogMTAwMCAvICh0aW1lc3RhbXAgLSB0aGlzLmxhc3RGcHNVcGRhdGUpICsoMSAtIDAuOSkgKiB0aGlzLmZwcztcbiAgICAgICAgdGhpcy5sYXN0RnBzVXBkYXRlID0gdGltZXN0YW1wO1xuICAgICAgICB0aGlzLmZyYW1lc1NpbmNlTGFzdEZwc1VwZGF0ZSA9IDA7XG5cbiAgICAgICAgRGVidWcubG9nKFwiZnBzXCIsIFwiRlBTOiBcIiArIHRoaXMuZnBzLnRvRml4ZWQoMSkpO1xuICAgICAgICBTdGF0cy51cGRhdGVGUFModGhpcy5mcHMpO1xuICAgIH1cblxuXHQgICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgbWF4aW11bSBhbGxvd2VkIHBoeXNpY3MgZnJhbWVyYXRlIG9mIHRoZSBnYW1lXG4gICAgICogQHBhcmFtIGluaXRNYXggVGhlIG1heCBmcmFtZXJhdGVcbiAgICAgKi9cbiAgICBzZXRNYXhVcGRhdGVGUFMoaW5pdE1heDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMubWF4VXBkYXRlRlBTID0gaW5pdE1heDtcbiAgICAgICAgdGhpcy51cGRhdGVUaW1lc3RlcCA9IE1hdGguZmxvb3IoMTAwMC90aGlzLm1heFVwZGF0ZUZQUyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWF4aW11bSByZW5kZXJpbmcgZnJhbWVyYXRlXG4gICAgICogQHBhcmFtIG1heEZQUyBUaGUgbWF4IGZyYW1lcmF0ZVxuICAgICAqL1xuICAgIHNldE1heEZQUyhtYXhGUFM6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLm1pbkZyYW1lRGVsYXkgPSAxMDAwL21heEZQUztcblx0fVxuXHRcblx0LyoqXG5cdCAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gdGhlIGdhbWUgbG9vcCBwYW5pY3MsIGkuZS4gaXQgdHJpZXMgdG8gcHJvY2VzcyB0b28gbXVjaCB0aW1lIGluIGFuIGVudGlyZSBmcmFtZS5cblx0ICogVGhpcyB3aWxsIHJlc2V0IHRoZSBhbW91bnQgb2YgdGltZSBiYWNrIHRvIHplcm8uXG5cdCAqIEByZXR1cm5zIFRoZSBhbW91bnQgb2YgdGltZSB3ZSBhcmUgZGlzY2FyZGluZyBmcm9tIHByb2Nlc3NpbmcuXG5cdCAqL1xuXHRyZXNldEZyYW1lRGVsdGEoKSA6IG51bWJlciB7XG4gICAgICAgIGxldCBvbGRGcmFtZURlbHRhID0gdGhpcy5mcmFtZURlbHRhO1xuICAgICAgICB0aGlzLmZyYW1lRGVsdGEgPSAwO1xuICAgICAgICByZXR1cm4gb2xkRnJhbWVEZWx0YTtcbiAgICB9XG5cblx0LyoqXG4gICAgICogU3RhcnRzIHVwIHRoZSBnYW1lIGxvb3AgYW5kIGNhbGxzIHRoZSBmaXJzdCByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgKi9cblx0c3RhcnQoKTogdm9pZCB7XG4gICAgICAgIGlmKCF0aGlzLnN0YXJ0ZWQpe1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgodGltZXN0YW1wKSA9PiB0aGlzLmRvRmlyc3RGcmFtZSh0aW1lc3RhbXApKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBhdXNlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmVzdW1lKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICAgIH1cblxuXHQvKipcbiAgICAgKiBUaGUgZmlyc3QgZ2FtZSBmcmFtZSAtIGluaXRpYWxpemVzIHRoZSBmaXJzdCBmcmFtZSB0aW1lIGFuZCBiZWdpbnMgdGhlIHJlbmRlclxuICAgICAqIEBwYXJhbSB0aW1lc3RhbXAgVGhlIGN1cnJlbnQgdGltZSBpbiBtc1xuICAgICAqL1xuICAgIHByb3RlY3RlZCBkb0ZpcnN0RnJhbWUodGltZXN0YW1wOiBudW1iZXIpOiB2b2lkICB7XG4gICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fZG9SZW5kZXIoKTtcblxuICAgICAgICB0aGlzLmxhc3RGcmFtZVRpbWUgPSB0aW1lc3RhbXA7XG4gICAgICAgIHRoaXMubGFzdEZwc1VwZGF0ZSA9IHRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5mcmFtZXNTaW5jZUxhc3RGcHNVcGRhdGUgPSAwO1xuXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKHQpID0+IHRoaXMuZG9GcmFtZSh0KSk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIGFueSBwcm9jZXNzaW5nIHRoYXQgbmVlZHMgdG8gYmUgZG9uZSBhdCB0aGUgc3RhcnQgb2YgdGhlIGZyYW1lXG5cdCAqIEBwYXJhbSB0aW1lc3RhbXAgVGhlIHRpbWUgb2YgdGhlIGZyYW1lIGluIG1zXG5cdCAqL1xuXHRwcm90ZWN0ZWQgc3RhcnRGcmFtZSh0aW1lc3RhbXA6IG51bWJlcik6IHZvaWQge1xuXHRcdC8vIFVwZGF0ZSB0aGUgYW1vdW50IG9mIHRpbWUgd2UgbmVlZCBvdXIgdXBkYXRlIHRvIHByb2Nlc3Ncblx0XHR0aGlzLmZyYW1lRGVsdGEgKz0gdGltZXN0YW1wIC0gdGhpcy5sYXN0RnJhbWVUaW1lO1xuXG5cdFx0Ly8gU2V0IHRoZSBuZXcgdGltZSBvZiB0aGUgbGFzdCBmcmFtZVxuICAgICAgICB0aGlzLmxhc3RGcmFtZVRpbWUgPSB0aW1lc3RhbXA7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBlc3RpbWF0ZSBvZiB0aGUgZnJhbWVyYXRlXG4gICAgICAgIGlmKHRpbWVzdGFtcCA+IHRoaXMubGFzdEZwc1VwZGF0ZSArIHRoaXMuZnBzVXBkYXRlSW50ZXJ2YWwpe1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGUFModGltZXN0YW1wKTtcbiAgICAgICAgfVxuXG5cdFx0Ly8gSW5jcmVtZW50IHRoZSBudW1iZXIgb2YgZnJhbWVzXG4gICAgICAgIHRoaXMuZnJhbWUrKztcbiAgICAgICAgdGhpcy5mcmFtZXNTaW5jZUxhc3RGcHNVcGRhdGUrKztcblx0fVxuXG5cdC8qKlxuICAgICAqIFRoZSBtYWluIGxvb3Agb2YgdGhlIGdhbWUuIFVwZGF0ZXMgdW50aWwgdGhlIGN1cnJlbnQgdGltZSBpcyByZWFjaGVkLiBSZW5kZXJzIG9uY2VcbiAgICAgKiBAcGFyYW0gdGltZXN0YW1wIFRoZSBjdXJyZW50IHRpbWUgaW4gbXNcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZG9GcmFtZSA9ICh0aW1lc3RhbXA6IG51bWJlcik6IHZvaWQgPT4ge1xuICAgICAgICAvLyBJZiBhIHBhdXNlIHdhcyBleGVjdXRlZCwgc3RvcCBkb2luZyB0aGUgbG9vcC5cbiAgICAgICAgaWYodGhpcy5wYXVzZWQpeyBcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlcXVlc3QgYW5pbWF0aW9uIGZyYW1lIHRvIHByZXBhcmUgZm9yIGFub3RoZXIgdXBkYXRlIG9yIHJlbmRlclxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCh0KSA9PiB0aGlzLmRvRnJhbWUodCkpO1xuXG4gICAgICAgIC8vIElmIHdlIGFyZSB0cnlpbmcgdG8gcmVuZGVyIHRvbyBzb29uLCBkbyBub3RoaW5nLlxuICAgICAgICBpZih0aW1lc3RhbXAgPCB0aGlzLmxhc3RGcmFtZVRpbWUgKyB0aGlzLm1pbkZyYW1lRGVsYXkpe1xuICAgICAgICAgICAgcmV0dXJuO1xuXHRcdH1cblx0XHRcblx0XHQvLyBBIGZyYW1lIGlzIGFjdHVhbGx5IGhhcHBlbmluZ1xuXHRcdHRoaXMuc3RhcnRGcmFtZSh0aW1lc3RhbXApO1xuXG5cdFx0Ly8gVXBkYXRlIHdoaWxlIHRoZXJlIGlzIHN0aWxsIHRpbWUgdG8gbWFrZSB1cC4gSWYgd2UgZG8gdG9vIG1hbnkgdXBkYXRlIHN0ZXBzLCBwYW5pYyBhbmQgZXhpdCB0aGUgbG9vcC5cblx0XHR0aGlzLm51bVVwZGF0ZVN0ZXBzID0gMDtcblx0XHRsZXQgcGFuaWMgPSBmYWxzZTtcblxuICAgICAgICB3aGlsZSh0aGlzLmZyYW1lRGVsdGEgPj0gdGhpcy51cGRhdGVUaW1lc3RlcCl7XG5cdFx0XHQvLyBEbyBhbiB1cGRhdGVcblx0XHRcdHRoaXMuX2RvVXBkYXRlKHRoaXMudXBkYXRlVGltZXN0ZXAvMTAwMCk7XG5cdFx0XHRcblx0XHRcdC8vIFJlbW92ZSB0aGUgdXBkYXRlIHN0ZXAgdGltZSBmcm9tIHRoZSB0aW1lIHdlIGhhdmUgdG8gcHJvY2Vzc1xuICAgICAgICAgICAgdGhpcy5mcmFtZURlbHRhIC09IHRoaXMudXBkYXRlVGltZXN0ZXA7XG5cblx0XHRcdC8vIEluY3JlbWVudCBzdGVwcyBhbmQgY2hlY2sgaWYgd2UndmUgZG9uZSB0b28gbWFueVxuICAgICAgICAgICAgdGhpcy5udW1VcGRhdGVTdGVwcysrO1xuICAgICAgICAgICAgaWYodGhpcy5udW1VcGRhdGVTdGVwcyA+IDEwMCl7XG4gICAgICAgICAgICAgICAgcGFuaWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlcyBhcmUgZG9uZSwgcmVuZGVyXG4gICAgICAgIHRoaXMuX2RvUmVuZGVyKCk7XG5cbiAgICAgICAgLy8gV3JhcCB1cCB0aGUgZnJhbWVcbiAgICAgICAgdGhpcy5maW5pc2hGcmFtZShwYW5pYyk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBXcmFwcyB1cCB0aGUgZnJhbWUgYW5kIGhhbmRsZXMgdGhlIHBhbmljIHN0YXRlIGlmIHRoZXJlIGlzIG9uZVxuXHQgKiBAcGFyYW0gcGFuaWMgV2hldGhlciBvciBub3QgdGhlIGxvb3AgcGFuaWNrZWRcblx0ICovXG5cdHByb3RlY3RlZCBmaW5pc2hGcmFtZShwYW5pYzogYm9vbGVhbik6IHZvaWQge1xuXHRcdGlmKHBhbmljKSB7XG4gICAgICAgICAgICB2YXIgZGlzY2FyZGVkVGltZSA9IE1hdGgucm91bmQodGhpcy5yZXNldEZyYW1lRGVsdGEoKSk7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ01haW4gbG9vcCBwYW5pY2tlZCwgcHJvYmFibHkgYmVjYXVzZSB0aGUgYnJvd3NlciB0YWIgd2FzIHB1dCBpbiB0aGUgYmFja2dyb3VuZC4gRGlzY2FyZGluZyAnICsgZGlzY2FyZGVkVGltZSArICdtcycpO1xuICAgICAgICB9XG5cdH1cblxufSIsImltcG9ydCBFdmVudFF1ZXVlIGZyb20gXCIuLi9FdmVudHMvRXZlbnRRdWV1ZVwiO1xuaW1wb3J0IElucHV0IGZyb20gXCIuLi9JbnB1dC9JbnB1dFwiO1xuaW1wb3J0IElucHV0SGFuZGxlciBmcm9tIFwiLi4vSW5wdXQvSW5wdXRIYW5kbGVyXCI7XG5pbXBvcnQgUmVjb3JkZXIgZnJvbSBcIi4uL1BsYXliYWNrL1JlY29yZGVyXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgVmlld3BvcnQgZnJvbSBcIi4uL1NjZW5lR3JhcGgvVmlld3BvcnRcIjtcbmltcG9ydCBTY2VuZU1hbmFnZXIgZnJvbSBcIi4uL1NjZW5lL1NjZW5lTWFuYWdlclwiO1xuaW1wb3J0IEF1ZGlvTWFuYWdlciBmcm9tIFwiLi4vU291bmQvQXVkaW9NYW5hZ2VyXCI7XG5pbXBvcnQgU3RhdHMgZnJvbSBcIi4uL0RlYnVnL1N0YXRzXCI7XG5pbXBvcnQgUmVuZGVyaW5nTWFuYWdlciBmcm9tIFwiLi4vUmVuZGVyaW5nL1JlbmRlcmluZ01hbmFnZXJcIjtcbmltcG9ydCBDYW52YXNSZW5kZXJlciBmcm9tIFwiLi4vUmVuZGVyaW5nL0NhbnZhc1JlbmRlcmVyXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XG5pbXBvcnQgR2FtZU9wdGlvbnMgZnJvbSBcIi4vR2FtZU9wdGlvbnNcIjtcbmltcG9ydCBHYW1lTG9vcCBmcm9tIFwiLi9HYW1lTG9vcFwiO1xuaW1wb3J0IEZpeGVkVXBkYXRlR2FtZUxvb3AgZnJvbSBcIi4vRml4ZWRVcGRhdGVHYW1lTG9vcFwiO1xuaW1wb3J0IEVudmlyb25tZW50SW5pdGlhbGl6ZXIgZnJvbSBcIi4vRW52aXJvbm1lbnRJbml0aWFsaXplclwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgUmVnaXN0cnlNYW5hZ2VyIGZyb20gXCIuLi9SZWdpc3RyeS9SZWdpc3RyeU1hbmFnZXJcIjtcbmltcG9ydCBXZWJHTFJlbmRlcmVyIGZyb20gXCIuLi9SZW5kZXJpbmcvV2ViR0xSZW5kZXJlclwiO1xuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZS9TY2VuZVwiO1xuXG4vKipcbiAqIFRoZSBtYWluIGxvb3Agb2YgdGhlIGdhbWUgZW5naW5lLlxuICogSGFuZGxlcyB0aGUgdXBkYXRlIG9yZGVyLCBhbmQgaW5pdGlhbGl6ZXMgYWxsIHN1YnN5c3RlbXMuXG4gKiBUaGUgR2FtZSBtYW5hZ2VzIHRoZSB1cGRhdGUgY3ljbGUsIGFuZCByZXF1ZXN0cyBhbmltYXRpb24gZnJhbWVzIHRvIHJlbmRlciB0byB0aGUgYnJvd3Nlci5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2FtZSB7XG4gICAgZ2FtZU9wdGlvbnM6IEdhbWVPcHRpb25zO1xuICAgIHByaXZhdGUgc2hvd0RlYnVnOiBib29sZWFuO1xuICAgIHByaXZhdGUgc2hvd1N0YXRzOiBib29sZWFuO1xuXG4gICAgLy8gVGhlIGdhbWUgbG9vcFxuICAgIHByaXZhdGUgbG9vcDogR2FtZUxvb3A7XG5cbiAgICAvLyBHYW1lIGNhbnZhcyBhbmQgaXRzIHdpZHRoIGFuZCBoZWlnaHRcbiAgICByZWFkb25seSBHQU1FX0NBTlZBUzogSFRNTENhbnZhc0VsZW1lbnQ7XG4gICAgcmVhZG9ubHkgREVCVUdfQ0FOVkFTOiBIVE1MQ2FudmFzRWxlbWVudDtcblx0cmVhZG9ubHkgV0lEVEg6IG51bWJlcjtcbiAgICByZWFkb25seSBIRUlHSFQ6IG51bWJlcjtcbiAgICBwcml2YXRlIHZpZXdwb3J0OiBWaWV3cG9ydDtcbiAgICBwcml2YXRlIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHwgV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuICAgIHByaXZhdGUgY2xlYXJDb2xvcjogQ29sb3I7XG4gICAgXG4gICAgLy8gQWxsIG9mIHRoZSBuZWNlc3Nhcnkgc3Vic3lzdGVtcyB0aGF0IG5lZWQgdG8gcnVuIGhlcmVcblx0cHJpdmF0ZSBldmVudFF1ZXVlOiBFdmVudFF1ZXVlO1xuXHRwcml2YXRlIGlucHV0SGFuZGxlcjogSW5wdXRIYW5kbGVyO1xuXHRwcml2YXRlIHJlY29yZGVyOiBSZWNvcmRlcjtcbiAgICBwcml2YXRlIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xuICAgIHByaXZhdGUgc2NlbmVNYW5hZ2VyOiBTY2VuZU1hbmFnZXI7XG4gICAgcHJpdmF0ZSBhdWRpb01hbmFnZXI6IEF1ZGlvTWFuYWdlcjtcbiAgICBwcml2YXRlIHJlbmRlcmluZ01hbmFnZXI6IFJlbmRlcmluZ01hbmFnZXI7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEdhbWVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgR2FtZSBpbml0aWFsaXphdGlvblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KXtcbiAgICAgICAgLy8gQmVmb3JlIGFueXRoaW5nIGVsc2UsIGJ1aWxkIHRoZSBlbnZpcm9ubWVudFxuICAgICAgICBFbnZpcm9ubWVudEluaXRpYWxpemVyLnNldHVwKCk7XG5cbiAgICAgICAgLy8gVHlwZWNhc3QgdGhlIGNvbmZpZyBvYmplY3QgdG8gYSBHYW1lQ29uZmlnIG9iamVjdFxuICAgICAgICB0aGlzLmdhbWVPcHRpb25zID0gR2FtZU9wdGlvbnMucGFyc2Uob3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5zaG93RGVidWcgPSB0aGlzLmdhbWVPcHRpb25zLnNob3dEZWJ1ZztcbiAgICAgICAgdGhpcy5zaG93U3RhdHMgPSB0aGlzLmdhbWVPcHRpb25zLnNob3dTdGF0cztcblxuICAgICAgICAvLyBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYSBnYW1lIGxvb3BcbiAgICAgICAgdGhpcy5sb29wID0gbmV3IEZpeGVkVXBkYXRlR2FtZUxvb3AoKTtcblxuICAgICAgICAvLyBHZXQgdGhlIGdhbWUgY2FudmFzIGFuZCBnaXZlIGl0IGEgYmFja2dyb3VuZCBjb2xvclxuICAgICAgICB0aGlzLkdBTUVfQ0FOVkFTID0gPEhUTUxDYW52YXNFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZ2FtZS1jYW52YXNcIik7XG4gICAgICAgIHRoaXMuREVCVUdfQ0FOVkFTID0gPEhUTUxDYW52YXNFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGVidWctY2FudmFzXCIpO1xuICAgIFxuICAgICAgICAvLyBHaXZlIHRoZSBjYW52YXMgYSBzaXplIGFuZCBnZXQgdGhlIHJlbmRlcmluZyBjb250ZXh0XG4gICAgICAgIHRoaXMuV0lEVEggPSB0aGlzLmdhbWVPcHRpb25zLmNhbnZhc1NpemUueDtcbiAgICAgICAgdGhpcy5IRUlHSFQgPSB0aGlzLmdhbWVPcHRpb25zLmNhbnZhc1NpemUueTtcblxuICAgICAgICAvLyBUaGlzIHN0ZXAgTVVTVCBoYXBwZW4gYmVmb3JlIHRoZSByZXNvdXJjZSBtYW5hZ2VyIGRvZXMgYW55dGhpbmdcbiAgICAgICAgaWYodGhpcy5nYW1lT3B0aW9ucy51c2VXZWJHTCl7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmluZ01hbmFnZXIgPSBuZXcgV2ViR0xSZW5kZXJlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJpbmdNYW5hZ2VyID0gbmV3IENhbnZhc1JlbmRlcmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0aWFsaXplR2FtZVdpbmRvdygpO1xuICAgICAgICB0aGlzLmN0eCA9IHRoaXMucmVuZGVyaW5nTWFuYWdlci5pbml0aWFsaXplQ2FudmFzKHRoaXMuR0FNRV9DQU5WQVMsIHRoaXMuV0lEVEgsIHRoaXMuSEVJR0hUKTtcbiAgICAgICAgdGhpcy5jbGVhckNvbG9yID0gbmV3IENvbG9yKHRoaXMuZ2FtZU9wdGlvbnMuY2xlYXJDb2xvci5yLCB0aGlzLmdhbWVPcHRpb25zLmNsZWFyQ29sb3IuZywgdGhpcy5nYW1lT3B0aW9ucy5jbGVhckNvbG9yLmIpO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgZGVidWdnaW5nIGFuZCBzdGF0c1xuICAgICAgICBEZWJ1Zy5pbml0aWFsaXplRGVidWdDYW52YXModGhpcy5ERUJVR19DQU5WQVMsIHRoaXMuV0lEVEgsIHRoaXMuSEVJR0hUKTtcbiAgICAgICAgU3RhdHMuaW5pdFN0YXRzKCk7XG5cbiAgICAgICAgaWYodGhpcy5nYW1lT3B0aW9ucy5zaG93U3RhdHMpIHtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHN0YXRzIG91dHB1dCBhbmQgbWFrZSBpdCBubyBsb25nZXIgaGlkZGVuXG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN0YXRzXCIpLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2l6ZSB0aGUgdmlld3BvcnQgdG8gdGhlIGdhbWUgY2FudmFzXG4gICAgICAgIGNvbnN0IGNhbnZhc1NpemUgPSBuZXcgVmVjMih0aGlzLldJRFRILCB0aGlzLkhFSUdIVCk7XG4gICAgICAgIHRoaXMudmlld3BvcnQgPSBuZXcgVmlld3BvcnQoY2FudmFzU2l6ZSwgdGhpcy5nYW1lT3B0aW9ucy56b29tTGV2ZWwpO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgYWxsIG5lY2Vzc2FyeSBnYW1lIHN1YnN5c3RlbXNcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlID0gRXZlbnRRdWV1ZS5nZXRJbnN0YW5jZSgpO1xuICAgICAgICB0aGlzLmlucHV0SGFuZGxlciA9IG5ldyBJbnB1dEhhbmRsZXIodGhpcy5HQU1FX0NBTlZBUyk7XG4gICAgICAgIElucHV0LmluaXRpYWxpemUodGhpcy52aWV3cG9ydCwgdGhpcy5nYW1lT3B0aW9ucy5pbnB1dHMpO1xuICAgICAgICB0aGlzLnJlY29yZGVyID0gbmV3IFJlY29yZGVyKCk7XG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyID0gbmV3IFNjZW5lTWFuYWdlcih0aGlzLnZpZXdwb3J0LCB0aGlzLnJlbmRlcmluZ01hbmFnZXIpO1xuICAgICAgICB0aGlzLmF1ZGlvTWFuYWdlciA9IEF1ZGlvTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB1cCB0aGUgZ2FtZSB3aW5kb3cgdGhhdCBob2xkcyB0aGUgY2FudmFzZXNcbiAgICAgKi9cbiAgICBwcml2YXRlIGluaXRpYWxpemVHYW1lV2luZG93KCk6IHZvaWQge1xuICAgICAgICBjb25zdCBnYW1lV2luZG93ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJnYW1lLXdpbmRvd1wiKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNldCB0aGUgaGVpZ2h0IG9mIHRoZSBnYW1lIHdpbmRvd1xuICAgICAgICBnYW1lV2luZG93LnN0eWxlLndpZHRoID0gdGhpcy5XSURUSCArIFwicHhcIjtcbiAgICAgICAgZ2FtZVdpbmRvdy5zdHlsZS5oZWlnaHQgPSB0aGlzLkhFSUdIVCArIFwicHhcIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyZWl2ZXMgdGhlIFNjZW5lTWFuYWdlciBmcm9tIHRoZSBHYW1lXG4gICAgICogQHJldHVybnMgVGhlIFNjZW5lTWFuYWdlclxuICAgICAqL1xuICAgIGdldFNjZW5lTWFuYWdlcigpOiBTY2VuZU1hbmFnZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2VuZU1hbmFnZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSBnYW1lXG4gICAgICovXG4gICAgc3RhcnQoSW5pdGlhbFNjZW5lOiBuZXcgKC4uLmFyZ3M6IGFueSkgPT4gU2NlbmUsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcbiAgICAgICAgLy8gU2V0IHRoZSB1cGRhdGUgZnVuY3Rpb24gb2YgdGhlIGxvb3BcbiAgICAgICAgdGhpcy5sb29wLmRvVXBkYXRlID0gKGRlbHRhVDogbnVtYmVyKSA9PiB0aGlzLnVwZGF0ZShkZWx0YVQpO1xuXG4gICAgICAgIC8vIFNldCB0aGUgcmVuZGVyIGZ1bmN0aW9uIG9mIHRoZSBsb29wXG4gICAgICAgIHRoaXMubG9vcC5kb1JlbmRlciA9ICgpID0+IHRoaXMucmVuZGVyKCk7XG5cbiAgICAgICAgLy8gUHJlbG9hZCByZWdpc3RyeSBpdGVtc1xuICAgICAgICBSZWdpc3RyeU1hbmFnZXIucHJlbG9hZCgpO1xuXG4gICAgICAgIC8vIExvYWQgdGhlIGl0ZW1zIHdpdGggdGhlIHJlc291cmNlIG1hbmFnZXJcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIubG9hZFJlc291cmNlc0Zyb21RdWV1ZSgoKSA9PiB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlJ3JlIGRvbmUgbG9hZGluZywgc3RhcnQgdGhlIGxvb3BcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRmluaXNoZWQgUHJlbG9hZCAtIGxvYWRpbmcgZmlyc3Qgc2NlbmVcIik7XG4gICAgICAgICAgICB0aGlzLnNjZW5lTWFuYWdlci5jaGFuZ2VUb1NjZW5lKEluaXRpYWxTY2VuZSwge30sIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5sb29wLnN0YXJ0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYWxsIG5lY2Vzc2FyeSBzdWJzeXN0ZW1zIG9mIHRoZSBnYW1lLiBEZWZlcnMgc2NlbmUgdXBkYXRlcyB0byB0aGUgc2NlbmVNYW5hZ2VyXG4gICAgICogQHBhcmFtIGRlbHRhVCBUaGUgdGltZSBzaW5lIHRoZSBsYXN0IHVwZGF0ZVxuICAgICAqL1xuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0cnl7XG4gICAgICAgICAgICAvLyBIYW5kbGUgYWxsIGV2ZW50cyB0aGF0IGhhcHBlbmVkIHNpbmNlIHRoZSBzdGFydCBvZiB0aGUgbGFzdCBsb29wXG4gICAgICAgICAgICB0aGlzLmV2ZW50UXVldWUudXBkYXRlKGRlbHRhVCk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaW5wdXQgZGF0YSBzdHJ1Y3R1cmVzIHNvIGdhbWUgb2JqZWN0cyBjYW4gc2VlIHRoZSBpbnB1dFxuICAgICAgICAgICAgSW5wdXQudXBkYXRlKGRlbHRhVCk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVjb3JkaW5nIG9mIHRoZSBnYW1lXG4gICAgICAgICAgICB0aGlzLnJlY29yZGVyLnVwZGF0ZShkZWx0YVQpO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgYWxsIHNjZW5lc1xuICAgICAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIudXBkYXRlKGRlbHRhVCk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBhbGwgc291bmRzXG4gICAgICAgICAgICB0aGlzLmF1ZGlvTWFuYWdlci51cGRhdGUoZGVsdGFUKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTG9hZCBvciB1bmxvYWQgYW55IHJlc291cmNlcyBpZiBuZWVkZWRcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyLnVwZGF0ZShkZWx0YVQpO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgdGhpcy5sb29wLnBhdXNlKCk7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmNhdWdodCBFcnJvciBpbiBVcGRhdGUgLSBDcmFzaGluZyBncmFjZWZ1bGx5XCIpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgY2FudmFzIGFuZCBkZWZlcnMgc2NlbmUgcmVuZGVyaW5nIHRvIHRoZSBzY2VuZU1hbmFnZXIuIFJlbmRlcnMgdGhlIGRlYnVnIGNhbnZhc1xuICAgICAqL1xuICAgIHJlbmRlcigpOiB2b2lkIHtcbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIGNhbnZhc2VzXG4gICAgICAgICAgICBEZWJ1Zy5jbGVhckNhbnZhcygpO1xuXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmluZ01hbmFnZXIuY2xlYXIodGhpcy5jbGVhckNvbG9yKTtcblxuICAgICAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIucmVuZGVyKCk7XG5cbiAgICAgICAgICAgIC8vIEhhY2t5IGRlYnVnIG1vZGVcbiAgICAgICAgICAgIGlmKElucHV0LmlzS2V5SnVzdFByZXNzZWQoXCJnXCIpKXtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dEZWJ1ZyA9ICF0aGlzLnNob3dEZWJ1ZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGVidWcgcmVuZGVyXG4gICAgICAgICAgICBpZih0aGlzLnNob3dEZWJ1Zyl7XG4gICAgICAgICAgICAgICAgRGVidWcucmVuZGVyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHRoaXMuc2hvd1N0YXRzKXtcbiAgICAgICAgICAgICAgICBTdGF0cy5yZW5kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIHRoaXMubG9vcC5wYXVzZSgpO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5jYXVnaHQgRXJyb3IgaW4gUmVuZGVyIC0gQ3Jhc2hpbmcgZ3JhY2VmdWxseVwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IE51bGxGdW5jIGZyb20gXCIuLi9EYXRhVHlwZXMvRnVuY3Rpb25zL051bGxGdW5jXCI7XG5cbi8qKlxuICogVGhlIG1haW4gZ2FtZSBsb29wIG9mIHRoZSBnYW1lLiBLZWVwcyB0cmFjayBvZiBmcHMgYW5kIGhhbmRsZXMgc2NoZWR1bGluZyBvZiB1cGRhdGVzIGFuZCByZW5kZXJpbmcuXG4gKiBUaGlzIGNsYXNzIGlzIGxlZnQgYWJzdHJhY3QsIHNvIHRoYXQgYSBzdWJjbGFzcyBjYW4gaGFuZGxlIGV4YWN0bHkgaG93IHRoZSBsb29wIGlzIHNjaGVkdWxlZC5cbiAqIEZvciBhbiBleGFtcGxlIG9mIGRpZmZlcmVudCB0eXBlcyBvZiBnYW1lIGxvb3Agc2NoZWR1bGluZywgY2hlY2sgb3V0IEBsaW5rKEdhbWUgUHJvZ3JhbW1pbmcgUGF0dGVybnMpKGh0dHBzOi8vZ2FtZXByb2dyYW1taW5ncGF0dGVybnMuY29tL2dhbWUtbG9vcC5odG1sKVxuICovXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBHYW1lTG9vcCB7XG5cblx0LyoqIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gYW4gdXBkYXRlIG9jY3VycyAqL1xuXHRwcm90ZWN0ZWQgX2RvVXBkYXRlOiBGdW5jdGlvbiA9IE51bGxGdW5jO1xuXG5cdHNldCBkb1VwZGF0ZSh1cGRhdGU6IEZ1bmN0aW9uKXtcblx0XHR0aGlzLl9kb1VwZGF0ZSA9IHVwZGF0ZTtcblx0fVxuXG5cdC8qKiBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGEgcmVuZGVyIG9jY3VycyAqL1xuXHRwcm90ZWN0ZWQgX2RvUmVuZGVyOiBGdW5jdGlvbiA9IE51bGxGdW5jO1xuXG5cblx0c2V0IGRvUmVuZGVyKHJlbmRlcjogRnVuY3Rpb24pe1xuXHRcdHRoaXMuX2RvUmVuZGVyID0gcmVuZGVyO1xuXHR9XG5cdFxuXHQvKipcblx0ICogUmV0cmlldmVzIHRoZSBjdXJyZW50IEZQUyBvZiB0aGUgZ2FtZVxuXHQgKi9cblx0YWJzdHJhY3QgZ2V0RlBTKCk6IG51bWJlcjtcblxuXHQvKipcbiAgICAgKiBTdGFydHMgdXAgdGhlIGdhbWUgbG9vcFxuICAgICAqL1xuXHRhYnN0cmFjdCBzdGFydCgpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBQYXVzZXMgdGhlIGdhbWUgbG9vcCwgdXN1YWxseSBmb3IgYW4gZXJyb3IgY29uZGl0aW9uLlxuXHQgKi9cblx0YWJzdHJhY3QgcGF1c2UoKTogdm9pZDtcblxuXHQvKipcblx0ICogUmVzdW1lcyB0aGUgZ2FtZSBsb29wLlxuXHQgKi9cblx0YWJzdHJhY3QgcmVzdW1lKCk6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIFJ1bnMgdGhlIGZpcnN0IGZyYW1lIG9mIHRoZSBnYW1lLiBObyB1cGRhdGUgb2NjdXJzIGhlcmUsIG9ubHkgYSByZW5kZXIuXG5cdCAqIFRoaXMgaXMgbmVlZGVkIHRvIGluaXRpYWxpemUgZGVsdGEgdGltZSB2YWx1ZXNcblx0ICogQHBhcmFtIHRpbWVzdGFtcCBUaGUgdGltZXN0YW1wIG9mIHRoZSBmcmFtZS4gVGhpcyBpcyByZWNlaXZlZCBmcm9tIHRoZSBicm93c2VyXG5cdCAqL1xuXHRwcm90ZWN0ZWQgYWJzdHJhY3QgZG9GaXJzdEZyYW1lKHRpbWVzdGFtcDogbnVtYmVyKTogdm9pZDtcblxuXHQvKipcblx0ICogUnVuIGJlZm9yZSBhbnkgdXBkYXRlcyBvciB0aGUgcmVuZGVyIG9mIGEgZnJhbWUuXG5cdCAqIEBwYXJhbSB0aW1lc3RhbXAgVGhlIHRpbWVzdGFtcCBvZiB0aGUgZnJhbWUuIFRoaXMgaXMgcmVjZWl2ZWQgZnJvbSB0aGUgYnJvd3NlclxuXHQgKi9cblx0cHJvdGVjdGVkIGFic3RyYWN0IHN0YXJ0RnJhbWUodGltZXN0YW1wOiBudW1iZXIpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBUaGUgY29yZSBvZiB0aGUgZnJhbWUsIHdoZXJlIGFueSBuZWNlc3NhcnkgdXBkYXRlcyBvY2N1ciwgYW5kIHdoZXJlIGEgcmVuZGVyIGhhcHBlbnNcblx0ICogQHBhcmFtIHRpbWVzdGFtcCBUaGUgdGltZXN0YW1wIG9mIHRoZSBmcmFtZS4gVGhpcyBpcyByZWNlaXZlZCBmcm9tIHRoZSBicm93c2VyXG5cdCAqL1xuXHRwcm90ZWN0ZWQgYWJzdHJhY3QgZG9GcmFtZSh0aW1lc3RhbXA6IG51bWJlcik6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIFdyYXBzIHVwIHRoZSBmcmFtZVxuXHQgKiBAcGFyYW0gcGFuaWMgV2hldGhlciBvciBub3QgdGhlIHVwZGF0ZSBjeWNsZSBwYW5pY2tlZC4gVGhpcyBoYXBwZW5zIHdoZW4gdG9vIG1hbnkgdXBkYXRlcyB0cnkgdG8gaGFwcGVuIGluIGEgc2luZ2xlIGZyYW1lXG5cdCAqL1xuXHRwcm90ZWN0ZWQgYWJzdHJhY3QgZmluaXNoRnJhbWUocGFuaWM6IGJvb2xlYW4pOiB2b2lkO1xufSIsIi8vIEBpZ25vcmVQYWdlXG5cbi8qKiBUaGUgb3B0aW9ucyBmb3IgaW5pdGlhbGl6aW5nIHRoZSBAcmVmZXJlbmNlW0dhbWVMb29wXSAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2FtZU9wdGlvbnMge1xuICAgIC8qKiBUaGUgc2l6ZSBvZiB0aGUgdmlld3BvcnQgKi9cbiAgICBjYW52YXNTaXplOiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9O1xuXG4gICAgLyogVGhlIGRlZmF1bHQgbGV2ZWwgb2Ygem9vbSAqL1xuICAgIHpvb21MZXZlbDogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBjb2xvciB0byBjbGVhciB0aGUgY2FudmFzIHRvIGVhY2ggZnJhbWUgKi9cbiAgICBjbGVhckNvbG9yOiB7cjogbnVtYmVyLCBnOiBudW1iZXIsIGI6IG51bWJlcn1cblxuICAgIC8qIEEgbGlzdCBvZiBpbnB1dCBiaW5kaW5ncyAqL1xuICAgIGlucHV0czogQXJyYXk8e25hbWU6IHN0cmluZywga2V5czogQXJyYXk8c3RyaW5nPn0+O1xuXG4gICAgLyogV2hldGhlciBvciBub3QgdGhlIGRlYnVnIHJlbmRlcmluZyBzaG91bGQgb2NjdXIgKi9cbiAgICBzaG93RGVidWc6IGJvb2xlYW47XG5cbiAgICAvKiBXaGV0aGVyIG9yIG5vdCB0aGUgc3RhdHMgcmVuZGVyaW5nIHNob3VsZCBvY2N1ciAqL1xuICAgIHNob3dTdGF0czogYm9vbGVhbjtcblxuICAgIC8qIFdoZXRoZXIgb3Igbm90IHRvIHVzZSB3ZWJHTCAqL1xuICAgIHVzZVdlYkdMOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBkYXRhIGluIHRoZSByYXcgb3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgZ2FtZSBvcHRpb25zIGFzIGEgUmVjb3JkXG4gICAgICogQHJldHVybnMgQSB2ZXJzaW9uIG9mIHRoZSBvcHRpb25zIGNvbnZlcnRlZCB0byBhIEdhbWVPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZShvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogR2FtZU9wdGlvbnMge1xuICAgICAgICBsZXQgZ09wdCA9IG5ldyBHYW1lT3B0aW9ucygpO1xuXG4gICAgICAgIGdPcHQuY2FudmFzU2l6ZSA9IG9wdGlvbnMuY2FudmFzU2l6ZSA/IG9wdGlvbnMuY2FudmFzU2l6ZSA6IHt4OiA4MDAsIHk6IDYwMH07XG4gICAgICAgIGdPcHQuem9vbUxldmVsID0gb3B0aW9ucy56b29tTGV2ZWwgPyBvcHRpb25zLnpvb21MZXZlbCA6IDE7XG4gICAgICAgIGdPcHQuY2xlYXJDb2xvciA9IG9wdGlvbnMuY2xlYXJDb2xvciA/IG9wdGlvbnMuY2xlYXJDb2xvciA6IHtyOiAyNTUsIGc6IDI1NSwgYjogMjU1fTtcbiAgICAgICAgZ09wdC5pbnB1dHMgPSBvcHRpb25zLmlucHV0cyA/IG9wdGlvbnMuaW5wdXRzIDogW107XG4gICAgICAgIGdPcHQuc2hvd0RlYnVnID0gISFvcHRpb25zLnNob3dEZWJ1ZztcbiAgICAgICAgZ09wdC5zaG93U3RhdHMgPSAhIW9wdGlvbnMuc2hvd1N0YXRzO1xuICAgICAgICBnT3B0LnVzZVdlYkdMID0gISFvcHRpb25zLnVzZVdlYkdMO1xuXG4gICAgICAgIHJldHVybiBnT3B0O1xuICAgIH1cbn0iLCJpbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4vR2FtZU5vZGVcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IFJlZ2lvbiBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvUmVnaW9uXCI7XG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XG5cbi8qKlxuICogVGhlIHJlcHJlc2VudGF0aW9uIG9mIGFuIG9iamVjdCBpbiB0aGUgZ2FtZSB3b3JsZCB0aGF0IGNhbiBiZSBkcmF3biB0byB0aGUgc2NyZWVuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIENhbnZhc05vZGUgZXh0ZW5kcyBHYW1lTm9kZSBpbXBsZW1lbnRzIFJlZ2lvbiB7XG5cdHByaXZhdGUgX3NpemU6IFZlYzI7XG5cdHByaXZhdGUgX3NjYWxlOiBWZWMyO1xuXHRwcml2YXRlIF9ib3VuZGFyeTogQUFCQjtcblx0cHJpdmF0ZSBfaGFzQ3VzdG9tU2hhZGVyOiBib29sZWFuO1xuXHRwcml2YXRlIF9jdXN0b21TaGFkZXJLZXk6IHN0cmluZztcblx0cHJpdmF0ZSBfYWxwaGE6IG51bWJlcjtcblxuXHQvKiogQSBmbGFnIGZvciB3aGV0aGVyIG9yIG5vdCB0aGUgQ2FudmFzTm9kZSBpcyB2aXNpYmxlICovXG5cdHZpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xuXHRcblx0Y29uc3RydWN0b3IoKXtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuX3NpemUgPSBuZXcgVmVjMigwLCAwKTtcblx0XHR0aGlzLl9zaXplLnNldE9uQ2hhbmdlKCgpID0+IHRoaXMuc2l6ZUNoYW5nZWQoKSk7XG5cdFx0dGhpcy5fc2NhbGUgPSBuZXcgVmVjMigxLCAxKTtcblx0XHR0aGlzLl9zY2FsZS5zZXRPbkNoYW5nZSgoKSA9PiB0aGlzLnNjYWxlQ2hhbmdlZCgpKTtcblx0XHR0aGlzLl9ib3VuZGFyeSA9IG5ldyBBQUJCKCk7XG5cdFx0dGhpcy51cGRhdGVCb3VuZGFyeSgpO1xuXG5cdFx0dGhpcy5faGFzQ3VzdG9tU2hhZGVyID0gZmFsc2U7XG5cdH1cblxuXHRnZXQgYWxwaGEoKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5fYWxwaGE7XG5cdH1cblxuXHRzZXQgYWxwaGEoYTogbnVtYmVyKSB7XG5cdFx0dGhpcy5fYWxwaGEgPSBhO1xuXHR9XG5cblx0Z2V0IHNpemUoKTogVmVjMiB7XG5cdFx0cmV0dXJuIHRoaXMuX3NpemU7XG5cdH1cblxuXHRzZXQgc2l6ZShzaXplOiBWZWMyKXtcblx0XHR0aGlzLl9zaXplID0gc2l6ZTtcblx0XHQvLyBFbnRlciBhcyBhIGxhbWJkYSB0byBiaW5kIFwidGhpc1wiXG5cdFx0dGhpcy5fc2l6ZS5zZXRPbkNoYW5nZSgoKSA9PiB0aGlzLnNpemVDaGFuZ2VkKCkpO1xuXHRcdHRoaXMuc2l6ZUNoYW5nZWQoKTtcblx0fVxuXG5cdGdldCBzY2FsZSgpOiBWZWMyIHtcblx0XHRyZXR1cm4gdGhpcy5fc2NhbGU7XG5cdH1cblxuXHRzZXQgc2NhbGUoc2NhbGU6IFZlYzIpe1xuXHRcdHRoaXMuX3NjYWxlID0gc2NhbGU7XG5cdFx0Ly8gRW50ZXIgYXMgYSBsYW1iZGEgdG8gYmluZCBcInRoaXNcIlxuXHRcdHRoaXMuX3NjYWxlLnNldE9uQ2hhbmdlKCgpID0+IHRoaXMuc2NhbGVDaGFuZ2VkKCkpO1xuXHRcdHRoaXMuc2NhbGVDaGFuZ2VkKCk7XG5cdH1cblxuXHRzZXQgc2NhbGVYKHZhbHVlOiBudW1iZXIpIHtcblx0XHR0aGlzLnNjYWxlLnggPSB2YWx1ZTtcblx0fVxuXG5cdHNldCBzY2FsZVkodmFsdWU6IG51bWJlcikge1xuXHRcdHRoaXMuc2NhbGUueSA9IHZhbHVlO1xuXHR9XG5cblx0Z2V0IGhhc0N1c3RvbVNoYWRlcigpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5faGFzQ3VzdG9tU2hhZGVyO1xuXHR9XG5cblx0Z2V0IGN1c3RvbVNoYWRlcktleSgpOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLl9jdXN0b21TaGFkZXJLZXk7XG5cdH1cblxuXHQvLyBAb3ZlcnJpZGVcblx0cHJvdGVjdGVkIHBvc2l0aW9uQ2hhbmdlZCgpOiB2b2lkIHtcblx0XHRzdXBlci5wb3NpdGlvbkNoYW5nZWQoKTtcblx0XHR0aGlzLnVwZGF0ZUJvdW5kYXJ5KCk7XG5cdH1cblxuXHQvKiogQ2FsbGVkIGlmIHRoZSBzaXplIHZlY3RvciBpcyBjaGFuZ2VkIG9yIHJlcGxhY2VkLiAqL1xuXHRwcm90ZWN0ZWQgc2l6ZUNoYW5nZWQoKTogdm9pZCB7XG5cdFx0dGhpcy51cGRhdGVCb3VuZGFyeSgpO1xuXHR9XG5cblx0LyoqIENhbGxlZCBpZiB0aGUgc2NhbGUgdmVjdG9yIGlzIGNoYW5nZWQgb3IgcmVwbGFjZWQgKi9cblx0cHJvdGVjdGVkIHNjYWxlQ2hhbmdlZCgpOiB2b2lkIHtcblx0XHR0aGlzLnVwZGF0ZUJvdW5kYXJ5KCk7XG5cdH1cblxuXHQvLyBAZG9jSWdub3JlXG5cdC8qKiBDYWxsZWQgaWYgdGhlIHBvc2l0aW9uLCBzaXplLCBvciBzY2FsZSBvZiB0aGUgQ2FudmFzTm9kZSBpcyBjaGFuZ2VkLiBVcGRhdGVzIHRoZSBib3VuZGFyeS4gKi9cblx0cHJpdmF0ZSB1cGRhdGVCb3VuZGFyeSgpOiB2b2lkIHtcblx0XHR0aGlzLl9ib3VuZGFyeS5jZW50ZXIuc2V0KHRoaXMucG9zaXRpb24ueCwgdGhpcy5wb3NpdGlvbi55KTtcblx0XHR0aGlzLl9ib3VuZGFyeS5oYWxmU2l6ZS5zZXQodGhpcy5zaXplLngqdGhpcy5zY2FsZS54LzIsIHRoaXMuc2l6ZS55KnRoaXMuc2NhbGUueS8yKTtcblx0fVxuXG5cdGdldCBib3VuZGFyeSgpOiBBQUJCIHtcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRhcnk7XG5cdH1cblxuXHRnZXQgc2l6ZVdpdGhab29tKCk6IFZlYzIge1xuXHRcdGxldCB6b29tID0gdGhpcy5zY2VuZS5nZXRWaWV3U2NhbGUoKTtcblxuXHRcdHJldHVybiB0aGlzLmJvdW5kYXJ5LmhhbGZTaXplLmNsb25lKCkuc2NhbGVkKHpvb20sIHpvb20pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBjdXN0b20gc2hhZGVyIHRvIHRoaXMgQ2FudmFzTm9kZVxuXHQgKiBAcGFyYW0ga2V5IFRoZSByZWdpc3RyeSBrZXkgb2YgdGhlIFNoYWRlclR5cGVcblx0ICovXG5cdHVzZUN1c3RvbVNoYWRlcihrZXk6IHN0cmluZyk6IHZvaWQge1xuXHRcdHRoaXMuX2hhc0N1c3RvbVNoYWRlciA9IHRydWU7XG5cdFx0dGhpcy5fY3VzdG9tU2hhZGVyS2V5ID0ga2V5O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcG9pbnQgKHgsIHkpIGlzIGluc2lkZSBvZiB0aGlzIGNhbnZhcyBvYmplY3Rcblx0ICogQHBhcmFtIHggVGhlIHggcG9zaXRpb24gb2YgdGhlIHBvaW50XG5cdCAqIEBwYXJhbSB5IFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBwb2ludFxuXHQgKiBAcmV0dXJucyBBIGZsYWcgcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoaXMgbm9kZSBjb250YWlucyB0aGUgcG9pbnQuXG5cdCAqL1xuXHRjb250YWlucyh4OiBudW1iZXIsIHk6IG51bWJlcik6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLl9ib3VuZGFyeS5jb250YWluc1BvaW50KG5ldyBWZWMyKHgsIHkpKTtcblx0fVxuXG5cdC8vIEBpbXBsZW1lbnRlZFxuXHRkZWJ1Z1JlbmRlcigpOiB2b2lkIHtcblx0XHREZWJ1Zy5kcmF3Qm94KHRoaXMucmVsYXRpdmVQb3NpdGlvbiwgdGhpcy5zaXplV2l0aFpvb20sIGZhbHNlLCBDb2xvci5CTFVFKTtcblx0XHRzdXBlci5kZWJ1Z1JlbmRlcigpO1xuXHR9XG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4uL0V2ZW50cy9SZWNlaXZlclwiO1xuaW1wb3J0IEVtaXR0ZXIgZnJvbSBcIi4uL0V2ZW50cy9FbWl0dGVyXCI7XG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lL1NjZW5lXCI7XG5pbXBvcnQgTGF5ZXIgZnJvbSBcIi4uL1NjZW5lL0xheWVyXCI7XG5pbXBvcnQgQUkgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL0FJXCI7XG5pbXBvcnQgUGh5c2ljYWwgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1BoeXNpY2FsXCI7XG5pbXBvcnQgUG9zaXRpb25lZCBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvUG9zaXRpb25lZFwiO1xuaW1wb3J0IHsgaXNSZWdpb24gfSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvUmVnaW9uXCI7XG5pbXBvcnQgVW5pcXVlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VbmlxdWVcIjtcbmltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VcGRhdGVhYmxlXCI7XG5pbXBvcnQgRGVidWdSZW5kZXJhYmxlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9EZWJ1Z1JlbmRlcmFibGVcIjtcbmltcG9ydCBBY3RvciBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvQWN0b3JcIjtcbmltcG9ydCBTaGFwZSBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9TaGFwZVwiO1xuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xuaW1wb3J0IE5hdmlnYXRpb25QYXRoIGZyb20gXCIuLi9QYXRoZmluZGluZy9OYXZpZ2F0aW9uUGF0aFwiO1xuaW1wb3J0IFR3ZWVuQ29udHJvbGxlciBmcm9tIFwiLi4vUmVuZGVyaW5nL0FuaW1hdGlvbnMvVHdlZW5Db250cm9sbGVyXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XG5pbXBvcnQgQ2lyY2xlIGZyb20gXCIuLi9EYXRhVHlwZXMvU2hhcGVzL0NpcmNsZVwiO1xuaW1wb3J0IEdvYXBBSSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvR29hcEFJXCI7XG5cbi8qKlxuICogVGhlIHJlcHJlc2VudGF0aW9uIG9mIGFuIG9iamVjdCBpbiB0aGUgZ2FtZSB3b3JsZC5cbiAqIFRvIGNvbnN0cnVjdCBHYW1lTm9kZXMsIHNlZSB0aGUgQHJlZmVyZW5jZVtTY2VuZV0gZG9jdW1lbnRhdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgR2FtZU5vZGUgaW1wbGVtZW50cyBQb3NpdGlvbmVkLCBVbmlxdWUsIFVwZGF0ZWFibGUsIFBoeXNpY2FsLCBBY3RvciwgRGVidWdSZW5kZXJhYmxlIHtcblx0LyotLS0tLS0tLS0tIFBPU0lUSU9ORUQgLS0tLS0tLS0tLSovXG5cdHByaXZhdGUgX3Bvc2l0aW9uOiBWZWMyO1xuXG5cdC8qLS0tLS0tLS0tLSBVTklRVUUgLS0tLS0tLS0tLSovXG5cdHByaXZhdGUgX2lkOiBudW1iZXI7XG5cblx0LyotLS0tLS0tLS0tIFBIWVNJQ0FMIC0tLS0tLS0tLS0qL1xuXHRoYXNQaHlzaWNzOiBib29sZWFuID0gZmFsc2U7XG5cdG1vdmluZzogYm9vbGVhbiA9IGZhbHNlO1xuXHRmcm96ZW46IGJvb2xlYW4gPSBmYWxzZTtcblx0b25Hcm91bmQ6IGJvb2xlYW4gPSBmYWxzZTtcblx0b25XYWxsOiBib29sZWFuID0gZmFsc2U7XG5cdG9uQ2VpbGluZzogYm9vbGVhbiA9IGZhbHNlO1xuXHRhY3RpdmU6IGJvb2xlYW4gPSBmYWxzZTtcblx0Y29sbGlzaW9uU2hhcGU6IFNoYXBlO1xuXHRjb2xsaWRlck9mZnNldDogVmVjMjtcblx0aXNTdGF0aWM6IGJvb2xlYW47XG5cdGlzQ29sbGlkYWJsZTogYm9vbGVhbjtcblx0aXNUcmlnZ2VyOiBib29sZWFuO1xuXHR0cmlnZ2VyTWFzazogbnVtYmVyO1xuXHR0cmlnZ2VyRW50ZXJzOiBBcnJheTxzdHJpbmc+O1xuXHR0cmlnZ2VyRXhpdHM6IEFycmF5PHN0cmluZz47XG5cdF92ZWxvY2l0eTogVmVjMjtcblx0c3dlcHRSZWN0OiBBQUJCO1xuXHRjb2xsaWRlZFdpdGhUaWxlbWFwOiBib29sZWFuO1xuXHRncm91cDogbnVtYmVyO1xuXHRpc1BsYXllcjogYm9vbGVhbjtcblx0aXNDb2xsaWRpbmc6IGJvb2xlYW4gPSBmYWxzZTtcblxuXHQvKi0tLS0tLS0tLS0gQUNUT1IgLS0tLS0tLS0tLSovXG5cdF9haTogQUkgfCBHb2FwQUk7XG5cdGFpQWN0aXZlOiBib29sZWFuO1xuXHRwYXRoOiBOYXZpZ2F0aW9uUGF0aDtcblx0cGF0aGZpbmRpbmc6IGJvb2xlYW4gPSBmYWxzZTtcblxuXHQvKi0tLS0tLS0tLS0gR0VORVJBTCAtLS0tLS0tLS0tKi9cblx0LyoqIEFuIGV2ZW50IHJlY2VpdmVyLiAqL1xuXHRwcm90ZWN0ZWQgcmVjZWl2ZXI6IFJlY2VpdmVyO1xuXHQvKiogQW4gZXZlbnQgZW1pdHRlci4gKi9cblx0cHJvdGVjdGVkIGVtaXR0ZXI6IEVtaXR0ZXI7XG5cdC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgc2NlbmUgdGhpcyBHYW1lTm9kZSBpcyBhIHBhcnQgb2YuICovXG5cdHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XG5cdC8qKiBUaGUgdmlzdWFsIGxheWVyIHRoaXMgR2FtZU5vZGUgcmVzaWRlcyBpbi4gKi9cblx0cHJvdGVjdGVkIGxheWVyOiBMYXllcjtcblx0LyoqIEEgdXRpbGl0eSB0aGF0IGFsbG93cyB0aGUgdXNlIG9mIHR3ZWVucyBvbiB0aGlzIEdhbWVOb2RlICovXG5cdHR3ZWVuczogVHdlZW5Db250cm9sbGVyO1xuXHQvKiogQSB0d2VlbmFibGUgcHJvcGVydHkgZm9yIHJvdGF0aW9uLiBEb2VzIG5vdCBhZmZlY3QgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGlzIEdhbWVOb2RlIC0gT25seSByZW5kZXJpbmcuICovXG5cdHJvdGF0aW9uOiBudW1iZXI7XG5cdC8qKiBUaGUgb3BhY2l0eSB2YWx1ZSBvZiB0aGlzIEdhbWVOb2RlICovXG5cdGFic3RyYWN0IHNldCBhbHBoYShhOiBudW1iZXIpO1xuXG5cdGFic3RyYWN0IGdldCBhbHBoYSgpOiBudW1iZXI7XG5cblx0Ly8gQ29uc3RydWN0b3IgZG9jcyBhcmUgaWdub3JlZCwgYXMgdGhlIHVzZXIgc2hvdWxkIE5PVCBjcmVhdGUgbmV3IEdhbWVOb2RlcyB3aXRoIGEgcmF3IGNvbnN0cnVjdG9yXG5cdGNvbnN0cnVjdG9yKCl7XG5cdFx0dGhpcy5fcG9zaXRpb24gPSBuZXcgVmVjMigwLCAwKTtcblx0XHR0aGlzLl9wb3NpdGlvbi5zZXRPbkNoYW5nZSgoKSA9PiB0aGlzLnBvc2l0aW9uQ2hhbmdlZCgpKTtcblx0XHR0aGlzLnJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKCk7XG5cdFx0dGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcblx0XHR0aGlzLnR3ZWVucyA9IG5ldyBUd2VlbkNvbnRyb2xsZXIodGhpcyk7XG5cdFx0dGhpcy5yb3RhdGlvbiA9IDA7XG5cdH1cblxuXHRkZXN0cm95KCl7XG5cdFx0dGhpcy50d2VlbnMuZGVzdHJveSgpO1xuXHRcdHRoaXMucmVjZWl2ZXIuZGVzdHJveSgpO1xuXG5cdFx0aWYodGhpcy5oYXNQaHlzaWNzKXtcblx0XHRcdHRoaXMucmVtb3ZlUGh5c2ljcygpO1xuXHRcdH1cblxuXHRcdGlmKHRoaXMuX2FpKXtcblx0XHRcdHRoaXMuX2FpLmRlc3Ryb3koKTtcblx0XHRcdGRlbGV0ZSB0aGlzLl9haTtcblx0XHRcdHRoaXMuc2NlbmUuZ2V0QUlNYW5hZ2VyKCkucmVtb3ZlQWN0b3IodGhpcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zY2VuZS5yZW1vdmUodGhpcyk7XG5cblx0XHR0aGlzLmxheWVyLnJlbW92ZU5vZGUodGhpcyk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0gUE9TSVRJT05FRCAtLS0tLS0tLS0tKi9cblx0Z2V0IHBvc2l0aW9uKCk6IFZlYzIge1xuXHRcdHJldHVybiB0aGlzLl9wb3NpdGlvbjtcblx0fVxuXG5cdHNldCBwb3NpdGlvbihwb3M6IFZlYzIpIHtcblx0XHR0aGlzLl9wb3NpdGlvbiA9IHBvcztcblx0XHR0aGlzLl9wb3NpdGlvbi5zZXRPbkNoYW5nZSgoKSA9PiB0aGlzLnBvc2l0aW9uQ2hhbmdlZCgpKTtcblx0XHR0aGlzLnBvc2l0aW9uQ2hhbmdlZCgpO1xuXHR9XG5cblx0Z2V0IHJlbGF0aXZlUG9zaXRpb24oKTogVmVjMiB7XG5cdFx0cmV0dXJuIHRoaXMuaW5SZWxhdGl2ZUNvb3JkaW5hdGVzKHRoaXMucG9zaXRpb24pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgcG9pbnQgdG8gY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gdGhlIHpvb20gYW5kIG9yaWdpbiBvZiB0aGlzIG5vZGVcblx0ICogQHBhcmFtIHBvaW50IFRoZSBwb2ludCB0byBjb252ZXJcblx0ICogQHJldHVybnMgQSBuZXcgVmVjMiByZXByZXNlbnRpbmcgdGhlIHBvaW50IGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG5cdCAqL1xuXHRpblJlbGF0aXZlQ29vcmRpbmF0ZXMocG9pbnQ6IFZlYzIpOiBWZWMyIHtcblx0XHRsZXQgb3JpZ2luID0gdGhpcy5zY2VuZS5nZXRWaWV3VHJhbnNsYXRpb24odGhpcyk7XG5cdFx0bGV0IHpvb20gPSB0aGlzLnNjZW5lLmdldFZpZXdTY2FsZSgpO1xuXHRcdHJldHVybiBwb2ludC5jbG9uZSgpLnN1YihvcmlnaW4pLnNjYWxlKHpvb20pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tIFVOSVFVRSAtLS0tLS0tLS0tKi9cblx0Z2V0IGlkKCk6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMuX2lkO1xuXHR9XG5cblx0c2V0IGlkKGlkOiBudW1iZXIpIHtcblx0XHQvLyBpZCBjYW4gb25seSBiZSBzZXQgb25jZVxuXHRcdGlmKHRoaXMuX2lkID09PSB1bmRlZmluZWQpe1xuXHRcdFx0dGhpcy5faWQgPSBpZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgXCJBdHRlbXB0ZWQgdG8gYXNzaWduIGlkIHRvIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIGlkLlwiXG5cdFx0fVxuXHR9XG5cblx0LyotLS0tLS0tLS0tIFBIWVNJQ0FMIC0tLS0tLS0tLS0qL1xuXHQvLyBAaW1wbGVtZW50ZWRcblx0LyoqXG4gICAgICogQHBhcmFtIHZlbG9jaXR5IFRoZSB2ZWxvY2l0eSB3aXRoIHdoaWNoIHRvIG1vdmUgdGhlIG9iamVjdC5cbiAgICAgKi9cblx0bW92ZSh2ZWxvY2l0eTogVmVjMik6IHZvaWQge1xuXHRcdGlmKHRoaXMuZnJvemVuKSByZXR1cm47XG5cdFx0dGhpcy5tb3ZpbmcgPSB0cnVlO1xuXHRcdHRoaXMuX3ZlbG9jaXR5ID0gdmVsb2NpdHk7XG5cdH07XG5cblx0bW92ZU9uUGF0aChzcGVlZDogbnVtYmVyLCBwYXRoOiBOYXZpZ2F0aW9uUGF0aCk6IHZvaWQge1xuXHRcdGlmKHRoaXMuZnJvemVuKSByZXR1cm47XG5cdFx0dGhpcy5wYXRoID0gcGF0aDtcblx0XHRsZXQgZGlyID0gcGF0aC5nZXRNb3ZlRGlyZWN0aW9uKHRoaXMpO1xuXHRcdHRoaXMubW92aW5nID0gdHJ1ZTtcblx0XHR0aGlzLnBhdGhmaW5kaW5nID0gdHJ1ZTtcblx0XHR0aGlzLl92ZWxvY2l0eSA9IGRpci5zY2FsZShzcGVlZCk7XG5cdH1cblxuXHQvLyBAaW1wbGVtZW50ZWRcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmVsb2NpdHkgVGhlIHZlbG9jaXR5IHdpdGggd2hpY2ggdGhlIG9iamVjdCB3aWxsIG1vdmUuXG4gICAgICovXG5cdGZpbmlzaE1vdmUoKTogdm9pZCB7XG5cdFx0dGhpcy5tb3ZpbmcgPSBmYWxzZTtcblx0XHR0aGlzLnBvc2l0aW9uLmFkZCh0aGlzLl92ZWxvY2l0eSk7XG5cdFx0aWYodGhpcy5wYXRoZmluZGluZyl7XG5cdFx0XHR0aGlzLnBhdGguaGFuZGxlUGF0aFByb2dyZXNzKHRoaXMpO1xuXHRcdFx0dGhpcy5wYXRoID0gbnVsbDtcblx0XHRcdHRoaXMucGF0aGZpbmRpbmcgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvLyBAaW1wbGVtZW50ZWRcblx0LyoqXG5cdCAqIEBwYXJhbSBjb2xsaXNpb25TaGFwZSBUaGUgY29sbGlkZXIgZm9yIHRoaXMgb2JqZWN0LiBJZiB0aGlzIGhhcyBhIHJlZ2lvbiAoaW1wbGVtZW50cyBSZWdpb24pLFxuXHQgKiBpdCB3aWxsIGJlIHVzZWQgd2hlbiBubyBjb2xsaXNpb24gc2hhcGUgaXMgc3BlY2lmaWVkIChvciBpZiBjb2xsaXNpb24gc2hhcGUgaXMgbnVsbCkuXG5cdCAqIEBwYXJhbSBpc0NvbGxpZGFibGUgV2hldGhlciB0aGlzIGlzIGNvbGxpZGFibGUgb3Igbm90LiBUcnVlIGJ5IGRlZmF1bHQuXG5cdCAqIEBwYXJhbSBpc1N0YXRpYyBXaGV0aGVyIHRoaXMgaXMgc3RhdGljIG9yIG5vdC4gRmFsc2UgYnkgZGVmYXVsdFxuXHQgKi9cblx0YWRkUGh5c2ljcyhjb2xsaXNpb25TaGFwZT86IFNoYXBlLCBjb2xsaWRlck9mZnNldD86IFZlYzIsIGlzQ29sbGlkYWJsZTogYm9vbGVhbiA9IHRydWUsIGlzU3RhdGljOiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcblx0XHQvLyBJbml0aWFsaXplIHRoZSBwaHlzaWNzIHZhcmlhYmxlc1xuXHRcdHRoaXMuaGFzUGh5c2ljcyA9IHRydWU7XG5cdFx0dGhpcy5tb3ZpbmcgPSBmYWxzZTtcblx0XHR0aGlzLm9uR3JvdW5kID0gZmFsc2U7XG5cdFx0dGhpcy5vbldhbGwgPSBmYWxzZTtcblx0XHR0aGlzLm9uQ2VpbGluZyA9IGZhbHNlO1xuXHRcdHRoaXMuYWN0aXZlID0gdHJ1ZTtcblx0XHR0aGlzLmlzQ29sbGlkYWJsZSA9IGlzQ29sbGlkYWJsZTtcblx0XHR0aGlzLmlzU3RhdGljID0gaXNTdGF0aWM7XG5cdFx0dGhpcy5pc1RyaWdnZXIgPSBmYWxzZTtcblx0XHR0aGlzLnRyaWdnZXJNYXNrID0gMDtcblx0XHR0aGlzLnRyaWdnZXJFbnRlcnMgPSBuZXcgQXJyYXkoMzIpO1xuXHRcdHRoaXMudHJpZ2dlckV4aXRzID0gbmV3IEFycmF5KDMyKTtcblx0XHR0aGlzLl92ZWxvY2l0eSA9IFZlYzIuWkVSTztcblx0XHR0aGlzLnN3ZXB0UmVjdCA9IG5ldyBBQUJCKCk7XG5cdFx0dGhpcy5jb2xsaWRlZFdpdGhUaWxlbWFwID0gZmFsc2U7XG5cdFx0dGhpcy5ncm91cCA9IC0xO1x0XHRcdFx0XHQvLyBUaGUgZGVmYXVsdCBncm91cCwgY29sbGlkZXMgd2l0aCBldmVyeXRoaW5nXG5cblx0XHQvLyBTZXQgdGhlIGNvbGxpc2lvbiBzaGFwZSBpZiBwcm92aWRlZCwgb3Igc2ltcGx5IHVzZSB0aGUgdGhlIHJlZ2lvbiBpZiB0aGVyZSBpcyBvbmUuXG5cdFx0aWYoY29sbGlzaW9uU2hhcGUpe1xuXHRcdFx0dGhpcy5jb2xsaXNpb25TaGFwZSA9IGNvbGxpc2lvblNoYXBlO1xuXHRcdFx0dGhpcy5jb2xsaXNpb25TaGFwZS5jZW50ZXIgPSB0aGlzLnBvc2l0aW9uO1xuXHRcdH0gZWxzZSBpZiAoaXNSZWdpb24odGhpcykpIHtcblx0XHRcdC8vIElmIHRoZSBnYW1lbm9kZSBoYXMgYSByZWdpb24gYW5kIG5vIG90aGVyIGlzIHNwZWNpZmllZCwgdXNlIHRoYXRcblx0XHRcdHRoaXMuY29sbGlzaW9uU2hhcGUgPSAoPGFueT50aGlzKS5ib3VuZGFyeS5jbG9uZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBcIk5vIGNvbGxpc2lvbiBzaGFwZSBzcGVjaWZpZWQgZm9yIHBoeXNpY3Mgb2JqZWN0LlwiXG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2Ugd2VyZSBwcm92aWRlZCB3aXRoIGEgY29sbGlkZXIgb2Zmc2V0LCBzZXQgaXQuIE90aGVyd2lzZSB0aGVyZSBpcyBubyBvZmZzZXQsIHNvIHVzZSB0aGUgemVybyB2ZWN0b3Jcblx0XHRpZihjb2xsaWRlck9mZnNldCl7XG5cdFx0XHR0aGlzLmNvbGxpZGVyT2Zmc2V0ID0gY29sbGlkZXJPZmZzZXQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuY29sbGlkZXJPZmZzZXQgPSBWZWMyLlpFUk87XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3dlcHQgcmVjdFxuXHRcdHRoaXMuc3dlcHRSZWN0ID0gdGhpcy5jb2xsaXNpb25TaGFwZS5nZXRCb3VuZGluZ1JlY3QoKTtcblxuXHRcdC8vIFJlZ2lzdGVyIHRoZSBvYmplY3Qgd2l0aCBwaHlzaWNzXG5cdFx0dGhpcy5zY2VuZS5nZXRQaHlzaWNzTWFuYWdlcigpLnJlZ2lzdGVyT2JqZWN0KHRoaXMpO1xuXHR9XG5cblx0LyoqIFJlbW92ZXMgdGhpcyBvYmplY3QgZnJvbSB0aGUgcGh5c2ljcyBzeXN0ZW0gKi9cbiAgICByZW1vdmVQaHlzaWNzKCk6IHZvaWQge1xuXHRcdC8vIFJlbW92ZSB0aGlzIGZyb20gdGhlIHBoeXNpY3MgbWFuYWdlclxuXHRcdHRoaXMuc2NlbmUuZ2V0UGh5c2ljc01hbmFnZXIoKS5kZXJlZ2lzdGVyT2JqZWN0KHRoaXMpO1xuXG5cdFx0Ly8gTnVsbGlmeSBhbGwgcGh5c2ljcyBmaWVsZHNcblx0XHR0aGlzLmhhc1BoeXNpY3MgPSBmYWxzZTtcblx0XHR0aGlzLm1vdmluZyA9IGZhbHNlO1xuXHRcdHRoaXMub25Hcm91bmQgPSBmYWxzZTtcblx0XHR0aGlzLm9uV2FsbCA9IGZhbHNlO1xuXHRcdHRoaXMub25DZWlsaW5nID0gZmFsc2U7XG5cdFx0dGhpcy5hY3RpdmUgPSBmYWxzZTtcblx0XHR0aGlzLmlzQ29sbGlkYWJsZSA9IGZhbHNlO1xuXHRcdHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcblx0XHR0aGlzLmlzVHJpZ2dlciA9IGZhbHNlO1xuXHRcdHRoaXMudHJpZ2dlck1hc2sgPSAwO1xuXHRcdHRoaXMudHJpZ2dlckVudGVycyA9IG51bGw7XG5cdFx0dGhpcy50cmlnZ2VyRXhpdHMgPSBudWxsO1xuXHRcdHRoaXMuX3ZlbG9jaXR5ID0gVmVjMi5aRVJPO1xuXHRcdHRoaXMuc3dlcHRSZWN0ID0gbnVsbDtcblx0XHR0aGlzLmNvbGxpZGVkV2l0aFRpbGVtYXAgPSBmYWxzZTtcblx0XHR0aGlzLmdyb3VwID0gLTE7XG5cdFx0dGhpcy5jb2xsaXNpb25TaGFwZSA9IG51bGw7XG5cdFx0dGhpcy5jb2xsaWRlck9mZnNldCA9IFZlYzIuWkVSTztcblx0XHR0aGlzLnN3ZXB0UmVjdCA9IG51bGw7XG5cdH1cblxuXHQvKiogRGlzYWJsZXMgcGh5c2ljcyBtb3ZlbWVudCBmb3IgdGhpcyBub2RlICovXG5cdGZyZWV6ZSgpOiB2b2lkIHtcblx0XHR0aGlzLmZyb3plbiA9IHRydWU7XG5cdH1cblxuXHQvKiogUmVlbmFibGVzIHBoeXNpY3MgbW92ZW1lbnQgZm9yIHRoaXMgbm9kZSAqL1xuXHR1bmZyZWV6ZSgpOiB2b2lkIHtcblx0XHR0aGlzLmZyb3plbiA9IGZhbHNlO1xuXHR9XG5cbiAgICAvKiogUHJldmVudHMgdGhpcyBvYmplY3QgZnJvbSBwYXJ0aWNpcGF0aW5nIGluIGFsbCBjb2xsaXNpb25zIGFuZCB0cmlnZ2Vycy4gSXQgY2FuIHN0aWxsIG1vdmUuICovXG4gICAgZGlzYWJsZVBoeXNpY3MoKTogdm9pZCB7XG5cdFx0dGhpcy5hY3RpdmUgPSBmYWxzZTtcblx0fVxuXG4gICAgLyoqIEVuYWJsZXMgdGhpcyBvYmplY3QgdG8gcGFydGljaXBhdGUgaW4gY29sbGlzaW9ucyBhbmQgdHJpZ2dlcnMuIFRoaXMgaXMgb25seSBuZWNlc3NhcnkgaWYgZGlzYWJsZVBoeXNpY3Mgd2FzIGNhbGxlZCAqL1xuICAgIGVuYWJsZVBoeXNpY3MoKTogdm9pZCB7XG5cdFx0dGhpcy5hY3RpdmUgPSB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGNvbGxpZGVyIGZvciB0aGlzIEdhbWVOb2RlXG5cdCAqIEBwYXJhbSBjb2xsaWRlciBUaGUgbmV3IGNvbGxpZGVyIHRvIHVzZVxuXHQgKi9cblx0c2V0Q29sbGlzaW9uU2hhcGUoY29sbGlkZXI6IFNoYXBlKTogdm9pZCB7XG5cdFx0dGhpcy5jb2xsaXNpb25TaGFwZSA9IGNvbGxpZGVyO1xuXHRcdHRoaXMuY29sbGlzaW9uU2hhcGUuY2VudGVyLmNvcHkodGhpcy5wb3NpdGlvbik7XG5cdH1cblxuXHQvLyBAaW1wbGVtZW50ZWRcblx0LyoqXG4gICAgICogU2V0cyB0aGlzIG9iamVjdCB0byBiZSBhIHRyaWdnZXIgZm9yIGEgc3BlY2lmaWMgZ3JvdXBcbiAgICAgKiBAcGFyYW0gZ3JvdXAgVGhlIG5hbWUgb2YgdGhlIGdyb3VwIHRoYXQgYWN0aXZhdGVzIHRoZSB0cmlnZ2VyXG4gICAgICogQHBhcmFtIG9uRW50ZXIgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHNlbmQgd2hlbiB0aGlzIHRyaWdnZXIgaXMgYWN0aXZhdGVkXG4gICAgICogQHBhcmFtIG9uRXhpdCBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gc2VuZCB3aGVuIHRoaXMgdHJpZ2dlciBzdG9wcyBiZWluZyBhY3RpdmF0ZWRcbiAgICAgKi9cbiAgICBzZXRUcmlnZ2VyKGdyb3VwOiBzdHJpbmcsIG9uRW50ZXI6IHN0cmluZywgb25FeGl0OiBzdHJpbmcpOiB2b2lkIHtcblx0XHQvLyBNYWtlIHRoaXMgb2JqZWN0IGEgdHJpZ2dlclxuXHRcdHRoaXMuaXNUcmlnZ2VyID0gdHJ1ZTtcblxuXHRcdC8vIEdldCB0aGUgbnVtYmVyIG9mIHRoZSBwaHlzaWNzIGxheWVyXG5cdFx0bGV0IGxheWVyTnVtYmVyID0gdGhpcy5zY2VuZS5nZXRQaHlzaWNzTWFuYWdlcigpLmdldEdyb3VwTnVtYmVyKGdyb3VwKTtcblxuXHRcdGlmKGxheWVyTnVtYmVyID09PSAwKXtcblx0XHRcdGNvbnNvbGUud2FybihgVHJpZ2dlciBmb3IgR2FtZU5vZGUgJHt0aGlzLmlkfSBub3Qgc2V0IC0gZ3JvdXAgXCIke2dyb3VwfVwiIHdhcyBub3QgcmVjb2duaXplZCBieSB0aGUgcGh5c2ljcyBtYW5hZ2VyLmApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGlzIHRvIHRoZSB0cmlnZ2VyIG1hc2tcblx0XHR0aGlzLnRyaWdnZXJNYXNrIHw9IGxheWVyTnVtYmVyO1xuXG5cdFx0Ly8gTGF5ZXIgbnVtYmVycyBhcmUgYml0cywgc28gZ2V0IHdoaWNoIGJpdCBpdCBpc1xuXHRcdGxldCBpbmRleCA9IE1hdGgubG9nMihsYXllck51bWJlcik7XG5cblx0XHQvLyBTZXQgdGhlIGV2ZW50IG5hbWVzXG5cdFx0dGhpcy50cmlnZ2VyRW50ZXJzW2luZGV4XSA9IG9uRW50ZXI7XG5cdFx0dGhpcy50cmlnZ2VyRXhpdHNbaW5kZXhdID0gb25FeGl0O1xuXHR9O1xuXG5cdC8vIEBpbXBsZW1lbnRlZFxuXHQvKipcblx0ICogQHBhcmFtIGdyb3VwIFRoZSBwaHlzaWNzIGdyb3VwIHRoaXMgbm9kZSBzaG91bGQgYmVsb25nIHRvXG5cdCAqL1xuXHRzZXRHcm91cChncm91cDogc3RyaW5nKTogdm9pZCB7XG5cdFx0dGhpcy5zY2VuZS5nZXRQaHlzaWNzTWFuYWdlcigpLnNldEdyb3VwKHRoaXMsIGdyb3VwKTtcblx0fVxuXG5cdC8vIEBpbXBsZW1lbmVkXG5cdGdldExhc3RWZWxvY2l0eSgpOiBWZWMyIHtcblx0XHRyZXR1cm4gdGhpcy5fdmVsb2NpdHk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0gQUNUT1IgLS0tLS0tLS0tLSovXG5cdGdldCBhaSgpOiBBSSB8IEdvYXBBSSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FpO1xuXHR9XG5cblx0c2V0IGFpKGFpOiBBSSB8IEdvYXBBSSkge1xuXHRcdGlmKCF0aGlzLl9haSl7XG5cdFx0XHQvLyBJZiB3ZSBoYXZlbid0IGJlZW4gcHJldmlvdXNseSBoYWQgYW4gYWksIHJlZ2lzdGVyIHVzIHdpdGggdGhlIGFpIG1hbmFnZXJcblx0XHRcdHRoaXMuc2NlbmUuZ2V0QUlNYW5hZ2VyKCkucmVnaXN0ZXJBY3Rvcih0aGlzKTtcblx0XHR9XG5cblx0XHR0aGlzLl9haSA9IGFpO1xuXHRcdHRoaXMuYWlBY3RpdmUgPSB0cnVlO1xuXHR9XG5cblx0Ly8gQGltcGxlbWVudGVkXG5cdGFkZEFJPFQgZXh0ZW5kcyBBSSB8IEdvYXBBST4oYWk6IHN0cmluZyB8IChuZXcgKCkgPT4gVCksIG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCB0eXBlPzogbnVtYmVyKTogdm9pZCB7XG5cdFx0aWYoIXRoaXMuX2FpKXtcblx0XHRcdHRoaXMuc2NlbmUuZ2V0QUlNYW5hZ2VyKCkucmVnaXN0ZXJBY3Rvcih0aGlzKTtcblx0XHR9XG5cblx0XHRpZih0eXBlb2YgYWkgPT09IFwic3RyaW5nXCIpe1xuXHRcdFx0dGhpcy5fYWkgPSB0aGlzLnNjZW5lLmdldEFJTWFuYWdlcigpLmdlbmVyYXRlQUkoYWkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9haSA9IG5ldyBhaSgpO1xuXHRcdH1cblxuXHRcdC8vIFF1ZXN0aW9uLCBob3cgbXVjaCBkbyB3ZSB3YW50IGRpZmZlcmVudCB0eXBlIG9mIEFJIHRvIGJlIGhhbmRsZWQgdGhlIHNhbWUsIGkuZS4gc2hvdWxkIEdvYXBBSSBhbmQgQUkgc2ltaWxhciBtZXRob2RzIGFuZCBzaWduYXR1cmVzIGZvciB0aGUgc2FrZSBvZiB1bml0eVxuXHRcdHRoaXMuX2FpLmluaXRpYWxpemVBSSh0aGlzLCBvcHRpb25zKTtcblxuXHRcdHRoaXMuYWlBY3RpdmUgPSB0cnVlO1xuXHR9XG5cblx0Ly8gQGltcGxlbWVudGVkXG5cdHNldEFJQWN0aXZlKGFjdGl2ZTogYm9vbGVhbiwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuXHRcdHRoaXMuYWlBY3RpdmUgPSBhY3RpdmU7XG5cdFx0aWYodGhpcy5haUFjdGl2ZSl7XG5cdFx0XHR0aGlzLmFpLmFjdGl2YXRlKG9wdGlvbnMpO1xuXHRcdH1cblx0fVxuXG5cdC8qLS0tLS0tLS0tLSBUV0VFTkFCTEUgUFJPUEVSVElFUyAtLS0tLS0tLS0tKi9cblx0c2V0IHBvc2l0aW9uWCh2YWx1ZTogbnVtYmVyKSB7XG5cdFx0dGhpcy5wb3NpdGlvbi54ID0gdmFsdWU7XG5cdH1cblxuXHRzZXQgcG9zaXRpb25ZKHZhbHVlOiBudW1iZXIpIHtcblx0XHR0aGlzLnBvc2l0aW9uLnkgPSB2YWx1ZTtcblx0fVxuXG5cdGFic3RyYWN0IHNldCBzY2FsZVgodmFsdWU6IG51bWJlcik7XG5cblx0YWJzdHJhY3Qgc2V0IHNjYWxlWSh2YWx1ZTogbnVtYmVyKTtcblxuXHQvKi0tLS0tLS0tLS0gR0FNRSBOT0RFIC0tLS0tLS0tLS0qL1xuXHQvKipcblx0ICogU2V0cyB0aGUgc2NlbmUgZm9yIHRoaXMgb2JqZWN0LlxuXHQgKiBAcGFyYW0gc2NlbmUgVGhlIHNjZW5lIHRoaXMgb2JqZWN0IGJlbG9uZ3MgdG8uXG5cdCAqL1xuXHRzZXRTY2VuZShzY2VuZTogU2NlbmUpOiB2b2lkIHtcblx0XHR0aGlzLnNjZW5lID0gc2NlbmU7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgc2NlbmUgdGhpcyBvYmplY3QgaXMgaW4uIFxuXHQgKiBAcmV0dXJucyBUaGUgc2NlbmUgdGhpcyBvYmplY3QgYmVsb25ncyB0b1xuXHQqL1xuXHRnZXRTY2VuZSgpOiBTY2VuZSB7XG5cdFx0cmV0dXJuIHRoaXMuc2NlbmU7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgbGF5ZXIgb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBwYXJhbSBsYXllciBUaGUgbGF5ZXIgdGhpcyBvYmplY3Qgd2lsbCBiZSBvbi5cblx0ICovXG5cdHNldExheWVyKGxheWVyOiBMYXllcik6IHZvaWQge1xuXHRcdHRoaXMubGF5ZXIgPSBsYXllcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsYXllciB0aGlzIG9iamVjdCBpcyBvbi5cblx0ICogQHJldHVybnMgVGhpcyBsYXllciB0aGlzIG9iamVjdCBpcyBvbi5cblx0Ki9cblx0Z2V0TGF5ZXIoKTogTGF5ZXIge1xuXHRcdHJldHVybiB0aGlzLmxheWVyO1xuXHR9XG5cblx0LyoqIENhbGxlZCBpZiB0aGUgcG9zaXRpb24gdmVjdG9yIGlzIG1vZGlmaWVkIG9yIHJlcGxhY2VkICovXG5cdHByb3RlY3RlZCBwb3NpdGlvbkNoYW5nZWQoKTogdm9pZCB7XG5cdFx0aWYodGhpcy5jb2xsaXNpb25TaGFwZSl7XG5cdFx0XHRpZih0aGlzLmNvbGxpZGVyT2Zmc2V0KXtcblx0XHRcdFx0dGhpcy5jb2xsaXNpb25TaGFwZS5jZW50ZXIgPSB0aGlzLnBvc2l0aW9uLmNsb25lKCkuYWRkKHRoaXMuY29sbGlkZXJPZmZzZXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5jb2xsaXNpb25TaGFwZS5jZW50ZXIgPSB0aGlzLnBvc2l0aW9uLmNsb25lKCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhpcyBHYW1lTm9kZVxuXHQgKiBAcGFyYW0gZGVsdGFUIFRoZSB0aW1lc3RlcCBvZiB0aGUgdXBkYXRlLlxuXHQgKi9cblx0dXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG5cdFx0Ly8gRGVmZXIgZXZlbnQgaGFuZGxpbmcgdG8gQUkuXG5cdFx0d2hpbGUodGhpcy5yZWNlaXZlci5oYXNOZXh0RXZlbnQoKSl7XG5cdFx0XHR0aGlzLl9haS5oYW5kbGVFdmVudCh0aGlzLnJlY2VpdmVyLmdldE5leHRFdmVudCgpKTtcblx0XHR9XG5cdH1cblxuXHQvLyBAaW1wbGVtZW50ZWRcblx0ZGVidWdSZW5kZXIoKTogdm9pZCB7XG5cdFx0Ly8gRHJhdyB0aGUgcG9zaXRpb24gb2YgdGhpcyBHYW1lTm9kZVxuXHRcdERlYnVnLmRyYXdQb2ludCh0aGlzLnJlbGF0aXZlUG9zaXRpb24sIENvbG9yLkJMVUUpO1xuXG5cdFx0Ly8gSWYgdmVsb2NpdHkgaXMgbm90IHplcm8sIGRyYXcgYSB2ZWN0b3IgZm9yIGl0XG5cdFx0aWYodGhpcy5fdmVsb2NpdHkgJiYgIXRoaXMuX3ZlbG9jaXR5LmlzWmVybygpKXtcblx0XHRcdERlYnVnLmRyYXdSYXkodGhpcy5yZWxhdGl2ZVBvc2l0aW9uLCB0aGlzLl92ZWxvY2l0eS5jbG9uZSgpLnNjYWxlVG8oMjApLmFkZCh0aGlzLnJlbGF0aXZlUG9zaXRpb24pLCBDb2xvci5CTFVFKTtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGlzIGhhcyBhIGNvbGxpZGVyLCBkcmF3IGl0XG5cdFx0aWYodGhpcy5jb2xsaXNpb25TaGFwZSl7XG5cdFx0XHRsZXQgY29sb3IgPSB0aGlzLmlzQ29sbGlkaW5nID8gQ29sb3IuUkVEIDogQ29sb3IuR1JFRU47XG5cblx0XHRcdGlmKHRoaXMuaXNUcmlnZ2VyKXtcblx0XHRcdFx0Y29sb3IgPSBDb2xvci5NQUdFTlRBO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRjb2xvci5hID0gMC4yO1xuXG5cdFx0XHRpZih0aGlzLmNvbGxpc2lvblNoYXBlIGluc3RhbmNlb2YgQUFCQil7XG5cdFx0XHRcdERlYnVnLmRyYXdCb3godGhpcy5pblJlbGF0aXZlQ29vcmRpbmF0ZXModGhpcy5jb2xsaXNpb25TaGFwZS5jZW50ZXIpLCB0aGlzLmNvbGxpc2lvblNoYXBlLmhhbGZTaXplLnNjYWxlZCh0aGlzLnNjZW5lLmdldFZpZXdTY2FsZSgpKSwgdHJ1ZSwgY29sb3IpO1xuXHRcdFx0fSBlbHNlIGlmKHRoaXMuY29sbGlzaW9uU2hhcGUgaW5zdGFuY2VvZiBDaXJjbGUpe1xuXHRcdFx0XHREZWJ1Zy5kcmF3Q2lyY2xlKHRoaXMuaW5SZWxhdGl2ZUNvb3JkaW5hdGVzKHRoaXMuY29sbGlzaW9uU2hhcGUuY2VudGVyKSwgdGhpcy5jb2xsaXNpb25TaGFwZS5odyp0aGlzLnNjZW5lLmdldFZpZXdTY2FsZSgpLCB0cnVlLCBjb2xvcik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmV4cG9ydCBlbnVtIFR3ZWVuYWJsZVByb3BlcnRpZXN7XG5cdHBvc1ggPSBcInBvc2l0aW9uWFwiLFxuXHRwb3NZID0gXCJwb3NpdGlvbllcIixcblx0c2NhbGVYID0gXCJzY2FsZVhcIixcblx0c2NhbGVZID0gXCJzY2FsZVlcIixcblx0cm90YXRpb24gPSBcInJvdGF0aW9uXCIsXG5cdGFscGhhID0gXCJhbHBoYVwiXG59IiwiaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4vQ2FudmFzTm9kZVwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xuXG4vKipcbiAqIFRoZSByZXByZXNlbnRhdGlvbiBvZiBhIGdhbWUgb2JqZWN0IHRoYXQgZG9lc24ndCByZWx5IG9uIGFueSByZXNvdXJjZXMgdG8gcmVuZGVyIC0gaXQgaXMgZHJhd24gdG8gdGhlIHNjcmVlbiBieSB0aGUgY2FudmFzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIEdyYXBoaWMgZXh0ZW5kcyBDYW52YXNOb2RlIHtcbiAgICAvKiogVGhlIGNvbG9yIG9mIHRoZSBHcmFwaGljICovXG4gICAgY29sb3I6IENvbG9yO1xuXG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb2xvciA9IENvbG9yLlJFRDtcbiAgICB9XG5cbiAgICBnZXQgYWxwaGEoKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5jb2xvci5hO1xuXHR9XG5cblx0c2V0IGFscGhhKGE6IG51bWJlcikge1xuXHRcdHRoaXMuY29sb3IuYSA9IGE7XG5cdH1cblxuICAgIC8vIEBkZXByZWNhdGVkXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY29sb3Igb2YgdGhlIEdyYXBoaWMuIERFUFJFQ0FURURcbiAgICAgKiBAcGFyYW0gY29sb3IgVGhlIG5ldyBjb2xvciBvZiB0aGUgR3JhcGhpYy5cbiAgICAgKi9cbiAgICBzZXRDb2xvcihjb2xvcjogQ29sb3Ipe1xuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gICAgfVxuXG4gICAgc2V0IGNvbG9yUihyOiBudW1iZXIpe1xuICAgICAgICB0aGlzLmNvbG9yLnIgPSByO1xuICAgIH1cblxuICAgIGdldCBjb2xvclIoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sb3IucjtcbiAgICB9XG5cbiAgICBzZXQgY29sb3JHKGc6IG51bWJlcil7XG4gICAgICAgIHRoaXMuY29sb3IuZyA9IGc7XG4gICAgfVxuXG4gICAgZ2V0IGNvbG9yRygpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xvci5nO1xuICAgIH1cblxuICAgIHNldCBjb2xvckIoYjogbnVtYmVyKXtcbiAgICAgICAgdGhpcy5jb2xvci5iID0gYjtcbiAgICB9XG5cbiAgICBnZXQgY29sb3JCKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9yLmI7XG4gICAgfVxufSIsImV4cG9ydCBlbnVtIEdyYXBoaWNUeXBlIHtcblx0UE9JTlQgPSBcIlBPSU5UXCIsXG5cdFJFQ1QgPSBcIlJFQ1RcIixcblx0TElORSA9IFwiTElORVwiLFxuXHRQQVJUSUNMRSA9IFwiUEFSVElDTEVcIlxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEdyYXBoaWMgZnJvbSBcIi4uL0dyYXBoaWNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZSBleHRlbmRzIEdyYXBoaWMge1xuICAgIHByb3RlY3RlZCBfZW5kOiBWZWMyO1xuICAgIHRoaWNrbmVzczogbnVtYmVyO1xuXG4gICAgY29uc3RydWN0b3Ioc3RhcnQ6IFZlYzIsIGVuZDogVmVjMil7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICAgIHRoaXMudGhpY2tuZXNzID0gMjtcblxuICAgICAgICAvLyBEb2VzIHRoaXMgcmVhbGx5IGhhdmUgYSBtZWFuaW5nIGZvciBsaW5lcz9cbiAgICAgICAgdGhpcy5zaXplLnNldCg1LCA1KTtcbiAgICB9XG5cbiAgICBzZXQgc3RhcnQocG9zOiBWZWMyKXtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvcztcbiAgICB9XG5cbiAgICBnZXQgc3RhcnQoKTogVmVjMiB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uO1xuICAgIH1cblxuICAgIHNldCBlbmQocG9zOiBWZWMyKXtcbiAgICAgICAgdGhpcy5fZW5kID0gcG9zO1xuICAgIH1cblxuICAgIGdldCBlbmQoKTogVmVjMiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmQ7XG4gICAgfVxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IFBvaW50IGZyb20gXCIuL1BvaW50XCI7XG5cbi8qKlxuICogLSBQb3NpdGlvbiBYXG4tIFZlbG9jaXR5IChzcGVlZCBhbmQgZGlyZWN0aW9uKSBYXG4tIENvbG9yIFhcbi0gTGlmZXRpbWUgXG4tIEFnZSBjYW4gYmUgaGFuZGxlZCBhcyBsaWZldGltZVxuLSBTaGFwZSBYXG4tIFNpemUgWFxuLSBUcmFuc3BhcmVuY3kgWFxuICovXG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFydGljbGUgZXh0ZW5kcyBQb2ludCB7XG4gICAgYWdlOiBudW1iZXI7XG5cbiAgICBpblVzZTogYm9vbGVhbjtcblxuICAgIHZlbDogVmVjMjtcblxuICAgIG1hc3M6IG51bWJlcjtcblxuICAgIGNvbnN0cnVjdG9yKHBvc2l0aW9uOiBWZWMyLCBzaXplOiBWZWMyLCBtYXNzOiBudW1iZXIpIHtcbiAgICAgICAgLy8gQXJlIHdlIG1ha2luZyB0aGlzIGEgY2lyY2xlP1xuICAgICAgICBzdXBlcihwb3NpdGlvbik7XG4gICAgICAgIHRoaXMuaW5Vc2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tYXNzID0gbWFzcztcbiAgICB9XG5cbiAgICBzZXRQYXJ0aWNsZUFjdGl2ZShsaWZldGltZTogbnVtYmVyLCBwb3NpdGlvbjogVmVjMikge1xuICAgICAgICB0aGlzLmFnZSA9IGxpZmV0aW1lO1xuICAgICAgICB0aGlzLmluVXNlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIH1cblxuICAgIGRlY3JlbWVudEFnZShkZWNheTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuYWdlIC09IGRlY2F5O1xuICAgIH1cblxuICAgIHNldFBhcnRpY2xlSW5hY3RpdmUoKXtcbiAgICAgICAgdGhpcy5pblVzZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBzZXQgdmVsWSh5OiBudW1iZXIpe1xuICAgICAgICB0aGlzLnZlbC55ID0geTtcbiAgICB9XG5cbiAgICBnZXQgdmVsWSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy52ZWwueTtcbiAgICB9XG5cblxufSIsImltcG9ydCBHcmFwaGljIGZyb20gXCIuLi9HcmFwaGljXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcblxuLyoqIEEgYmFzaWMgcG9pbnQgdG8gYmUgZHJhd24gb24gdGhlIHNjcmVlbi4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvaW50IGV4dGVuZHMgR3JhcGhpYyB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwb3NpdGlvbjogVmVjMikge1xuICAgICAgICAvLyBBcmUgd2UgbWFraW5nIHRoaXMgYSBjaXJjbGU/XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgdGhpcy5zaXplLnNldCg1LCA1KTtcbiAgICB9XG59IiwiaW1wb3J0IEdyYXBoaWMgZnJvbSBcIi4uL0dyYXBoaWNcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9VdGlscy9Db2xvclwiO1xuXG4vKiogQSBiYXNpYyByZWN0YW5nbGUgdG8gYmUgZHJhd24gb24gdGhlIHNjcmVlbi4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlY3QgZXh0ZW5kcyBHcmFwaGljIHtcblxuICAgIC8qKiBUaGUgYm9yZGVyIGNvbG9yIG9mIHRoZSBSZWN0ICovXG4gICAgYm9yZGVyQ29sb3I6IENvbG9yO1xuXG4gICAgLyoqIFRoZSB3aWR0aCBvZiB0aGUgYm9yZGVyICovXG4gICAgYm9yZGVyV2lkdGg6IG51bWJlcjtcblxuICAgIGNvbnN0cnVjdG9yKHBvc2l0aW9uOiBWZWMyLCBzaXplOiBWZWMyKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgICAgICB0aGlzLmJvcmRlckNvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XG4gICAgICAgIHRoaXMuYm9yZGVyV2lkdGggPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGJvcmRlciBjb2xvciBvZiB0aGlzIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBjb2xvciBUaGUgYm9yZGVyIGNvbG9yXG4gICAgICovXG4gICAgc2V0Qm9yZGVyQ29sb3IoY29sb3I6IENvbG9yKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSBjb2xvcjtcbiAgICB9XG5cbiAgICAvLyBAZGVwcmVjYXRlZFxuICAgIGdldEJvcmRlckNvbG9yKCk6IENvbG9yIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9yZGVyQ29sb3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYm9yZGVyIHdpZHRoIG9mIHRoaXMgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlIGluIHBpeGVsc1xuICAgICAqL1xuICAgIHNldEJvcmRlcldpZHRoKHdpZHRoOiBudW1iZXIpe1xuICAgICAgICB0aGlzLmJvcmRlcldpZHRoID0gd2lkdGg7XG4gICAgfVxuXG4gICAgZ2V0Qm9yZGVyV2lkdGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9yZGVyV2lkdGg7XG4gICAgfVxufSIsImltcG9ydCBTcHJpdGUgZnJvbSBcIi4vU3ByaXRlXCI7XHJcbmltcG9ydCBBbmltYXRpb25NYW5hZ2VyIGZyb20gXCIuLi8uLi9SZW5kZXJpbmcvQW5pbWF0aW9ucy9BbmltYXRpb25NYW5hZ2VyXCI7XHJcbmltcG9ydCBTcHJpdGVzaGVldCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1Nwcml0ZXNoZWV0XCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgTGFiZWwgZnJvbSBcIi4uL1VJRWxlbWVudHMvTGFiZWxcIjtcclxuXHJcbi8qKiBBbiBzcHJpdGUgd2l0aCBzcGVjaWZpZWQgYW5pbWF0aW9uIGZyYW1lcy4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0ZWRTcHJpdGUgZXh0ZW5kcyBTcHJpdGUge1xyXG4gICAgLyoqIFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGlzIHNwcml0ZSBzaGVldCAqL1xyXG4gICAgcHJvdGVjdGVkIG51bUNvbHM6IG51bWJlcjtcclxuICAgIFxyXG4gICAgaHBEaXNwbGF5OiBMYWJlbDtcclxuXHJcbiAgICBnZXQgY29scygpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm51bUNvbHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGlzIHNwcml0ZSBzaGVldCAqL1xyXG4gICAgcHJvdGVjdGVkIG51bVJvd3M6IG51bWJlcjtcclxuXHJcbiAgICBnZXQgcm93cygpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm51bVJvd3M7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRoZSBhbmltYXRpb25NYW5hZ2VyIGZvciB0aGlzIHNwcml0ZSAqL1xyXG4gICAgYW5pbWF0aW9uOiBBbmltYXRpb25NYW5hZ2VyO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHNwcml0ZXNoZWV0OiBTcHJpdGVzaGVldCl7XHJcbiAgICAgICAgc3VwZXIoc3ByaXRlc2hlZXQubmFtZSk7XHJcbiAgICAgICAgdGhpcy5udW1Db2xzID0gc3ByaXRlc2hlZXQuY29sdW1ucztcclxuICAgICAgICB0aGlzLm51bVJvd3MgPSBzcHJpdGVzaGVldC5yb3dzO1xyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIHNpemUgb2YgdGhlIHNwcml0ZSB0byB0aGUgc3ByaXRlIHNpemUgc3BlY2lmaWVkIGJ5IHRoZSBzcHJpdGVzaGVldFxyXG4gICAgICAgIHRoaXMuc2l6ZS5zZXQoc3ByaXRlc2hlZXQuc3ByaXRlV2lkdGgsIHNwcml0ZXNoZWV0LnNwcml0ZUhlaWdodCk7XHJcblxyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbk1hbmFnZXIodGhpcyk7XHJcblxyXG4gICAgICAgIC8vIEFkZCB0aGUgYW5pbWF0aW9ucyB0byB0aGUgYW5pbWF0ZWQgc3ByaXRlXHJcbiAgICAgICAgZm9yKGxldCBhbmltYXRpb24gb2Ygc3ByaXRlc2hlZXQuYW5pbWF0aW9ucyl7XHJcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLmFkZChhbmltYXRpb24ubmFtZSwgYW5pbWF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBpbWFnZSBvZmZzZXQgZm9yIHRoZSBjdXJyZW50IGluZGV4IG9mIGFuaW1hdGlvblxyXG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCB3ZSdyZSBhdCBpbiB0aGUgYW5pbWF0aW9uXHJcbiAgICAgKiBAcmV0dXJucyBBIFZlYzIgY29udGFpbmluZyB0aGUgaW1hZ2Ugb2Zmc2V0XHJcbiAgICAgKi9cclxuICAgIGdldEFuaW1hdGlvbk9mZnNldChpbmRleDogbnVtYmVyKTogVmVjMiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKChpbmRleCAlIHRoaXMubnVtQ29scykgKiB0aGlzLnNpemUueCwgTWF0aC5mbG9vcihpbmRleCAvIHRoaXMubnVtQ29scykgKiB0aGlzLnNpemUueSk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vQ2FudmFzTm9kZVwiO1xuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5cbi8qKlxuICogVGhlIHJlcHJlc2VudGF0aW9uIG9mIGEgc3ByaXRlIC0gYW4gaW4tZ2FtZSBpbWFnZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcHJpdGUgZXh0ZW5kcyBDYW52YXNOb2RlIHtcbiAgICAvKiogVGhlIGlkIG9mIHRoZSBpbWFnZSBmcm9tIHRoZSByZXNvdXJjZU1hbmFnZXIgKi9cbiAgICBpbWFnZUlkOiBzdHJpbmc7XG4gICAgLyoqIFRoZSBvZmZzZXQgb2YgdGhlIHNwcml0ZSBpbiBhbiBhdGxhcyBpbWFnZSAqL1xuICAgIGltYWdlT2Zmc2V0OiBWZWMyO1xuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgeC1heGlzIHNob3VsZCBiZSBpbnZlcnRlZCBvbiByZW5kZXIgKi9cbiAgICBpbnZlcnRYOiBib29sZWFuO1xuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgeS1heGlzIHNob3VsZCBiZSBpbnZlcnRlZCBvbiByZW5kZXIgKi9cbiAgICBpbnZlcnRZOiBib29sZWFuO1xuXG4gICAgY29uc3RydWN0b3IoaW1hZ2VJZDogc3RyaW5nKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pbWFnZUlkID0gaW1hZ2VJZDtcbiAgICAgICAgbGV0IGltYWdlID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCkuZ2V0SW1hZ2UodGhpcy5pbWFnZUlkKTtcbiAgICAgICAgdGhpcy5zaXplID0gbmV3IFZlYzIoaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XG4gICAgICAgIHRoaXMuaW1hZ2VPZmZzZXQgPSBWZWMyLlpFUk87XG4gICAgICAgIHRoaXMuaW52ZXJ0WCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmludmVydFkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBvZmZzZXQgb2YgdGhlIHNwcml0ZSBmcm9tICgwLCAwKSBpbiB0aGUgaW1hZ2UncyBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldCBvZiB0aGUgc3ByaXRlIGZyb20gKDAsIDApIGluIGltYWdlIGNvb3JkaW5hdGVzXG4gICAgICovXG4gICAgc2V0SW1hZ2VPZmZzZXQob2Zmc2V0OiBWZWMyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaW1hZ2VPZmZzZXQgPSBvZmZzZXQ7XG4gICAgfVxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IFRpbGVzZXQgZnJvbSBcIi4uL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlc2V0XCI7XG5pbXBvcnQgeyBUaWxlZFRpbGVtYXBEYXRhLCBUaWxlZExheWVyRGF0YSB9IGZyb20gXCIuLi9EYXRhVHlwZXMvVGlsZXNldHMvVGlsZWREYXRhXCJcbmltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuL0NhbnZhc05vZGVcIjtcbmltcG9ydCBQaHlzaWNzTWFuYWdlciBmcm9tIFwiLi4vUGh5c2ljcy9QaHlzaWNzTWFuYWdlclwiO1xuXG4vKipcbiAqIFRoZSByZXByZXNlbnRhdGlvbiBvZiBhIHRpbGVtYXAgLSB0aGlzIGNhbiBjb25zaXN0IG9mIGEgY29tYmluYXRpb24gb2YgdGlsZXNldHMgaW4gb25lIGxheWVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFRpbGVtYXAgZXh0ZW5kcyBDYW52YXNOb2RlIHtcbiAgICAvKiogQW4gYXJyYXkgb2YgdGhlIHRpbGVzZXRzIHRoYXQgdGhpcyB0aWxlbWFwIHVzZXMgKi9cbiAgICBwcm90ZWN0ZWQgdGlsZXNldHM6IEFycmF5PFRpbGVzZXQ+O1xuXG4gICAgLyoqIFRoZSBzaXplIG9mIGEgdGlsZSBpbiB0aGlzIHRpbGVtYXAgKi9cbiAgICBwcm90ZWN0ZWQgdGlsZVNpemU6IFZlYzI7XG5cbiAgICAvKiogQW4gYXJyYXkgb2YgdGlsZSBkYXRhICovXG4gICAgcHJvdGVjdGVkIGRhdGE6IEFycmF5PG51bWJlcj47XG5cbiAgICAvKiogQW4gYXJyYXkgb2YgdGlsZSBjb2xsaXNpb24gZGF0YSAqL1xuICAgIHByb3RlY3RlZCBjb2xsaXNpb25NYXA6IEFycmF5PGJvb2xlYW4+O1xuXG4gICAgLyoqIFRoZSBuYW1lIG9mIHRoZSB0aWxlbWFwICovXG4gICAgbmFtZTogc3RyaW5nO1xuXG4gICAgLy8gVE9ETzogTWFrZSB0aGlzIG5vIGxvbmdlciBiZSBzcGVjaWZpYyB0byBUaWxlZFxuICAgIGNvbnN0cnVjdG9yKHRpbGVtYXBEYXRhOiBUaWxlZFRpbGVtYXBEYXRhLCBsYXllcjogVGlsZWRMYXllckRhdGEsIHRpbGVzZXRzOiBBcnJheTxUaWxlc2V0Piwgc2NhbGU6IFZlYzIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50aWxlc2V0cyA9IHRpbGVzZXRzO1xuICAgICAgICB0aGlzLnRpbGVTaXplID0gbmV3IFZlYzIoMCwgMCk7XG4gICAgICAgIHRoaXMubmFtZSA9IGxheWVyLm5hbWU7XG5cbiAgICAgICAgbGV0IHRpbGVjb3VudCA9IDA7XG4gICAgICAgIGZvcihsZXQgdGlsZXNldCBvZiB0aWxlc2V0cyl7XG4gICAgICAgICAgICB0aWxlY291bnQgKz0gdGlsZXNldC5nZXRUaWxlQ291bnQoKSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbGxpc2lvbk1hcCA9IG5ldyBBcnJheSh0aWxlY291bnQpO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5jb2xsaXNpb25NYXAubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25NYXBbaV0gPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmVyIHBhcnNpbmcgb2YgdGhlIGRhdGEgdG8gY2hpbGQgY2xhc3NlcyAtIHRoaXMgYWxsb3dzIGZvciBpc29tZXRyaWMgdnMuIG9ydGhvZ3JhcGhpYyB0aWxlbWFwcyBhbmQgaGFuZGxpbmcgb2YgVGlsZWQgZGF0YSBvciBvdGhlciBkYXRhXG4gICAgICAgIHRoaXMucGFyc2VUaWxlbWFwRGF0YSh0aWxlbWFwRGF0YSwgbGF5ZXIpO1xuICAgICAgICB0aGlzLnNjYWxlLnNldChzY2FsZS54LCBzY2FsZS55KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSB0aWxlc2V0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyB0aWxlbWFwXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgYWxsIG9mIHRoZSB0aWxlc2V0cyBhc3NvY2FpdGVkIHdpdGggdGhpcyB0aWxlbWFwLlxuICAgICAqL1xuICAgIGdldFRpbGVzZXRzKCk6IFRpbGVzZXRbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbGVzZXRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNpemUgb2YgdGlsZXMgaW4gdGhpcyB0aWxlbWFwIGFzIHRoZXkgYXBwZWFyIGluIHRoZSBnYW1lIHdvcmxkIGFmdGVyIHNjYWxpbmdcbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciBjb250YWluaW5nIHRoZSBzaXplIG9mIHRpbGVzIGluIHRoaXMgdGlsZW1hcCBhcyB0aGV5IGFwcGVhciBpbiB0aGUgZ2FtZSB3b3JsZCBhZnRlciBzY2FsaW5nLlxuICAgICAqL1xuICAgIGdldFRpbGVTaXplKCk6IFZlYzIge1xuICAgICAgICByZXR1cm4gdGhpcy50aWxlU2l6ZS5zY2FsZWQodGhpcy5zY2FsZS54LCB0aGlzLnNjYWxlLnkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHRpbGUgc2l6ZSB0YWtpbmcgem9vbSBpbnRvIGFjY291bnRcbiAgICAgKiBAcmV0dXJucyBUaGUgdGlsZSBzaXplIHdpdGggem9vbVxuICAgICovXG4gICAgZ2V0VGlsZVNpemVXaXRoWm9vbSgpOiBWZWMyIHtcbiAgICAgICAgbGV0IHpvb20gPSB0aGlzLnNjZW5lLmdldFZpZXdTY2FsZSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldFRpbGVTaXplKCkuc2NhbGUoem9vbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGlzIHRpbGVtYXAgdG8gdGhlIHBoeXNpY3Mgc3lzdGVtXG4gICAgKi9cbiAgICBhZGRQaHlzaWNzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmhhc1BoeXNpY3MgPSB0cnVlO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuZ3JvdXAgPSAtMTtcbiAgICAgICAgdGhpcy5zY2VuZS5nZXRQaHlzaWNzTWFuYWdlcigpLnJlZ2lzdGVyVGlsZW1hcCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHdvcmxkQ29vcmRzIFRoZSBwb3NpdGlvbiBpbiB3b3JsZCBjb29yZGluYXRlc1xuICAgICAqIEByZXR1cm5zIEEgbnVtYmVyIHRoYXQgcmVwcmVzZW50cyB0aGUgZGF0YSB2YWx1ZSBvZiB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIHdvcmxkIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIGFic3RyYWN0IGdldFRpbGVBdFdvcmxkUG9zaXRpb24od29ybGRDb29yZHM6IFZlYzIpOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3b3JsZCBwb3NpdGlvbiBvZiB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlIGluIHRoZSB0aWxlRGF0YSBhcnJheVxuICAgICAqIEByZXR1cm5zIFRoZSB3b3JsZCBwb3NpdGlvbiBvZiB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAgICovXG4gICAgYWJzdHJhY3QgZ2V0VGlsZVdvcmxkUG9zaXRpb24oaW5kZXg6IG51bWJlcik6IFZlYzI7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGlsZSBpbiB0aGUgdGlsZURhdGEgYXJyYXlcbiAgICAgKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIHRpbGUgaW4gdGhlIHRpbGVEYXRhIGFycmF5XG4gICAgICovXG4gICAgYWJzdHJhY3QgZ2V0VGlsZShpbmRleDogbnVtYmVyKTogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGlsZVxuICAgICAqIEBwYXJhbSB0eXBlIFRoZSBuZXcgZGF0YSB2YWx1ZSBvZiB0aGUgdGlsZVxuICAgICAqL1xuICAgIGFic3RyYWN0IHNldFRpbGUoaW5kZXg6IG51bWJlciwgdHlwZTogbnVtYmVyKTogdm9pZDtcblxuICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkbid0IHVzZSB0aWxlZCBkYXRhIHNwZWNpZmljYWxseSAtIGl0IHNob3VsZCBiZSBtb3JlIGdlbmVyYWxcbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSB0aWxlc2V0IHVzaW5nIHRoZSBkYXRhIGxvYWRlZCBmcm9tIGZpbGVcbiAgICAgKiBAcGFyYW0gdGlsZW1hcERhdGEgVGhlIHRpbGVtYXAgZGF0YSBmcm9tIGZpbGVcbiAgICAgKiBAcGFyYW0gbGF5ZXIgVGhlIGxheWVyIGRhdGEgZnJvbSBmaWxlXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHBhcnNlVGlsZW1hcERhdGEodGlsZW1hcERhdGE6IFRpbGVkVGlsZW1hcERhdGEsIGxheWVyOiBUaWxlZExheWVyRGF0YSk6IHZvaWQ7XG59IiwiaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uL1RpbGVtYXBcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IHsgVGlsZWRUaWxlbWFwRGF0YSwgVGlsZWRMYXllckRhdGEgfSBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1RpbGVzZXRzL1RpbGVkRGF0YVwiO1xuaW1wb3J0IERlYnVnIGZyb20gXCIuLi8uLi9EZWJ1Zy9EZWJ1Z1wiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9VdGlscy9Db2xvclwiO1xuXG4vKipcbiAqIFRoZSByZXByZXNlbnRhdGlvbiBvZiBhbiBvcnRob2dvbmFsIHRpbGVtYXAgLSBpLmUuIGEgdG9wIGRvd24gb3IgcGxhdGZvcm1lciB0aWxlbWFwXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9ydGhvZ29uYWxUaWxlbWFwIGV4dGVuZHMgVGlsZW1hcCB7XG4gICAgLyoqIFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgdGlsZW1hcCAqL1xuICAgIHByb3RlY3RlZCBudW1Db2xzOiBudW1iZXI7XG4gICAgLyoqIFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgdGlsZW1hcCAqL1xuICAgIHByb3RlY3RlZCBudW1Sb3dzOiBudW1iZXI7XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBwcm90ZWN0ZWQgcGFyc2VUaWxlbWFwRGF0YSh0aWxlbWFwRGF0YTogVGlsZWRUaWxlbWFwRGF0YSwgbGF5ZXI6IFRpbGVkTGF5ZXJEYXRhKTogdm9pZCB7XG4gICAgICAgIC8vIFRoZSBzaXplIG9mIHRoZSB0aWxlbWFwIGluIGxvY2FsIHNwYWNlXG4gICAgICAgIHRoaXMubnVtQ29scyA9IHRpbGVtYXBEYXRhLndpZHRoO1xuICAgICAgICB0aGlzLm51bVJvd3MgPSB0aWxlbWFwRGF0YS5oZWlnaHQ7XG5cbiAgICAgICAgLy8gVGhlIHNpemUgb2YgdGlsZXNcbiAgICAgICAgdGhpcy50aWxlU2l6ZS5zZXQodGlsZW1hcERhdGEudGlsZXdpZHRoLCB0aWxlbWFwRGF0YS50aWxlaGVpZ2h0KTtcblxuICAgICAgICAvLyBUaGUgc2l6ZSBvZiB0aGUgdGlsZW1hcCBvbiB0aGUgY2FudmFzXG4gICAgICAgIHRoaXMuc2l6ZS5zZXQodGhpcy5udW1Db2xzICogdGhpcy50aWxlU2l6ZS54LCB0aGlzLm51bVJvd3MgKiB0aGlzLnRpbGVTaXplLnkpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uLmNvcHkodGhpcy5zaXplLnNjYWxlZCgwLjUpKTtcbiAgICAgICAgdGhpcy5kYXRhID0gbGF5ZXIuZGF0YTtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gbGF5ZXIudmlzaWJsZTtcblxuICAgICAgICAvLyBXaGV0aGVyIHRoZSB0aWxlbWFwIGlzIGNvbGxpZGFibGUgb3Igbm90XG4gICAgICAgIHRoaXMuaXNDb2xsaWRhYmxlID0gZmFsc2U7XG4gICAgICAgIGlmKGxheWVyLnByb3BlcnRpZXMpe1xuICAgICAgICAgICAgZm9yKGxldCBpdGVtIG9mIGxheWVyLnByb3BlcnRpZXMpe1xuICAgICAgICAgICAgICAgIGlmKGl0ZW0ubmFtZSA9PT0gXCJDb2xsaWRhYmxlXCIpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzQ29sbGlkYWJsZSA9IGl0ZW0udmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGFsbCB0aWxlcyBiZXNpZGVzIFwiZW1wdHk6IDBcIiB0byBiZSBjb2xsaWRhYmxlXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDE7IGkgPCB0aGlzLmNvbGxpc2lvbk1hcC5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbGxpc2lvbk1hcFtpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkaW1lbnNpb25zIG9mIHRoZSB0aWxlbWFwXG4gICAgICogQHJldHVybnMgQSBWZWMyIGNvbnRhaW5pbmcgdGhlIG51bWJlciBvZiBjb2x1bW5zIGFuZCB0aGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIHRpbGVtYXAuXG4gICAgICovXG4gICAgZ2V0RGltZW5zaW9ucygpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMubnVtQ29scywgdGhpcy5udW1Sb3dzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkYXRhIHZhbHVlIG9mIHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgd29ybGQgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gd29ybGRDb29yZHMgVGhlIGNvb3JkaW5hdGVzIGluIHdvcmxkIHNwYWNlXG4gICAgICogQHJldHVybnMgVGhlIGRhdGEgdmFsdWUgb2YgdGhlIHRpbGVcbiAgICAgKi9cbiAgICBnZXRUaWxlQXRXb3JsZFBvc2l0aW9uKHdvcmxkQ29vcmRzOiBWZWMyKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IGxvY2FsQ29vcmRzID0gdGhpcy5nZXRDb2xSb3dBdCh3b3JsZENvb3Jkcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFRpbGVBdFJvd0NvbChsb2NhbENvb3Jkcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgcm93IGFuZCBjb2x1bW5cbiAgICAgKiBAcGFyYW0gcm93Q29sIFRoZSBjb29yZGluYXRlcyBpbiB0aWxlbWFwIHNwYWNlXG4gICAgICogQHJldHVybnMgVGhlIGRhdGEgdmFsdWUgb2YgdGhlIHRpbGVcbiAgICAgKi9cbiAgICBnZXRUaWxlQXRSb3dDb2wocm93Q29sOiBWZWMyKTogbnVtYmVyIHtcbiAgICAgICAgaWYocm93Q29sLnggPCAwIHx8IHJvd0NvbC54ID49IHRoaXMubnVtQ29scyB8fCByb3dDb2wueSA8IDAgfHwgcm93Q29sLnkgPj0gdGhpcy5udW1Sb3dzKXtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbcm93Q29sLnkgKiB0aGlzLm51bUNvbHMgKyByb3dDb2wueF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgd29ybGQgcG9zaXRpb24gb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGVcbiAgICAgKiBAcmV0dXJucyBBIFZlYzIgY29udGFpbmluZyB0aGUgd29ybGQgcG9zaXRpb24gb2YgdGhlIHRpbGVcbiAgICAgKi9cbiAgICBnZXRUaWxlV29ybGRQb3NpdGlvbihpbmRleDogbnVtYmVyKTogVmVjMiB7XG4gICAgICAgIC8vIEdldCB0aGUgbG9jYWwgcG9zaXRpb25cbiAgICAgICAgbGV0IGNvbCA9IGluZGV4ICUgdGhpcy5udW1Db2xzO1xuICAgICAgICBsZXQgcm93ID0gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMubnVtQ29scyk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSB3b3JsZCBwb3NpdGlvblxuICAgICAgICBsZXQgeCA9IGNvbCAqIHRoaXMudGlsZVNpemUueDtcbiAgICAgICAgbGV0IHkgPSByb3cgKiB0aGlzLnRpbGVTaXplLnk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHgsIHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRhdGEgdmFsdWUgb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGVcbiAgICAgKiBAcmV0dXJucyBUaGUgZGF0YSB2YWx1ZSBvZiB0aGUgdGlsZVxuICAgICAqL1xuICAgIGdldFRpbGUoaW5kZXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbaW5kZXhdO1xuICAgIH1cblxuICAgIC8vIEBvdmVycmlkZVxuICAgIHNldFRpbGUoaW5kZXg6IG51bWJlciwgdHlwZTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGF0YVtpbmRleF0gPSB0eXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCByb3cgYW5kIGNvbHVtblxuICAgICAqIEBwYXJhbSByb3dDb2wgVGhlIHBvc2l0aW9uIG9mIHRoZSB0aWxlIGluIHRpbGVtYXAgc3BhY2VcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgbmV3IGRhdGEgdmFsdWUgb2YgdGhlIHRpbGVcbiAgICAgKi9cbiAgICBzZXRUaWxlQXRSb3dDb2wocm93Q29sOiBWZWMyLCB0eXBlOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgbGV0IGluZGV4ID0gcm93Q29sLnkgKiB0aGlzLm51bUNvbHMgKyByb3dDb2wueDtcbiAgICAgICAgdGhpcy5zZXRUaWxlKGluZGV4LCB0eXBlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCByb3cgYW5kIGNvbHVtbiBvZiB0aGUgdGlsZW1hcCBpcyBjb2xsaWRhYmxlXG4gICAgICogQHBhcmFtIGluZGV4T3JDb2wgVGhlIGluZGV4IG9mIHRoZSB0aWxlIG9yIHRoZSBjb2x1bW4gaXQgaXMgaW5cbiAgICAgKiBAcGFyYW0gcm93IFRoZSByb3cgdGhlIHRpbGUgaXMgaW5cbiAgICAgKiBAcmV0dXJucyBBIGZsYWcgcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoZSB0aWxlIGlzIGNvbGxpZGFibGUuXG4gICAgICovXG4gICAgaXNUaWxlQ29sbGlkYWJsZShpbmRleE9yQ29sOiBudW1iZXIsIHJvdz86IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICAvLyBUaGUgdmFsdWUgb2YgdGhlIHRpbGVcbiAgICAgICAgbGV0IHRpbGUgPSAwO1xuXG4gICAgICAgIGlmKHJvdyl7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIGEgY29sdW1uIGFuZCBhIHJvd1xuICAgICAgICAgICAgdGlsZSA9IHRoaXMuZ2V0VGlsZUF0Um93Q29sKG5ldyBWZWMyKGluZGV4T3JDb2wsIHJvdykpO1xuXG4gICAgICAgICAgICBpZih0aWxlIDwgMCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYoaW5kZXhPckNvbCA8IDAgfHwgaW5kZXhPckNvbCA+PSB0aGlzLmRhdGEubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAvLyBUaWxlcyB0aGF0IGRvbid0IGV4aXN0IGFyZW4ndCBjb2xsaWRhYmxlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgaGF2ZSBhbiBpbmRleFxuICAgICAgICAgICAgdGlsZSA9IHRoaXMuZ2V0VGlsZShpbmRleE9yQ29sKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNvbGxpc2lvbk1hcFt0aWxlXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBpbiB3b3JsZCBjb29yZGluYXRlcyBhbmQgcmV0dXJucyB0aGUgcm93IGFuZCBjb2x1bW4gb2YgdGhlIHRpbGUgYXQgdGhhdCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB3b3JsZENvb3JkcyBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvdGVudGlhbCB0aWxlIGluIHdvcmxkIHNwYWNlXG4gICAgICogQHJldHVybnMgQSBWZWMyIGNvbnRhaW5pbmcgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb3RlbnRpYWwgdGlsZSBpbiB0aWxlbWFwIHNwYWNlXG4gICAgICovXG4gICAgZ2V0Q29sUm93QXQod29ybGRDb29yZHM6IFZlYzIpOiBWZWMyIHtcbiAgICAgICAgbGV0IGNvbCA9IE1hdGguZmxvb3Iod29ybGRDb29yZHMueCAvIHRoaXMudGlsZVNpemUueCAvIHRoaXMuc2NhbGUueCk7XG4gICAgICAgIGxldCByb3cgPSBNYXRoLmZsb29yKHdvcmxkQ29vcmRzLnkgLyB0aGlzLnRpbGVTaXplLnkgLyB0aGlzLnNjYWxlLnkpO1xuXG4gICAgICAgIHJldHVybiBuZXcgVmVjMihjb2wsIHJvdyk7XG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7fVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgZGVidWdSZW5kZXIoKXtcbiAgICAgICAgLy8gSGFsZiBvZiB0aGUgdGlsZSBzaXplXG4gICAgICAgIGxldCB6b29tZWRIYWxmVGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplV2l0aFpvb20oKS5zY2FsZWQoMC41KTtcbiAgICAgICAgbGV0IGhhbGZUaWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKS5zY2FsZWQoMC41KTtcblxuICAgICAgICAvLyBUaGUgY2VudGVyIG9mIHRoZSB0b3AgbGVmdCB0aWxlXG4gICAgICAgIGxldCB0b3BMZWZ0ID0gdGhpcy5wb3NpdGlvbi5jbG9uZSgpLnN1Yih0aGlzLnNpemUuc2NhbGVkKDAuNSkpO1xuICAgICAgICBcbiAgICAgICAgLy8gQSB2ZWMgdG8gc3RvcmUgdGhlIGNlbnRlclxuICAgICAgICBsZXQgY2VudGVyID0gVmVjMi5aRVJPO1xuXG4gICAgICAgIGZvcihsZXQgY29sID0gMDsgY29sIDwgdGhpcy5udW1Db2xzOyBjb2wrKyl7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHgtcG9zaXRpb25cbiAgICAgICAgICAgIGNlbnRlci54ID0gdG9wTGVmdC54ICsgY29sKjIqaGFsZlRpbGVTaXplLnggKyBoYWxmVGlsZVNpemUueDtcblxuICAgICAgICAgICAgZm9yKGxldCByb3cgPSAwOyByb3cgPCB0aGlzLm51bVJvd3M7IHJvdysrKXtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmlzQ29sbGlkYWJsZSAmJiB0aGlzLmlzVGlsZUNvbGxpZGFibGUoY29sLCByb3cpKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB5LXBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNlbnRlci55ID0gdG9wTGVmdC55ICsgcm93KjIqaGFsZlRpbGVTaXplLnkgKyBoYWxmVGlsZVNpemUueTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBEcmF3IGEgYm94IGZvciB0aGlzIHRpbGVcbiAgICAgICAgICAgICAgICAgICAgRGVidWcuZHJhd0JveCh0aGlzLmluUmVsYXRpdmVDb29yZGluYXRlcyhjZW50ZXIpLCB6b29tZWRIYWxmVGlsZVNpemUsIGZhbHNlLCBDb2xvci5CTFVFKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4vQ2FudmFzTm9kZVwiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uL0lucHV0L0lucHV0XCI7XHJcblxyXG4vKipcclxuICogVGhlIHJlcHJlc2VudGF0aW9uIG9mIGEgVUlFbGVtZW50IC0gdGhlIHBhcmVudCBjbGFzcyBvZiB0aGluZ3MgbGlrZSBidXR0b25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBVSUVsZW1lbnQgZXh0ZW5kcyBDYW52YXNOb2RlIHtcclxuXHQvLyBTdHlsZSBhdHRyaWJ1dGVzIC0gVE9ETyAtIGFic3RyYWN0IHRoaXMgaW50byBhIHN0eWxlIG9iamVjdC9pbnRlcmZhY2VcclxuXHQvKiogVGhlIGJhY2tnb3VuZCBjb2xvciAqL1xyXG5cdGJhY2tncm91bmRDb2xvcjogQ29sb3I7XHJcblx0LyoqIFRoZSBib3JkZXIgY29sb3IgKi9cclxuXHRib3JkZXJDb2xvcjogQ29sb3I7XHJcblx0LyoqIFRoZSBib3JkZXIgcmFkaXVzICovXHJcblx0Ym9yZGVyUmFkaXVzOiBudW1iZXI7XHJcblx0LyoqIFRoZSBib3JkZXIgd2lkdGggKi9cclxuXHRib3JkZXJXaWR0aDogbnVtYmVyO1xyXG5cdC8qKiBUaGUgcGFkZGluZyAqL1xyXG5cdHBhZGRpbmc6IFZlYzI7XHJcblxyXG5cdC8vIEV2ZW50QXR0cmlidXRlc1xyXG5cdC8qKiBUaGUgcmVhY3Rpb24gb2YgdGhpcyBVSUVsZW1lbnQgb24gYSBjbGljayAqL1xyXG5cdG9uQ2xpY2s6IEZ1bmN0aW9uO1xyXG5cdC8qKiBUaGUgZXZlbnQgcHJvcGFnYXRlZCBvbiBjbGljayAqL1xyXG5cdG9uQ2xpY2tFdmVudElkOiBzdHJpbmc7XHJcblx0LyoqIFRoZSByZWFjdGlvbiB0byB0aGUgcmVsZWFzZSBvZiBhIGNsaWNrICovXHJcblx0b25SZWxlYXNlOiBGdW5jdGlvbjtcclxuXHQvKiogVGhlIGV2ZW50IHByb3BhZ2F0ZWQgb24gdGhlIHJlbGVhc2Ugb2YgYSBjbGljayAqL1xyXG5cdG9uUmVsZWFzZUV2ZW50SWQ6IHN0cmluZztcclxuXHQvKiogVGhlIHJlYWN0aW9uIHdoZW4gYSBtb3VzZSBlbnRlcnMgdGhpcyBVSUVsZW1lbnQgKi9cclxuXHRvbkVudGVyOiBGdW5jdGlvbjtcclxuXHQvKiogVGhlIGV2ZW50IHByb3BhZ2F0ZWQgd2hlbiBhIG1vdXNlIGVudGVycyB0aGlzIFVJRWxlbWVudCAqL1xyXG5cdG9uRW50ZXJFdmVudElkOiBzdHJpbmc7XHJcblx0LyoqIFRoZSByZWFjdGlvbiB3aGVuIGEgbW91c2UgbGVhdmVzIHRoaXMgVUlFbGVtZW50ICovXHJcblx0b25MZWF2ZTogRnVuY3Rpb247XHJcblx0LyoqIFRoZSBldmVudCBwcm9wb2dhdGVkIHdoZW4gYSBtb3VzZSBsZWF2ZXMgdGhpcyBVSUVsZW1lbnQgKi9cclxuXHRvbkxlYXZlRXZlbnRJZDogc3RyaW5nO1xyXG4gXHJcblx0LyoqIFdoZXRoZXIgb3Igbm90IHRoaXMgVUlFbGVtZW50IGlzIGN1cnJlbnRseSBjbGlja2VkIG9uICovXHJcblx0cHJvdGVjdGVkIGlzQ2xpY2tlZDogYm9vbGVhbjtcclxuXHQvKiogV2hldGhlciBvciBub3QgdGhpcyBVSUVsZW1lbnQgaXMgY3VycmVudGx5IGhvdmVyZWQgb3ZlciAqL1xyXG5cdHByb3RlY3RlZCBpc0VudGVyZWQ6IGJvb2xlYW47XHJcblxyXG5cdGNvbnN0cnVjdG9yKHBvc2l0aW9uOiBWZWMyKXtcclxuXHRcdHN1cGVyKCk7XHJcblx0XHR0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XHJcblx0XHRcclxuXHRcdHRoaXMuYmFja2dyb3VuZENvbG9yID0gbmV3IENvbG9yKDAsIDAsIDAsIDApO1xyXG5cdFx0dGhpcy5ib3JkZXJDb2xvciA9IG5ldyBDb2xvcigwLCAwLCAwLCAwKTtcclxuXHRcdHRoaXMuYm9yZGVyUmFkaXVzID0gNTtcclxuXHRcdHRoaXMuYm9yZGVyV2lkdGggPSAxO1xyXG5cdFx0dGhpcy5wYWRkaW5nID0gVmVjMi5aRVJPO1xyXG5cclxuXHRcdHRoaXMub25DbGljayA9IG51bGw7XHJcblx0XHR0aGlzLm9uQ2xpY2tFdmVudElkID0gbnVsbDtcclxuXHRcdHRoaXMub25SZWxlYXNlID0gbnVsbDtcclxuXHRcdHRoaXMub25SZWxlYXNlRXZlbnRJZCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5vbkVudGVyID0gbnVsbDtcclxuXHRcdHRoaXMub25FbnRlckV2ZW50SWQgPSBudWxsO1xyXG5cdFx0dGhpcy5vbkxlYXZlID0gbnVsbDtcclxuXHRcdHRoaXMub25MZWF2ZUV2ZW50SWQgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuaXNDbGlja2VkID0gZmFsc2U7XHJcblx0XHR0aGlzLmlzRW50ZXJlZCA9IGZhbHNlO1xyXG5cdH1cclxuXHJcblx0Ly8gQGRlcHJlY2F0ZWRcclxuXHRzZXRCYWNrZ3JvdW5kQ29sb3IoY29sb3I6IENvbG9yKTogdm9pZCB7XHJcblx0XHR0aGlzLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO1xyXG5cdH1cclxuXHJcblx0Ly8gQGRlcHJlY2F0ZWRcclxuXHRzZXRQYWRkaW5nKHBhZGRpbmc6IFZlYzIpOiB2b2lkIHtcclxuXHRcdHRoaXMucGFkZGluZy5jb3B5KHBhZGRpbmcpO1xyXG5cdH1cclxuXHRzZXRQb3NpdGlvbihwb3NpdGlvbjogVmVjMik6IHZvaWR7XHJcblx0XHR0aGlzLnBvc2l0aW9uID0gcG9zaXRpb25cclxuXHR9XHJcblx0dXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRzdXBlci51cGRhdGUoZGVsdGFUKTtcclxuXHJcblx0XHQvLyBTZWUgb2YgdGhpcyBvYmplY3Qgd2FzIGp1c3QgY2xpY2tlZFxyXG5cdFx0aWYoSW5wdXQuaXNNb3VzZUp1c3RQcmVzc2VkKCkpe1xyXG5cdFx0XHRsZXQgY2xpY2tQb3MgPSBJbnB1dC5nZXRNb3VzZVByZXNzUG9zaXRpb24oKTtcclxuXHRcdFx0aWYodGhpcy5jb250YWlucyhjbGlja1Bvcy54LCBjbGlja1Bvcy55KSAmJiB0aGlzLnZpc2libGUgJiYgIXRoaXMubGF5ZXIuaXNIaWRkZW4oKSl7XHJcblx0XHRcdFx0dGhpcy5pc0NsaWNrZWQgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRpZih0aGlzLm9uQ2xpY2sgIT09IG51bGwpe1xyXG5cdFx0XHRcdFx0dGhpcy5vbkNsaWNrKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHRoaXMub25DbGlja0V2ZW50SWQgIT09IG51bGwpe1xyXG5cdFx0XHRcdFx0bGV0IGRhdGEgPSB7fTtcclxuXHRcdFx0XHRcdHRoaXMuZW1pdHRlci5maXJlRXZlbnQodGhpcy5vbkNsaWNrRXZlbnRJZCwgZGF0YSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSWYgdGhlIG1vdXNlIHdhc24ndCBqdXN0IHByZXNzZWQsIHRoZW4gd2UgZGVmaW5pdGVseSB3ZXJlbid0IGNsaWNrZWRcclxuXHRcdGlmKCFJbnB1dC5pc01vdXNlUHJlc3NlZCgpKXtcclxuXHRcdFx0aWYodGhpcy5pc0NsaWNrZWQpe1xyXG5cdFx0XHRcdHRoaXMuaXNDbGlja2VkID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBDaGVjayBpZiB0aGUgbW91c2UgaXMgaG92ZXJpbmcgb3ZlciB0aGlzIGVsZW1lbnRcclxuXHRcdGxldCBtb3VzZVBvcyA9IElucHV0LmdldE1vdXNlUG9zaXRpb24oKTtcclxuXHRcdGlmKG1vdXNlUG9zICYmIHRoaXMuY29udGFpbnMobW91c2VQb3MueCwgbW91c2VQb3MueSkpe1xyXG5cdFx0XHR0aGlzLmlzRW50ZXJlZCA9IHRydWU7XHJcblxyXG5cdFx0XHRpZih0aGlzLm9uRW50ZXIgIT09IG51bGwpe1xyXG5cdFx0XHRcdHRoaXMub25FbnRlcigpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKHRoaXMub25FbnRlckV2ZW50SWQgIT09IG51bGwpe1xyXG5cdFx0XHRcdGxldCBkYXRhID0ge307XHJcblx0XHRcdFx0dGhpcy5lbWl0dGVyLmZpcmVFdmVudCh0aGlzLm9uRW50ZXJFdmVudElkLCBkYXRhKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZih0aGlzLmlzRW50ZXJlZCkge1xyXG5cdFx0XHR0aGlzLmlzRW50ZXJlZCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0aWYodGhpcy5vbkxlYXZlICE9PSBudWxsKXtcclxuXHRcdFx0XHR0aGlzLm9uTGVhdmUoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZih0aGlzLm9uTGVhdmVFdmVudElkICE9PSBudWxsKXtcclxuXHRcdFx0XHRsZXQgZGF0YSA9IHt9O1xyXG5cdFx0XHRcdHRoaXMuZW1pdHRlci5maXJlRXZlbnQodGhpcy5vbkxlYXZlRXZlbnRJZCwgZGF0YSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZih0aGlzLmlzQ2xpY2tlZCkge1xyXG5cdFx0XHQvLyBJZiBtb3VzZSBpcyBkcmFnZ2VkIG9mZiBvZiBlbGVtZW50IHdoaWxlIGRvd24sIGl0IGlzIG5vdCBjbGlja2VkIGFueW1vcmVcclxuXHRcdFx0dGhpcy5pc0NsaWNrZWQgPSBmYWxzZTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIE92ZXJyaWRhYmxlIG1ldGhvZCBmb3IgY2FsY3VsYXRpbmcgYmFja2dyb3VuZCBjb2xvciAtIHVzZWZ1bCBmb3IgZWxlbWVudHMgdGhhdCB3YW50IHRvIGJlIGNvbG9yZWQgb24gZGlmZmVyZW50IGFmdGVyIGNlcnRhaW4gZXZlbnRzXHJcblx0ICogQHJldHVybnMgVGhlIGJhY2tncm91bmQgY29sb3Igb2YgdGhlIFVJRWxlbWVudFxyXG5cdCAqL1xyXG5cdGNhbGN1bGF0ZUJhY2tncm91bmRDb2xvcigpOiBDb2xvciB7XHJcblx0XHRyZXR1cm4gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBPdmVycmlkYWJsZSBtZXRob2QgZm9yIGNhbGN1bGF0aW5nIGJvcmRlciBjb2xvciAtIHVzZWZ1bCBmb3IgZWxlbWVudHMgdGhhdCB3YW50IHRvIGJlIGNvbG9yZWQgb24gZGlmZmVyZW50IGFmdGVyIGNlcnRhaW4gZXZlbnRzXHJcblx0ICogQHJldHVybnMgVGhlIGJvcmRlciBjb2xvciBvZiB0aGUgVUlFbGVtZW50XHJcblx0ICovXHJcblx0Y2FsY3VsYXRlQm9yZGVyQ29sb3IoKTogQ29sb3Ige1xyXG5cdFx0cmV0dXJuIHRoaXMuYm9yZGVyQ29sb3I7XHJcblx0fVxyXG59IiwiaW1wb3J0IExhYmVsIGZyb20gXCIuL0xhYmVsXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1V0aWxzL0NvbG9yXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcblxuLyoqIEEgY2xpY2thYmxlIGJ1dHRvbiBVSUVsZW1lbnQgKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ1dHRvbiBleHRlbmRzIExhYmVsIHtcblxuXHRjb25zdHJ1Y3Rvcihwb3NpdGlvbjogVmVjMiwgdGV4dDogc3RyaW5nKXtcblx0XHRzdXBlcihwb3NpdGlvbiwgdGV4dCk7XG5cdFx0XG5cdFx0dGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBuZXcgQ29sb3IoMTUwLCA3NSwgMjAzKTtcblx0XHR0aGlzLmJvcmRlckNvbG9yID0gbmV3IENvbG9yKDQxLCA0NiwgMzApO1xuXHRcdHRoaXMudGV4dENvbG9yID0gbmV3IENvbG9yKDI1NSwgMjU1LCAyNTUpO1xuXHR9XG5cblx0Ly8gQG92ZXJyaWRlXG5cdGNhbGN1bGF0ZUJhY2tncm91bmRDb2xvcigpOiBDb2xvciB7XG5cdFx0Ly8gQ2hhbmdlIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIGlmIGNsaWNrZWQgb3IgaG92ZXJlZFxuXHRcdGlmKHRoaXMuaXNFbnRlcmVkICYmICF0aGlzLmlzQ2xpY2tlZCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5iYWNrZ3JvdW5kQ29sb3IubGlnaHRlbigpO1xuXHRcdH0gZWxzZSBpZih0aGlzLmlzQ2xpY2tlZCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5iYWNrZ3JvdW5kQ29sb3IuZGFya2VuKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLmJhY2tncm91bmRDb2xvcjtcblx0XHR9XG5cdH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9VdGlscy9Db2xvclwiO1xyXG5pbXBvcnQgVUlFbGVtZW50IGZyb20gXCIuLi9VSUVsZW1lbnRcIjtcclxuXHJcbi8qKiBBIGJhc2ljIHRleHQtY29udGFpbmluZyBsYWJlbCAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYWJlbCBleHRlbmRzIFVJRWxlbWVudHtcclxuXHQvKiogVGhlIGNvbG9yIG9mIHRoZSB0ZXh0IG9mIHRoaXMgVUlFbGVtZW50ICovXHJcblx0dGV4dENvbG9yOiBDb2xvcjtcclxuXHQvKiogVGhlIHZhbHVlIG9mIHRoZSB0ZXh0IG9mIHRoaXMgVUlFbGVtZW50ICovXHJcblx0dGV4dDogc3RyaW5nO1xyXG5cdC8qKiBUaGUgbmFtZSBvZiB0aGUgZm9udCAqL1xyXG5cdGZvbnQ6IHN0cmluZztcclxuXHQvKiogVGhlIHNpemUgb2YgdGhlIGZvbnQgKi9cclxuXHRmb250U2l6ZTogbnVtYmVyO1xyXG5cdC8qKiBUaGUgaG9yaXpvbnRhbCBhbGlnbm1lbnQgb2YgdGhlIHRleHQgd2l0aGluIHRoZSBsYWJlbCAqL1xyXG5cdHByb3RlY3RlZCBoQWxpZ246IHN0cmluZztcclxuXHQvKiogVGhlIHZlcnRpY2FsIGFsaWdubWVudCBvZiB0ZXh0IHdpdGhpbiB0aGUgbGFiZWwgKi9cclxuXHRwcm90ZWN0ZWQgdkFsaWduOiBzdHJpbmc7XHJcblxyXG5cclxuXHQvKiogQSBmbGFnIGZvciBpZiB0aGUgd2lkdGggb2YgdGhlIHRleHQgaGFzIGJlZW4gbWVhc3VyZWQgb24gdGhlIGNhbnZhcyBmb3IgYXV0byB3aWR0aCBhc3NpZ25tZW50ICovXHJcblx0cHJvdGVjdGVkIHNpemVBc3NpZ25lZDogYm9vbGVhbjtcclxuXHJcblx0Y29uc3RydWN0b3IocG9zaXRpb246IFZlYzIsIHRleHQ6IHN0cmluZyl7XHJcblx0XHRzdXBlcihwb3NpdGlvbik7XHJcblx0XHR0aGlzLnRleHQgPSB0ZXh0O1xyXG5cdFx0dGhpcy50ZXh0Q29sb3IgPSBuZXcgQ29sb3IoMCwgMCwgMCwgMSk7XHJcblx0XHR0aGlzLmZvbnQgPSBcIkZhbnRhc3lcIjtcclxuXHRcdHRoaXMuZm9udFNpemUgPSAzMDtcclxuXHRcdHRoaXMuaEFsaWduID0gXCJjZW50ZXJcIjtcclxuXHRcdHRoaXMudkFsaWduID0gXCJjZW50ZXJcIjtcclxuXHJcblx0XHR0aGlzLnNpemVBc3NpZ25lZCA9IGZhbHNlO1xyXG5cdH1cclxuXHJcblx0Ly8gQGRlcHJlY2F0ZWRcclxuXHRzZXRUZXh0KHRleHQ6IHN0cmluZyk6IHZvaWQge1xyXG5cdFx0dGhpcy50ZXh0ID0gdGV4dDtcclxuXHR9XHJcblxyXG5cdC8vIEBkZXByZWNhdGVkXHJcblx0c2V0VGV4dENvbG9yKGNvbG9yOiBDb2xvcik6IHZvaWQge1xyXG5cdFx0dGhpcy50ZXh0Q29sb3IgPSBjb2xvcjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgYSBzdHJpbmcgY29udGFpbmcgdGhlIGZvbnQgZGV0YWlscyBmb3IgcmVuZGVyaW5nXHJcblx0ICogQHJldHVybnMgQSBzdHJpbmcgY29udGFpbmluZyB0aGUgZm9udCBkZXRhaWxzXHJcblx0ICovXHJcblx0Z2V0Rm9udFN0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuZm9udFNpemUgKyBcInB4IFwiICsgdGhpcy5mb250O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogT3ZlcnJpZGFibGUgbWV0aG9kIGZvciBjYWxjdWxhdGluZyB0ZXh0IGNvbG9yIC0gdXNlZnVsIGZvciBlbGVtZW50cyB0aGF0IHdhbnQgdG8gYmUgY29sb3JlZCBvbiBkaWZmZXJlbnQgYWZ0ZXIgY2VydGFpbiBldmVudHNcclxuXHQgKiBAcmV0dXJucyBhIHN0cmluZyBjb250YWluZyB0aGUgdGV4dCBjb2xvclxyXG5cdCAqL1xyXG5cdGNhbGN1bGF0ZVRleHRDb2xvcigpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMudGV4dENvbG9yLnRvU3RyaW5nUkdCQSgpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVXNlcyB0aGUgY2FudmFzIHRvIGNhbGN1bGF0ZSB0aGUgd2lkdGggb2YgdGhlIHRleHRcclxuXHQgKiBAcGFyYW0gY3R4IFRoZSByZW5kZXJpbmcgY29udGV4dFxyXG5cdCAqIEByZXR1cm5zIEEgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgcmVuZGVyZWQgdGV4dCB3aWR0aFxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBjYWxjdWxhdGVUZXh0V2lkdGgoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpOiBudW1iZXIge1xyXG5cdFx0Y3R4LmZvbnQgPSB0aGlzLmZvbnRTaXplICsgXCJweCBcIiArIHRoaXMuZm9udDtcclxuXHRcdHJldHVybiBjdHgubWVhc3VyZVRleHQodGhpcy50ZXh0KS53aWR0aDtcclxuXHR9XHJcblxyXG5cdHNldEhBbGlnbihhbGlnbjogc3RyaW5nKTogdm9pZCB7XHJcblx0XHR0aGlzLmhBbGlnbiA9IGFsaWduO1xyXG5cdH1cclxuXHJcblx0c2V0VkFsaWduKGFsaWduOiBzdHJpbmcpOiB2b2lkIHtcclxuXHRcdHRoaXMudkFsaWduID0gYWxpZ247XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDYWxjdWxhdGUgdGhlIG9mZnNldCBvZiB0aGUgdGV4dCAtIHRoaXMgaXMgdXNlZCBmb3IgcmVuZGVyaW5nIHRleHQgd2l0aCBkaWZmZXJlbnQgYWxpZ25tZW50c1xyXG5cdCAqIEBwYXJhbSBjdHggVGhlIHJlbmRlcmluZyBjb250ZXh0XHJcblx0ICogQHJldHVybnMgVGhlIG9mZnNldCBvZiB0aGUgdGV4dCBpbiBhIFZlYzJcclxuXHQgKi9cclxuXHRjYWxjdWxhdGVUZXh0T2Zmc2V0KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogVmVjMiB7XHJcblx0XHRsZXQgdGV4dFdpZHRoID0gdGhpcy5jYWxjdWxhdGVUZXh0V2lkdGgoY3R4KTtcclxuXHJcblx0XHRsZXQgb2Zmc2V0ID0gbmV3IFZlYzIoMCwgMCk7XHJcblxyXG5cdFx0bGV0IGhEaWZmID0gdGhpcy5zaXplLnggLSB0ZXh0V2lkdGg7XHJcblx0XHRpZih0aGlzLmhBbGlnbiA9PT0gSEFsaWduLkNFTlRFUil7XHJcblx0XHRcdG9mZnNldC54ID0gaERpZmYvMjtcclxuXHRcdH0gZWxzZSBpZiAodGhpcy5oQWxpZ24gPT09IEhBbGlnbi5SSUdIVCl7XHJcblx0XHRcdG9mZnNldC54ID0gaERpZmY7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYodGhpcy52QWxpZ24gPT09IFZBbGlnbi5UT1Ape1xyXG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gXCJ0b3BcIjtcclxuXHRcdFx0b2Zmc2V0LnkgPSAwO1xyXG5cdFx0fSBlbHNlIGlmICh0aGlzLnZBbGlnbiA9PT0gVkFsaWduLkJPVFRPTSl7XHJcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSBcImJvdHRvbVwiO1xyXG5cdFx0XHRvZmZzZXQueSA9IHRoaXMuc2l6ZS55O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XHJcblx0XHRcdG9mZnNldC55ID0gdGhpcy5zaXplLnkvMjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gb2Zmc2V0O1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIHNpemVDaGFuZ2VkKCk6IHZvaWQge1xyXG5cdFx0c3VwZXIuc2l6ZUNoYW5nZWQoKTtcclxuXHRcdHRoaXMuc2l6ZUFzc2lnbmVkID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEF1dG9tYXRpY2FsbHkgc2l6ZXMgdGhlIGVsZW1lbnQgdG8gdGhlIHRleHQgd2l0aGluIGl0XHJcblx0ICogQHBhcmFtIGN0eCBUaGUgcmVuZGVyaW5nIGNvbnRleHRcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgYXV0b1NpemUoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpOiB2b2lkIHtcclxuXHRcdGxldCB3aWR0aCA9IHRoaXMuY2FsY3VsYXRlVGV4dFdpZHRoKGN0eCk7XHJcblx0XHRsZXQgaGVpZ2h0ID0gdGhpcy5mb250U2l6ZTtcclxuXHRcdHRoaXMuc2l6ZS5zZXQod2lkdGggKyB0aGlzLnBhZGRpbmcueCoyLCBoZWlnaHQgKyB0aGlzLnBhZGRpbmcueSoyKTtcclxuXHRcdHRoaXMuc2l6ZUFzc2lnbmVkID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluaXRpYWxseSBhc3NpZ25zIGEgc2l6ZSB0byB0aGUgVUlFbGVtZW50IGlmIG5vbmUgaXMgcHJvdmlkZWRcclxuXHQgKiBAcGFyYW0gY3R4IFRoZSByZW5kZXJpbmcgY29udGV4dFxyXG5cdCAqL1xyXG5cdGhhbmRsZUluaXRpYWxTaXppbmcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpOiB2b2lkIHtcclxuXHRcdGlmKCF0aGlzLnNpemVBc3NpZ25lZCl7XHJcblx0XHRcdHRoaXMuYXV0b1NpemUoY3R4KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKiBPbiB0aGUgbmV4dCByZW5kZXIsIHNpemUgdGhpcyBlbGVtZW50IHRvIGl0J3MgY3VycmVudCB0ZXh0IHVzaW5nIGl0cyBjdXJyZW50IGZvbnQgc2l6ZSAqL1xyXG5cdHNpemVUb1RleHQoKTogdm9pZCB7XHJcblx0XHR0aGlzLnNpemVBc3NpZ25lZCA9IGZhbHNlO1xyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGVudW0gVkFsaWduIHtcclxuXHRUT1AgPSBcInRvcFwiLFxyXG5cdENFTlRFUiA9IFwiY2VudGVyXCIsXHJcblx0Qk9UVE9NID0gXCJib3R0b21cIlxyXG59XHJcblxyXG5leHBvcnQgZW51bSBIQWxpZ24ge1xyXG5cdExFRlQgPSBcImxlZnRcIixcclxuXHRDRU5URVIgPSBcImNlbnRlclwiLFxyXG5cdFJJR0hUID0gXCJyaWdodFwiXHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBJbnB1dCBmcm9tIFwiLi4vLi4vSW5wdXQvSW5wdXRcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vVXRpbHMvQ29sb3JcIjtcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uLy4uL1V0aWxzL01hdGhVdGlsc1wiO1xuaW1wb3J0IFVJRWxlbWVudCBmcm9tIFwiLi4vVUlFbGVtZW50XCI7XG5cbi8qKiBBIHNsaWRlciBVSUVsZW1lbnQgKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNsaWRlciBleHRlbmRzIFVJRWxlbWVudCB7XG4gICAgLyoqIFRoZSB2YWx1ZSBvZiB0aGUgc2xpZGVyIGZyb20gWzAsIDFdICovXG4gICAgcHJvdGVjdGVkIHZhbHVlOiBudW1iZXI7XG4gICAgLyoqIFRoZSBjb2xvciBvZiB0aGUgc2xpZGVyIG5pYiAqL1xuICAgIHB1YmxpYyBuaWJDb2xvcjogQ29sb3I7XG4gICAgLyoqIFRoZSBzaXplIG9mIHRoZSBuaWIgKi9cbiAgICBwdWJsaWMgbmliU2l6ZTogVmVjMjtcbiAgICAvKiogVGhlIGNvbG9yIG9mIHRoZSBzbGlkZXIgdHJhY2sgKi9cbiAgICBwdWJsaWMgc2xpZGVyQ29sb3I6IENvbG9yO1xuICAgIC8qKiBUaGUgcmVhY3Rpb24gb2YgdGhpcyBVSUVsZW1lbnQgdG8gYSB2YWx1ZSBjaGFuZ2UgKi9cbiAgICBwdWJsaWMgb25WYWx1ZUNoYW5nZTogRnVuY3Rpb247XG4gICAgLyoqIFRoZSBldmVudCBwcm9wYWdhdGVkIGJ5IHRoaXMgVUlFbGVtZW50IHdoZW4gdmFsdWUgY2hhbmdlcyAqL1xuICAgIHB1YmxpYyBvblZhbHVlQ2hhbmdlRXZlbnRJZDogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocG9zaXRpb246IFZlYzIsIGluaXRWYWx1ZTogbnVtYmVyKXtcbiAgICAgICAgc3VwZXIocG9zaXRpb24pO1xuXG4gICAgICAgIHRoaXMudmFsdWUgPSBpbml0VmFsdWU7XG4gICAgICAgIHRoaXMubmliQ29sb3IgPSBDb2xvci5SRUQ7XG4gICAgICAgIHRoaXMuc2xpZGVyQ29sb3IgPSBDb2xvci5CTEFDSztcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcbiAgICAgICAgdGhpcy5ib3JkZXJDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xuICAgICAgICB0aGlzLm5pYlNpemUgPSBuZXcgVmVjMigxMCwgMjApO1xuXG4gICAgICAgIC8vIFNldCBhIGRlZmF1bHQgc2l6ZVxuICAgICAgICB0aGlzLnNpemUuc2V0KDIwMCwgMjApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdmFsdWUgb2YgdGhlIHNsaWRlclxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgc2xpZGVyXG4gICAgICovXG4gICAgZ2V0VmFsdWUoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuXG4gICAgLyoqIEEgbWV0aG9kIGNhbGxlZCBpbiByZXNwb25zZSB0byB0aGUgdmFsdWUgY2hhbmdpbmcgKi9cbiAgICBwcm90ZWN0ZWQgdmFsdWVDaGFuZ2VkKCk6IHZvaWQge1xuICAgICAgICBpZih0aGlzLm9uVmFsdWVDaGFuZ2Upe1xuICAgICAgICAgICAgdGhpcy5vblZhbHVlQ2hhbmdlKHRoaXMudmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5vblZhbHVlQ2hhbmdlRXZlbnRJZCl7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KHRoaXMub25WYWx1ZUNoYW5nZUV2ZW50SWQsIHt0YXJnZXQ6IHRoaXMsIHZhbHVlOiB0aGlzLnZhbHVlfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgc3VwZXIudXBkYXRlKGRlbHRhVCk7XG5cbiAgICAgICAgaWYodGhpcy5pc0NsaWNrZWQpe1xuICAgICAgICAgICAgbGV0IHZhbCA9IE1hdGhVdGlscy5pbnZMZXJwKHRoaXMucG9zaXRpb24ueCAtIHRoaXMuc2l6ZS54LzIsIHRoaXMucG9zaXRpb24ueCArIHRoaXMuc2l6ZS54LzIsIElucHV0LmdldE1vdXNlUG9zaXRpb24oKS54KTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBNYXRoVXRpbHMuY2xhbXAwMSh2YWwpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vVXRpbHMvQ29sb3JcIjtcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi9MYWJlbFwiO1xuaW1wb3J0IElucHV0IGZyb20gXCIuLi8uLi9JbnB1dC9JbnB1dFwiO1xuXG4vKiogQSB0ZXh0IGlucHV0IFVJRWxlbWVudCAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dElucHV0IGV4dGVuZHMgTGFiZWwge1xuICAgIC8qKiBBIGZsYWcgdGhlIHJlcHJlc2VudHMgd2hldGhlciB0aGUgdXNlciBjYW4gdHlwZSBpbiB0aGlzIFRleHRJbnB1dCAqL1xuICAgIGZvY3VzZWQ6IGJvb2xlYW47XG4gICAgLyoqIFRoZSBwb3NpdGlvbiBvZiB0aGUgY3Vyc29yIGluIHRoaXMgVGV4dElucHV0ICovXG4gICAgY3Vyc29yQ291bnRlcjogbnVtYmVyO1xuXG4gICAgY29uc3RydWN0b3IocG9zaXRpb246IFZlYzIpe1xuICAgICAgICBzdXBlcihwb3NpdGlvbiwgXCJcIik7XG5cbiAgICAgICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3Vyc29yQ291bnRlciA9IDA7XG5cbiAgICAgICAgLy8gR2l2ZSBhIGRlZmF1bHQgc2l6ZSB0byB0aGUgeCBvbmx5XG4gICAgICAgIHRoaXMuc2l6ZS5zZXQoMjAwLCB0aGlzLmZvbnRTaXplKTtcbiAgICAgICAgdGhpcy5oQWxpZ24gPSBcImxlZnRcIjtcblxuICAgICAgICB0aGlzLmJvcmRlckNvbG9yID0gQ29sb3IuQkxBQ0s7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gQ29sb3IuV0hJVEU7XG4gICAgfVxuXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLnVwZGF0ZShkZWx0YVQpO1xuXG4gICAgICAgIGlmKElucHV0LmlzTW91c2VKdXN0UHJlc3NlZCgpKXtcblx0XHRcdGxldCBjbGlja1BvcyA9IElucHV0LmdldE1vdXNlUHJlc3NQb3NpdGlvbigpO1xuXHRcdFx0aWYodGhpcy5jb250YWlucyhjbGlja1Bvcy54LCBjbGlja1Bvcy55KSl7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvckNvdW50ZXIgPSAzMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLmZvY3VzZWQpe1xuICAgICAgICAgICAgbGV0IGtleXMgPSBJbnB1dC5nZXRLZXlzSnVzdFByZXNzZWQoKTtcbiAgICAgICAgICAgIGxldCBudW1zID0gXCIxMjM0NTY3ODkwXCI7XG4gICAgICAgICAgICBsZXQgc3BlY2lhbENoYXJzID0gXCJgfiFAIyQlXiYqKCktXz0rW3tdfVxcXFx8OzonXFxcIiw8Lj4vP1wiO1xuICAgICAgICAgICAgbGV0IGxldHRlcnMgPSBcInF3ZXJ0eXVpb3Bhc2RmZ2hqa2x6eGN2Ym5tXCI7XG4gICAgICAgICAgICBsZXQgbWFzayA9IG51bXMgKyBzcGVjaWFsQ2hhcnMgKyBsZXR0ZXJzO1xuICAgICAgICAgICAga2V5cyA9IGtleXMuZmlsdGVyKGtleSA9PiBtYXNrLmluY2x1ZGVzKGtleSkpO1xuICAgICAgICAgICAgbGV0IHNoaWZ0UHJlc3NlZCA9IElucHV0LmlzS2V5UHJlc3NlZChcInNoaWZ0XCIpO1xuICAgICAgICAgICAgbGV0IGJhY2tzcGFjZVByZXNzZWQgPSBJbnB1dC5pc0tleUp1c3RQcmVzc2VkKFwiYmFja3NwYWNlXCIpO1xuICAgICAgICAgICAgbGV0IHNwYWNlUHJlc3NlZCA9IElucHV0LmlzS2V5SnVzdFByZXNzZWQoXCJzcGFjZVwiKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoYmFja3NwYWNlUHJlc3NlZCl7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy50ZXh0LnN1YnN0cmluZygwLCB0aGlzLnRleHQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYoc3BhY2VQcmVzc2VkKXtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQgKz0gXCIgXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYoa2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYoc2hpZnRQcmVzc2VkKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0ICs9IGtleXNbMF0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHQgKz0ga2V5c1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59IiwiZXhwb3J0IGVudW0gVUlFbGVtZW50VHlwZSB7XG5cdEJVVFRPTiA9IFwiQlVUVE9OXCIsXG5cdExBQkVMID0gXCJMQUJFTFwiLFxuXHRTTElERVIgPSBcIlNMSURFUlwiLFxuXHRURVhUX0lOUFVUID0gXCJURVhUSU5QVVRcIlxufSIsImltcG9ydCBOYXZpZ2FibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL05hdmlnYWJsZVwiO1xuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgTmF2aWdhdGlvblBhdGggZnJvbSBcIi4vTmF2aWdhdGlvblBhdGhcIjtcblxuLyoqXG4gKiBUaGUgbWFuYWdlciBjbGFzcyBmb3IgbmF2aWdhdGlvbi5cbiAqIEhhbmRsZXMgYWxsIG5hdmlnYWJsZSBlbnRpdGllcywgc3VjaCBhbmQgYWxsb3dzIHRoZW0gdG8gYmUgYWNjZXNzZWQgYnkgb3V0c2lkZSBzeXN0ZW1zIGJ5IHJlcXVlc3RpbmcgYSBwYXRoXG4gKiBmcm9tIG9uZSBwb3NpdGlvbiB0byBhbm90aGVyLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOYXZpZ2F0aW9uTWFuYWdlciB7XG5cdC8qKiBUaGUgbGlzdCBvZiBhbGwgbmF2aWdhYmxlIGVudGl0aWVzICovXG5cdHByb3RlY3RlZCBuYXZpZ2FibGVFbnRpdGllczogTWFwPE5hdmlnYWJsZT47XG5cblx0Y29uc3RydWN0b3IoKXtcblx0XHR0aGlzLm5hdmlnYWJsZUVudGl0aWVzID0gbmV3IE1hcCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBuYXZpZ2FibGUgZW50aXR5IHRvIHRoZSBOYXZpZ2F0aW9uTWFuYWdlclxuXHQgKiBAcGFyYW0gbmF2TmFtZSBUaGUgbmFtZSBvZiB0aGUgbmF2aWdhYmxlIGVudGl0cnlcblx0ICogQHBhcmFtIG5hdiBUaGUgYWN0dWFsIE5hdmlnYWJsZSBpbnN0YW5jZVxuXHQgKi9cblx0YWRkTmF2aWdhYmxlRW50aXR5KG5hdk5hbWU6IHN0cmluZywgbmF2OiBOYXZpZ2FibGUpOiB2b2lkIHtcblx0XHR0aGlzLm5hdmlnYWJsZUVudGl0aWVzLmFkZChuYXZOYW1lLCBuYXYpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgYSBwYXRoIGZyb21lIG9uZSBwb2ludCB0byBhbm90aGVyIHVzaW5nIGEgc3BlY2lmaWVkIE5hdmlnYWJsZSBvYmplY3Rcblx0ICogQHBhcmFtIG5hdk5hbWUgVGhlIG5hbWUgb2YgdGhlIHJlZ2lzdGVyZWQgTmF2aWdhYmxlIG9iamVjdFxuXHQgKiBAcGFyYW0gZnJvbVBvc2l0aW9uIFRoZSBzdGFydGluZyBwb3NpdGlvbiBvZiBuYXZpZ2F0aW9uXG5cdCAqIEBwYXJhbSB0b1Bvc2l0aW9uIFRoZSBlbmRpbmcgcG9zaXRpb24gb2YgTmF2aWdhdGlvblxuXHQgKiBAcGFyYW0gZGlyZWN0IElmIHRydWUsIGdvIGRpcmVjdCBmcm9tIGZyb21Qb3NpdGlvbiB0byB0b1Bvc2l0aW9uLCBkb24ndCB1c2UgTmF2TWVzaFxuXHQgKiBAcmV0dXJucyBBIE5hdmlnYXRpb25QYXRoIGNvbnRhaW5pbmcgdGhlIHJvdXRlIHRvIHRha2Ugb3ZlciB0aGUgTmF2aWdhYmxlIGVudGl0eSB0byBnZXQgYmV0d2VlbiB0aGUgcHJvdmlkZWQgcG9zaXRpb25zLlxuXHQgKi9cblx0Z2V0UGF0aChuYXZOYW1lOiBzdHJpbmcsIGZyb21Qb3NpdGlvbjogVmVjMiwgdG9Qb3NpdGlvbjogVmVjMiwgZGlyZWN0PzogYm9vbGVhbik6IE5hdmlnYXRpb25QYXRoIHtcblx0XHRsZXQgbmF2ID0gdGhpcy5uYXZpZ2FibGVFbnRpdGllcy5nZXQobmF2TmFtZSk7XG5cdFx0cmV0dXJuIG5hdi5nZXROYXZpZ2F0aW9uUGF0aChmcm9tUG9zaXRpb24uY2xvbmUoKSwgdG9Qb3NpdGlvbi5jbG9uZSgpLCBkaXJlY3QpO1xuXHR9XG59IiwiaW1wb3J0IFN0YWNrIGZyb20gXCIuLi9EYXRhVHlwZXMvU3RhY2tcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Ob2Rlcy9HYW1lTm9kZVwiO1xuXG4vKipcbiAqIEEgcGF0aCB0aGF0IEFJcyBjYW4gZm9sbG93LiBVc2VzIGZpbmlzaE1vdmUoKSBpbiBQaHlzaWNhbCB0byBkZXRlcm1pbmUgcHJvZ3Jlc3Mgb24gdGhlIHJvdXRlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdmlnYXRpb25QYXRoIHtcblx0LyoqIFRoZSBuYXZpZ2F0aW9uIHBhdGgsIHN0b3JlZCBhcyBhIHN0YWNrIG9mIG5leHQgcG9zaXRpb25zICovXG5cdHByb3RlY3RlZCBwYXRoOiBTdGFjazxWZWMyPjtcblx0LyoqIFRoZSBjdXJyZW50IGRpcmVjdGlvbiBvZiBtb3ZlbWVudCAqL1xuXHRwcm90ZWN0ZWQgY3VycmVudE1vdmVEaXJlY3Rpb246IFZlYzI7XG5cdC8qKiBUaGUgZGlzdGFuY2UgYSBub2RlIG11c3QgYmUgdG8gYSBwb2ludCB0byBjb25zaWRlciBpdCBhcyBoYXZpbmcgYXJyaXZlZCAqL1xuXHRwcm90ZWN0ZWQgZGlzdGFuY2VUaHJlc2hvbGQ6IG51bWJlcjtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBOYXZpZ2F0aW9uUGF0aFxuXHQgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCBvZiBub2RlcyB0byB0YWtlXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihwYXRoOiBTdGFjazxWZWMyPil7XG5cdFx0dGhpcy5wYXRoID0gcGF0aDtcblx0XHR0aGlzLmN1cnJlbnRNb3ZlRGlyZWN0aW9uID0gVmVjMi5aRVJPO1xuXHRcdHRoaXMuZGlzdGFuY2VUaHJlc2hvbGQgPSA0O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHN0YXR1cyBvZiBuYXZpZ2F0aW9uIGFsb25nIHRoaXMgTmF2aWdhdGlvblBhdGhcblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgbm9kZSBoYXMgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBwYXRoLCBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdGlzRG9uZSgpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5wYXRoLmlzRW1wdHkoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBtb3ZlbWVudCBkaXJlY3Rpb24gaW4gdGhlIGN1cnJlbnQgcG9zaXRpb24gYWxvbmcgdGhlIHBhdGhcblx0ICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gbW92ZSBhbG9uZyB0aGUgcGF0aFxuXHQgKiBAcmV0dXJucyBUaGUgbW92ZW1lbnQgZGlyZWN0aW9uIGFzIGEgVmVjMlxuXHQgKi9cblx0Z2V0TW92ZURpcmVjdGlvbihub2RlOiBHYW1lTm9kZSk6IFZlYzIge1xuXHRcdC8vIFJldHVybiBkaXJlY3Rpb24gdG8gbmV4dCBwb2ludCBpbiB0aGUgbmF2XG5cdFx0cmV0dXJuIG5vZGUucG9zaXRpb24uZGlyVG8odGhpcy5wYXRoLnBlZWsoKSk7XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGlzIE5hdmlnYXRpb25QYXRoIHRvIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBHYW1lTm9kZVxuXHQgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSBtb3ZpbmcgYWxvbmcgdGhlIHBhdGhcblx0ICovXG5cdGhhbmRsZVBhdGhQcm9ncmVzcyhub2RlOiBHYW1lTm9kZSk6IHZvaWQge1xuXHRcdGlmKG5vZGUucG9zaXRpb24uZGlzdGFuY2VTcVRvKHRoaXMucGF0aC5wZWVrKCkpIDwgdGhpcy5kaXN0YW5jZVRocmVzaG9sZCp0aGlzLmRpc3RhbmNlVGhyZXNob2xkKXtcblx0XHRcdC8vIFdlJ3ZlIHJlYWNoZWQgb3VyIG5vZGUsIG1vdmUgb24gdG8gdGhlIG5leHQgZGVzdGluYXRpb25cblx0XHRcdHRoaXMucGF0aC5wb3AoKTtcblx0XHR9XG5cdH1cblxuXHR0b1N0cmluZygpOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLnBhdGgudG9TdHJpbmcoKVxuXHR9XG59IiwiaW1wb3J0IFBvc2l0aW9uR3JhcGggZnJvbSBcIi4uL0RhdGFUeXBlcy9HcmFwaHMvUG9zaXRpb25HcmFwaFwiO1xuaW1wb3J0IE5hdmlnYWJsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvTmF2aWdhYmxlXCI7XG5pbXBvcnQgU3RhY2sgZnJvbSBcIi4uL0RhdGFUeXBlcy9TdGFja1wiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgR3JhcGhVdGlscyBmcm9tIFwiLi4vVXRpbHMvR3JhcGhVdGlsc1wiO1xuaW1wb3J0IE5hdmlnYXRpb25QYXRoIGZyb20gXCIuL05hdmlnYXRpb25QYXRoXCI7XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgYSBOYXZtZXNoLiBOYXZtZXNoZXMgYXJlIGdyYXBocyBpbiB0aGUgZ2FtZSB3b3JsZCBhbG9uZyB3aGljaCBub2RlcyBjYW4gbW92ZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF2bWVzaCBpbXBsZW1lbnRzIE5hdmlnYWJsZSB7XG5cdC8qKiBUaGUgZ3JhcGggb2YgcG9pbnRzIGluIHRoZSBOYXZNZXNoICovXG5cdHByb3RlY3RlZCBncmFwaDogUG9zaXRpb25HcmFwaDtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyBOYXZtZXNoIGZyb20gdGhlIHBvaW50cyBpbiB0aGUgc3BlZWNpZmllZCBncmFwaFxuXHQgKiBAcGFyYW0gZ3JhcGggVGhlIGdyYXBoIHRvIGNvbnN0cnVjdCBhIG5hdm1lc2ggZnJvbVxuXHQgKi9cblx0Y29uc3RydWN0b3IoZ3JhcGg6IFBvc2l0aW9uR3JhcGgpe1xuXHRcdHRoaXMuZ3JhcGggPSBncmFwaDtcblx0fVxuXG5cdC8vIEBpbXBsZW1lbnRlZFxuXHRnZXROYXZpZ2F0aW9uUGF0aChmcm9tUG9zaXRpb246IFZlYzIsIHRvUG9zaXRpb246IFZlYzIsIGRpcmVjdDogYm9vbGVhbik6IE5hdmlnYXRpb25QYXRoIHtcblx0XHRsZXQgc3RhcnQgPSB0aGlzLmdldENsb3Nlc3ROb2RlKGZyb21Qb3NpdGlvbik7XG5cdFx0bGV0IGVuZCA9IHRoaXMuZ2V0Q2xvc2VzdE5vZGUodG9Qb3NpdGlvbik7XG5cblx0XHRsZXQgcGF0aFN0YWNrID0gbmV3IFN0YWNrPFZlYzI+KHRoaXMuZ3JhcGgubnVtVmVydGljZXMpO1xuXHRcdFxuXHRcdC8vIFB1c2ggdGhlIGZpbmFsIHBvc2l0aW9uIGFuZCB0aGUgZmluYWwgcG9zaXRpb24gaW4gdGhlIGdyYXBoXG5cdFx0cGF0aFN0YWNrLnB1c2godG9Qb3NpdGlvbi5jbG9uZSgpKTtcblxuXHRcdGlmIChkaXJlY3QpIHtcblx0XHRcdHJldHVybiBuZXcgTmF2aWdhdGlvblBhdGgocGF0aFN0YWNrKTtcblx0XHR9XG5cblx0XHRwYXRoU3RhY2sucHVzaCh0aGlzLmdyYXBoLnBvc2l0aW9uc1tlbmRdKTtcblxuXHRcdGxldCBwYXJlbnQgPSBHcmFwaFV0aWxzLmRqaWtzdHJhKHRoaXMuZ3JhcGgsIHN0YXJ0KTtcblxuXHRcdC8vIEFkZCBhbGwgcGFyZW50cyBhbG9uZyB0aGUgcGF0aFxuXHRcdGxldCBpID0gZW5kO1xuXHRcdHdoaWxlKHBhcmVudFtpXSAhPT0gLTEpe1xuXHRcdFx0cGF0aFN0YWNrLnB1c2godGhpcy5ncmFwaC5wb3NpdGlvbnNbcGFyZW50W2ldXSk7XG5cdFx0XHRpID0gcGFyZW50W2ldO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgTmF2aWdhdGlvblBhdGgocGF0aFN0YWNrKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBjbG9zZXN0IG5vZGUgaW4gdGhpcyBOYXZtZXNoIHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb25cblx0ICogQHBhcmFtIHBvc2l0aW9uIFRoZSBwb3NpdGlvbiB0byBxdWVyeVxuXHQgKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIGNsb3Nlc3Qgbm9kZSBpbiB0aGUgTmF2bWVzaCB0byB0aGUgcG9zaXRpb25cblx0ICovXG5cdHByb3RlY3RlZCBnZXRDbG9zZXN0Tm9kZShwb3NpdGlvbjogVmVjMik6IG51bWJlciB7XG5cdFx0bGV0IG4gPSB0aGlzLmdyYXBoLm51bVZlcnRpY2VzO1xuXHRcdGxldCBpID0gMTtcblx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdGxldCBkaXN0ID0gcG9zaXRpb24uZGlzdGFuY2VTcVRvKHRoaXMuZ3JhcGgucG9zaXRpb25zWzBdKTtcblx0XHR3aGlsZShpIDwgbil7XG5cdFx0XHRsZXQgZCA9IHBvc2l0aW9uLmRpc3RhbmNlU3FUbyh0aGlzLmdyYXBoLnBvc2l0aW9uc1tpXSk7XG5cdFx0XHRpZihkIDwgZGlzdCl7XG5cdFx0XHRcdGRpc3QgPSBkO1xuXHRcdFx0XHRpbmRleCA9IGk7XG5cdFx0XHR9XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9XG59IiwiaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Ob2Rlcy9HYW1lTm9kZVwiO1xuaW1wb3J0IFBoeXNpY2FsIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9QaHlzaWNhbFwiO1xuaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uL05vZGVzL1RpbGVtYXBcIjtcbmltcG9ydCBQaHlzaWNzTWFuYWdlciBmcm9tIFwiLi9QaHlzaWNzTWFuYWdlclwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XG5pbXBvcnQgT3J0aG9nb25hbFRpbGVtYXAgZnJvbSBcIi4uL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwXCI7XG5pbXBvcnQgQXJlYUNvbGxpc2lvbiBmcm9tIFwiLi4vRGF0YVR5cGVzL1BoeXNpY3MvQXJlYUNvbGxpc2lvblwiO1xuaW1wb3J0IFVuaXF1ZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvVW5pcXVlXCI7XG5cbi8qKlxuICogQUxHT1JJVEhNOlxuICogXHRJbiBhbiBlZmZvcnQgdG8ga2VlcCB0aGluZ3Mgc2ltcGxlIGFuZCB3b3JraW5nIGVmZmVjdGl2ZWx5LCBlYWNoIGR5bmFtaWMgbm9kZSB3aWxsIHJlc29sdmUgaXRzXG4gKiBcdGNvbGxpc2lvbnMgY29uc2lkZXJpbmcgdGhlIHJlc3Qgb2YgdGhlIHdvcmxkIGFzIHN0YXRpYy5cbiAqIFxuICogXHRDb2xsaXNpb24gZGV0ZWN0aW5nIHdpbGwgaGFwcGVuIGZpcnN0LiBUaGlzIGNhbiBiZSBjb25zaWRlcmVkIGEgYnJvYWQgcGhhc2UsIGJ1dCBpdCBpcyBub3QgZXNwZWNpYWxseVxuICogXHRlZmZpY2llbnQsIGFzIGl0IGRvZXMgbm90IG5lZWQgdG8gYmUgZm9yIHRoaXMgZ2FtZSBlbmdpbmUuIEV2ZXJ5IGR5bmFtaWMgbm9kZSBpcyBjaGVja2VkIGFnYWluc3QgZXZlcnlcbiAqIFx0b3RoZXIgbm9kZSBmb3IgY29sbGlzaW9uIGFyZWEuIElmIGNvbGxpc2lvbiBhcmVhIGlzIG5vbi16ZXJvIChtZWFuaW5nIHRoZSBjdXJyZW50IG5vZGUgc3dlZXBzIGludG8gYW5vdGhlciksXG4gKiBcdGl0IGlzIGFkZGVkIHRvIGEgbGlzdCBvZiBoaXRzLlxuICogXG4gKiBcdElOSVRJQUxJWkFUSU9OOlxuICogXHRcdC0gUGh5c2ljcyBjb25zdGFudHMgYXJlIHJlc2V0XG4gKiBcdFx0LSBTd2VwdCBzaGFwZXMgYXJlIHJlY2FsY3VsYXRlZC4gSWYgYSBub2RlIGlzbid0IG1vdmluZywgaXQgaXMgc2tpcHBlZC5cbiAqIFxuICogXHRDT0xMSVNJT04gREVURUNUSU9OOlxuICogXHRcdC0gRm9yIGEgbm9kZSwgY29sbGlzaW9uIGFyZWEgd2lsbCBiZSBjYWxjdWxhdGVkIHVzaW5nIHRoZSBzd2VwdCBBQUJCIG9mIHRoZSBub2RlIGFnYWluc3QgZXZlcnkgb3RoZXIgQUFCQiBpbiBhIHN0YXRpYyBzdGF0ZVxuICogXHRcdC0gVGhlc2UgY29sbGlzaW9ucyB3aWxsIGJlIHNvcnRlZCBieSBhcmVhIGluIGRlc2NlbmRpbmcgb3JkZXJcbiAqIFx0XG4gKiBcdENPTExJU0lPTiBSRVNPTFVUSU9OOlxuICogXHRcdC0gRm9yIGVhY2ggaGl0LCB0aW1lIG9mIGNvbGxpc2lvbiBpcyBjYWxjdWxhdGVkIHVzaW5nIGEgc3dlcHQgbGluZSB0aHJvdWdoIHRoZSBBQUJCIG9mIHRoZSBzdGF0aWMgbm9kZSBleHBhbmRlZFxuICogXHRcdFx0d2l0aCBtaW5rb3dza2kgc3VtcyAoZGlzY3JldGVseSwgYnV0IHRoZSBjb25jZXB0IGlzIHRoZXJlKVxuICogXHRcdC0gVGhlIGNvbGxpc2lvbiBpcyByZXNvbHZlZCBiYXNlZCBvbiB0aGUgbmVhciB0aW1lIG9mIHRoZSBjb2xsaXNpb24gKGZyb20gbWV0aG9kIG9mIHNlcGFyYXRlZCBheGVzKVxuICogXHRcdFx0LSBYIGlzIHJlc29sdmVkIGJ5IG5lYXIgeCwgWSBieSBuZWFyIHkuXG4gKiBcdFx0XHQtIFRoZXJlIGlzIHNvbWUgZnVkZ2luZyB0byBhbGxvdyBmb3Igc2xpZGluZyBhbG9uZyB3YWxscyBvZiBzZXBhcmF0ZSBjb2xsaWRlcnMuIFNvcnRpbmcgYnkgYXJlYSBhbHNvIGhlbHBzIHdpdGggdGhpcy5cbiAqIFx0XHRcdC0gQ29ybmVyIHRvIGNvcm5lciBjb2xsaXNpb25zIGFyZSByZXNvbHZlIHRvIGZhdm9yIHgtbW92ZW1lbnQuIFRoaXMgaXMgaW4gY29uc2lkZXJhdGlvbiBvZiBwbGF0Zm9ybWVycywgdG8gZ2l2ZVxuICogXHRcdFx0XHR0aGUgcGxheWVyIHNvbWUgaGVscCB3aXRoIGp1bXBzXG4gKiBcbiAqIFx0UHJvczpcbiAqIFx0XHQtIEV2ZXJ5dGhpbmcgaGFwcGVucyB3aXRoIGEgY29uc2lzdGVudCB0aW1lLiBUaGVyZSBpcyBhIGRpc3RpbmN0IGJlZm9yZSBhbmQgYWZ0ZXIgZm9yIGVhY2ggcmVzb2x1dGlvbi5cbiAqIFx0XHQtIE5vIGJhY2stdHJhY2tpbmcgbmVlZHMgdG8gYmUgZG9uZS4gT25jZSB3ZSByZXNvbHZlIGEgbm9kZSwgaXQgaXMgZGVmaW5pdGl2ZWx5IHJlc29sdmVkLlxuICogXHRcbiAqIFx0Q29uczpcbiAqIFx0XHQtIE5vZGVzIHRoYXQgYXJlIHByb2Nlc3NlZCBlYXJseSBoYXZlIG1vdmVtZW50IHByaW9yaXR5IG92ZXIgb3RoZXIgbm9kZXMuIFRoaXMgY2FuIGxlYWQgdG8gc29tZSB1bmRlc2lyYWJsZSBpbnRlcmFjdGlvbnMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2ljUGh5c2ljc01hbmFnZXIgZXh0ZW5kcyBQaHlzaWNzTWFuYWdlciB7XG5cblx0LyoqIFRoZSBhcnJheSBvZiBzdGF0aWMgbm9kZXMgKi9cblx0cHJvdGVjdGVkIHN0YXRpY05vZGVzOiBBcnJheTxQaHlzaWNhbD47XG5cblx0LyoqIFRoZSBhcnJheSBvZiBkeW5hbWljIG5vZGVzICovXG5cdHByb3RlY3RlZCBkeW5hbWljTm9kZXM6IEFycmF5PFBoeXNpY2FsPjtcblxuXHQvKiogVGhlIGFycmF5IG9mIHRpbGVtYXBzICovXG5cdHByb3RlY3RlZCB0aWxlbWFwczogQXJyYXk8VGlsZW1hcD47XG5cblx0LyoqIEFuIGFycmF5IG9mIHRoZSBjb2xsaXNpb24gbWFza3MgZm9yIGVhY2ggZ3JvdXAgKi9cblx0cHJvdGVjdGVkIGNvbGxpc2lvbk1hc2tzOiBBcnJheTxudW1iZXI+O1xuXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pe1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5zdGF0aWNOb2RlcyA9IG5ldyBBcnJheSgpO1xuXHRcdHRoaXMuZHluYW1pY05vZGVzID0gbmV3IEFycmF5KCk7XG5cdFx0dGhpcy50aWxlbWFwcyA9IG5ldyBBcnJheSgpO1xuXHRcdHRoaXMuY29sbGlzaW9uTWFza3MgPSBuZXcgQXJyYXkoMzIpO1xuXG5cdFx0Ly8gUGFyc2Ugb3B0aW9uc1xuXHRcdHRoaXMucGFyc2VPcHRpb25zKG9wdGlvbnMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBhcnNlcyB0aGUgb3B0aW9ucyBmb3IgY29uc3RydWN0aW5nIHRoZSBwaHlzaWNzIG1hbmFnZXJcblx0ICogQHBhcmFtIG9wdGlvbnMgQSByZWNvcmQgb2Ygb3B0aW9uc1xuXHQgKi9cblx0cHJvdGVjdGVkIHBhcnNlT3B0aW9ucyhvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XG5cdFx0aWYob3B0aW9ucy5ncm91cE5hbWVzICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5jb2xsaXNpb25zICE9PSB1bmRlZmluZWQpe1xuXHRcdFx0Zm9yKGxldCBpID0gMDsgaSA8IG9wdGlvbnMuZ3JvdXBOYW1lcy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdGxldCBncm91cCA9IG9wdGlvbnMuZ3JvdXBOYW1lc1tpXTtcblxuXHRcdFx0XHQvLyBSZWdpc3RlciB0aGUgZ3JvdXAgbmFtZSBhbmQgbnVtYmVyXG5cdFx0XHRcdHRoaXMuZ3JvdXBOYW1lc1tpXSA9IGdyb3VwO1xuXG5cdFx0XHRcdHRoaXMuZ3JvdXBNYXAuc2V0KGdyb3VwLCAxIDw8IGkpO1xuXG5cdFx0XHRcdGxldCBjb2xsaXNpb25NYXNrID0gMDtcblxuXHRcdFx0XHRmb3IobGV0IGogPSAwOyBqIDwgb3B0aW9ucy5jb2xsaXNpb25zW2ldLmxlbmd0aDsgaisrKXtcblx0XHRcdFx0XHRpZihvcHRpb25zLmNvbGxpc2lvbnNbaV1bal0pe1xuXHRcdFx0XHRcdFx0Y29sbGlzaW9uTWFzayB8PSAxIDw8IGo7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5jb2xsaXNpb25NYXNrc1tpXSA9IGNvbGxpc2lvbk1hc2s7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQG92ZXJyaWRlXG5cdHJlZ2lzdGVyT2JqZWN0KG5vZGU6IFBoeXNpY2FsKTogdm9pZCB7XG5cdFx0aWYobm9kZS5pc1N0YXRpYyl7XG5cdFx0XHQvLyBTdGF0aWMgYW5kIG5vdCBjb2xsaWRhYmxlXG5cdFx0XHR0aGlzLnN0YXRpY05vZGVzLnB1c2gobm9kZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIER5bmFtaWMgYW5kIG5vdCBjb2xsaWRhYmxlXG5cdFx0XHR0aGlzLmR5bmFtaWNOb2Rlcy5wdXNoKG5vZGUpO1xuXHRcdH1cblx0fVxuXG5cdC8vIEBvdmVycmlkZVxuXHRkZXJlZ2lzdGVyT2JqZWN0KG5vZGU6IFBoeXNpY2FsKTogdm9pZCB7XG5cdFx0aWYobm9kZS5pc1N0YXRpYyl7XG5cdFx0XHQvLyBSZW1vdmUgdGhlIG5vZGUgZnJvbSB0aGUgc3RhdGljIGxpc3Rcblx0XHRcdGNvbnN0IGluZGV4ID0gdGhpcy5zdGF0aWNOb2Rlcy5pbmRleE9mKG5vZGUpO1xuXHRcdFx0dGhpcy5zdGF0aWNOb2Rlcy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBSZW1vdmUgdGhlIG5vZGUgZnJvbSB0aGUgZHluYW1pYyBsaXN0XG5cdFx0XHRjb25zdCBpbmRleCA9IHRoaXMuZHluYW1pY05vZGVzLmluZGV4T2Yobm9kZSk7XG5cdFx0XHR0aGlzLmR5bmFtaWNOb2Rlcy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdH1cblx0fVxuXG5cdC8vIEBvdmVycmlkZVxuXHRyZWdpc3RlclRpbGVtYXAodGlsZW1hcDogVGlsZW1hcCk6IHZvaWQge1xuXHRcdHRoaXMudGlsZW1hcHMucHVzaCh0aWxlbWFwKTtcblx0fVxuXG5cdC8vIEBvdmVycmlkZVxuXHRkZXJlZ2lzdGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZCB7XG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLnRpbGVtYXBzLmluZGV4T2YodGlsZW1hcCk7XG5cdFx0dGhpcy50aWxlbWFwcy5zcGxpY2UoaW5kZXgsIDEpO1xuXHR9XG5cblx0Ly8gQG92ZXJyaWRlXG5cdHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuXHRcdGZvcihsZXQgbm9kZSBvZiB0aGlzLmR5bmFtaWNOb2Rlcyl7XG5cdFx0XHQvKi0tLS0tLS0tLS0gSU5JVElBTElaQVRJT04gUEhBU0UgLS0tLS0tLS0tLSovXG5cdFx0XHQvLyBDbGVhciBmcmFtZSBkZXBlbmRlbnQgYm9vbGVhbiB2YWx1ZXMgZm9yIGVhY2ggbm9kZVxuXHRcdFx0bm9kZS5vbkdyb3VuZCA9IGZhbHNlO1xuXHRcdFx0bm9kZS5vbkNlaWxpbmcgPSBmYWxzZTtcblx0XHRcdG5vZGUub25XYWxsID0gZmFsc2U7XG5cdFx0XHRub2RlLmNvbGxpZGVkV2l0aFRpbGVtYXAgPSBmYWxzZTtcblx0XHRcdG5vZGUuaXNDb2xsaWRpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gSWYgdGhpcyBub2RlIGlzIG5vdCBhY3RpdmUsIGRvbid0IHByb2Nlc3MgaXRcblx0XHRcdGlmKCFub2RlLmFjdGl2ZSl7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVcGRhdGUgdGhlIHN3ZXB0IHNoYXBlcyBvZiBlYWNoIG5vZGVcblx0XHRcdGlmKG5vZGUubW92aW5nKXtcblx0XHRcdFx0Ly8gSWYgbW92aW5nLCByZWZsZWN0IHRoYXQgaW4gdGhlIHN3ZXB0IHNoYXBlXG5cdFx0XHRcdG5vZGUuc3dlcHRSZWN0LnN3ZWVwKG5vZGUuX3ZlbG9jaXR5LCBub2RlLmNvbGxpc2lvblNoYXBlLmNlbnRlciwgbm9kZS5jb2xsaXNpb25TaGFwZS5oYWxmU2l6ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJZiBvdXIgbm9kZSBpc24ndCBtb3ZpbmcsIGRvbid0IGJvdGhlciB0byBjaGVjayBpdCAob3RoZXIgbm9kZXMgd2lsbCBkZXRlY3QgaWYgdGhleSBydW4gaW50byBpdClcblx0XHRcdFx0bm9kZS5fdmVsb2NpdHkuemVybygpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0LyotLS0tLS0tLS0tIERFVEVDVElPTiBQSEFTRSAtLS0tLS0tLS0tKi9cblx0XHRcdC8vIEdhdGhlciBhIHNldCBvZiBvdmVybGFwc1xuXHRcdFx0bGV0IG92ZXJsYXBzID0gbmV3IEFycmF5PEFyZWFDb2xsaXNpb24+KCk7XG5cblx0XHRcdGxldCBncm91cEluZGV4ID0gbm9kZS5ncm91cCA9PT0gLTEgPyAtMSA6IE1hdGgubG9nMihub2RlLmdyb3VwKTtcblxuXHRcdFx0Ly8gRmlyc3QsIGNoZWNrIHRoaXMgbm9kZSBhZ2FpbnN0IGV2ZXJ5IHN0YXRpYyBub2RlIChvcmRlciBkb2Vzbid0IGFjdHVhbGx5IG1hdHRlciBoZXJlLCBzaW5jZSB3ZSBzb3J0IGFueXdheXMpXG5cdFx0XHRmb3IobGV0IG90aGVyIG9mIHRoaXMuc3RhdGljTm9kZXMpe1xuXHRcdFx0XHQvLyBJZ25vcmUgaW5hY3RpdmUgbm9kZXNcblx0XHRcdFx0aWYoIW90aGVyLmFjdGl2ZSkgY29udGludWU7XG5cblx0XHRcdFx0bGV0IGNvbGxpZGVyID0gb3RoZXIuY29sbGlzaW9uU2hhcGUuZ2V0Qm91bmRpbmdSZWN0KCk7XG5cdFx0XHRcdGxldCBhcmVhID0gbm9kZS5zd2VwdFJlY3Qub3ZlcmxhcEFyZWEoY29sbGlkZXIpO1xuXHRcdFx0XHRpZihhcmVhID4gMCl7XG5cdFx0XHRcdFx0Ly8gV2UgaGFkIGEgY29sbGlzaW9uXG5cdFx0XHRcdFx0b3ZlcmxhcHMucHVzaChuZXcgQXJlYUNvbGxpc2lvbihhcmVhLCBjb2xsaWRlciwgb3RoZXIsIFwiR2FtZU5vZGVcIiwgbnVsbCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZW4sIGNoZWNrIGl0IGFnYWluc3QgZXZlcnkgZHluYW1pYyBub2RlXG5cdFx0XHRmb3IobGV0IG90aGVyIG9mIHRoaXMuZHluYW1pY05vZGVzKXtcblx0XHRcdFx0Ly8gSWdub3JlIG91cnNlbHZlc1xuXHRcdFx0XHRpZihub2RlID09PSBvdGhlcikgY29udGludWU7XG5cblx0XHRcdFx0Ly8gSWdub3JlIGluYWN0aXZlIG5vZGVzXG5cdFx0XHRcdGlmKCFvdGhlci5hY3RpdmUpIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGxldCBjb2xsaWRlciA9IG90aGVyLmNvbGxpc2lvblNoYXBlLmdldEJvdW5kaW5nUmVjdCgpO1xuXHRcdFx0XHRsZXQgYXJlYSA9IG5vZGUuc3dlcHRSZWN0Lm92ZXJsYXBBcmVhKGNvbGxpZGVyKTtcblx0XHRcdFx0aWYoYXJlYSA+IDApe1xuXHRcdFx0XHRcdC8vIFdlIGhhZCBhIGNvbGxpc2lvblxuXHRcdFx0XHRcdG92ZXJsYXBzLnB1c2gobmV3IEFyZWFDb2xsaXNpb24oYXJlYSwgY29sbGlkZXIsIG90aGVyLCBcIkdhbWVOb2RlXCIsIG51bGwpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMYXN0bHksIGdhdGhlciBhIHNldCBvZiBBQUJCcyBmcm9tIHRoZSB0aWxlbWFwLlxuXHRcdFx0Ly8gVGhpcyBzdGVwIGludm9sdmVzIHRoZSBtb3N0IGV4dHJhIHdvcmssIHNvIGl0IGlzIGFic3RyYWN0ZWQgaW50byBhIG1ldGhvZFxuXHRcdFx0Zm9yKGxldCB0aWxlbWFwIG9mIHRoaXMudGlsZW1hcHMpe1xuXHRcdFx0XHQvLyBJZ25vcmUgaW5hY3RpdmUgdGlsZW1hcHNcblx0XHRcdFx0aWYoIXRpbGVtYXAuYWN0aXZlKSBjb250aW51ZTtcblxuXHRcdFx0XHRpZih0aWxlbWFwIGluc3RhbmNlb2YgT3J0aG9nb25hbFRpbGVtYXApe1xuXHRcdFx0XHRcdHRoaXMuY29sbGlkZVdpdGhPcnRob2dvbmFsVGlsZW1hcChub2RlLCB0aWxlbWFwLCBvdmVybGFwcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU29ydCB0aGUgb3ZlcmxhcHMgYnkgYXJlYVxuXHRcdFx0b3ZlcmxhcHMgPSBvdmVybGFwcy5zb3J0KChhLCBiKSA9PiBiLmFyZWEgLSBhLmFyZWEpO1xuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIGhpdHMgdG8gdXNlIGxhdGVyXG5cdFx0XHRsZXQgaGl0cyA9IFtdO1xuXG5cdFx0XHQvKi0tLS0tLS0tLS0gUkVTT0xVVElPTiBQSEFTRSAtLS0tLS0tLS0tKi9cblx0XHRcdC8vIEZvciBldmVyeSBvdmVybGFwLCBkZXRlcm1pbmUgaWYgd2UgbmVlZCB0byBjb2xsaWRlIHdpdGggaXQgYW5kIHdoZW5cblx0XHRcdGZvcihsZXQgb3ZlcmxhcCBvZiBvdmVybGFwcyl7XG5cdFx0XHRcdC8vIElnbm9yZSBub2RlcyB3ZSBkb24ndCBpbnRlcmFjdCB3aXRoXG5cdFx0XHRcdGlmKCBncm91cEluZGV4ICE9PSAtMSAmJiBvdmVybGFwLm90aGVyLmdyb3VwICE9PSAtMSAmJiAoKHRoaXMuY29sbGlzaW9uTWFza3NbZ3JvdXBJbmRleF0gJiBvdmVybGFwLm90aGVyLmdyb3VwKSA9PT0gMCkgKSBjb250aW51ZTtcblxuXHRcdFx0XHQvLyBEbyBhIHN3ZXB0IGxpbmUgdGVzdCBvbiB0aGUgc3RhdGljIEFBQkIgd2l0aCB0aGlzIEFBQkIgc2l6ZSBhcyBwYWRkaW5nICh0aGlzIGlzIGJhc2ljYWxseSB1c2luZyBhIG1pbmtvd3NraSBzdW0hKVxuXHRcdFx0XHQvLyBTdGFydCB0aGUgc3dlZXAgYXQgdGhlIHBvc2l0aW9uIG9mIHRoaXMgbm9kZSB3aXRoIGEgZGVsdGEgb2YgX3ZlbG9jaXR5XG5cdFx0XHRcdGNvbnN0IHBvaW50ID0gbm9kZS5jb2xsaXNpb25TaGFwZS5jZW50ZXI7XG5cdFx0XHRcdGNvbnN0IGRlbHRhID0gbm9kZS5fdmVsb2NpdHk7XG5cdFx0XHRcdGNvbnN0IHBhZGRpbmcgPSBub2RlLmNvbGxpc2lvblNoYXBlLmhhbGZTaXplO1xuXHRcdFx0XHRjb25zdCBvdGhlckFBQkIgPSBvdmVybGFwLmNvbGxpZGVyO1xuXG5cblx0XHRcdFx0Y29uc3QgaGl0ID0gb3RoZXJBQUJCLmludGVyc2VjdFNlZ21lbnQobm9kZS5jb2xsaXNpb25TaGFwZS5jZW50ZXIsIG5vZGUuX3ZlbG9jaXR5LCBub2RlLmNvbGxpc2lvblNoYXBlLmhhbGZTaXplKTtcblxuXHRcdFx0XHRvdmVybGFwLmhpdCA9IGhpdDtcblxuXHRcdFx0XHRpZihoaXQgIT09IG51bGwpe1xuXHRcdFx0XHRcdGhpdHMucHVzaChoaXQpO1xuXG5cdFx0XHRcdFx0Ly8gV2UgZ290IGEgaGl0LCByZXNvbHZlIHdpdGggdGhlIHRpbWUgaW5zaWRlIG9mIHRoZSBoaXRcblx0XHRcdFx0XHRsZXQgdG5lYXJ4ID0gaGl0Lm5lYXJUaW1lcy54O1xuXHRcdFx0XHRcdGxldCB0bmVhcnkgPSBoaXQubmVhclRpbWVzLnk7XG5cblx0XHRcdFx0XHQvLyBBbGxvdyBlZGdlIGNsaXBwaW5nIChlZGdlIG92ZXJsYXBzIGRvbid0IGNvdW50LCBvbmx5IGFyZWEgb3ZlcmxhcHMpXG5cdFx0XHRcdFx0Ly8gSW1wb3J0YW50bHkgZG9uJ3QgYWxsb3cgYm90aCBjYXNlcyB0byBiZSB0cnVlLiBUaGVuIHdlIGNsaXAgdGhyb3VnaCBjb3JuZXJzLiBGYXZvciB4IHRvIGhlbHAgcGxheWVycyBsYW5kIGp1bXBzXG5cdFx0XHRcdFx0aWYodG5lYXJ4IDwgMS4wICYmIChwb2ludC55ID09PSBvdGhlckFBQkIudG9wIC0gcGFkZGluZy55IHx8IHBvaW50LnkgPT09IG90aGVyQUFCQi5ib3R0b20gKyBwYWRkaW5nLnkpICYmIGRlbHRhLnggIT09IDApIHtcblx0XHRcdFx0XHRcdHRuZWFyeCA9IDEuMDtcblx0XHRcdFx0XHR9IGVsc2UgaWYodG5lYXJ5IDwgMS4wICYmIChwb2ludC54ID09PSBvdGhlckFBQkIubGVmdCAtIHBhZGRpbmcueCB8fCBwb2ludC54ID09PSBvdGhlckFBQkIucmlnaHQgKyBwYWRkaW5nLngpICYmIGRlbHRhLnkgIT09IDApIHtcblx0XHRcdFx0XHRcdHRuZWFyeSA9IDEuMDtcblx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHRcdGlmKGhpdC5uZWFyVGltZXMueCA+PSAwICYmIGhpdC5uZWFyVGltZXMueCA8IDEpe1xuXHRcdFx0XHRcdFx0Ly8gQW55IHRpbGVtYXAgb2JqZWN0cyB0aGF0IG1hZGUgaXQgaGVyZSBhcmUgY29sbGlkYWJsZVxuXHRcdFx0XHRcdFx0aWYob3ZlcmxhcC50eXBlID09PSBcIlRpbGVtYXBcIiB8fCBvdmVybGFwLm90aGVyLmlzQ29sbGlkYWJsZSl7XG5cdFx0XHRcdFx0XHRcdG5vZGUuX3ZlbG9jaXR5LnggPSBub2RlLl92ZWxvY2l0eS54ICogdG5lYXJ4O1xuXHRcdFx0XHRcdFx0XHRub2RlLmlzQ29sbGlkaW5nID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZihoaXQubmVhclRpbWVzLnkgPj0gMCAmJiBoaXQubmVhclRpbWVzLnkgPCAxKXtcblx0XHRcdFx0XHRcdC8vIEFueSB0aWxlbWFwIG9iamVjdHMgdGhhdCBtYWRlIGl0IGhlcmUgYXJlIGNvbGxpZGFibGVcblx0XHRcdFx0XHRcdGlmKG92ZXJsYXAudHlwZSA9PT0gXCJUaWxlbWFwXCIgfHwgb3ZlcmxhcC5vdGhlci5pc0NvbGxpZGFibGUpe1xuXHRcdFx0XHRcdFx0XHRub2RlLl92ZWxvY2l0eS55ID0gbm9kZS5fdmVsb2NpdHkueSAqIHRuZWFyeTtcblx0XHRcdFx0XHRcdFx0bm9kZS5pc0NvbGxpZGluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qLS0tLS0tLS0tLSBJTkZPUk1BVElPTi9UUklHR0VSIFBIQVNFIC0tLS0tLS0tLS0qL1xuXHRcdFx0Ly8gQ2hlY2sgaWYgd2UgZW5kZWQgdXAgb24gdGhlIGdyb3VuZCwgY2VpbGluZyBvciB3YWxsXG5cdFx0XHQvLyBBbHNvIGNoZWNrIGZvciB0cmlnZ2Vyc1xuXHRcdFx0Zm9yKGxldCBvdmVybGFwIG9mIG92ZXJsYXBzKXtcblx0XHRcdFx0Ly8gQ2hlY2sgZm9yIGEgdHJpZ2dlci4gSWYgd2UgY2FyZSBhYm91dCB0aGUgdHJpZ2dlciwgcmVhY3Rcblx0XHRcdFx0aWYob3ZlcmxhcC5vdGhlci5pc1RyaWdnZXIgJiYgKG92ZXJsYXAub3RoZXIudHJpZ2dlck1hc2sgJiBub2RlLmdyb3VwKSl7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBiaXQgdGhhdCB0aGlzIGdyb3VwIGlzIHJlcHJlc2VudGVkIGJ5XG5cdFx0XHRcdFx0bGV0IGluZGV4ID0gTWF0aC5mbG9vcihNYXRoLmxvZzIobm9kZS5ncm91cCkpO1xuXG5cdFx0XHRcdFx0Ly8gRXh0cmFjdCB0aGUgdHJpZ2dlckVudGVyIGV2ZW50IG5hbWVcblx0XHRcdFx0XHR0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KG92ZXJsYXAub3RoZXIudHJpZ2dlckVudGVyc1tpbmRleF0sIHtcblx0XHRcdFx0XHRcdG5vZGU6ICg8R2FtZU5vZGU+bm9kZSkuaWQsXG5cdFx0XHRcdFx0XHRvdGhlcjogKDxHYW1lTm9kZT5vdmVybGFwLm90aGVyKS5pZFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWdub3JlIGNvbGxpc2lvbiBzaWRlcyBmb3Igbm9kZXMgd2UgZG9uJ3QgaW50ZXJhY3Qgd2l0aFxuXHRcdFx0XHRpZiggZ3JvdXBJbmRleCAhPT0gLTEgJiYgb3ZlcmxhcC5vdGhlci5ncm91cCAhPT0gLTEgJiYgKCh0aGlzLmNvbGxpc2lvbk1hc2tzW2dyb3VwSW5kZXhdICYgb3ZlcmxhcC5vdGhlci5ncm91cCkgPT09IDApKSBjb250aW51ZTtcblxuXHRcdFx0XHQvLyBPbmx5IGNoZWNrIGZvciBkaXJlY3Rpb24gaWYgdGhlIG92ZXJsYXAgd2FzIGNvbGxpZGFibGVcblx0XHRcdFx0aWYob3ZlcmxhcC50eXBlID09PSBcIlRpbGVtYXBcIiB8fCBvdmVybGFwLm90aGVyLmlzQ29sbGlkYWJsZSl7XG5cdFx0XHRcdFx0bGV0IGNvbGxpc2lvblNpZGUgPSBvdmVybGFwLmNvbGxpZGVyLnRvdWNoZXNBQUJCV2l0aG91dENvcm5lcnMobm9kZS5jb2xsaXNpb25TaGFwZS5nZXRCb3VuZGluZ1JlY3QoKSk7XG5cdFx0XHRcdFx0aWYoY29sbGlzaW9uU2lkZSAhPT0gbnVsbCl7XG5cdFx0XHRcdFx0XHQvLyBJZiB3ZSB0b3VjaCwgbm90IGluY2x1ZGluZyBjb3JuZXIgY2FzZXMsIGNoZWNrIHRoZSBjb2xsaXNpb24gbm9ybWFsXG5cdFx0XHRcdFx0XHRpZihvdmVybGFwLmhpdCAhPT0gbnVsbCl7XG5cdFx0XHRcdFx0XHRcdC8vIElmIHdlIGhpdCBhIHRpbGVtYXAsIGtlZXAgdHJhY2sgb2YgaXRcblx0XHRcdFx0XHRcdFx0aWYob3ZlcmxhcC50eXBlID09IFwiVGlsZW1hcFwiKXtcblx0XHRcdFx0XHRcdFx0XHRub2RlLmNvbGxpZGVkV2l0aFRpbGVtYXAgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYoY29sbGlzaW9uU2lkZS55ID09PSAtMSl7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gTm9kZSBpcyBvbiB0b3Agb2Ygb3ZlcmxhcCwgc28gb25Hcm91bmRcblx0XHRcdFx0XHRcdFx0XHRub2RlLm9uR3JvdW5kID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmKGNvbGxpc2lvblNpZGUueSA9PT0gMSl7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gTm9kZSBpcyBvbiBib3R0b20gb2Ygb3ZlcmxhcCwgc28gb25DZWlsaW5nXG5cdFx0XHRcdFx0XHRcdFx0bm9kZS5vbkNlaWxpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdC8vIE5vZGUgd2Fzbid0IHRvdWNoaW5nIG9uIHksIHNvIGl0IGlzIHRvdWNoaW5nIG9uIHhcblx0XHRcdFx0XHRcdFx0XHRub2RlLm9uV2FsbCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVzb2x2ZSB0aGUgY29sbGlzaW9uIHdpdGggdGhlIG5vZGUsIGFuZCBtb3ZlIGl0XG5cdFx0XHRub2RlLmZpbmlzaE1vdmUoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlcyBhIGNvbGxpc2lvbiBiZXR3ZWVuIHRoaXMgbm9kZSBhbmQgYW4gb3J0aG9nb25hbCB0aWxlbWFwXG5cdCAqIEBwYXJhbSBub2RlIFRoZSBub2RlXG5cdCAqIEBwYXJhbSB0aWxlbWFwIFRoZSB0aWxlbWFwIHRoZSBub2RlIG1heSBiZSBjb2xsaWRpbmcgd2l0aFxuXHQgKiBAcGFyYW0gb3ZlcmxhcHMgVGhlIGxpc3Qgb2Ygb3ZlcmxhcHNcblx0ICovXG5cdHByb3RlY3RlZCBjb2xsaWRlV2l0aE9ydGhvZ29uYWxUaWxlbWFwKG5vZGU6IFBoeXNpY2FsLCB0aWxlbWFwOiBPcnRob2dvbmFsVGlsZW1hcCwgb3ZlcmxhcHM6IEFycmF5PEFyZWFDb2xsaXNpb24+KTogdm9pZCB7XG5cdFx0Ly8gR2V0IHRoZSBtaW4gYW5kIG1heCB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBtb3Zpbmcgbm9kZVxuXHRcdGxldCBtaW4gPSBuZXcgVmVjMihub2RlLnN3ZXB0UmVjdC5sZWZ0LCBub2RlLnN3ZXB0UmVjdC50b3ApO1xuXHRcdGxldCBtYXggPSBuZXcgVmVjMihub2RlLnN3ZXB0UmVjdC5yaWdodCwgbm9kZS5zd2VwdFJlY3QuYm90dG9tKTtcblxuXHRcdC8vIENvbnZlcnQgdGhlIG1pbi9tYXggeC95IHRvIHRoZSBtaW4gYW5kIG1heCByb3cvY29sIGluIHRoZSB0aWxlbWFwIGFycmF5XG5cdFx0bGV0IG1pbkluZGV4ID0gdGlsZW1hcC5nZXRDb2xSb3dBdChtaW4pO1xuXHRcdGxldCBtYXhJbmRleCA9IHRpbGVtYXAuZ2V0Q29sUm93QXQobWF4KTtcblxuXHRcdGxldCB0aWxlU2l6ZSA9IHRpbGVtYXAuZ2V0VGlsZVNpemUoKTtcblxuXHRcdC8vIExvb3Agb3ZlciBhbGwgcG9zc2libGUgdGlsZXMgKHdoaWNoIGlzbid0IG1hbnkgaW4gdGhlIHNjb3BlIG9mIHRoZSB2ZWxvY2l0eSBwZXIgZnJhbWUpXG5cdFx0Zm9yKGxldCBjb2wgPSBtaW5JbmRleC54OyBjb2wgPD0gbWF4SW5kZXgueDsgY29sKyspe1xuXHRcdFx0Zm9yKGxldCByb3cgPSBtaW5JbmRleC55OyByb3cgPD0gbWF4SW5kZXgueTsgcm93Kyspe1xuXHRcdFx0XHRpZih0aWxlbWFwLmlzVGlsZUNvbGxpZGFibGUoY29sLCByb3cpKXtcblx0XHRcdFx0XHQvLyBHZXQgdGhlIHBvc2l0aW9uIG9mIHRoaXMgdGlsZVxuXHRcdFx0XHRcdGxldCB0aWxlUG9zID0gbmV3IFZlYzIoY29sICogdGlsZVNpemUueCArIHRpbGVTaXplLngvMiwgcm93ICogdGlsZVNpemUueSArIHRpbGVTaXplLnkvMik7XG5cblx0XHRcdFx0XHQvLyBDcmVhdGUgYSBuZXcgY29sbGlkZXIgZm9yIHRoaXMgdGlsZVxuXHRcdFx0XHRcdGxldCBjb2xsaWRlciA9IG5ldyBBQUJCKHRpbGVQb3MsIHRpbGVTaXplLnNjYWxlZCgxLzIpKTtcblxuXHRcdFx0XHRcdC8vIENhbGN1bGF0ZSBjb2xsaXNpb24gYXJlYSBiZXR3ZWVuIHRoZSBub2RlIGFuZCB0aGUgdGlsZVxuXHRcdFx0XHRcdGxldCBhcmVhID0gbm9kZS5zd2VwdFJlY3Qub3ZlcmxhcEFyZWEoY29sbGlkZXIpO1xuXHRcdFx0XHRcdGlmKGFyZWEgPiAwKXtcblx0XHRcdFx0XHRcdC8vIFdlIGhhZCBhIGNvbGxpc2lvblxuXHRcdFx0XHRcdFx0b3ZlcmxhcHMucHVzaChuZXcgQXJlYUNvbGxpc2lvbihhcmVhLCBjb2xsaWRlciwgdGlsZW1hcCwgXCJUaWxlbWFwXCIsIG5ldyBWZWMyKGNvbCwgcm93KSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSIsImltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VcGRhdGVhYmxlXCI7XG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vTm9kZXMvVGlsZW1hcFwiO1xuaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuLi9FdmVudHMvUmVjZWl2ZXJcIjtcbmltcG9ydCBFbWl0dGVyIGZyb20gXCIuLi9FdmVudHMvRW1pdHRlclwiO1xuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xuaW1wb3J0IFBoeXNpY2FsIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9QaHlzaWNhbFwiO1xuXG4vKipcbiAqIEFuIGFic3RyYWN0IHBoeXNpY3MgbWFuYWdlci5cbiAqIFRoaXMgY2xhc3MgZXhwb3NlcyBmdW5jdGlvbnMgZm9yIHN1YmNsYXNzZXMgdG8gaW1wbGVtZW50IHRoYXQgc2hvdWxkIGFsbG93IGZvciBhIHdvcmtpbmcgcGh5c2ljcyBzeXN0ZW0gdG8gYmUgY3JlYXRlZC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgUGh5c2ljc01hbmFnZXIgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcblx0LyoqIFRoZSBldmVudCByZWNlaXZlciBmb3IgdGhlIHBoeXNpY3Mgc3lzdGVtICovXG5cdHByb3RlY3RlZCByZWNlaXZlcjogUmVjZWl2ZXI7XG5cdC8qKiBUaGUgZXZlbnQgZW1pdHRlciBmb3IgdGhlIHBoeXNpY3Mgc3lzdGVtICovXG5cdHByb3RlY3RlZCBlbWl0dGVyOiBFbWl0dGVyO1xuXG5cdC8qKiBNYXBzIGxheWVyIG5hbWVzIHRvIG51bWJlcnMgKi9cblx0cHJvdGVjdGVkIGdyb3VwTWFwOiBNYXA8bnVtYmVyPjtcblxuXHQvKiogTWFwcyBsYXllciBudW1iZXJzIHRvIG5hbWVzICovXG5cdHByb3RlY3RlZCBncm91cE5hbWVzOiBBcnJheTxzdHJpbmc+O1xuXG5cdC8qKiBUaGUgZGVmYXVsdCBncm91cCBuYW1lICovXG5cdHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgREVGQVVMVF9HUk9VUDogc3RyaW5nID0gXCJEZWZhdWx0XCI7XG5cblx0Y29uc3RydWN0b3IoKXtcblx0XHR0aGlzLnJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKCk7XG5cdFx0dGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcblxuXHRcdC8vIFRoZSBjcmVhdGlvbiBhbmQgaW1wbGVtZW50YXRpb24gb2YgbGF5ZXJzIGlzIGRlZmVycmVkIHRvIHRoZSBzdWJjbGFzc1xuXHRcdHRoaXMuZ3JvdXBNYXAgPSBuZXcgTWFwKCk7XG5cdFx0dGhpcy5ncm91cE5hbWVzID0gbmV3IEFycmF5KCk7XG5cdH1cblxuXHRkZXN0cm95KCk6IHZvaWQge1xuXHRcdHRoaXMucmVjZWl2ZXIuZGVzdHJveSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyBhIGdhbWVub2RlIHdpdGggdGhpcyBwaHlzaWNzIG1hbmFnZXJcblx0ICogQHBhcmFtIG9iamVjdCBUaGUgb2JqZWN0IHRvIHJlZ2lzdGVyXG5cdCAqL1xuXHRhYnN0cmFjdCByZWdpc3Rlck9iamVjdChvYmplY3Q6IFBoeXNpY2FsKTogdm9pZDtcblxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHJlZmVyZW5jZXMgdG8gdGhpcyBvYmplY3QgZnJvbSB0aGUgcGh5c2ljcyBtYW5hZ2VyclxuXHQgKiBAcGFyYW0gb2JqZWN0IFRoZSBvYmplY3QgdG8gZGVyZWdpc3RlclxuXHQgKi9cblx0YWJzdHJhY3QgZGVyZWdpc3Rlck9iamVjdChvYmplY3Q6IFBoeXNpY2FsKTogdm9pZDtcblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIGEgdGlsZW1hcCB3aXRoIHRoaXMgcGh5c2ljcyBtYW5hZ2VyXG5cdCAqIEBwYXJhbSB0aWxlbWFwIFRoZSB0aWxlbWFwIHRvIHJlZ2lzdGVyXG5cdCAqL1xuXHRhYnN0cmFjdCByZWdpc3RlclRpbGVtYXAodGlsZW1hcDogVGlsZW1hcCk6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgcmVmZXJlbmNlcyB0byB0aGlzIHRpbGVtYXAgZnJvbSB0aGUgcGh5c2ljcyBtYW5hZ2VyclxuXHQgKiBAcGFyYW0gdGlsZW1hcCBUaGUgb2JqZWN0IHRvIGRlcmVnaXN0ZXJcblx0ICovXG5cdGFic3RyYWN0IGRlcmVnaXN0ZXJUaWxlbWFwKHRpbGVtYXA6IFRpbGVtYXApOiB2b2lkO1xuXG5cdGFic3RyYWN0IHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHBoeXNpY3MgbGF5ZXIgb2YgdGhlIEdhbWVOb2RlXG5cdCAqIEBwYXJhbSBub2RlIFRoZSBHYW1lTm9kZVxuXHQgKiBAcGFyYW0gZ3JvdXAgVGhlIGdyb3VwIHRoYXQgdGhlIEdhbWVOb2RlIHNob3VsZCBiZSBvblxuXHQgKi9cblx0c2V0R3JvdXAobm9kZTogUGh5c2ljYWwsIGdyb3VwOiBzdHJpbmcpOiB2b2lkIHtcblx0XHRub2RlLmdyb3VwID0gdGhpcy5ncm91cE1hcC5nZXQoZ3JvdXApO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHJpZXZlcyB0aGUgbGF5ZXIgbnVtYmVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQgbmFtZVxuXHQgKiBAcGFyYW0gbGF5ZXIgVGhlIG5hbWUgb2YgdGhlIGxheWVyXG5cdCAqIEByZXR1cm5zIFRoZSBsYXllciBudW1iZXIsIG9yIDAgaWYgdGhlcmUgaXMgbm90IGEgbGF5ZXIgd2l0aCB0aGF0IG5hbWUgcmVnaXN0ZXJlZFxuXHQgKi9cblx0Z2V0R3JvdXBOdW1iZXIoZ3JvdXA6IHN0cmluZyk6IG51bWJlciB7XG5cdFx0aWYodGhpcy5ncm91cE1hcC5oYXMoZ3JvdXApKXtcblx0XHRcdHJldHVybiB0aGlzLmdyb3VwTWFwLmdldChncm91cCk7XG5cdFx0fSBlbHNle1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgYWxsIGdyb3VwIG5hbWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgbnVtYmVyIHByb3ZpZGVkXG5cdCAqIEBwYXJhbSBncm91cHMgQSBtYXNrIG9mIGdyb3Vwc1xuXHQgKiBAcmV0dXJucyBBbGwgZ3JvdXBzIGNvbnRhaW5lZCBpbiB0aGUgbWFza1xuXHQgKi9cblx0Z2V0R3JvdXBOYW1lcyhncm91cHM6IG51bWJlcik6IEFycmF5PHN0cmluZz4ge1xuXHRcdGlmKGdyb3VwcyA9PT0gLTEpe1xuXHRcdFx0cmV0dXJuIFtQaHlzaWNzTWFuYWdlci5ERUZBVUxUX0dST1VQXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IGcgPSAxO1xuXHRcdFx0bGV0IG5hbWVzID0gW107XG5cblx0XHRcdGZvcihsZXQgaSA9IDA7IGkgPCAzMjsgaSsrKXtcblx0XHRcdFx0aWYoZyAmIGdyb3Vwcyl7XG5cdFx0XHRcdFx0Ly8gVGhpcyBncm91cCBpcyBpbiB0aGUgZ3JvdXBzIG51bWJlclxuXHRcdFx0XHRcdG5hbWVzLnB1c2godGhpcy5ncm91cE5hbWVzW2ldKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNoaWZ0IHRoZSBiaXQgb3ZlclxuXHRcdFx0XHRnID0gZyA8PCAxO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSIsImltcG9ydCBRdWV1ZSBmcm9tIFwiLi4vRGF0YVR5cGVzL1F1ZXVlXCI7XG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4uL0V2ZW50cy9SZWNlaXZlclwiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IEV2ZW50UXVldWUgZnJvbSBcIi4uL0V2ZW50cy9FdmVudFF1ZXVlXCI7XG5pbXBvcnQgeyBHYW1lRXZlbnRUeXBlIH0gZnJvbSBcIi4uL0V2ZW50cy9HYW1lRXZlbnRUeXBlXCI7XG5cbi8vIEBpZ25vcmVQYWdlXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlY29yZGVyIHtcblx0cHJpdmF0ZSByZWNlaXZlcjogUmVjZWl2ZXI7XG5cdHByaXZhdGUgbG9nOiBRdWV1ZTxMb2dJdGVtPjtcblx0cHJpdmF0ZSByZWNvcmRpbmc6IGJvb2xlYW47XG5cdHByaXZhdGUgZXZlbnRRdWV1ZTogRXZlbnRRdWV1ZTtcblx0cHJpdmF0ZSBmcmFtZTogbnVtYmVyO1xuXHRwcml2YXRlIHBsYXlpbmc6IGJvb2xlYW47XG5cblx0Y29uc3RydWN0b3IoKXtcblx0XHR0aGlzLnJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKCk7XG5cdFx0dGhpcy5sb2cgPSBuZXcgUXVldWUoMTAwMCk7XG5cdFx0dGhpcy5yZWNvcmRpbmcgPSBmYWxzZTtcblx0XHR0aGlzLnBsYXlpbmcgPSBmYWxzZTtcblx0XHR0aGlzLmZyYW1lID0gMDtcblxuXHRcdHRoaXMuZXZlbnRRdWV1ZSA9IEV2ZW50UXVldWUuZ2V0SW5zdGFuY2UoKTtcblx0XHR0aGlzLmV2ZW50UXVldWUuc3Vic2NyaWJlKHRoaXMucmVjZWl2ZXIsIFwiYWxsXCIpO1xuXHR9XG5cblx0dXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG5cdFx0aWYodGhpcy5yZWNvcmRpbmcpe1xuXHRcdFx0dGhpcy5mcmFtZSArPSAxO1xuXHRcdH1cblxuXHRcdGlmKHRoaXMucGxheWluZyl7XG5cdFx0XHQvLyBJZiBwbGF5aW5nLCBpZ25vcmUgZXZlbnRzLCBqdXN0IGZlZWQgdGhlIHJlY29yZCB0byB0aGUgZXZlbnQgcXVldWVcblx0XHRcdHRoaXMucmVjZWl2ZXIuaWdub3JlRXZlbnRzKCk7XG5cblx0XHRcdC8qXG5cdFx0XHRcdFdoaWxlIHRoZXJlIGlzIGEgbmV4dCBpdGVtLCBhbmQgd2hpbGUgaXQgc2hvdWxkIG9jY3VyIGluIHRoaXMgZnJhbWUsXG5cdFx0XHRcdHNlbmQgdGhlIGV2ZW50LiBpLmUuLCB3aGlsZSBjdXJyZW50X2ZyYW1lICogY3VycmVudF9kZWx0YV90IGlzIGdyZWF0ZXJcblx0XHRcdFx0dGhhbiByZWNvcmRlZF9mcmFtZSAqIHJlY29yZGVkX2RlbHRhX3Rcblx0XHRcdCovXG5cdFx0XHR3aGlsZSh0aGlzLmxvZy5oYXNJdGVtcygpXG5cdFx0XHRcdFx0JiYgdGhpcy5sb2cucGVla05leHQoKS5mcmFtZSAqIHRoaXMubG9nLnBlZWtOZXh0KCkuZGVsdGEgPCB0aGlzLmZyYW1lICogZGVsdGFUKXtcblx0XHRcdFx0bGV0IGV2ZW50ID0gdGhpcy5sb2cuZGVxdWV1ZSgpLmV2ZW50O1xuXHRcdFx0XHRjb25zb2xlLmxvZyhldmVudCk7XG5cdFx0XHRcdHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChldmVudCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKCF0aGlzLmxvZy5oYXNJdGVtcygpKXtcblx0XHRcdFx0dGhpcy5wbGF5aW5nID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZnJhbWUgKz0gMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gSWYgbm90IHBsYXlpbmcsIGhhbmRsZSBldmVudHNcblx0XHRcdHdoaWxlKHRoaXMucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpe1xuXHRcdFx0XHRsZXQgZXZlbnQgPSB0aGlzLnJlY2VpdmVyLmdldE5leHRFdmVudCgpO1xuXG5cdFx0XHRcdGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuU1RPUF9SRUNPUkRJTkcpe1xuXHRcdFx0XHRcdHRoaXMucmVjb3JkaW5nID0gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZih0aGlzLnJlY29yZGluZyl7XG5cdFx0XHRcdFx0dGhpcy5sb2cuZW5xdWV1ZShuZXcgTG9nSXRlbSh0aGlzLmZyYW1lLCBkZWx0YVQsIGV2ZW50KSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlNUQVJUX1JFQ09SRElORyl7XG5cdFx0XHRcdFx0dGhpcy5sb2cuY2xlYXIoKTtcblx0XHRcdFx0XHR0aGlzLnJlY29yZGluZyA9IHRydWU7XG5cdFx0XHRcdFx0dGhpcy5mcmFtZSA9IDBcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuUExBWV9SRUNPUkRJTkcpe1xuXHRcdFx0XHRcdHRoaXMuZnJhbWUgPSAwO1xuXHRcdFx0XHRcdHRoaXMucmVjb3JkaW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0dGhpcy5wbGF5aW5nID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5jbGFzcyBMb2dJdGVtIHtcblx0ZnJhbWU6IG51bWJlcjtcblx0ZGVsdGE6IG51bWJlcjtcblx0ZXZlbnQ6IEdhbWVFdmVudDtcblxuXHRjb25zdHJ1Y3RvcihmcmFtZTogbnVtYmVyLCBkZWx0YVQ6IG51bWJlciwgZXZlbnQ6IEdhbWVFdmVudCl7XG5cdFx0dGhpcy5mcmFtZSA9IGZyYW1lO1xuXHRcdHRoaXMuZGVsdGEgPSBkZWx0YVQ7XG5cdFx0dGhpcy5ldmVudCA9IGV2ZW50O1xuXHR9XG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL01hcFwiO1xuXG4vKiogKi9cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFJlZ2lzdHJ5PFQ+IGV4dGVuZHMgTWFwPFQ+e1xuXG4gICAgLyoqIFByZWxvYWRzIHJlZ2lzdHJ5IGRhdGEgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgcHJlbG9hZCgpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGFuIGl0ZW0gYW5kIHByZWxvYWRzIGFueSBuZWNlc3NhcnkgZmlsZXNcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gcmVnaXN0ZXIgdGhpcyBpdGVtIHdpdGhcbiAgICAgKiBAcGFyYW0gYXJncyBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgbmVlZGVkIGZvciByZWdpc3RyYXRpb25cbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgcmVnaXN0ZXJBbmRQcmVsb2FkSXRlbShrZXk6IHN0cmluZywgLi4uYXJnczogYW55KTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhbiBpdGVtIGFuZCBwcmVsb2FkcyBhbnkgbmVjZXNzYXJ5IGZpbGVzXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIHJlZ2lzdGVyIHRoaXMgaXRlbSB3aXRoXG4gICAgICogQHBhcmFtIGFyZ3MgQW55IGFkaXRpb25hbCBhcmd1bWVudHMgbmVlZGVkIGZvciByZWdpc3RyYXRpb25cbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgcmVnaXN0ZXJJdGVtKGtleTogc3RyaW5nLCAuLi5hcmdzOiBhbnkpOiB2b2lkO1xufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9NYXBcIjtcbmltcG9ydCBTaGFkZXJUeXBlIGZyb20gXCIuLi8uLi9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZVwiO1xuaW1wb3J0IExhYmVsU2hhZGVyVHlwZSBmcm9tIFwiLi4vLi4vUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL0xhYmVsU2hhZGVyVHlwZVwiO1xuaW1wb3J0IFBvaW50U2hhZGVyVHlwZSBmcm9tIFwiLi4vLi4vUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL1BvaW50U2hhZGVyVHlwZVwiO1xuaW1wb3J0IFJlY3RTaGFkZXJUeXBlIGZyb20gXCIuLi8uLi9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZXMvUmVjdFNoYWRlclR5cGVcIjtcbmltcG9ydCBTcHJpdGVTaGFkZXJUeXBlIGZyb20gXCIuLi8uLi9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZXMvU3ByaXRlU2hhZGVyVHlwZVwiO1xuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xuaW1wb3J0IFJlZ2lzdHJ5IGZyb20gXCIuL1JlZ2lzdHJ5XCI7XG5cbi8qKlxuICogQSByZWdpc3RyeSB0aGF0IGhhbmRsZXMgc2hhZGVyc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFkZXJSZWdpc3RyeSBleHRlbmRzIFJlZ2lzdHJ5PFNoYWRlclR5cGU+IHtcblxuXHQvLyBTaGFkZXIgbmFtZXNcblx0cHVibGljIHN0YXRpYyBQT0lOVF9TSEFERVIgPSBcInBvaW50XCI7XG5cdHB1YmxpYyBzdGF0aWMgUkVDVF9TSEFERVIgPSBcInJlY3RcIjtcblx0cHVibGljIHN0YXRpYyBTUFJJVEVfU0hBREVSID0gXCJzcHJpdGVcIjtcblx0cHVibGljIHN0YXRpYyBMQUJFTF9TSEFERVIgPSBcImxhYmVsXCI7XG5cblx0cHJpdmF0ZSByZWdpc3RyeUl0ZW1zOiBBcnJheTxTaGFkZXJSZWdpc3RyeUl0ZW0+ID0gbmV3IEFycmF5KCk7XG5cblx0LyoqXG5cdCAqIFByZWxvYWRzIGFsbCBidWlsdC1pbiBzaGFkZXJzXG5cdCAqL1xuXHRwdWJsaWMgcHJlbG9hZCgpe1xuXHRcdC8vIEdldCB0aGUgcmVzb3VyY2VNYW5hZ2VyIGFuZCBxdWV1ZSBhbGwgYnVpbHQtaW4gc2hhZGVycyBmb3IgcHJlbG9hZGluZ1xuXHRcdGNvbnN0IHJtID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XG5cblx0XHQvLyBRdWV1ZSBhIGxvYWQgZm9yIHRoZSBwb2ludCBzaGFkZXJcblx0XHR0aGlzLnJlZ2lzdGVyQW5kUHJlbG9hZEl0ZW0oU2hhZGVyUmVnaXN0cnkuUE9JTlRfU0hBREVSLCBQb2ludFNoYWRlclR5cGUsIFwiYnVpbHRpbi9zaGFkZXJzL3BvaW50LnZzaGFkZXJcIiwgXCJidWlsdGluL3NoYWRlcnMvcG9pbnQuZnNoYWRlclwiKTtcblxuXHRcdC8vIFF1ZXVlIGEgbG9hZCBmb3IgdGhlIHJlY3Qgc2hhZGVyXG5cdFx0dGhpcy5yZWdpc3RlckFuZFByZWxvYWRJdGVtKFNoYWRlclJlZ2lzdHJ5LlJFQ1RfU0hBREVSLCBSZWN0U2hhZGVyVHlwZSwgXCJidWlsdGluL3NoYWRlcnMvcmVjdC52c2hhZGVyXCIsIFwiYnVpbHRpbi9zaGFkZXJzL3JlY3QuZnNoYWRlclwiKTtcblxuXHRcdC8vIFF1ZXVlIGEgbG9hZCBmb3IgdGhlIHNwcml0ZSBzaGFkZXJcblx0XHR0aGlzLnJlZ2lzdGVyQW5kUHJlbG9hZEl0ZW0oU2hhZGVyUmVnaXN0cnkuU1BSSVRFX1NIQURFUiwgU3ByaXRlU2hhZGVyVHlwZSwgXCJidWlsdGluL3NoYWRlcnMvc3ByaXRlLnZzaGFkZXJcIiwgXCJidWlsdGluL3NoYWRlcnMvc3ByaXRlLmZzaGFkZXJcIik7XG5cdFxuXHRcdC8vIFF1ZXVlIGEgbG9hZCBmb3IgdGhlIGxhYmVsIHNoYWRlclxuXHRcdHRoaXMucmVnaXN0ZXJBbmRQcmVsb2FkSXRlbShTaGFkZXJSZWdpc3RyeS5MQUJFTF9TSEFERVIsIExhYmVsU2hhZGVyVHlwZSwgXCJidWlsdGluL3NoYWRlcnMvbGFiZWwudnNoYWRlclwiLCBcImJ1aWx0aW4vc2hhZGVycy9sYWJlbC5mc2hhZGVyXCIpO1xuXG5cdFx0Ly8gUXVldWUgYSBsb2FkIGZvciBhbnkgcHJlbG9hZGVkIGl0ZW1zXG5cdFx0Zm9yKGxldCBpdGVtIG9mIHRoaXMucmVnaXN0cnlJdGVtcyl7XG5cdFx0XHRjb25zdCBzaGFkZXIgPSBuZXcgaXRlbS5jb25zdHIoaXRlbS5rZXkpO1xuXHRcdFx0c2hhZGVyLmluaXRCdWZmZXJPYmplY3QoKTtcblx0XHRcdHRoaXMuYWRkKGl0ZW0ua2V5LCBzaGFkZXIpO1xuXG5cdFx0XHQvLyBMb2FkIGlmIGRlc2lyZWRcblx0XHRcdGlmKGl0ZW0ucHJlbG9hZCAhPT0gdW5kZWZpbmVkKXtcblx0XHRcdFx0cm0uc2hhZGVyKGl0ZW0ua2V5LCBpdGVtLnByZWxvYWQudnNoYWRlckxvY2F0aW9uLCBpdGVtLnByZWxvYWQuZnNoYWRlckxvY2F0aW9uKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIGEgc2hhZGVyIGluIHRoZSByZWdpc3RyeSBhbmQgbG9hZHMgaXQgYmVmb3JlIHRoZSBnYW1lIGJlZ2luc1xuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgeW91IHdpc2ggdG8gYXNzaWduIHRvIHRoZSBzaGFkZXJcblx0ICogQHBhcmFtIGNvbnN0ciBUaGUgY29uc3RydWN0b3Igb2YgdGhlIFNoYWRlclR5cGVcblx0ICogQHBhcmFtIHZzaGFkZXJMb2NhdGlvbiBUaGUgbG9jYXRpb24gb2YgdGhlIHZlcnRleCBzaGFkZXJcblx0ICogQHBhcmFtIGZzaGFkZXJMb2NhdGlvbiB0aGUgbG9jYXRpb24gb2YgdGhlIGZyYWdtZW50IHNoYWRlclxuXHQgKi9cblx0cHVibGljIHJlZ2lzdGVyQW5kUHJlbG9hZEl0ZW0oa2V5OiBzdHJpbmcsIGNvbnN0cjogbmV3IChwcm9ncmFtS2V5OiBzdHJpbmcpID0+IFNoYWRlclR5cGUsIHZzaGFkZXJMb2NhdGlvbjogc3RyaW5nLCBmc2hhZGVyTG9jYXRpb246IHN0cmluZyk6IHZvaWQge1xuXHRcdGxldCBzaGFkZXJQcmVsb2FkID0gbmV3IFNoYWRlclByZWxvYWQoKTtcblx0XHRzaGFkZXJQcmVsb2FkLnZzaGFkZXJMb2NhdGlvbiA9IHZzaGFkZXJMb2NhdGlvbjtcblx0XHRzaGFkZXJQcmVsb2FkLmZzaGFkZXJMb2NhdGlvbiA9IGZzaGFkZXJMb2NhdGlvbjtcblxuXHRcdGxldCByZWdpc3RyeUl0ZW0gPSBuZXcgU2hhZGVyUmVnaXN0cnlJdGVtKCk7XG5cdFx0cmVnaXN0cnlJdGVtLmtleSA9IGtleTtcblx0XHRyZWdpc3RyeUl0ZW0uY29uc3RyID0gY29uc3RyO1xuXHRcdHJlZ2lzdHJ5SXRlbS5wcmVsb2FkID0gc2hhZGVyUHJlbG9hZDtcblxuXHRcdHRoaXMucmVnaXN0cnlJdGVtcy5wdXNoKHJlZ2lzdHJ5SXRlbSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIGEgc2hhZGVyIGluIHRoZSByZWdpc3RyeS4gTk9URTogSWYgeW91IHVzZSB0aGlzLCB5b3UgTVVTVCBsb2FkIHRoZSBzaGFkZXIgYmVmb3JlIHVzZS5cblx0ICogSWYgeW91IHdpc2ggdG8gcHJlbG9hZCB0aGUgc2hhZGVyLCB1c2UgcmVnaXN0ZXJBbmRQcmVsb2FkSXRlbSgpXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSB5b3Ugd2lzaCB0byBhc3NpZ24gdG8gdGhlIHNoYWRlclxuXHQgKiBAcGFyYW0gY29uc3RyIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgU2hhZGVyVHlwZVxuXHQgKi9cblx0cHVibGljIHJlZ2lzdGVySXRlbShrZXk6IHN0cmluZywgY29uc3RyOiBuZXcgKHByb2dyYW1LZXk6IHN0cmluZykgPT4gU2hhZGVyVHlwZSk6IHZvaWQge1xuXHRcdGxldCByZWdpc3RyeUl0ZW0gPSBuZXcgU2hhZGVyUmVnaXN0cnlJdGVtKCk7XG5cdFx0cmVnaXN0cnlJdGVtLmtleSA9IGtleTtcblx0XHRyZWdpc3RyeUl0ZW0uY29uc3RyID0gY29uc3RyO1xuXG5cdFx0dGhpcy5yZWdpc3RyeUl0ZW1zLnB1c2gocmVnaXN0cnlJdGVtKTtcblx0fVxufVxuXG5jbGFzcyBTaGFkZXJSZWdpc3RyeUl0ZW0ge1xuXHRrZXk6IHN0cmluZztcblx0Y29uc3RyOiBuZXcgKHByb2dyYW1LZXk6IHN0cmluZykgPT4gU2hhZGVyVHlwZTtcblx0cHJlbG9hZDogU2hhZGVyUHJlbG9hZDtcbn1cblxuY2xhc3MgU2hhZGVyUHJlbG9hZCB7XG5cdHZzaGFkZXJMb2NhdGlvbjogc3RyaW5nO1xuXHRmc2hhZGVyTG9jYXRpb246IHN0cmluZztcbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XG5pbXBvcnQgUmVnaXN0cnkgZnJvbSBcIi4vUmVnaXN0cmllcy9SZWdpc3RyeVwiO1xuaW1wb3J0IFNoYWRlclJlZ2lzdHJ5IGZyb20gXCIuL1JlZ2lzdHJpZXMvU2hhZGVyUmVnaXN0cnlcIjtcblxuLyoqXG4gKiBUaGUgUmVnaXN0cnkgaXMgdGhlIHN5c3RlbSdzIHdheSBvZiBjb252ZXJ0aW5nIGNsYXNzZXMgYW5kIHR5cGVzIGludG8gc3RyaW5nXG4gKiByZXByZXNlbnRhdGlvbnMgZm9yIHVzZSBlbHNld2hlcmUgaW4gdGhlIGFwcGxpY2F0aW9uLlxuICogSXQgYWxsb3dzIGNsYXNzZXMgdG8gYmUgYWNjZXNzZWQgd2l0aG91dCBleHBsaWNpdGx5IHVzaW5nIGNvbnN0cnVjdG9ycyBpbiBjb2RlLFxuICogYW5kIGZvciByZXNvdXJjZXMgdG8gYmUgbG9hZGVkIGF0IEdhbWUgY3JlYXRpb24gdGltZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVnaXN0cnlNYW5hZ2VyIHtcblxuXHRwdWJsaWMgc3RhdGljIHNoYWRlcnMgPSBuZXcgU2hhZGVyUmVnaXN0cnkoKTtcblxuXHQvKiogQWRkaXRpb25hbCBjdXN0b20gcmVnaXN0cmllcyB0byBhZGQgdG8gdGhlIHJlZ2lzdHJ5IG1hbmFnZXIgKi9cblx0cHJvdGVjdGVkIHN0YXRpYyByZWdpc3RyaWVzOiBNYXA8UmVnaXN0cnk8YW55Pj4gPSBuZXcgTWFwKCk7XG5cblx0c3RhdGljIHByZWxvYWQoKXtcblx0XHR0aGlzLnNoYWRlcnMucHJlbG9hZCgpO1xuXG5cdFx0dGhpcy5yZWdpc3RyaWVzLmZvckVhY2goKGtleTogc3RyaW5nKSA9PiB0aGlzLnJlZ2lzdHJpZXMuZ2V0KGtleSkucHJlbG9hZCgpKTtcblx0fVxuXG5cdHN0YXRpYyBhZGRDdXN0b21SZWdpc3RyeShuYW1lOiBzdHJpbmcsIHJlZ2lzdHJ5OiBSZWdpc3RyeTxhbnk+KXtcblx0XHR0aGlzLnJlZ2lzdHJpZXMuYWRkKG5hbWUsIHJlZ2lzdHJ5KTtcblx0fVxuXG5cdHN0YXRpYyBnZXRSZWdpc3RyeShrZXk6IHN0cmluZyl7XG5cdFx0cmV0dXJuIHRoaXMucmVnaXN0cmllcy5nZXQoa2V5KTtcblx0fVxufSIsImltcG9ydCBSZWdpc3RyeSBmcm9tIFwiLi9SZWdpc3RyaWVzL1JlZ2lzdHJ5XCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgTGFzZXJHdW4gZnJvbSBcIi4uLy4uL21heWhlbUZpbGVzL0dhbWVTeXN0ZW1zL2l0ZW1zL1dlYXBvblR5cGVzL0xhc2VyR3VuXCI7XG5pbXBvcnQgU2VtaUF1dG9HdW4gZnJvbSBcIi4uLy4uL21heWhlbUZpbGVzL0dhbWVTeXN0ZW1zL2l0ZW1zL1dlYXBvblR5cGVzL1NlbWlBdXRvR3VuXCI7XG5pbXBvcnQgU2xpY2UgZnJvbSBcIi4uLy4uL21heWhlbUZpbGVzL0dhbWVTeXN0ZW1zL2l0ZW1zL1dlYXBvblR5cGVzL1NsaWNlXCI7XG5pbXBvcnQgV2VhcG9uVHlwZSBmcm9tIFwiLi4vLi4vbWF5aGVtRmlsZXMvR2FtZVN5c3RlbXMvaXRlbXMvV2VhcG9uVHlwZXMvV2VhcG9uVHlwZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWFwb25UZW1wbGF0ZVJlZ2lzdHJ5IGV4dGVuZHMgUmVnaXN0cnk8V2VhcG9uQ29uc3RydWN0b3I+IHtcbiAgICBcbiAgICBwdWJsaWMgcHJlbG9hZCgpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgcm0gPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcblxuICAgICAgICAvLyBMb2FkIHNwcml0ZXNcbiAgICAgICAgcm0uaW1hZ2UoXCJwaXN0b2xcIiwgXCJtYXloZW1Bc3NldHMvc3ByaXRlcy9waXN0b2wucG5nXCIpO1xuICAgICAgICBybS5pbWFnZShcImtuaWZlXCIsIFwibWF5aGVtQXNzZXRzL3Nwcml0ZXMva25pZmUucG5nXCIpO1xuICAgICAgICBybS5pbWFnZShcImxhc2VyR3VuXCIsIFwibWF5aGVtQXNzZXRzL3Nwcml0ZXMvbGFzZXJHdW4ucG5nXCIpXG5cbiAgICAgICAgLy8gTG9hZCBzcHJpdGVzaGVldHNcbiAgICAgICAgcm0uc3ByaXRlc2hlZXQoXCJzbGljZVwiLCBcIm1heWhlbUFzc2V0cy9zcHJpdGVzaGVldHMvc2xpY2UuanNvblwiKTtcblxuICAgICAgICAvLyBSZWdpc3RlciBkZWZhdWx0IHR5cGVzXG4gICAgICAgIHRoaXMucmVnaXN0ZXJJdGVtKFwic2xpY2VcIiwgU2xpY2UpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVySXRlbShcImxhc2VyR3VuXCIsIExhc2VyR3VuKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlckl0ZW0oXCJzZW1pQXV0b0d1blwiLCBTZW1pQXV0b0d1bik7XG4gICAgfVxuXG4gICAgLy8gV2UgZG9uJ3QgbmVlZCB0aGlzIGZvciB0aGlzIGFzc2lnbm1lbnRcbiAgICBwdWJsaWMgcmVnaXN0ZXJBbmRQcmVsb2FkSXRlbShrZXk6IHN0cmluZyk6IHZvaWQge31cblxuICAgIHB1YmxpYyByZWdpc3Rlckl0ZW0oa2V5OiBzdHJpbmcsIGNvbnN0cjogV2VhcG9uQ29uc3RydWN0b3IpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hZGQoa2V5LCBjb25zdHIpO1xuICAgIH1cbn1cblxudHlwZSBXZWFwb25Db25zdHJ1Y3RvciA9IG5ldyAoLi4uYXJnczogYW55KSA9PiBXZWFwb25UeXBlOyIsImltcG9ydCBSZWdpc3RyeSBmcm9tIFwiLi9SZWdpc3RyaWVzL1JlZ2lzdHJ5XCI7XG5pbXBvcnQgV2VhcG9uVHlwZSBmcm9tIFwiLi4vLi4vbWF5aGVtRmlsZXMvR2FtZVN5c3RlbXMvaXRlbXMvV2VhcG9uVHlwZXMvV2VhcG9uVHlwZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWFwb25UeXBlUmVnaXN0cnkgZXh0ZW5kcyBSZWdpc3RyeTxXZWFwb25UeXBlPiB7XG4gICAgXG4gICAgcHVibGljIHByZWxvYWQoKTogdm9pZCB7fVxuXG4gICAgLy8gV2UgZG9uJ3QgbmVlZCB0aGlzIGZvciB0aGlzIGFzc2lnbm1lbnRcbiAgICBwdWJsaWMgcmVnaXN0ZXJBbmRQcmVsb2FkSXRlbShrZXk6IHN0cmluZyk6IHZvaWQge31cblxuICAgIHB1YmxpYyByZWdpc3Rlckl0ZW0oa2V5OiBzdHJpbmcsIHR5cGU6IFdlYXBvblR5cGUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hZGQoa2V5LCB0eXBlKTtcbiAgICB9XG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vLi4vRXZlbnRzL0VtaXR0ZXJcIjtcclxuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uLy4uL05vZGVzL0NhbnZhc05vZGVcIjtcclxuaW1wb3J0IHsgQW5pbWF0aW9uRGF0YSwgQW5pbWF0aW9uU3RhdGUgfSBmcm9tIFwiLi9BbmltYXRpb25UeXBlc1wiO1xyXG5cclxuLyoqXHJcbiAqIEFuIGFuaW1hdGlvbiBtYW5hZ2VyIGNsYXNzIGZvciBhbiBhbmltYXRlZCBDYW52YXNOb2RlLlxyXG4gKiBUaGlzIGNsYXNzIGtlZXBzIHRyYWNrIG9mIHRoZSBwb3NzaWJsZSBhbmltYXRpb25zLCBhcyB3ZWxsIGFzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBzdGF0ZSxcclxuICogYW5kIGFic3RyYWN0cyBhbGwgaW50ZXJhY3Rpb25zIHdpdGggcGxheWluZywgcGF1c2luZywgYW5kIHN0b3BwaW5nIGFuaW1hdGlvbnMgYXMgd2VsbCBhc1xyXG4gKiBjcmVhdGluZyBuZXcgYW5pbWF0aW9ucyBmcm9tIHRoZSBDYW52YXNOb2RlLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0aW9uTWFuYWdlciB7XHJcbiAgLyoqIFRoZSBvd25lciBvZiB0aGlzIGFuaW1hdGlvbiBtYW5hZ2VyICovXHJcbiAgcHJvdGVjdGVkIG93bmVyOiBDYW52YXNOb2RlO1xyXG5cclxuICAvKiogVGhlIGN1cnJlbnQgYW5pbWF0aW9uIHN0YXRlIG9mIHRoaXMgc3ByaXRlICovXHJcbiAgcHJvdGVjdGVkIGFuaW1hdGlvblN0YXRlOiBBbmltYXRpb25TdGF0ZTtcclxuXHJcbiAgLyoqIFRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBvZiB0aGlzIHNwcml0ZSAqL1xyXG4gIHByb3RlY3RlZCBjdXJyZW50QW5pbWF0aW9uOiBzdHJpbmc7XHJcblxyXG4gIC8qKiBUaGUgY3VycmVudCBmcmFtZSBvZiB0aGlzIGFuaW1hdGlvbiAqL1xyXG4gIHByb3RlY3RlZCBjdXJyZW50RnJhbWU6IG51bWJlcjtcclxuXHJcbiAgLyoqIFRoZSBwcm9ncmVzcyBvZiB0aGUgY3VycmVudCBhbmltYXRpb24gdGhyb3VnaCB0aGUgY3VycmVudCBmcmFtZSAqL1xyXG4gIHByb3RlY3RlZCBmcmFtZVByb2dyZXNzOiBudW1iZXI7XHJcblxyXG4gIC8qKiBXaGV0aGVyIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBpcyBsb29waW5nIG9yIG5vdCAqL1xyXG4gIHByb3RlY3RlZCBsb29wOiBib29sZWFuO1xyXG5cclxuICAvKiogVGhlIG1hcCBvZiBhbmltYXRpb25zICovXHJcbiAgcHJvdGVjdGVkIGFuaW1hdGlvbnM6IE1hcDxBbmltYXRpb25EYXRhPjtcclxuXHJcbiAgLyoqIFRoZSBuYW1lIG9mIHRoZSBldmVudCAoaWYgYW55KSB0byBzZW5kIHdoZW4gdGhlIGN1cnJlbnQgYW5pbWF0aW9uIHN0b3BzIHBsYXlpbmcuICovXHJcbiAgcHJvdGVjdGVkIG9uRW5kRXZlbnQ6IHN0cmluZztcclxuXHJcbiAgLyoqIFRoZSBldmVudCBlbWl0dGVyIGZvciB0aGlzIGFuaW1hdGlvbiBtYW5hZ2VyICovXHJcbiAgcHJvdGVjdGVkIGVtaXR0ZXI6IEVtaXR0ZXI7XHJcblxyXG4gIC8qKiBBIHF1ZXVlZCBhbmltYXRpb24gKi9cclxuICBwcm90ZWN0ZWQgcGVuZGluZ0FuaW1hdGlvbjogc3RyaW5nO1xyXG5cclxuICAvKiogVGhlIGxvb3Agc3RhdHVzIG9mIGEgcGVuZGluZyBhbmltYXRpb24gKi9cclxuICBwcm90ZWN0ZWQgcGVuZGluZ0xvb3A6IGJvb2xlYW47XHJcblxyXG4gIC8qKiBUaGUgb25FbmQgZXZlbnQgb2YgYSBwZW5kaW5nIGFuaW1hdGlvbiAqL1xyXG4gIHByb3RlY3RlZCBwZW5kaW5nT25FbmQ6IHN0cmluZztcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBBbmltYXRpb25NYW5hZ2VyXHJcbiAgICogQHBhcmFtIG93bmVyIFRoZSBvd25lciBvZiB0aGUgQW5pbWF0aW9uTWFuYWdlclxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKG93bmVyOiBDYW52YXNOb2RlKSB7XHJcbiAgICB0aGlzLm93bmVyID0gb3duZXI7XHJcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGUuU1RPUFBFRDtcclxuICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IFwiXCI7XHJcbiAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XHJcbiAgICB0aGlzLmZyYW1lUHJvZ3Jlc3MgPSAwO1xyXG4gICAgdGhpcy5sb29wID0gZmFsc2U7XHJcbiAgICB0aGlzLmFuaW1hdGlvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLm9uRW5kRXZlbnQgPSBudWxsO1xyXG4gICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBhbiBhbmltYXRpb24gdG8gdGhpcyBzcHJpdGVcclxuICAgKiBAcGFyYW0ga2V5IFRoZSB1bmlxdWUga2V5IG9mIHRoZSBhbmltYXRpb25cclxuICAgKiBAcGFyYW0gYW5pbWF0aW9uIFRoZSBhbmltYXRpb24gZGF0YVxyXG4gICAqL1xyXG4gIGFkZChrZXk6IHN0cmluZywgYW5pbWF0aW9uOiBBbmltYXRpb25EYXRhKTogdm9pZCB7XHJcbiAgICB0aGlzLmFuaW1hdGlvbnMuYWRkKGtleSwgYW5pbWF0aW9uKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGluZGV4IHNwZWNpZmllZCBieSB0aGUgY3VycmVudCBhbmltYXRpb24gYW5kIGN1cnJlbnQgZnJhbWVcclxuICAgKiBAcmV0dXJucyBUaGUgaW5kZXggaW4gdGhlIGN1cnJlbnQgYW5pbWF0aW9uXHJcbiAgICovXHJcbiAgZ2V0SW5kZXgoKTogbnVtYmVyIHtcclxuICAgIGlmICh0aGlzLmFuaW1hdGlvbnMuaGFzKHRoaXMuY3VycmVudEFuaW1hdGlvbikpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9ucy5nZXQodGhpcy5jdXJyZW50QW5pbWF0aW9uKS5mcmFtZXNbXHJcbiAgICAgICAgdGhpcy5jdXJyZW50RnJhbWVcclxuICAgICAgXS5pbmRleDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIE5vIGN1cnJlbnQgYW5pbWF0aW9uLCB3YXJuIHRoZSB1c2VyXHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICBgQW5pbWF0aW9uIGluZGV4IHdhcyByZXF1ZXN0ZWQsIGJ1dCB0aGUgY3VycmVudCBhbmltYXRpb246ICR7dGhpcy5jdXJyZW50QW5pbWF0aW9ufSB3YXMgaW52YWxpZGBcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXRDdXJyZW50QW5pbWF0aW9uKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50QW5pbWF0aW9uO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBhbmltYXRpb24gaXMgY3VycmVudGx5IHBsYXlpbmdcclxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGFuaW1hdGlvbiB0byBjaGVja1xyXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBhbmltYXRpb24gaXMgcGxheWluZywgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICovXHJcbiAgaXNQbGF5aW5nKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24gPT09IGtleSAmJlxyXG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXRlID09PSBBbmltYXRpb25TdGF0ZS5QTEFZSU5HXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBpbmRleCBhbmQgYWR2YW5jZXMgdGhlIGFuaW1hdGlvbiBmcmFtZVxyXG4gICAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgYW5pbWF0aW9uIGZyYW1lXHJcbiAgICovXHJcbiAgZ2V0SW5kZXhBbmRBZHZhbmNlQW5pbWF0aW9uKCk6IG51bWJlciB7XHJcbiAgICAvLyBJZiB3ZSBhcmVuJ3QgcGxheWluZywgd2Ugd29uJ3QgYmUgYWR2YW5jaW5nIHRoZSBhbmltYXRpb25cclxuICAgIGlmICghKHRoaXMuYW5pbWF0aW9uU3RhdGUgPT09IEFuaW1hdGlvblN0YXRlLlBMQVlJTkcpKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldEluZGV4KCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuYW5pbWF0aW9ucy5oYXModGhpcy5jdXJyZW50QW5pbWF0aW9uKSkge1xyXG4gICAgICBsZXQgY3VycmVudEFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9ucy5nZXQodGhpcy5jdXJyZW50QW5pbWF0aW9uKTtcclxuICAgICAgbGV0IGluZGV4ID0gY3VycmVudEFuaW1hdGlvbi5mcmFtZXNbdGhpcy5jdXJyZW50RnJhbWVdLmluZGV4O1xyXG5cclxuICAgICAgLy8gQWR2YW5jZSB0aGUgYW5pbWF0aW9uXHJcbiAgICAgIHRoaXMuZnJhbWVQcm9ncmVzcyArPSAxO1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgdGhpcy5mcmFtZVByb2dyZXNzID49XHJcbiAgICAgICAgY3VycmVudEFuaW1hdGlvbi5mcmFtZXNbdGhpcy5jdXJyZW50RnJhbWVdLmR1cmF0aW9uXHJcbiAgICAgICkge1xyXG4gICAgICAgIC8vIFdlIGhhdmUgYmVlbiBvbiB0aGlzIGZyYW1lIGZvciBpdHMgd2hvbGUgZHVyYXRpb24sIGdvIHRvIHRoZSBuZXh0IG9uZVxyXG4gICAgICAgIHRoaXMuZnJhbWVQcm9ncmVzcyA9IDA7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgKz0gMTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEZyYW1lID49IGN1cnJlbnRBbmltYXRpb24uZnJhbWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgLy8gV2UgaGF2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhpcyBhbmltYXRpb25cclxuICAgICAgICAgIGlmICh0aGlzLmxvb3ApIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmZyYW1lUHJvZ3Jlc3MgPSAwO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5lbmRDdXJyZW50QW5pbWF0aW9uKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZXR1cm4gdGhlIGN1cnJlbnQgaW5kZXhcclxuICAgICAgcmV0dXJuIGluZGV4O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gTm8gY3VycmVudCBhbmltYXRpb24sIGNhbid0IGFkdmFuY2UuIFdhcm4gdGhlIHVzZXJcclxuICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgIGBBbmltYXRpb24gaW5kZXggYW5kIGFkdmFuY2Ugd2FzIHJlcXVlc3RlZCwgYnV0IHRoZSBjdXJyZW50IGFuaW1hdGlvbiAoJHt0aGlzLmN1cnJlbnRBbmltYXRpb259KSBpbiBub2RlIHdpdGggaWQ6ICR7dGhpcy5vd25lci5pZH0gd2FzIGludmFsaWRgXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIEVuZHMgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGFuZCBmaXJlcyBhbnkgbmVjZXNzYXJ5IGV2ZW50cywgYXMgd2VsbCBhcyBzdGFydGluZyBhbnkgbmV3IGFuaW1hdGlvbnMgKi9cclxuICBwcm90ZWN0ZWQgZW5kQ3VycmVudEFuaW1hdGlvbigpOiB2b2lkIHtcclxuICAgIHRoaXMuY3VycmVudEZyYW1lID0gMDtcclxuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5TVE9QUEVEO1xyXG5cclxuICAgIGlmICh0aGlzLm9uRW5kRXZlbnQgIT09IG51bGwpIHtcclxuICAgICAgdGhpcy5lbWl0dGVyLmZpcmVFdmVudCh0aGlzLm9uRW5kRXZlbnQsIHtcclxuICAgICAgICBvd25lcjogdGhpcy5vd25lci5pZCxcclxuICAgICAgICBhbmltYXRpb246IHRoaXMuY3VycmVudEFuaW1hdGlvbixcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgdGhlcmUgaXMgYSBwZW5kaW5nIGFuaW1hdGlvbiwgcGxheSBpdFxyXG4gICAgaWYgKHRoaXMucGVuZGluZ0FuaW1hdGlvbiAhPT0gbnVsbCkge1xyXG4gICAgICB0aGlzLnBsYXkodGhpcy5wZW5kaW5nQW5pbWF0aW9uLCB0aGlzLnBlbmRpbmdMb29wLCB0aGlzLnBlbmRpbmdPbkVuZCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQbGF5cyB0aGUgc3BlY2lmaWVkIGFuaW1hdGlvbi4gRG9lcyBub3QgcmVzdGFydCBpdCBpZiBpdCBpcyBhbHJlYWR5IHBsYXlpbmdcclxuICAgKiBAcGFyYW0gYW5pbWF0aW9uIFRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdG8gcGxheVxyXG4gICAqIEBwYXJhbSBsb29wIFdoZXRoZXIgb3Igbm90IHRvIGxvb3AgdGhlIGFuaW1hdGlvbi4gRmFsc2UgYnkgZGVmYXVsdFxyXG4gICAqIEBwYXJhbSBvbkVuZCBUaGUgbmFtZSBvZiBhbiBldmVudCB0byBzZW5kIHdoZW4gdGhpcyBhbmltYXRpb24gbmF0dXJhbGx5IHN0b3BzIHBsYXlpbmcuIFRoaXMgb25seSBtYXR0ZXJzIGlmIGxvb3AgaXMgZmFsc2UuXHJcbiAgICovXHJcbiAgcGxheUlmTm90QWxyZWFkeShhbmltYXRpb246IHN0cmluZywgbG9vcD86IGJvb2xlYW4sIG9uRW5kPzogc3RyaW5nKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5jdXJyZW50QW5pbWF0aW9uICE9PSBhbmltYXRpb24pIHtcclxuICAgICAgdGhpcy5wbGF5KGFuaW1hdGlvbiwgbG9vcCwgb25FbmQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGxheXMgdGhlIHNwZWNpZmllZCBhbmltYXRpb25cclxuICAgKiBAcGFyYW0gYW5pbWF0aW9uIFRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdG8gcGxheVxyXG4gICAqIEBwYXJhbSBsb29wIFdoZXRoZXIgb3Igbm90IHRvIGxvb3AgdGhlIGFuaW1hdGlvbi4gRmFsc2UgYnkgZGVmYXVsdFxyXG4gICAqIEBwYXJhbSBvbkVuZCBUaGUgbmFtZSBvZiBhbiBldmVudCB0byBzZW5kIHdoZW4gdGhpcyBhbmltYXRpb24gbmF0dXJhbGx5IHN0b3BzIHBsYXlpbmcuIFRoaXMgb25seSBtYXR0ZXJzIGlmIGxvb3AgaXMgZmFsc2UuXHJcbiAgICovXHJcbiAgcGxheShhbmltYXRpb246IHN0cmluZywgbG9vcD86IGJvb2xlYW4sIG9uRW5kPzogc3RyaW5nKTogdm9pZCB7XHJcbiAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24gPSBhbmltYXRpb247XHJcbiAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XHJcbiAgICB0aGlzLmZyYW1lUHJvZ3Jlc3MgPSAwO1xyXG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlBMQVlJTkc7XHJcblxyXG4gICAgLy8gSWYgbG9vcCBhcmcgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdFxyXG4gICAgaWYgKGxvb3AgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLmxvb3AgPSBsb29wO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gT3RoZXJ3aXNlLCB1c2Ugd2hhdCB0aGUganNvbiBmaWxlIHNwZWNpZmllZFxyXG4gICAgICB0aGlzLmxvb3AgPSB0aGlzLmFuaW1hdGlvbnMuZ2V0KGFuaW1hdGlvbikucmVwZWF0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvbkVuZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMub25FbmRFdmVudCA9IG9uRW5kO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5vbkVuZEV2ZW50ID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXNldCBwZW5kaW5nIGFuaW1hdGlvblxyXG4gICAgdGhpcy5wZW5kaW5nQW5pbWF0aW9uID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFF1ZXVlcyBhIHNpbmdsZSBhbmltYXRpb24gdG8gYmUgcGxheWVkIGFmdGVyIHRoZSBjdXJyZW50IG9uZS4gRG9lcyBOT1Qgc3RhY2suXHJcbiAgICogUXVldWVpbmcgYWRkaXRpb25hbCBhbmltYXRpb25zIHBhc3QgMSB3aWxsIGp1c3QgcmVwbGFjZSB0aGUgcXVldWVkIGFuaW1hdGlvblxyXG4gICAqIEBwYXJhbSBhbmltYXRpb24gVGhlIGFuaW1hdGlvbiB0byBxdWV1ZVxyXG4gICAqIEBwYXJhbSBsb29wIFdoZXRoZXIgb3Igbm90IHRoZSBsb29wIHRoZSBxdWV1ZWQgYW5pbWF0aW9uXHJcbiAgICogQHBhcmFtIG9uRW5kIFRoZSBldmVudCB0byBmaXJlIHdoZW4gdGhlIHF1ZXVlZCBhbmltYXRpb24gZW5kc1xyXG4gICAqL1xyXG4gIHF1ZXVlKGFuaW1hdGlvbjogc3RyaW5nLCBsb29wOiBib29sZWFuID0gZmFsc2UsIG9uRW5kPzogc3RyaW5nKTogdm9pZCB7XHJcbiAgICB0aGlzLnBlbmRpbmdBbmltYXRpb24gPSBhbmltYXRpb247XHJcbiAgICB0aGlzLnBlbmRpbmdMb29wID0gbG9vcDtcclxuICAgIGlmIChvbkVuZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMucGVuZGluZ09uRW5kID0gb25FbmQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnBlbmRpbmdPbkVuZCA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogUGF1c2VzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiAqL1xyXG4gIHBhdXNlKCk6IHZvaWQge1xyXG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlBBVVNFRDtcclxuICB9XHJcblxyXG4gIC8qKiBSZXN1bWVzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBpZiBwb3NzaWJsZSAqL1xyXG4gIHJlc3VtZSgpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLmFuaW1hdGlvblN0YXRlID09PSBBbmltYXRpb25TdGF0ZS5QQVVTRUQpIHtcclxuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlBMQVlJTkc7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogU3RvcHMgdGhlIGN1cnJlbnQgYW5pbWF0aW9uLiBUaGUgYW5pbWF0aW9uIGNhbm5vdCBiZSByZXN1bWVkIGFmdGVyIHRoaXMuICovXHJcbiAgc3RvcCgpOiB2b2lkIHtcclxuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5TVE9QUEVEO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBUd2VlbmFibGVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uLy4uL05vZGVzL0dhbWVOb2RlXCI7XG5pbXBvcnQgeyBFYXNlRnVuY3Rpb25UeXBlIH0gZnJvbSBcIi4uLy4uL1V0aWxzL0Vhc2VGdW5jdGlvbnNcIjtcblxuLy8gQGlnbm9yZVBhZ2VcblxuZXhwb3J0IGVudW0gQW5pbWF0aW9uU3RhdGUge1xuICAgIFNUT1BQRUQgPSAwLFxuICAgIFBBVVNFRCA9IDEsXG4gICAgUExBWUlORyA9IDIsXG59XG5cbmV4cG9ydCBjbGFzcyBBbmltYXRpb25EYXRhIHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgZnJhbWVzOiBBcnJheTx7aW5kZXg6IG51bWJlciwgZHVyYXRpb246IG51bWJlcn0+O1xuICAgIHJlcGVhdDogYm9vbGVhbiA9IGZhbHNlO1xufVxuXG5leHBvcnQgY2xhc3MgVHdlZW5FZmZlY3Qge1xuICAgIC8qKiBUaGUgcHJvcGVydHkgdG8gdHdlZW4gKi9cbiAgICBwcm9wZXJ0eTogVHdlZW5hYmxlUHJvcGVydGllcztcblxuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgVHdlZW4gc2hvdWxkIHJlc2V0IHRoZSBwcm9wZXJ0eSB0byBpdHMgb3JpZ2luYWwgdmFsdWUgYWZ0ZXIgcGxheWluZyAqL1xuICAgIHJlc2V0T25Db21wbGV0ZTogYm9vbGVhbjtcblxuICAgIC8qKiBUaGUgc3RhcnRpbmcgdmFsdWUgZm9yIHRoZSB0d2VlbiAqL1xuICAgIHN0YXJ0OiBhbnk7XG5cbiAgICAvKiogVGhlIGVuZGluZyB2YWx1ZSBmb3IgdGhlIHR3ZWVuICovXG4gICAgZW5kOiBhbnk7XG5cbiAgICAvKiogVGhlIGVhc2UgZnVuY3Rpb24gdG8gdXNlICovXG4gICAgZWFzZTogRWFzZUZ1bmN0aW9uVHlwZTtcblxuICAgIC8qKiBETyBOT1QgTU9ESUZZIC0gVGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSAtIHNldCBhdXRvbWF0aWNhbGx5ICovXG4gICAgaW5pdGlhbFZhbHVlOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBUd2VlbkRhdGEge1xuICAgIC8vIE1lbWJlcnMgZm9yIGluaXRpYWxpemF0aW9uIGJ5IHRoZSB1c2VyXG4gICAgLyoqIFRoZSBhbW91bnQgb2YgdGltZSBpbiBtcyB0byB3YWl0IGJlZm9yZSBleGVjdXRpbmcgdGhlIHR3ZWVuICovXG4gICAgc3RhcnREZWxheTogbnVtYmVyO1xuICAgIC8qKiBUaGUgZHVyYXRpb24gb2YgdGltZSBvdmVyIHdoaWNoIHRoZSB2YWx1ZSB3aXRoIGNoYW5nZSBmcm9tIHN0YXJ0IHRvIGVuZCAqL1xuICAgIGR1cmF0aW9uOiBudW1iZXI7XG4gICAgLyoqIEFuIGFycmF5IG9mIHRoZSBlZmZlY3RzIG9uIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QgKi9cbiAgICBlZmZlY3RzOiBBcnJheTxUd2VlbkVmZmVjdD47XG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoaXMgdHdlZW4gc2hvdWxkIHJldmVyc2UgZnJvbSBlbmQgdG8gc3RhcnQgZm9yIGVhY2ggcHJvcGVydHkgd2hlbiBpdCBmaW5pc2hlcyAqL1xuICAgIHJldmVyc2VPbkNvbXBsZXRlOiBib29sZWFuO1xuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIHR3ZWVuIHNob3VsZCBsb29wIHdoZW4gaXQgY29tcGxldGVzICovXG4gICAgbG9vcDogYm9vbGVhbjtcbiAgICAvKiogVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHNlbmQgKGlmIGFueSkgd2hlbiB0aGUgdHdlZW4gZmluaXNoZXMgcGxheWluZyAqL1xuICAgIG9uRW5kOiBzdHJpbmdcbiAgICBcbiAgICAvLyBNZW1iZXJzIGZvciBtYW5hZ2VtZW50IGJ5IHRoZSB0d2VlbiBtYW5hZ2VyXG4gICAgLyoqIFRoZSBwcm9ncmVzcyBvZiB0aGlzIHR3ZWVuIHRocm91Z2ggaXRzIGVmZmVjdHMgKi9cbiAgICBwcm9ncmVzczogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBhbW91bnQgb2YgdGltZSBpbiBtcyB0aGF0IGhhcyBwYXNzZWQgZnJvbSB3aGVuIHRoaXMgdHdlZW4gc3RhcnRlZCBydW5uaW5nICovXG4gICAgZWxhcHNlZFRpbWU6IG51bWJlcjtcblxuICAgIC8qKiBUaGUgc3RhdGUgb2YgdGhpcyB0d2VlbiAqL1xuICAgIGFuaW1hdGlvblN0YXRlOiBBbmltYXRpb25TdGF0ZTtcblxuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIHR3ZWVuIGlzIGN1cnJlbnRseSByZXZlcnNpbmcgKi9cbiAgICByZXZlcnNpbmc6IGJvb2xlYW47XG59IiwiaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcbmltcG9ydCBQYXJ0aWNsZVN5c3RlbSBmcm9tIFwiLi9QYXJ0aWNsZVN5c3RlbVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJ0aWNsZVN5c3RlbU1hbmFnZXIgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcblxuICAgIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBQYXJ0aWNsZVN5c3RlbU1hbmFnZXIgPSBudWxsO1xuICAgIFxuICAgIHByb3RlY3RlZCBwYXJ0aWNsZVN5c3RlbXM6IEFycmF5PFBhcnRpY2xlU3lzdGVtPjtcblxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5wYXJ0aWNsZVN5c3RlbXMgPSBuZXcgQXJyYXkoKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogUGFydGljbGVTeXN0ZW1NYW5hZ2VyIHtcbiAgICAgICAgaWYoUGFydGljbGVTeXN0ZW1NYW5hZ2VyLmluc3RhbmNlID09PSBudWxsKXtcbiAgICAgICAgICAgIFBhcnRpY2xlU3lzdGVtTWFuYWdlci5pbnN0YW5jZSA9IG5ldyBQYXJ0aWNsZVN5c3RlbU1hbmFnZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQYXJ0aWNsZVN5c3RlbU1hbmFnZXIuaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJQYXJ0aWNsZVN5c3RlbShzeXN0ZW06IFBhcnRpY2xlU3lzdGVtKXtcbiAgICAgICAgdGhpcy5wYXJ0aWNsZVN5c3RlbXMucHVzaChzeXN0ZW0pO1xuICAgIH1cblxuICAgIGRlcmVnaXN0ZXJQYXJ0aWNsZVN5c3RlbShzeXN0ZW06IFBhcnRpY2xlU3lzdGVtKXtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5wYXJ0aWNsZVN5c3RlbXMuaW5kZXhPZihzeXN0ZW0pO1xuICAgICAgICB0aGlzLnBhcnRpY2xlU3lzdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cblxuICAgIGNsZWFyUGFydGljbGVTeXN0ZW1zKCl7XG4gICAgICAgIHRoaXMucGFydGljbGVTeXN0ZW1zID0gbmV3IEFycmF5KCk7XG4gICAgfVxuXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGZvcihsZXQgcGFydGljbGVTeXN0ZW0gb2YgdGhpcy5wYXJ0aWNsZVN5c3RlbXMpe1xuICAgICAgICAgICAgcGFydGljbGVTeXN0ZW0udXBkYXRlKGRlbHRhVCk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL01hcFwiO1xuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi8uLi9Ob2Rlcy9HYW1lTm9kZVwiO1xuaW1wb3J0IHsgQW5pbWF0aW9uU3RhdGUsIFR3ZWVuRGF0YSB9IGZyb20gXCIuL0FuaW1hdGlvblR5cGVzXCI7XG5pbXBvcnQgRWFzZUZ1bmN0aW9ucyBmcm9tIFwiLi4vLi4vVXRpbHMvRWFzZUZ1bmN0aW9uc1wiO1xuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vLi4vVXRpbHMvTWF0aFV0aWxzXCI7XG5pbXBvcnQgVHdlZW5NYW5hZ2VyIGZyb20gXCIuL1R3ZWVuTWFuYWdlclwiO1xuaW1wb3J0IEVtaXR0ZXIgZnJvbSBcIi4uLy4uL0V2ZW50cy9FbWl0dGVyXCI7XG5cbi8qKlxuICogQSBtYW5hZ2VyIGZvciB0aGUgdHdlZW5zIG9mIGEgR2FtZU5vZGUuXG4gKiBUd2VlbnMgYXJlIHNob3J0IGFuaW1hdGlvbnMgcGxheWVkIGJ5IGludGVycG9sYXRpbmcgYmV0d2VlbiB0d28gcHJvcGVydGllcyB1c2luZyBhbiBlYXNpbmcgZnVuY3Rpb24uXG4gKiBGb3IgYSBnb29kIHZpc3VhbCByZXByZXNlbnRhdGlvbiBvZiBlYXNpbmcgZnVuY3Rpb25zLCBjaGVjayBvdXQgQGxpbmsoaHR0cHM6Ly9lYXNpbmdzLm5ldC8pKGh0dHBzOi8vZWFzaW5ncy5uZXQvKS5cbiAqIE11bHRpcGxlIHR3ZWVuIGNhbiBiZSBwbGF5ZWQgYXQgdGhlIHNhbWUgdGltZSwgYXMgbG9uZyBhcyB0aGV5IGRvbid0IGNoYW5nZSB0aGUgc2FtZSBwcm9wZXJ0eS5cbiAqIFRoaXMgYWxsb3dzIGZvciBzb21lIGludGVyZXN0aW5nIHBvbGlzaGVzIG9yIGFuaW1hdGlvbnMgdGhhdCBtYXkgYmUgdmVyeSBkaWZmaWN1bHQgdG8gZG8gd2l0aCBzcHJpdGUgd29yayBhbG9uZVxuICogLSBlc3BlY2lhbGx5IHBpeGVsIGFydCAoc3VjaCBhcyByb3RhdGlvbnMgb3Igc2NhbGluZykuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR3ZWVuQ29udHJvbGxlciB7XG4gICAgLyoqIFRoZSBHYW1lTm9kZSB0aGlzIFR3ZWVuQ29udHJvbGxlciBhY3RzIHVwb24gKi9cbiAgICBwcm90ZWN0ZWQgb3duZXI6IEdhbWVOb2RlO1xuICAgIC8qKiBUaGUgbGlzdCBvZiBjcmVhdGVkIHR3ZWVucyAqL1xuICAgIHByb3RlY3RlZCB0d2VlbnM6IE1hcDxUd2VlbkRhdGE+O1xuICAgIC8qKiBBbiBldmVudCBlbWl0dGVyICovXG4gICAgcHJvdGVjdGVkIGVtaXR0ZXI6IEVtaXR0ZXI7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFR3ZWVuQ29udHJvbGxlclxuICAgICAqIEBwYXJhbSBvd25lciBUaGUgb3duZXIgb2YgdGhlIFR3ZWVuQ29udHJvbGxlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG93bmVyOiBHYW1lTm9kZSl7XG4gICAgICAgIHRoaXMub3duZXIgPSBvd25lcjtcbiAgICAgICAgdGhpcy50d2VlbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG5cbiAgICAgICAgLy8gR2l2ZSBvdXJzZWx2ZXMgdG8gdGhlIFR3ZWVuTWFuYWdlclxuICAgICAgICBUd2Vlbk1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5yZWdpc3RlclR3ZWVuQ29udHJvbGxlcih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIFR3ZWVuQ29udHJvbGxlclxuICAgICAqL1xuICAgIGRlc3Ryb3koKXtcbiAgICAgICAgLy8gT25seSB0aGUgZ2FtZW5vZGUgYW5kIHRoZSB0d2VlbiBtYW5hZ2VyIHNob3VsZCBoYXZlIGEgcmVmZXJlbmNlIHRvIHRoaXNcbiAgICAgICAgZGVsZXRlIHRoaXMub3duZXIudHdlZW5zO1xuICAgICAgICBUd2Vlbk1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5kZXJlZ2lzdGVyVHdlZW5Db250cm9sbGVyKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIHR3ZWVuIHRvIHRoaXMgZ2FtZSBub2RlXG4gICAgICogQHBhcmFtIGtleSBUaGUgbmFtZSBvZiB0aGUgdHdlZW5cbiAgICAgKiBAcGFyYW0gdHdlZW4gVGhlIGRhdGEgb2YgdGhlIHR3ZWVuXG4gICAgICovXG4gICAgYWRkKGtleTogc3RyaW5nLCB0d2VlbjogUmVjb3JkPHN0cmluZywgYW55PiB8IFR3ZWVuRGF0YSk6IHZvaWQge1xuICAgICAgICBsZXQgdHlwZWRUd2VlbiA9IDxUd2VlbkRhdGE+dHdlZW47XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBtZW1iZXJzIHRoYXQgd2UgbmVlZCAoYW5kIHRoZSB1c2VyIGRpZG4ndCBwcm92aWRlKVxuICAgICAgICB0eXBlZFR3ZWVuLnByb2dyZXNzID0gMDtcbiAgICAgICAgdHlwZWRUd2Vlbi5lbGFwc2VkVGltZSA9IDA7XG4gICAgICAgIHR5cGVkVHdlZW4uYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5TVE9QUEVEO1xuXG4gICAgICAgIHRoaXMudHdlZW5zLmFkZChrZXksIHR5cGVkVHdlZW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBsYXkgYSB0d2VlbiB3aXRoIGEgY2VydGFpbiBuYW1lXG4gICAgICogQHBhcmFtIGtleSBUaGUgbmFtZSBvZiB0aGUgdHdlZW4gdG8gcGxheVxuICAgICAqIEBwYXJhbSBsb29wIFdoZXRoZXIgb3Igbm90IHRoZSB0d2VlbiBzaG91bGQgbG9vcFxuICAgICAqL1xuICAgIHBsYXkoa2V5OiBzdHJpbmcsIGxvb3A/OiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGlmKHRoaXMudHdlZW5zLmhhcyhrZXkpKXtcbiAgICAgICAgICAgIGxldCB0d2VlbiA9IHRoaXMudHdlZW5zLmdldChrZXkpO1xuXG4gICAgICAgICAgICAvLyBTZXQgbG9vcCBpZiBuZWVkZWRcbiAgICAgICAgICAgIGlmKGxvb3AgIT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICAgICAgdHdlZW4ubG9vcCA9IGxvb3A7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGUgaW5pdGlhbCB2YWx1ZXNcbiAgICAgICAgICAgIGZvcihsZXQgZWZmZWN0IG9mIHR3ZWVuLmVmZmVjdHMpe1xuICAgICAgICAgICAgICAgIGlmKGVmZmVjdC5yZXNldE9uQ29tcGxldGUpe1xuICAgICAgICAgICAgICAgICAgICBlZmZlY3QuaW5pdGlhbFZhbHVlID0gdGhpcy5vd25lcltlZmZlY3QucHJvcGVydHldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RhcnQgdGhlIHR3ZWVuIHJ1bm5pbmdcbiAgICAgICAgICAgIHR3ZWVuLmFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGUuUExBWUlORztcbiAgICAgICAgICAgIHR3ZWVuLmVsYXBzZWRUaW1lID0gMDtcbiAgICAgICAgICAgIHR3ZWVuLnByb2dyZXNzID0gMDtcbiAgICAgICAgICAgIHR3ZWVuLnJldmVyc2luZyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBUcmllZCB0byBwbGF5IHR3ZWVuIFwiJHtrZXl9XCIgb24gbm9kZSB3aXRoIGlkICR7dGhpcy5vd25lci5pZH0sIGJ1dCBubyBzdWNoIHR3ZWVuIGV4aXN0c2ApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGF1c2VzIGEgcGxheWluZyB0d2Vlbi4gRG9lcyBub3QgYWZmZWN0IHR3ZWVucyB0aGF0IGFyZSBzdG9wcGVkLlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIG5hbWUgb2YgdGhlIHR3ZWVuIHRvIHBhdXNlLlxuICAgICAqL1xuICAgIHBhdXNlKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGlmKHRoaXMudHdlZW5zLmhhcyhrZXkpKXtcbiAgICAgICAgICAgIHRoaXMudHdlZW5zLmdldChrZXkpLmFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGUuUEFVU0VEO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzdW1lcyBhIHBhdXNlZCB0d2Vlbi5cbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBuYW1lIG9mIHRoZSB0d2VlbiB0byByZXN1bWVcbiAgICAgKi9cbiAgICByZXN1bWUoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgaWYodGhpcy50d2VlbnMuaGFzKGtleSkpe1xuICAgICAgICAgICAgbGV0IHR3ZWVuID0gdGhpcy50d2VlbnMuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZih0d2Vlbi5hbmltYXRpb25TdGF0ZSA9PT0gQW5pbWF0aW9uU3RhdGUuUEFVU0VEKVxuICAgICAgICAgICAgICAgIHR3ZWVuLmFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGUuUExBWUlORztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3BzIGEgY3VycmVudGx5IHBsYXlpbmcgdHdlZW5cbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHR3ZWVuXG4gICAgICovXG4gICAgc3RvcChrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBpZih0aGlzLnR3ZWVucy5oYXMoa2V5KSl7XG4gICAgICAgICAgICBsZXQgdHdlZW4gPSB0aGlzLnR3ZWVucy5nZXQoa2V5KTtcbiAgICAgICAgICAgIHR3ZWVuLmFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGUuU1RPUFBFRDtcblxuICAgICAgICAgICAgLy8gUmV0dXJuIHRvIHRoZSBpbml0aWFsIHZhbHVlc1xuICAgICAgICAgICAgZm9yKGxldCBlZmZlY3Qgb2YgdHdlZW4uZWZmZWN0cyl7XG4gICAgICAgICAgICAgICAgaWYoZWZmZWN0LnJlc2V0T25Db21wbGV0ZSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3duZXJbZWZmZWN0LnByb3BlcnR5XSA9IGVmZmVjdC5pbml0aWFsVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hdHVyYWwgc3RvcCBvZiBhIGN1cnJlbnRseSBwbGF5aW5nIHR3ZWVuXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSB0d2VlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBlbmQoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zdG9wKGtleSk7XG4gICAgICAgIGlmKHRoaXMudHdlZW5zLmhhcyhrZXkpKXtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgdHdlZW5cbiAgICAgICAgICAgIGxldCB0d2VlbiA9IHRoaXMudHdlZW5zLmdldChrZXkpO1xuXG4gICAgICAgICAgICAvLyBJZiBpdCBoYXMgYW4gb25FbmQsIHNlbmQgYW4gZXZlbnRcbiAgICAgICAgICAgIGlmKHR3ZWVuLm9uRW5kKXtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KHR3ZWVuLm9uRW5kLCB7a2V5OiBrZXksIG5vZGU6IHRoaXMub3duZXIuaWR9KTsgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9wcyBhbGwgY3VycmVudGx5IHBsYXlpbmcgdHdlZW5zXG4gICAgICovXG4gICAgc3RvcEFsbCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy50d2VlbnMuZm9yRWFjaChrZXkgPT4gdGhpcy5zdG9wKGtleSkpO1xuICAgIH1cbiAgICBcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy50d2VlbnMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHR3ZWVuID0gdGhpcy50d2VlbnMuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZih0d2Vlbi5hbmltYXRpb25TdGF0ZSA9PT0gQW5pbWF0aW9uU3RhdGUuUExBWUlORyl7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBwcm9ncmVzcyBvZiB0aGUgdHdlZW5cbiAgICAgICAgICAgICAgICB0d2Vlbi5lbGFwc2VkVGltZSArPSBkZWx0YVQqMTAwMDtcblxuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIHBhc3QgdGhlIHN0YXJ0RGVsYXksIGRvIHRoZSB0d2VlblxuICAgICAgICAgICAgICAgIGlmKHR3ZWVuLmVsYXBzZWRUaW1lID49IHR3ZWVuLnN0YXJ0RGVsYXkpe1xuICAgICAgICAgICAgICAgICAgICBpZighdHdlZW4ucmV2ZXJzaW5nICYmIHR3ZWVuLmVsYXBzZWRUaW1lID49IHR3ZWVuLnN0YXJ0RGVsYXkgKyB0d2Vlbi5kdXJhdGlvbil7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBvdmVyIHRpbWUsIHN0b3AgdGhlIHR3ZWVuLCBsb29wLCBvciByZXZlcnNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0d2Vlbi5yZXZlcnNlT25Db21wbGV0ZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgb3ZlciB0aW1lIGFuZCBjYW4gcmV2ZXJzZSwgZG8gc29cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0d2Vlbi5yZXZlcnNpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHR3ZWVuLmxvb3Ape1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGNhbid0IHJldmVyc2UgYW5kIGNhbiBsb29wLCBkbyBzb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR3ZWVuLmVsYXBzZWRUaW1lIC09IHR3ZWVuLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmVuJ3QgbG9vcGluZyBhbmQgY2FuJ3QgcmV2ZXJzZSwgc28gc3RvcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgdGhlIGVuZCBvZiByZXZlcnNpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYodHdlZW4ucmV2ZXJzaW5nICYmIHR3ZWVuLmVsYXBzZWRUaW1lID49IHR3ZWVuLnN0YXJ0RGVsYXkgKyAyKnR3ZWVuLmR1cmF0aW9uKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR3ZWVuLmxvb3Ape1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR3ZWVuLnJldmVyc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR3ZWVuLmVsYXBzZWRUaW1lIC09IDIqdHdlZW4uZHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByb2dyZXNzLCBtYWtlIHN1cmUgaXQgaXMgYmV0d2VlbiAwIGFuZCAxLiBFcnJvcnMgZnJvbSB0aGlzIHNob3VsZCBuZXZlciBiZSBsYXJnZVxuICAgICAgICAgICAgICAgICAgICBpZih0d2Vlbi5yZXZlcnNpbmcpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4ucHJvZ3Jlc3MgPSBNYXRoVXRpbHMuY2xhbXAwMSgoMip0d2Vlbi5kdXJhdGlvbiAtICh0d2Vlbi5lbGFwc2VkVGltZS0gdHdlZW4uc3RhcnREZWxheSkpL3R3ZWVuLmR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR3ZWVuLnByb2dyZXNzID0gTWF0aFV0aWxzLmNsYW1wMDEoKHR3ZWVuLmVsYXBzZWRUaW1lIC0gdHdlZW4uc3RhcnREZWxheSkvdHdlZW4uZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBlZmZlY3Qgb2YgdHdlZW4uZWZmZWN0cyl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdmFsdWUgZnJvbSB0aGUgZWFzZSBmdW5jdGlvbiB0aGF0IGNvcnJlc3BvbmRzIHRvIG91ciBwcm9ncmVzc1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVhc2UgPSBFYXNlRnVuY3Rpb25zW2VmZmVjdC5lYXNlXSh0d2Vlbi5wcm9ncmVzcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgdmFsdWUgdG8gbGVycCB0aGUgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IE1hdGhVdGlscy5sZXJwKGVmZmVjdC5zdGFydCwgZWZmZWN0LmVuZCwgZWFzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzc2lnbiB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm93bmVyW2VmZmVjdC5wcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufSIsImltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VcGRhdGVhYmxlXCI7XG5pbXBvcnQgVHdlZW5Db250cm9sbGVyIGZyb20gXCIuL1R3ZWVuQ29udHJvbGxlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUd2Vlbk1hbmFnZXIgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcblxuICAgIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBUd2Vlbk1hbmFnZXIgPSBudWxsO1xuICAgIFxuICAgIHByb3RlY3RlZCB0d2VlbkNvbnRyb2xsZXJzOiBBcnJheTxUd2VlbkNvbnRyb2xsZXI+O1xuXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLnR3ZWVuQ29udHJvbGxlcnMgPSBuZXcgQXJyYXkoKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogVHdlZW5NYW5hZ2VyIHtcbiAgICAgICAgaWYoVHdlZW5NYW5hZ2VyLmluc3RhbmNlID09PSBudWxsKXtcbiAgICAgICAgICAgIFR3ZWVuTWFuYWdlci5pbnN0YW5jZSA9IG5ldyBUd2Vlbk1hbmFnZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBUd2Vlbk1hbmFnZXIuaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJUd2VlbkNvbnRyb2xsZXIoY29udHJvbGxlcjogVHdlZW5Db250cm9sbGVyKXtcbiAgICAgICAgdGhpcy50d2VlbkNvbnRyb2xsZXJzLnB1c2goY29udHJvbGxlcik7XG4gICAgfVxuXG4gICAgZGVyZWdpc3RlclR3ZWVuQ29udHJvbGxlcihjb250cm9sbGVyOiBUd2VlbkNvbnRyb2xsZXIpe1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLnR3ZWVuQ29udHJvbGxlcnMuaW5kZXhPZihjb250cm9sbGVyKTtcbiAgICAgICAgdGhpcy50d2VlbkNvbnRyb2xsZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuXG4gICAgY2xlYXJUd2VlbkNvbnRyb2xsZXJzKCl7XG4gICAgICAgIHRoaXMudHdlZW5Db250cm9sbGVycyA9IG5ldyBBcnJheSgpO1xuICAgIH1cblxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBmb3IobGV0IHR3ZWVuQ29udHJvbGxlciBvZiB0aGlzLnR3ZWVuQ29udHJvbGxlcnMpe1xuICAgICAgICAgICAgdHdlZW5Db250cm9sbGVyLnVwZGF0ZShkZWx0YVQpO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcbmltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuLi9Ob2Rlcy9DYW52YXNOb2RlXCI7XG5pbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vTm9kZXMvR3JhcGhpY1wiO1xuaW1wb3J0IFBvaW50IGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljcy9Qb2ludFwiO1xuaW1wb3J0IFJlY3QgZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNzL1JlY3RcIjtcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vTm9kZXMvVGlsZW1hcFwiO1xuaW1wb3J0IE9ydGhvZ29uYWxUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwcy9PcnRob2dvbmFsVGlsZW1hcFwiO1xuaW1wb3J0IFVJRWxlbWVudCBmcm9tIFwiLi4vTm9kZXMvVUlFbGVtZW50XCI7XG5pbXBvcnQgVUlMYXllciBmcm9tIFwiLi4vU2NlbmUvTGF5ZXJzL1VJTGF5ZXJcIjtcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmUvU2NlbmVcIjtcbmltcG9ydCBHcmFwaGljUmVuZGVyZXIgZnJvbSBcIi4vQ2FudmFzUmVuZGVyaW5nL0dyYXBoaWNSZW5kZXJlclwiO1xuaW1wb3J0IFJlbmRlcmluZ01hbmFnZXIgZnJvbSBcIi4vUmVuZGVyaW5nTWFuYWdlclwiXG5pbXBvcnQgVGlsZW1hcFJlbmRlcmVyIGZyb20gXCIuL0NhbnZhc1JlbmRlcmluZy9UaWxlbWFwUmVuZGVyZXJcIjtcbmltcG9ydCBVSUVsZW1lbnRSZW5kZXJlciBmcm9tIFwiLi9DYW52YXNSZW5kZXJpbmcvVUlFbGVtZW50UmVuZGVyZXJcIjtcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xuaW1wb3J0IEJ1dHRvbiBmcm9tIFwiLi4vTm9kZXMvVUlFbGVtZW50cy9CdXR0b25cIjtcbmltcG9ydCBTbGlkZXIgZnJvbSBcIi4uL05vZGVzL1VJRWxlbWVudHMvU2xpZGVyXCI7XG5pbXBvcnQgVGV4dElucHV0IGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRzL1RleHRJbnB1dFwiO1xuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcbmltcG9ydCBMaW5lIGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljcy9MaW5lXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIFJlbmRlcmluZ01hbmFnZXIgY2xhc3MgdXNpbmcgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYW52YXNSZW5kZXJlciBleHRlbmRzIFJlbmRlcmluZ01hbmFnZXIge1xuICAgIHByb3RlY3RlZCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcbiAgICBwcm90ZWN0ZWQgZ3JhcGhpY1JlbmRlcmVyOiBHcmFwaGljUmVuZGVyZXI7XG4gICAgcHJvdGVjdGVkIHRpbGVtYXBSZW5kZXJlcjogVGlsZW1hcFJlbmRlcmVyO1xuICAgIHByb3RlY3RlZCB1aUVsZW1lbnRSZW5kZXJlcjogVUlFbGVtZW50UmVuZGVyZXI7XG5cbiAgICBwcm90ZWN0ZWQgb3JpZ2luOiBWZWMyO1xuICAgIHByb3RlY3RlZCB6b29tOiBudW1iZXI7XG5cbiAgICBwcm90ZWN0ZWQgd29ybGRTaXplOiBWZWMyO1xuXG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBzZXRTY2VuZShzY2VuZTogU2NlbmUpe1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgICAgIHRoaXMuZ3JhcGhpY1JlbmRlcmVyLnNldFNjZW5lKHNjZW5lKTtcbiAgICAgICAgdGhpcy50aWxlbWFwUmVuZGVyZXIuc2V0U2NlbmUoc2NlbmUpO1xuICAgICAgICB0aGlzLnVpRWxlbWVudFJlbmRlcmVyLnNldFNjZW5lKHNjZW5lKTtcbiAgICB9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBpbml0aWFsaXplQ2FudmFzKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHtcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgdGhpcy53b3JsZFNpemUgPSBuZXcgVmVjMih3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICB0aGlzLmN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICAgICAgdGhpcy5ncmFwaGljUmVuZGVyZXIgPSBuZXcgR3JhcGhpY1JlbmRlcmVyKHRoaXMuY3R4KTtcbiAgICAgICAgdGhpcy50aWxlbWFwUmVuZGVyZXIgPSBuZXcgVGlsZW1hcFJlbmRlcmVyKHRoaXMuY3R4KTtcbiAgICAgICAgdGhpcy51aUVsZW1lbnRSZW5kZXJlciA9IG5ldyBVSUVsZW1lbnRSZW5kZXJlcih0aGlzLmN0eClcblxuICAgICAgICAvLyBGb3IgY3Jpc3AgcGl4ZWwgYXJ0XG4gICAgICAgIHRoaXMuY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmN0eDtcbiAgICB9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICByZW5kZXIodmlzaWJsZVNldDogQ2FudmFzTm9kZVtdLCB0aWxlbWFwczogVGlsZW1hcFtdLCB1aUxheWVyczogTWFwPFVJTGF5ZXI+KTogdm9pZCB7XG4gICAgICAgIC8vIFNvcnQgYnkgZGVwdGgsIHRoZW4gYnkgdmlzaWJsZSBzZXQgYnkgeS12YWx1ZVxuICAgICAgICB2aXNpYmxlU2V0LnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGlmKGEuZ2V0TGF5ZXIoKS5nZXREZXB0aCgpID09PSBiLmdldExheWVyKCkuZ2V0RGVwdGgoKSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhLmJvdW5kYXJ5LmJvdHRvbSkgLSAoYi5ib3VuZGFyeS5ib3R0b20pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5nZXRMYXllcigpLmdldERlcHRoKCkgLSBiLmdldExheWVyKCkuZ2V0RGVwdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IHRpbGVtYXBJbmRleCA9IDA7XG4gICAgICAgIGxldCB0aWxlbWFwTGVuZ3RoID0gdGlsZW1hcHMubGVuZ3RoO1xuXG4gICAgICAgIGxldCB2aXNpYmxlU2V0SW5kZXggPSAwO1xuICAgICAgICBsZXQgdmlzaWJsZVNldExlbmd0aCA9IHZpc2libGVTZXQubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlKHRpbGVtYXBJbmRleCA8IHRpbGVtYXBMZW5ndGggfHwgdmlzaWJsZVNldEluZGV4IDwgdmlzaWJsZVNldExlbmd0aCl7XG4gICAgICAgICAgICAvLyBDaGVjayBjb25kaXRpb25zIHdoZXJlIHdlJ3ZlIGFscmVhZHkgcmVhY2hlZCB0aGUgZWRnZSBvZiBvbmUgbGlzdFxuICAgICAgICAgICAgaWYodGlsZW1hcEluZGV4ID49IHRpbGVtYXBMZW5ndGgpe1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgcmVuZGVyIHRoZSByZW1haW5pbmcgdmlzaWJsZSBzZXRcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IHZpc2libGVTZXRbdmlzaWJsZVNldEluZGV4KytdO1xuICAgICAgICAgICAgICAgIGlmKG5vZGUudmlzaWJsZSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHZpc2libGVTZXRJbmRleCA+PSB2aXNpYmxlU2V0TGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHJlbmRlciB0aWxlbWFwc1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVGlsZW1hcCh0aWxlbWFwc1t0aWxlbWFwSW5kZXgrK10pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZW5kZXIgd2hpY2hldmVyIGlzIGZ1cnRoZXIgZG93blxuICAgICAgICAgICAgaWYodGlsZW1hcHNbdGlsZW1hcEluZGV4XS5nZXRMYXllcigpLmdldERlcHRoKCkgPD0gdmlzaWJsZVNldFt2aXNpYmxlU2V0SW5kZXhdLmdldExheWVyKCkuZ2V0RGVwdGgoKSl7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJUaWxlbWFwKHRpbGVtYXBzW3RpbGVtYXBJbmRleCsrXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0gdmlzaWJsZVNldFt2aXNpYmxlU2V0SW5kZXgrK107XG4gICAgICAgICAgICAgICAgaWYobm9kZS52aXNpYmxlKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJOb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbmRlciB0aGUgdWlMYXllcnMgb24gdG9wIG9mIGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICBsZXQgc29ydGVkVUlMYXllcnMgPSBuZXcgQXJyYXk8VUlMYXllcj4oKTtcblxuICAgICAgICB1aUxheWVycy5mb3JFYWNoKGtleSA9PiBzb3J0ZWRVSUxheWVycy5wdXNoKHVpTGF5ZXJzLmdldChrZXkpKSk7XG5cbiAgICAgICAgc29ydGVkVUlMYXllcnMgPSBzb3J0ZWRVSUxheWVycy5zb3J0KCh1aTEsIHVpMikgPT4gdWkxLmdldERlcHRoKCkgLSB1aTIuZ2V0RGVwdGgoKSk7XG5cbiAgICAgICAgc29ydGVkVUlMYXllcnMuZm9yRWFjaCh1aUxheWVyID0+IHtcblx0XHRcdGlmKCF1aUxheWVyLmlzSGlkZGVuKCkpXG5cdFx0XHRcdHVpTGF5ZXIuZ2V0SXRlbXMoKS5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZigoPENhbnZhc05vZGU+bm9kZSkudmlzaWJsZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck5vZGUoPENhbnZhc05vZGU+bm9kZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG5cdFx0fSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIHNwZWNpZmllZCBDYW52YXNOb2RlXG4gICAgICogQHBhcmFtIG5vZGUgVGhlIENhbnZhc05vZGUgdG8gcmVuZGVyXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHJlbmRlck5vZGUobm9kZTogQ2FudmFzTm9kZSk6IHZvaWQge1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG9yaWdpbiBvZiB0aGUgdmlld3BvcnQgYWNjb3JkaW5nIHRvIHRoaXMgc3ByaXRlXG4gICAgICAgIHRoaXMub3JpZ2luID0gdGhpcy5zY2VuZS5nZXRWaWV3VHJhbnNsYXRpb24obm9kZSk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSB6b29tIGxldmVsIG9mIHRoZSBzY2VuZVxuICAgICAgICB0aGlzLnpvb20gPSB0aGlzLnNjZW5lLmdldFZpZXdTY2FsZSgpO1xuICAgICAgICBcbiAgICAgICAgLy8gTW92ZSB0aGUgY2FudmFzIHRvIHRoZSBwb3NpdGlvbiBvZiB0aGUgbm9kZSBhbmQgcm90YXRlXG4gICAgICAgIGxldCB4U2NhbGUgPSAxO1xuICAgICAgICBsZXQgeVNjYWxlID0gMTtcbiAgICAgICAgXG4gICAgICAgIGlmKG5vZGUgaW5zdGFuY2VvZiBTcHJpdGUpe1xuICAgICAgICAgICAgeFNjYWxlID0gbm9kZS5pbnZlcnRYID8gLTEgOiAxO1xuICAgICAgICAgICAgeVNjYWxlID0gbm9kZS5pbnZlcnRZID8gLTEgOiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKHhTY2FsZSwgMCwgMCwgeVNjYWxlLCAobm9kZS5wb3NpdGlvbi54IC0gdGhpcy5vcmlnaW4ueCkqdGhpcy56b29tLCAobm9kZS5wb3NpdGlvbi55IC0gdGhpcy5vcmlnaW4ueSkqdGhpcy56b29tKTtcbiAgICAgICAgdGhpcy5jdHgucm90YXRlKC1ub2RlLnJvdGF0aW9uKTtcbiAgICAgICAgbGV0IGdsb2JhbEFscGhhID0gdGhpcy5jdHguZ2xvYmFsQWxwaGE7XG4gICAgICAgIGlmKG5vZGUgaW5zdGFuY2VvZiBSZWN0KXtcbiAgICAgICAgICAgIERlYnVnLmxvZyhcIm5vZGVcIiArIG5vZGUuaWQsIFwiTm9kZVwiICsgbm9kZS5pZCArIFwiIEFscGhhOiBcIiArIG5vZGUuYWxwaGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gbm9kZS5hbHBoYTtcbiAgICAgICAgXG4gICAgICAgIGlmKG5vZGUgaW5zdGFuY2VvZiBBbmltYXRlZFNwcml0ZSl7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckFuaW1hdGVkU3ByaXRlKDxBbmltYXRlZFNwcml0ZT5ub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmKG5vZGUgaW5zdGFuY2VvZiBTcHJpdGUpe1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJTcHJpdGUoPFNwcml0ZT5ub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmKG5vZGUgaW5zdGFuY2VvZiBHcmFwaGljKXtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyR3JhcGhpYyg8R3JhcGhpYz5ub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmKG5vZGUgaW5zdGFuY2VvZiBVSUVsZW1lbnQpe1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJVSUVsZW1lbnQoPFVJRWxlbWVudD5ub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gZ2xvYmFsQWxwaGE7XG4gICAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICB9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBwcm90ZWN0ZWQgcmVuZGVyU3ByaXRlKHNwcml0ZTogU3ByaXRlKTogdm9pZCB7XG4gICAgICAgIC8vIEdldCB0aGUgaW1hZ2UgZnJvbSB0aGUgcmVzb3VyY2UgbWFuYWdlclxuICAgICAgICBsZXQgaW1hZ2UgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRJbWFnZShzcHJpdGUuaW1hZ2VJZCk7XG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIENvb3JkaW5hdGVzIGluIHRoZSBzcGFjZSBvZiB0aGUgaW1hZ2U6XG4gICAgICAgICAgICAgICAgaW1hZ2UgY3JvcCBzdGFydCAtPiB4LCB5XG4gICAgICAgICAgICAgICAgaW1hZ2UgY3JvcCBzaXplICAtPiB3LCBoXG4gICAgICAgICAgICBDb29yZGluYXRlcyBpbiB0aGUgc3BhY2Ugb2YgdGhlIHdvcmxkXG4gICAgICAgICAgICAgICAgaW1hZ2UgZHJhdyBzdGFydCAtPiB4LCB5XG4gICAgICAgICAgICAgICAgaW1hZ2UgZHJhdyBzaXplICAtPiB3LCBoXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZShpbWFnZSxcbiAgICAgICAgICAgIHNwcml0ZS5pbWFnZU9mZnNldC54LCBzcHJpdGUuaW1hZ2VPZmZzZXQueSxcbiAgICAgICAgICAgIHNwcml0ZS5zaXplLngsIHNwcml0ZS5zaXplLnksXG4gICAgICAgICAgICAoLXNwcml0ZS5zaXplLngqc3ByaXRlLnNjYWxlLngvMikqdGhpcy56b29tLCAoLXNwcml0ZS5zaXplLnkqc3ByaXRlLnNjYWxlLnkvMikqdGhpcy56b29tLFxuICAgICAgICAgICAgc3ByaXRlLnNpemUueCAqIHNwcml0ZS5zY2FsZS54KnRoaXMuem9vbSwgc3ByaXRlLnNpemUueSAqIHNwcml0ZS5zY2FsZS55KnRoaXMuem9vbSk7XG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgcHJvdGVjdGVkIHJlbmRlckFuaW1hdGVkU3ByaXRlKHNwcml0ZTogQW5pbWF0ZWRTcHJpdGUpOiB2b2lkIHtcbiAgICAgICAgLy8gR2V0IHRoZSBpbWFnZSBmcm9tIHRoZSByZXNvdXJjZSBtYW5hZ2VyXG4gICAgICAgIGxldCBpbWFnZSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldEltYWdlKHNwcml0ZS5pbWFnZUlkKTtcblxuICAgICAgICBsZXQgYW5pbWF0aW9uSW5kZXggPSBzcHJpdGUuYW5pbWF0aW9uLmdldEluZGV4QW5kQWR2YW5jZUFuaW1hdGlvbigpO1xuXG4gICAgICAgIGxldCBhbmltYXRpb25PZmZzZXQgPSBzcHJpdGUuZ2V0QW5pbWF0aW9uT2Zmc2V0KGFuaW1hdGlvbkluZGV4KTtcblxuICAgICAgICAvKlxuICAgICAgICAgICAgQ29vcmRpbmF0ZXMgaW4gdGhlIHNwYWNlIG9mIHRoZSBpbWFnZTpcbiAgICAgICAgICAgICAgICBpbWFnZSBjcm9wIHN0YXJ0IC0+IHgsIHlcbiAgICAgICAgICAgICAgICBpbWFnZSBjcm9wIHNpemUgIC0+IHcsIGhcbiAgICAgICAgICAgIENvb3JkaW5hdGVzIGluIHRoZSBzcGFjZSBvZiB0aGUgd29ybGQgKGdpdmVuIHdlIG1vdmVkKVxuICAgICAgICAgICAgICAgIGltYWdlIGRyYXcgc3RhcnQgLT4gLXcvMiwgLWgvMlxuICAgICAgICAgICAgICAgIGltYWdlIGRyYXcgc2l6ZSAgLT4gdywgaFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoaW1hZ2UsXG4gICAgICAgICAgICBzcHJpdGUuaW1hZ2VPZmZzZXQueCArIGFuaW1hdGlvbk9mZnNldC54LCBzcHJpdGUuaW1hZ2VPZmZzZXQueSArIGFuaW1hdGlvbk9mZnNldC55LFxuICAgICAgICAgICAgc3ByaXRlLnNpemUueCwgc3ByaXRlLnNpemUueSxcbiAgICAgICAgICAgICgtc3ByaXRlLnNpemUueCpzcHJpdGUuc2NhbGUueC8yKSp0aGlzLnpvb20sICgtc3ByaXRlLnNpemUueSpzcHJpdGUuc2NhbGUueS8yKSp0aGlzLnpvb20sXG4gICAgICAgICAgICBzcHJpdGUuc2l6ZS54ICogc3ByaXRlLnNjYWxlLngqdGhpcy56b29tLCBzcHJpdGUuc2l6ZS55ICogc3ByaXRlLnNjYWxlLnkqdGhpcy56b29tKTtcbiAgICB9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBwcm90ZWN0ZWQgcmVuZGVyR3JhcGhpYyhncmFwaGljOiBHcmFwaGljKTogdm9pZCB7XG4gICAgICAgIGlmKGdyYXBoaWMgaW5zdGFuY2VvZiBQb2ludCl7XG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNSZW5kZXJlci5yZW5kZXJQb2ludCg8UG9pbnQ+Z3JhcGhpYywgdGhpcy56b29tKTtcbiAgICAgICAgfSBlbHNlIGlmKGdyYXBoaWMgaW5zdGFuY2VvZiBMaW5lKXtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY1JlbmRlcmVyLnJlbmRlckxpbmUoPExpbmU+Z3JhcGhpYywgdGhpcy5vcmlnaW4sIHRoaXMuem9vbSk7XG4gICAgICAgIH0gZWxzZSBpZihncmFwaGljIGluc3RhbmNlb2YgUmVjdCl7XG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNSZW5kZXJlci5yZW5kZXJSZWN0KDxSZWN0PmdyYXBoaWMsIHRoaXMuem9vbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBwcm90ZWN0ZWQgcmVuZGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZCB7XG4gICAgICAgIGlmKHRpbGVtYXAgaW5zdGFuY2VvZiBPcnRob2dvbmFsVGlsZW1hcCl7XG4gICAgICAgICAgICB0aGlzLnRpbGVtYXBSZW5kZXJlci5yZW5kZXJPcnRob2dvbmFsVGlsZW1hcCg8T3J0aG9nb25hbFRpbGVtYXA+dGlsZW1hcCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBwcm90ZWN0ZWQgcmVuZGVyVUlFbGVtZW50KHVpRWxlbWVudDogVUlFbGVtZW50KTogdm9pZCB7XG4gICAgICAgIGlmKHVpRWxlbWVudCBpbnN0YW5jZW9mIExhYmVsKXtcbiAgICAgICAgICAgIHRoaXMudWlFbGVtZW50UmVuZGVyZXIucmVuZGVyTGFiZWwodWlFbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIGlmKHVpRWxlbWVudCBpbnN0YW5jZW9mIEJ1dHRvbil7XG4gICAgICAgICAgICB0aGlzLnVpRWxlbWVudFJlbmRlcmVyLnJlbmRlckJ1dHRvbih1aUVsZW1lbnQpO1xuICAgICAgICB9IGVsc2UgaWYodWlFbGVtZW50IGluc3RhbmNlb2YgU2xpZGVyKXtcbiAgICAgICAgICAgIHRoaXMudWlFbGVtZW50UmVuZGVyZXIucmVuZGVyU2xpZGVyKHVpRWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSBpZih1aUVsZW1lbnQgaW5zdGFuY2VvZiBUZXh0SW5wdXQpe1xuICAgICAgICAgICAgdGhpcy51aUVsZW1lbnRSZW5kZXJlci5yZW5kZXJUZXh0SW5wdXQodWlFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsZWFyKGNsZWFyQ29sb3I6IENvbG9yKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndvcmxkU2l6ZS54LCB0aGlzLndvcmxkU2l6ZS55KTtcbiAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gY2xlYXJDb2xvci50b1N0cmluZygpO1xuICAgICAgICB0aGlzLmN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLndvcmxkU2l6ZS54LCB0aGlzLndvcmxkU2l6ZS55KTtcbiAgICB9XG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgTGluZSBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvTGluZVwiO1xuaW1wb3J0IFBvaW50IGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljcy9Qb2ludFwiO1xuaW1wb3J0IFJlY3QgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL1JlY3RcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vLi4vU2NlbmUvU2NlbmVcIjtcblxuLyoqXG4gKiBBIHV0aWxpdHkgY2xhc3MgdG8gaGVscCB0aGUgQHJlZmVyZW5jZVtDYW52YXNSZW5kZXJlcl0gcmVuZGVyIEByZWZlcmVuY2VbR3JhcGhpY11zXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyYXBoaWNSZW5kZXJlciB7XG4gICAgLyoqIFRoZSByZXNvdXJjZSBtYW5hZ2VyIG9mIHRoZSBnYW1lIGVuZ2luZSAqL1xuICAgIHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcbiAgICAvKiogVGhlIGN1cnJlbnQgc2NlbmUgKi9cbiAgICBwcm90ZWN0ZWQgc2NlbmU6IFNjZW5lO1xuICAgIC8qKiBUaGUgcmVuZGVyaW5nIGNvbnRleHQgKi9cbiAgICBwcm90ZWN0ZWQgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG5cbiAgICBjb25zdHJ1Y3RvcihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCl7XG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNjZW5lIG9mIHRoaXMgR3JhcGhpY1JlbmRlcmVyXG4gICAgICogQHBhcmFtIHNjZW5lIFRoZSBjdXJyZW50IHNjZW5lXG4gICAgICovXG4gICAgc2V0U2NlbmUoc2NlbmU6IFNjZW5lKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgcG9pbnRcbiAgICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRvIHJlbmRlclxuICAgICAqIEBwYXJhbSB6b29tIFRoZSB6b29tIGxldmVsXG4gICAgICovXG4gICAgcmVuZGVyUG9pbnQocG9pbnQ6IFBvaW50LCB6b29tOiBudW1iZXIpOiB2b2lkIHtcblx0XHR0aGlzLmN0eC5maWxsU3R5bGUgPSBwb2ludC5jb2xvci50b1N0cmluZ1JHQkEoKTtcbiAgICAgICAgdGhpcy5jdHguZmlsbFJlY3QoKC1wb2ludC5zaXplLngvMikqem9vbSwgKC1wb2ludC5zaXplLnkvMikqem9vbSxcbiAgICAgICAgcG9pbnQuc2l6ZS54Knpvb20sIHBvaW50LnNpemUueSp6b29tKTtcbiAgICB9XG5cbiAgICByZW5kZXJMaW5lKGxpbmU6IExpbmUsIG9yaWdpbjogVmVjMiwgem9vbTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gbGluZS5jb2xvci50b1N0cmluZ1JHQkEoKTtcbiAgICAgICAgdGhpcy5jdHgubGluZVdpZHRoID0gbGluZS50aGlja25lc3M7XG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oMCwgMCk7XG4gICAgICAgIHRoaXMuY3R4LmxpbmVUbygobGluZS5lbmQueCAtIGxpbmUuc3RhcnQueCkqem9vbSwgKGxpbmUuZW5kLnkgLSBsaW5lLnN0YXJ0LnkpKnpvb20pO1xuICAgICAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIHJlY3RcbiAgICAgKiBAcGFyYW0gcmVjdCBUaGUgcmVjdCB0byByZW5kZXJcbiAgICAgKiBAcGFyYW0gem9vbSBUaGUgem9vbSBsZXZlbFxuICAgICAqL1xuICAgIHJlbmRlclJlY3QocmVjdDogUmVjdCwgem9vbTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIC8vIERyYXcgdGhlIGludGVyaW9yIG9mIHRoZSByZWN0XG4gICAgICAgIGlmKHJlY3QuY29sb3IuYSAhPT0gMCl7XG4gICAgICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSByZWN0LmNvbG9yLnRvU3RyaW5nUkdCKCk7XG4gICAgICAgICAgICB0aGlzLmN0eC5maWxsUmVjdCgoLXJlY3Quc2l6ZS54LzIpKnpvb20sICgtcmVjdC5zaXplLnkvMikqem9vbSwgcmVjdC5zaXplLngqem9vbSwgcmVjdC5zaXplLnkqem9vbSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEcmF3IHRoZSBib3JkZXIgb2YgdGhlIHJlY3QgaWYgaXQgaXNuJ3QgdHJhbnNwYXJlbnRcbiAgICAgICAgaWYocmVjdC5ib3JkZXJDb2xvci5hICE9PSAwKXtcbiAgICAgICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gcmVjdC5nZXRCb3JkZXJDb2xvcigpLnRvU3RyaW5nUkdCKCk7XG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lV2lkdGggPSByZWN0LmdldEJvcmRlcldpZHRoKCk7XG4gICAgICAgICAgICB0aGlzLmN0eC5zdHJva2VSZWN0KCgtcmVjdC5zaXplLngvMikqem9vbSwgKC1yZWN0LnNpemUueS8yKSp6b29tLCByZWN0LnNpemUueCp6b29tLCByZWN0LnNpemUueSp6b29tKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uL1NjZW5lL1NjZW5lXCI7XG5pbXBvcnQgT3J0aG9nb25hbFRpbGVtYXAgZnJvbSBcIi4uLy4uL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBUaWxlc2V0IGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVGlsZXNldHMvVGlsZXNldFwiO1xuXG4vKipcbiAqIEEgdXRpbGl0eSBjbGFzcyBmb3IgdGhlIEByZWZlcmVuY2VbQ2FudmFzUmVuZGVyZXJdIHRvIHJlbmRlciBAcmVmZXJlbmNlW1RpbGVtYXBdc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaWxlbWFwUmVuZGVyZXIge1xuICAgIHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcbiAgICBwcm90ZWN0ZWQgc2NlbmU6IFNjZW5lO1xuICAgIHByb3RlY3RlZCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcblxuICAgIGNvbnN0cnVjdG9yKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKXtcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgdGhpcy5jdHggPSBjdHg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2NlbmUgb2YgdGhpcyBUaWxlbWFwUmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gc2NlbmUgVGhlIGN1cnJlbnQgc2NlbmVcbiAgICAgKi9cbiAgICBzZXRTY2VuZShzY2VuZTogU2NlbmUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYW4gb3J0aG9nb25hbCB0aWxlbWFwXG4gICAgICogQHBhcmFtIHRpbGVtYXAgVGhlIHRpbGVtYXAgdG8gcmVuZGVyXG4gICAgICovXG4gICAgcmVuZGVyT3J0aG9nb25hbFRpbGVtYXAodGlsZW1hcDogT3J0aG9nb25hbFRpbGVtYXApOiB2b2lkIHtcbiAgICAgICAgbGV0IHByZXZpb3VzQWxwaGEgPSB0aGlzLmN0eC5nbG9iYWxBbHBoYTtcbiAgICAgICAgdGhpcy5jdHguZ2xvYmFsQWxwaGEgPSB0aWxlbWFwLmdldExheWVyKCkuZ2V0QWxwaGEoKTtcbiAgICAgICAgXG4gICAgICAgIGxldCBvcmlnaW4gPSB0aGlzLnNjZW5lLmdldFZpZXdUcmFuc2xhdGlvbih0aWxlbWFwKTtcbiAgICAgICAgbGV0IHNpemUgPSB0aGlzLnNjZW5lLmdldFZpZXdwb3J0KCkuZ2V0SGFsZlNpemUoKTtcbiAgICAgICAgbGV0IHpvb20gPSB0aGlzLnNjZW5lLmdldFZpZXdTY2FsZSgpO1xuICAgICAgICBsZXQgYm90dG9tUmlnaHQgPSBvcmlnaW4uY2xvbmUoKS5hZGQoc2l6ZS5zY2FsZWQoMip6b29tKSk7XG5cbiAgICAgICAgaWYodGlsZW1hcC52aXNpYmxlKXtcbiAgICAgICAgICAgIGxldCBtaW5Db2xSb3cgPSB0aWxlbWFwLmdldENvbFJvd0F0KG9yaWdpbik7XG4gICAgICAgICAgICBsZXQgbWF4Q29sUm93ID0gdGlsZW1hcC5nZXRDb2xSb3dBdChib3R0b21SaWdodCk7XG5cbiAgICAgICAgICAgIGZvcihsZXQgeCA9IG1pbkNvbFJvdy54OyB4IDw9IG1heENvbFJvdy54OyB4Kyspe1xuICAgICAgICAgICAgICAgIGZvcihsZXQgeSA9IG1pbkNvbFJvdy55OyB5IDw9IG1heENvbFJvdy55OyB5Kyspe1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHRpbGUgYXQgdGhpcyBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICBsZXQgdGlsZSA9IHRpbGVtYXAuZ2V0VGlsZUF0Um93Q29sKG5ldyBWZWMyKHgsIHkpKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSByb3QvZmxpcCBwYXJhbWV0ZXJzIGlmIHRoZXJlIGFyZSBhbnlcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFzayA9ICgweEUgPDwgMjgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByb3RGbGlwID0gKChtYXNrICYgdGlsZSkgPj4gMjgpICYgMHhGO1xuICAgICAgICAgICAgICAgICAgICB0aWxlID0gdGlsZSAmIH5tYXNrO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIHRpbGVzZXQgdGhhdCBvd25zIHRoaXMgdGlsZSBpbmRleCBhbmQgcmVuZGVyXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgdGlsZXNldCBvZiB0aWxlbWFwLmdldFRpbGVzZXRzKCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGlsZXNldC5oYXNUaWxlKHRpbGUpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclRpbGUodGlsZXNldCwgdGlsZSwgeCwgeSwgb3JpZ2luLCB0aWxlbWFwLnNjYWxlLCB6b29tLCByb3RGbGlwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gcHJldmlvdXNBbHBoYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgdGlsZVxuICAgICAqIEBwYXJhbSB0aWxlc2V0IFRoZSB0aWxlc2V0IHRoaXMgdGlsZSBiZWxvbmdzIHRvIFxuICAgICAqIEBwYXJhbSB0aWxlSW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlXG4gICAgICogQHBhcmFtIHRpbGVtYXBSb3cgVGhlIHJvdyBvZiB0aGUgdGlsZSBpbiB0aGUgdGlsZW1hcFxuICAgICAqIEBwYXJhbSB0aWxlbWFwQ29sIFRoZSBjb2x1bW4gb2YgdGhlIHRpbGUgaW4gdGhlIHRpbGVtYXBcbiAgICAgKiBAcGFyYW0gb3JpZ2luIFRoZSBvcmlnaW4gb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHNjYWxlIFRoZSBzY2FsZSBvZiB0aGUgdGlsZW1hcFxuICAgICAqIEBwYXJhbSB6b29tIFRoZSB6b29tIGxldmVsIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqL1xuICAgIHByb3RlY3RlZCByZW5kZXJUaWxlKHRpbGVzZXQ6IFRpbGVzZXQsIHRpbGVJbmRleDogbnVtYmVyLCB0aWxlbWFwUm93OiBudW1iZXIsIHRpbGVtYXBDb2w6IG51bWJlciwgb3JpZ2luOiBWZWMyLCBzY2FsZTogVmVjMiwgem9vbTogbnVtYmVyLCByb3RGbGlwOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgbGV0IGltYWdlID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0SW1hZ2UodGlsZXNldC5nZXRJbWFnZUtleSgpKTtcblxuICAgICAgICAvLyBHZXQgdGhlIHRydWUgaW5kZXhcbiAgICAgICAgbGV0IGluZGV4ID0gdGlsZUluZGV4IC0gdGlsZXNldC5nZXRTdGFydEluZGV4KCk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSByb3cgYW5kIGNvbCBvZiB0aGUgdGlsZSBpbiBpbWFnZSBzcGFjZVxuICAgICAgICBsZXQgcm93ID0gTWF0aC5mbG9vcihpbmRleCAvIHRpbGVzZXQuZ2V0TnVtQ29scygpKTtcbiAgICAgICAgbGV0IGNvbCA9IGluZGV4ICUgdGlsZXNldC5nZXROdW1Db2xzKCk7XG4gICAgICAgIGxldCB3aWR0aCA9IHRpbGVzZXQuZ2V0VGlsZVNpemUoKS54O1xuICAgICAgICBsZXQgaGVpZ2h0ID0gdGlsZXNldC5nZXRUaWxlU2l6ZSgpLnk7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiB0byBzdGFydCBhIGNyb3AgaW4gdGhlIHRpbGVzZXQgaW1hZ2VcbiAgICAgICAgbGV0IGxlZnQgPSBjb2wgKiB3aWR0aDtcbiAgICAgICAgbGV0IHRvcCA9IHJvdyAqIGhlaWdodDtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHBvc2l0aW9uIGluIHRoZSB3b3JsZCB0byByZW5kZXIgdGhlIHRpbGVcbiAgICAgICAgbGV0IHggPSBNYXRoLmZsb29yKHRpbGVtYXBSb3cgKiB3aWR0aCAqIHNjYWxlLngpO1xuICAgICAgICBsZXQgeSA9IE1hdGguZmxvb3IodGlsZW1hcENvbCAqIGhlaWdodCAqIHNjYWxlLnkpO1xuXG4gICAgICAgIGxldCB3b3JsZFggPSBNYXRoLmZsb29yKCh4IC0gb3JpZ2luLngpKnpvb20pO1xuICAgICAgICBsZXQgd29ybGRZID0gTWF0aC5mbG9vcigoeSAtIG9yaWdpbi55KSp6b29tKTtcbiAgICAgICAgbGV0IHdvcmxkV2lkdGggPSBNYXRoLmNlaWwod2lkdGggKiBzY2FsZS54ICogem9vbSk7XG4gICAgICAgIGxldCB3b3JsZEhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgKiBzY2FsZS55ICogem9vbSk7XG5cbiAgICAgICAgaWYocm90RmxpcCAhPT0gMCl7XG4gICAgICAgICAgICBsZXQgc2NhbGVYID0gMTtcbiAgICAgICAgICAgIGxldCBzY2FsZVkgPSAxO1xuICAgICAgICAgICAgbGV0IHNoZWFyWCA9IDA7XG4gICAgICAgICAgICBsZXQgc2hlYXJZID0gMDtcblxuICAgICAgICAgICAgLy8gRmxpcCBvbiB0aGUgeC1heGlzXG4gICAgICAgICAgICBpZihyb3RGbGlwICYgOCl7XG4gICAgICAgICAgICAgICAgc2NhbGVYID0gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZsaXAgb24gdGhlIHktYXhpc1xuICAgICAgICAgICAgaWYocm90RmxpcCAmIDQpe1xuICAgICAgICAgICAgICAgIHNjYWxlWSA9IC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGbGlwIG92ZXIgdGhlIGxpbmUgeT14XG4gICAgICAgICAgICBpZihyb3RGbGlwICYgMil7XG4gICAgICAgICAgICAgICAgc2hlYXJYID0gc2NhbGVZO1xuICAgICAgICAgICAgICAgIHNoZWFyWSA9IHNjYWxlWDtcbiAgICAgICAgICAgICAgICBzY2FsZVggPSAwO1xuICAgICAgICAgICAgICAgIHNjYWxlWSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybShzY2FsZVgsIHNoZWFyWCwgc2hlYXJZLCBzY2FsZVksIHdvcmxkWCArIHdvcmxkV2lkdGgvMiwgd29ybGRZICsgd29ybGRIZWlnaHQvMik7XG4gICAgICAgIFxuICAgICAgICAgICAgLy8gUmVuZGVyIHRoZSB0aWxlXG4gICAgICAgICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoaW1hZ2UsXG4gICAgICAgICAgICAgICAgbGVmdCwgdG9wLFxuICAgICAgICAgICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgICAgICAgICAgLXdvcmxkV2lkdGgvMiwgLXdvcmxkSGVpZ2h0LzIsXG4gICAgICAgICAgICAgICAgd29ybGRXaWR0aCwgd29ybGRIZWlnaHQpO1xuXG4gICAgICAgICAgICBpZihyb3RGbGlwICE9PSAwKXtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBObyByb3RhdGlvbnMsIGRvbid0IGRvIHRoZSBjYWxjdWxhdGlvbnMsIGp1c3QgcmVuZGVyIHRoZSB0aWxlXG4gICAgICAgICAgICAvLyBSZW5kZXIgdGhlIHRpbGVcbiAgICAgICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZShpbWFnZSxcbiAgICAgICAgICAgICAgICBsZWZ0LCB0b3AsXG4gICAgICAgICAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgICAgICAgICB3b3JsZFgsIHdvcmxkWSxcbiAgICAgICAgICAgICAgICB3b3JsZFdpZHRoLCB3b3JsZEhlaWdodCk7XG4gICAgICAgIH1cblxuXG4gICAgfVxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEJ1dHRvbiBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9CdXR0b25cIjtcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xuaW1wb3J0IFNsaWRlciBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9TbGlkZXJcIjtcbmltcG9ydCBUZXh0SW5wdXQgZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvVGV4dElucHV0XCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uL1NjZW5lL1NjZW5lXCI7XG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuLi8uLi9VdGlscy9NYXRoVXRpbHNcIjtcblxuLyoqXG4gKiBBIHV0aWxpdHkgY2xhc3MgdG8gaGVscCB0aGUgQHJlZmVyZW5jZVtDYW52YXNSZW5kZXJlcl0gcmVuZGVyIEByZWZlcmVuY2VbVUlFbGVtZW50XXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVUlFbGVtZW50UmVuZGVyZXIge1xuICAgIHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcbiAgICBwcm90ZWN0ZWQgc2NlbmU6IFNjZW5lO1xuICAgIHByb3RlY3RlZCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcblxuICAgIGNvbnN0cnVjdG9yKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKXtcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgdGhpcy5jdHggPSBjdHg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2NlbmUgb2YgdGhpcyBVSUVsZW1lbnRSZW5kZXJlclxuICAgICAqIEBwYXJhbSBzY2VuZSBUaGUgY3VycmVudCBzY2VuZVxuICAgICAqL1xuICAgIHNldFNjZW5lKHNjZW5lOiBTY2VuZSk6IHZvaWQge1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIGxhYmVsXG4gICAgICogQHBhcmFtIGxhYmVsIFRoZSBsYWJlbCB0byByZW5kZXJcbiAgICAgKi9cbiAgICByZW5kZXJMYWJlbChsYWJlbDogTGFiZWwpOiB2b2lkIHtcbiAgICAgICAgLy8gSWYgdGhlIHNpemUgaXMgdW5hc3NpZ25lZCAoYnkgdGhlIHVzZXIgb3IgYXV0b21hdGljYWxseSkgYXNzaWduIGl0XG4gICAgICAgIGxhYmVsLmhhbmRsZUluaXRpYWxTaXppbmcodGhpcy5jdHgpO1xuXHRcdFxuXHRcdC8vIEdyYWIgdGhlIGdsb2JhbCBhbHBoYSBzbyB3ZSBjYW4gYWRqdXN0IGl0IGZvciB0aGlzIHJlbmRlclxuXHRcdGxldCBwcmV2aW91c0FscGhhID0gdGhpcy5jdHguZ2xvYmFsQWxwaGE7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBmb250IGFuZCB0ZXh0IHBvc2l0aW9uIGluIGxhYmVsXG5cdFx0dGhpcy5jdHguZm9udCA9IGxhYmVsLmdldEZvbnRTdHJpbmcoKTtcblx0XHRsZXQgb2Zmc2V0ID0gbGFiZWwuY2FsY3VsYXRlVGV4dE9mZnNldCh0aGlzLmN0eCk7XG5cblx0XHQvLyBTdHJva2UgYW5kIGZpbGwgYSByb3VuZGVkIHJlY3QgYW5kIGdpdmUgaXQgdGV4dFxuXHRcdHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gbGFiZWwuYmFja2dyb3VuZENvbG9yLmE7XG5cdFx0dGhpcy5jdHguZmlsbFN0eWxlID0gbGFiZWwuY2FsY3VsYXRlQmFja2dyb3VuZENvbG9yKCkudG9TdHJpbmdSR0JBKCk7XG5cdFx0dGhpcy5jdHguZmlsbFJvdW5kZWRSZWN0KC1sYWJlbC5zaXplLngvMiwgLWxhYmVsLnNpemUueS8yLFxuXHRcdFx0bGFiZWwuc2l6ZS54LCBsYWJlbC5zaXplLnksIGxhYmVsLmJvcmRlclJhZGl1cyk7XG5cdFx0XG5cdFx0dGhpcy5jdHguc3Ryb2tlU3R5bGUgPSBsYWJlbC5jYWxjdWxhdGVCb3JkZXJDb2xvcigpLnRvU3RyaW5nUkdCQSgpO1xuXHRcdHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gbGFiZWwuYm9yZGVyQ29sb3IuYTtcblx0XHR0aGlzLmN0eC5saW5lV2lkdGggPSBsYWJlbC5ib3JkZXJXaWR0aDtcblx0XHR0aGlzLmN0eC5zdHJva2VSb3VuZGVkUmVjdCgtbGFiZWwuc2l6ZS54LzIsIC1sYWJlbC5zaXplLnkvMixcblx0XHRcdGxhYmVsLnNpemUueCwgbGFiZWwuc2l6ZS55LCBsYWJlbC5ib3JkZXJSYWRpdXMpO1xuXG5cdFx0dGhpcy5jdHguZmlsbFN0eWxlID0gbGFiZWwuY2FsY3VsYXRlVGV4dENvbG9yKCk7XG5cdFx0dGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBsYWJlbC50ZXh0Q29sb3IuYTtcblx0XHR0aGlzLmN0eC5maWxsVGV4dChsYWJlbC50ZXh0LCBvZmZzZXQueCAtIGxhYmVsLnNpemUueC8yLCBvZmZzZXQueSAtIGxhYmVsLnNpemUueS8yKTtcblx0XG5cdFx0dGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBwcmV2aW91c0FscGhhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYSBidXR0b25cbiAgICAgKiBAcGFyYW0gYnV0dG9uIFRoZSBidXR0b24gdG8gcmVuZGVyXG4gICAgICovXG4gICAgcmVuZGVyQnV0dG9uKGJ1dHRvbjogQnV0dG9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMucmVuZGVyTGFiZWwoYnV0dG9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgc2xpZGVyXG4gICAgICogQHBhcmFtIHNsaWRlciBUaGUgc2xpZGVyIHRvIHJlbmRlclxuICAgICAqL1xuICAgIHJlbmRlclNsaWRlcihzbGlkZXI6IFNsaWRlcik6IHZvaWQge1xuXHRcdC8vIEdyYWIgdGhlIGdsb2JhbCBhbHBoYSBzbyB3ZSBjYW4gYWRqdXN0IGl0IGZvciB0aGlzIHJlbmRlclxuXHRcdGxldCBwcmV2aW91c0FscGhhID0gdGhpcy5jdHguZ2xvYmFsQWxwaGE7XG5cdFx0dGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBzbGlkZXIuZ2V0TGF5ZXIoKS5nZXRBbHBoYSgpO1xuXG4gICAgICAgIC8vIENhbGN1YWxhdGUgdGhlIHNsaWRlciBzaXplXG4gICAgICAgIGxldCBzbGlkZXJTaXplID0gbmV3IFZlYzIoc2xpZGVyLnNpemUueCwgMik7XG5cbiAgICAgICAgLy8gRHJhdyB0aGUgc2xpZGVyXG5cdFx0dGhpcy5jdHguZmlsbFN0eWxlID0gc2xpZGVyLnNsaWRlckNvbG9yLnRvU3RyaW5nKCk7XG5cdFx0dGhpcy5jdHguZmlsbFJvdW5kZWRSZWN0KC1zbGlkZXJTaXplLngvMiwgLXNsaWRlclNpemUueS8yLFxuICAgICAgICAgICAgc2xpZGVyU2l6ZS54LCBzbGlkZXJTaXplLnksIHNsaWRlci5ib3JkZXJSYWRpdXMpO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbmliIHNpemUgYW5kIHBvc2l0aW9uXG4gICAgICAgIGxldCB4ID0gTWF0aFV0aWxzLmxlcnAoLXNsaWRlci5zaXplLngvMiwgc2xpZGVyLnNpemUueC8yLCBzbGlkZXIuZ2V0VmFsdWUoKSk7XG5cbiAgICAgICAgLy8gRHJhdyB0aGUgbmliXG5cdFx0dGhpcy5jdHguZmlsbFN0eWxlID0gc2xpZGVyLm5pYkNvbG9yLnRvU3RyaW5nKCk7XG5cdFx0dGhpcy5jdHguZmlsbFJvdW5kZWRSZWN0KHgtc2xpZGVyLm5pYlNpemUueC8yLCAtc2xpZGVyLm5pYlNpemUueS8yLFxuICAgICAgICAgICAgc2xpZGVyLm5pYlNpemUueCwgc2xpZGVyLm5pYlNpemUueSwgc2xpZGVyLmJvcmRlclJhZGl1cyk7XG5cbiAgICAgICAgLy8gUmVzZXQgdGhlIGFscGhhXG4gICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gcHJldmlvdXNBbHBoYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgdGV4dElucHV0XG4gICAgICogQHBhcmFtIHRleHRJbnB1dCBUaGUgdGV4dElucHV0IHRvIHJlbmRlclxuICAgICAqL1xuICAgIHJlbmRlclRleHRJbnB1dCh0ZXh0SW5wdXQ6IFRleHRJbnB1dCk6IHZvaWQge1xuICAgICAgICAvLyBTaG93IGEgY3Vyc29yIHNvbWV0aW1lc1xuICAgICAgICBpZih0ZXh0SW5wdXQuZm9jdXNlZCAmJiB0ZXh0SW5wdXQuY3Vyc29yQ291bnRlciAlIDYwID4gMzApe1xuICAgICAgICAgICAgdGV4dElucHV0LnRleHQgKz0gXCJ8XCI7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlbmRlckxhYmVsKHRleHRJbnB1dCk7XG5cbiAgICAgICAgaWYodGV4dElucHV0LmZvY3VzZWQpe1xuICAgICAgICAgICAgaWYodGV4dElucHV0LmN1cnNvckNvdW50ZXIgJSA2MCA+IDMwKXtcbiAgICAgICAgICAgICAgICB0ZXh0SW5wdXQudGV4dCA9IHRleHRJbnB1dC50ZXh0LnN1YnN0cmluZygwLCB0ZXh0SW5wdXQudGV4dC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGV4dElucHV0LmN1cnNvckNvdW50ZXIgKz0gMTtcbiAgICAgICAgICAgIGlmKHRleHRJbnB1dC5jdXJzb3JDb3VudGVyID49IDYwKXtcbiAgICAgICAgICAgICAgICB0ZXh0SW5wdXQuY3Vyc29yQ291bnRlciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xuaW1wb3J0IEdyYXBoaWMgZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNcIjtcbmltcG9ydCBBbmltYXRlZFNwcml0ZSBmcm9tIFwiLi4vTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZVwiO1xuaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi4vTm9kZXMvU3ByaXRlcy9TcHJpdGVcIjtcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwXCI7XG5pbXBvcnQgVUlFbGVtZW50IGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBVSUxheWVyIGZyb20gXCIuLi9TY2VuZS9MYXllcnMvVUlMYXllclwiO1xuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZS9TY2VuZVwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xuXG4vKipcbiAqIEFuIGFic3RyYWN0IGZyYW1ld29yayB0byBwdXQgYWxsIHJlbmRlcmluZyBpbiBvbmNlIHBsYWNlIGluIHRoZSBhcHBsaWNhdGlvblxuICovXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBSZW5kZXJpbmdNYW5hZ2VyIHtcbiAgICAvKiogVGhlIFJlc291cmNlTWFuYWdlciAqL1xuICAgIHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcblxuICAgIC8qKiBUaGUgc2NlbmUgY3VycmVudGx5IGJlaW5nIHJlbmRlcmVkICovXG4gICAgcHJvdGVjdGVkIHNjZW5lOiBTY2VuZTtcblxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2NlbmUgY3VycmVudGx5IGJlaW5nIHJlbmRlcmVkXG4gICAgICogQHBhcmFtIHNjZW5lIFRoZSBjdXJyZW50IFNjZW5lXG4gICAgICovXG4gICAgc2V0U2NlbmUoc2NlbmU6IFNjZW5lKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSBjYW52YXMgZm9yIHRoZSBnYW1lXG4gICAgICogQHBhcmFtIGNhbnZhcyBUaGUgY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gd2lkdGggVGhlIGRlc2lyZWQgd2lkdGggb2YgdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSBoZWlnaHQgVGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSBjYW52YXNcbiAgICAgKiBAcmV0dXJucyBUaGUgcmVuZGVyaW5nIGNvbnRleHQgb2YgdGhlIGNhbnZhc1xuICAgICAqL1xuICAgIGFic3RyYWN0IGluaXRpYWxpemVDYW52YXMoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSB2aXNpYmxlIHNldCBvZiBDYW52YXNOb2RlcyBhbmQgdmlzaWJsZSBwb3J0aW9ucyBvZiB0aWxlbWFwcywgYXMgd2VsbCBhcyBhbnkgVUlFbGVtZW50IGluIFVJTGF5ZXJzXG4gICAgICogQHBhcmFtIHZpc2libGVTZXQgVGhlIHZpc2libGUgc2V0IG9mIENhbnZhc05vZGVzXG4gICAgICogQHBhcmFtIHRpbGVtYXBzIFRoZSB0aWxlbWFwcyB1c2VkIGluIHRoZSBhcHBsaWNhdGlvblxuICAgICAqIEBwYXJhbSB1aUxheWVycyBUaGUgdXNlciBpbnRlcmZhY2UgbGF5ZXJzXG4gICAgICovXG4gICAgYWJzdHJhY3QgcmVuZGVyKHZpc2libGVTZXQ6IEFycmF5PENhbnZhc05vZGU+LCB0aWxlbWFwczogQXJyYXk8VGlsZW1hcD4sIHVpTGF5ZXJzOiBNYXA8VUlMYXllcj4pOiB2b2lkO1xuXG4gICAgLyoqIENsZWFycyB0aGUgY2FudmFzICovXG4gICAgYWJzdHJhY3QgY2xlYXIoY29sb3I6IENvbG9yKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYSBzcHJpdGVcbiAgICAgKiBAcGFyYW0gc3ByaXRlIFRoZSBzcHJpdGUgdG8gcmVuZGVyXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHJlbmRlclNwcml0ZShzcHJpdGU6IFNwcml0ZSk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGFuIGFuaW1hdGVkIHNwcml0ZVxuICAgICAqIEBwYXJhbSBzcHJpdGUgVGhlIGFuaW1hdGVkIHNwcml0ZSB0byByZW5kZXJcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVuZGVyQW5pbWF0ZWRTcHJpdGUoc3ByaXRlOiBBbmltYXRlZFNwcml0ZSk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgZ3JhcGhpY1xuICAgICAqIEBwYXJhbSBncmFwaGljIFRoZSBncmFwaGljIHRvIHJlbmRlclxuICAgICAqL1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCByZW5kZXJHcmFwaGljKGdyYXBoaWM6IEdyYXBoaWMpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIHRpbGVtYXBcbiAgICAgKiBAcGFyYW0gdGlsZW1hcCBUaGUgdGlsZW1hcCB0byByZW5kZXJcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVuZGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZDtcblxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIFVJRWxlbWVudFxuICAgICAqIEBwYXJhbSB1aUVsZW1lbnQgVGhlIFVJRWxlbWVudCB0byByZW5kZXJcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVuZGVyVUlFbGVtZW50KHVpRWxlbWVudDogVUlFbGVtZW50KTogdm9pZDtcbn0iLCJpbXBvcnQgR3JhcGggZnJvbSBcIi4uL0RhdGFUeXBlcy9HcmFwaHMvR3JhcGhcIjtcbmltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IERlYnVnIGZyb20gXCIuLi9EZWJ1Zy9EZWJ1Z1wiO1xuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uL05vZGVzL0NhbnZhc05vZGVcIjtcbmltcG9ydCBHcmFwaGljIGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljXCI7XG5pbXBvcnQgeyBHcmFwaGljVHlwZSB9IGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljcy9HcmFwaGljVHlwZXNcIjtcbmltcG9ydCBQb2ludCBmcm9tIFwiLi4vTm9kZXMvR3JhcGhpY3MvUG9pbnRcIjtcbmltcG9ydCBSZWN0IGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljcy9SZWN0XCI7XG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vTm9kZXMvVGlsZW1hcFwiO1xuaW1wb3J0IFVJRWxlbWVudCBmcm9tIFwiLi4vTm9kZXMvVUlFbGVtZW50XCI7XG5pbXBvcnQgTGFiZWwgZnJvbSBcIi4uL05vZGVzL1VJRWxlbWVudHMvTGFiZWxcIjtcbmltcG9ydCBTaGFkZXJSZWdpc3RyeSBmcm9tIFwiLi4vUmVnaXN0cnkvUmVnaXN0cmllcy9TaGFkZXJSZWdpc3RyeVwiO1xuaW1wb3J0IFJlZ2lzdHJ5TWFuYWdlciBmcm9tIFwiLi4vUmVnaXN0cnkvUmVnaXN0cnlNYW5hZ2VyXCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgUGFyYWxsYXhMYXllciBmcm9tIFwiLi4vU2NlbmUvTGF5ZXJzL1BhcmFsbGF4TGF5ZXJcIjtcbmltcG9ydCBVSUxheWVyIGZyb20gXCIuLi9TY2VuZS9MYXllcnMvVUlMYXllclwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xuaW1wb3J0IFJlbmRlcmluZ1V0aWxzIGZyb20gXCIuLi9VdGlscy9SZW5kZXJpbmdVdGlsc1wiO1xuaW1wb3J0IFJlbmRlcmluZ01hbmFnZXIgZnJvbSBcIi4vUmVuZGVyaW5nTWFuYWdlclwiO1xuaW1wb3J0IFNoYWRlclR5cGUgZnJvbSBcIi4vV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJHTFJlbmRlcmVyIGV4dGVuZHMgUmVuZGVyaW5nTWFuYWdlciB7XG5cblx0cHJvdGVjdGVkIG9yaWdpbjogVmVjMjtcblx0cHJvdGVjdGVkIHpvb206IG51bWJlcjtcblx0cHJvdGVjdGVkIHdvcmxkU2l6ZTogVmVjMjtcblxuXHRwcm90ZWN0ZWQgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dDtcblx0cHJvdGVjdGVkIHRleHRDdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcblxuXHRpbml0aWFsaXplQ2FudmFzKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogV2ViR0xSZW5kZXJpbmdDb250ZXh0IHtcblx0XHRjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuXHRcdHRoaXMud29ybGRTaXplID0gVmVjMi5aRVJPO1xuXHRcdHRoaXMud29ybGRTaXplLnggPSB3aWR0aDtcblx0XHR0aGlzLndvcmxkU2l6ZS55ID0gaGVpZ2h0O1xuXG5cdFx0Ly8gR2V0IHRoZSBXZWJHTCBjb250ZXh0XG4gICAgICAgIHRoaXMuZ2wgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIpO1xuXG5cdFx0dGhpcy5nbC52aWV3cG9ydCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG5cdFx0dGhpcy5nbC5kaXNhYmxlKHRoaXMuZ2wuREVQVEhfVEVTVCk7XG4gICAgICAgIHRoaXMuZ2wuZW5hYmxlKHRoaXMuZ2wuQkxFTkQpO1xuICAgICAgICB0aGlzLmdsLmJsZW5kRnVuYyh0aGlzLmdsLlNSQ19BTFBIQSwgdGhpcy5nbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcbiAgICAgICAgdGhpcy5nbC5lbmFibGUodGhpcy5nbC5DVUxMX0ZBQ0UpO1xuXG5cdFx0Ly8gVGVsbCB0aGUgcmVzb3VyY2UgbWFuYWdlciB3ZSdyZSB1c2luZyBXZWJHTFxuXHRcdFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLnVzZVdlYkdMKHRydWUsIHRoaXMuZ2wpO1xuXG5cdFx0Ly8gU2hvdyB0aGUgdGV4dCBjYW52YXMgYW5kIGdldCBpdHMgY29udGV4dFxuXHRcdGxldCB0ZXh0Q2FudmFzID0gPEhUTUxDYW52YXNFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGV4dC1jYW52YXNcIik7XG5cdFx0dGV4dENhbnZhcy5oaWRkZW4gPSBmYWxzZTtcblx0XHR0aGlzLnRleHRDdHggPSB0ZXh0Q2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuXHRcdC8vIFNpemUgdGhlIHRleHQgY2FudmFzIHRvIGJlIHRoZSBzYW1lIGFzIHRoZSBnYW1lIGNhbnZhc1xuXHRcdHRleHRDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHRleHRDYW52YXMud2lkdGggPSB3aWR0aDtcblxuICAgICAgICByZXR1cm4gdGhpcy5nbDtcblx0fVxuXG5cdHJlbmRlcih2aXNpYmxlU2V0OiBDYW52YXNOb2RlW10sIHRpbGVtYXBzOiBUaWxlbWFwW10sIHVpTGF5ZXJzOiBNYXA8VUlMYXllcj4pOiB2b2lkIHtcblx0XHRmb3IobGV0IG5vZGUgb2YgdmlzaWJsZVNldCl7XG5cdFx0XHR0aGlzLnJlbmRlck5vZGUobm9kZSk7XG5cdFx0fVxuXG5cdFx0dWlMYXllcnMuZm9yRWFjaChrZXkgPT4ge1xuXHRcdFx0aWYoIXVpTGF5ZXJzLmdldChrZXkpLmlzSGlkZGVuKCkpXG5cdFx0XHRcdHVpTGF5ZXJzLmdldChrZXkpLmdldEl0ZW1zKCkuZm9yRWFjaChub2RlID0+IHRoaXMucmVuZGVyTm9kZSg8Q2FudmFzTm9kZT5ub2RlKSlcblx0XHR9KTtcblx0fVxuXG5cdGNsZWFyKGNvbG9yOiBDb2xvcik6IHZvaWQge1xuXHRcdHRoaXMuZ2wuY2xlYXJDb2xvcihjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCBjb2xvci5hKTtcblx0XHR0aGlzLmdsLmNsZWFyKHRoaXMuZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IHRoaXMuZ2wuREVQVEhfQlVGRkVSX0JJVCk7XG5cblx0XHR0aGlzLnRleHRDdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMud29ybGRTaXplLngsIHRoaXMud29ybGRTaXplLnkpO1xuXHR9XG5cblx0cHJvdGVjdGVkIHJlbmRlck5vZGUobm9kZTogQ2FudmFzTm9kZSk6IHZvaWQge1xuXHRcdC8vIENhbGN1bGF0ZSB0aGUgb3JpZ2luIG9mIHRoZSB2aWV3cG9ydCBhY2NvcmRpbmcgdG8gdGhpcyBzcHJpdGVcbiAgICAgICAgdGhpcy5vcmlnaW4gPSB0aGlzLnNjZW5lLmdldFZpZXdUcmFuc2xhdGlvbihub2RlKTtcblxuICAgICAgICAvLyBHZXQgdGhlIHpvb20gbGV2ZWwgb2YgdGhlIHNjZW5lXG4gICAgICAgIHRoaXMuem9vbSA9IHRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCk7XG5cdFx0XG5cdFx0aWYobm9kZS5oYXNDdXN0b21TaGFkZXIpe1xuXHRcdFx0Ly8gSWYgdGhlIG5vZGUgaGFzIGEgY3VzdG9tIHNoYWRlciwgcmVuZGVyIHVzaW5nIHRoYXRcblx0XHRcdHRoaXMucmVuZGVyQ3VzdG9tKG5vZGUpO1xuXHRcdH0gZWxzZSBpZihub2RlIGluc3RhbmNlb2YgR3JhcGhpYyl7XG5cdFx0XHR0aGlzLnJlbmRlckdyYXBoaWMobm9kZSk7XG5cdFx0fSBlbHNlIGlmKG5vZGUgaW5zdGFuY2VvZiBTcHJpdGUpe1xuXHRcdFx0aWYobm9kZSBpbnN0YW5jZW9mIEFuaW1hdGVkU3ByaXRlKXtcblx0XHRcdFx0dGhpcy5yZW5kZXJBbmltYXRlZFNwcml0ZShub2RlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMucmVuZGVyU3ByaXRlKG5vZGUpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZihub2RlIGluc3RhbmNlb2YgVUlFbGVtZW50KXtcblx0XHRcdHRoaXMucmVuZGVyVUlFbGVtZW50KG5vZGUpO1xuXHRcdH1cblx0fVxuXG5cdHByb3RlY3RlZCByZW5kZXJTcHJpdGUoc3ByaXRlOiBTcHJpdGUpOiB2b2lkIHtcblx0XHRsZXQgc2hhZGVyID0gUmVnaXN0cnlNYW5hZ2VyLnNoYWRlcnMuZ2V0KFNoYWRlclJlZ2lzdHJ5LlNQUklURV9TSEFERVIpO1xuXHRcdGxldCBvcHRpb25zID0gdGhpcy5hZGRPcHRpb25zKHNoYWRlci5nZXRPcHRpb25zKHNwcml0ZSksIHNwcml0ZSk7XG5cdFx0c2hhZGVyLnJlbmRlcih0aGlzLmdsLCBvcHRpb25zKTtcblx0fVxuXG5cdHByb3RlY3RlZCByZW5kZXJBbmltYXRlZFNwcml0ZShzcHJpdGU6IEFuaW1hdGVkU3ByaXRlKTogdm9pZCB7XG5cdFx0bGV0IHNoYWRlciA9IFJlZ2lzdHJ5TWFuYWdlci5zaGFkZXJzLmdldChTaGFkZXJSZWdpc3RyeS5TUFJJVEVfU0hBREVSKTtcblx0XHRsZXQgb3B0aW9ucyA9IHRoaXMuYWRkT3B0aW9ucyhzaGFkZXIuZ2V0T3B0aW9ucyhzcHJpdGUpLCBzcHJpdGUpO1xuXHRcdHNoYWRlci5yZW5kZXIodGhpcy5nbCwgb3B0aW9ucyk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgcmVuZGVyR3JhcGhpYyhncmFwaGljOiBHcmFwaGljKTogdm9pZCB7XG5cblx0XHRpZihncmFwaGljIGluc3RhbmNlb2YgUG9pbnQpe1xuXHRcdFx0bGV0IHNoYWRlciA9IFJlZ2lzdHJ5TWFuYWdlci5zaGFkZXJzLmdldChTaGFkZXJSZWdpc3RyeS5QT0lOVF9TSEFERVIpO1xuXHRcdFx0bGV0IG9wdGlvbnMgPSB0aGlzLmFkZE9wdGlvbnMoc2hhZGVyLmdldE9wdGlvbnMoZ3JhcGhpYyksIGdyYXBoaWMpO1xuXHRcdFx0c2hhZGVyLnJlbmRlcih0aGlzLmdsLCBvcHRpb25zKTtcblx0XHR9IGVsc2UgaWYoZ3JhcGhpYyBpbnN0YW5jZW9mIFJlY3QpIHtcblx0XHRcdGxldCBzaGFkZXIgPSBSZWdpc3RyeU1hbmFnZXIuc2hhZGVycy5nZXQoU2hhZGVyUmVnaXN0cnkuUkVDVF9TSEFERVIpO1xuXHRcdFx0bGV0IG9wdGlvbnMgPSB0aGlzLmFkZE9wdGlvbnMoc2hhZGVyLmdldE9wdGlvbnMoZ3JhcGhpYyksIGdyYXBoaWMpO1xuXHRcdFx0c2hhZGVyLnJlbmRlcih0aGlzLmdsLCBvcHRpb25zKTtcblx0XHR9IFxuXHR9XG5cblx0cHJvdGVjdGVkIHJlbmRlclRpbGVtYXAodGlsZW1hcDogVGlsZW1hcCk6IHZvaWQge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuXHR9XG5cblx0cHJvdGVjdGVkIHJlbmRlclVJRWxlbWVudCh1aUVsZW1lbnQ6IFVJRWxlbWVudCk6IHZvaWQge1xuXHRcdGlmKHVpRWxlbWVudCBpbnN0YW5jZW9mIExhYmVsKXtcblx0XHRcdGxldCBzaGFkZXIgPSBSZWdpc3RyeU1hbmFnZXIuc2hhZGVycy5nZXQoU2hhZGVyUmVnaXN0cnkuTEFCRUxfU0hBREVSKTtcblx0XHRcdGxldCBvcHRpb25zID0gdGhpcy5hZGRPcHRpb25zKHNoYWRlci5nZXRPcHRpb25zKHVpRWxlbWVudCksIHVpRWxlbWVudCk7XG5cdFx0XHRzaGFkZXIucmVuZGVyKHRoaXMuZ2wsIG9wdGlvbnMpO1xuXG5cdFx0XHR0aGlzLnRleHRDdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsICh1aUVsZW1lbnQucG9zaXRpb24ueCAtIHRoaXMub3JpZ2luLngpKnRoaXMuem9vbSwgKHVpRWxlbWVudC5wb3NpdGlvbi55IC0gdGhpcy5vcmlnaW4ueSkqdGhpcy56b29tKTtcblx0XHRcdHRoaXMudGV4dEN0eC5yb3RhdGUoLXVpRWxlbWVudC5yb3RhdGlvbik7XG5cdFx0XHRsZXQgZ2xvYmFsQWxwaGEgPSB0aGlzLnRleHRDdHguZ2xvYmFsQWxwaGE7XG5cdFx0XHR0aGlzLnRleHRDdHguZ2xvYmFsQWxwaGEgPSB1aUVsZW1lbnQuYWxwaGE7XG5cblx0XHRcdC8vIFJlbmRlciB0ZXh0XG5cdFx0XHR0aGlzLnRleHRDdHguZm9udCA9IHVpRWxlbWVudC5nZXRGb250U3RyaW5nKCk7XG5cdFx0XHRsZXQgb2Zmc2V0ID0gdWlFbGVtZW50LmNhbGN1bGF0ZVRleHRPZmZzZXQodGhpcy50ZXh0Q3R4KTtcblx0XHRcdHRoaXMudGV4dEN0eC5maWxsU3R5bGUgPSB1aUVsZW1lbnQuY2FsY3VsYXRlVGV4dENvbG9yKCk7XG5cdFx0XHR0aGlzLnRleHRDdHguZ2xvYmFsQWxwaGEgPSB1aUVsZW1lbnQudGV4dENvbG9yLmE7XG5cdFx0XHR0aGlzLnRleHRDdHguZmlsbFRleHQodWlFbGVtZW50LnRleHQsIG9mZnNldC54IC0gdWlFbGVtZW50LnNpemUueC8yLCBvZmZzZXQueSAtIHVpRWxlbWVudC5zaXplLnkvMik7XG5cblx0XHRcdHRoaXMudGV4dEN0eC5nbG9iYWxBbHBoYSA9IGdsb2JhbEFscGhhO1xuICAgICAgICBcdHRoaXMudGV4dEN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cdFx0fVxuXHR9XG5cblx0cHJvdGVjdGVkIHJlbmRlckN1c3RvbShub2RlOiBDYW52YXNOb2RlKTogdm9pZCB7XG5cdFx0bGV0IHNoYWRlciA9IFJlZ2lzdHJ5TWFuYWdlci5zaGFkZXJzLmdldChub2RlLmN1c3RvbVNoYWRlcktleSk7XG5cdFx0bGV0IG9wdGlvbnMgPSB0aGlzLmFkZE9wdGlvbnMoc2hhZGVyLmdldE9wdGlvbnMobm9kZSksIG5vZGUpO1xuXHRcdHNoYWRlci5yZW5kZXIodGhpcy5nbCwgb3B0aW9ucyk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgYWRkT3B0aW9ucyhvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBub2RlOiBDYW52YXNOb2RlKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG5cdFx0Ly8gR2l2ZSB0aGUgc2hhZGVyIGFjY2VzcyB0byB0aGUgd29ybGQgc2l6ZVxuXHRcdG9wdGlvbnMud29ybGRTaXplID0gdGhpcy53b3JsZFNpemU7XG5cblx0XHQvLyBBZGp1c3QgdGhlIG9yaWdpbiBwb3NpdGlvbiB0byB0aGUgcGFyYWxsYXhcblx0XHRsZXQgbGF5ZXIgPSBub2RlLmdldExheWVyKCk7XG5cdFx0bGV0IHBhcmFsbGF4ID0gbmV3IFZlYzIoMSwgMSk7XG5cdFx0aWYobGF5ZXIgaW5zdGFuY2VvZiBQYXJhbGxheExheWVyKXtcblx0XHRcdHBhcmFsbGF4ID0gKDxQYXJhbGxheExheWVyPmxheWVyKS5wYXJhbGxheDtcblx0XHR9XG5cblx0XHRvcHRpb25zLm9yaWdpbiA9IHRoaXMub3JpZ2luLmNsb25lKCkubXVsdChwYXJhbGxheCk7XG5cblx0XHRyZXR1cm4gb3B0aW9ucztcblx0fVxuXG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL01hcFwiO1xuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uLy4uL05vZGVzL0NhbnZhc05vZGVcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcblxuLyoqXG4gKiBBIHdyYXBwZXIgY2xhc3MgZm9yIFdlYkdMIHNoYWRlcnMuXG4gKiBUaGlzIGNsYXNzIGlzIGEgc2luZ2xldG9uLCBhbmQgdGhlcmUgaXMgb25seSBvbmUgZm9yIGVhY2ggc2hhZGVyIHR5cGUuXG4gKiBBbGwgb2JqZWN0cyB0aGF0IHVzZSB0aGlzIHNoYWRlciB0eXBlIHdpbGwgcmVmZXIgdG8gYW5kIG1vZGlmeSB0aGlzIHNhbWUgdHlwZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyVHlwZSB7XG5cdC8qKiBUaGUgbmFtZSBvZiB0aGlzIHNoYWRlciAqL1xuXHRwcm90ZWN0ZWQgbmFtZTogc3RyaW5nO1xuXG5cdC8qKiBUaGUga2V5IHRvIHRoZSBXZWJHTFByb2dyYW0gaW4gdGhlIFJlc291cmNlTWFuYWdlciAqL1xuXHRwcm90ZWN0ZWQgcHJvZ3JhbUtleTogc3RyaW5nO1xuXG5cdC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgcmVzb3VyY2UgbWFuYWdlciAqL1xuXHRwcm90ZWN0ZWQgcmVzb3VyY2VNYW5hZ2VyOiBSZXNvdXJjZU1hbmFnZXI7XG5cblx0Y29uc3RydWN0b3IocHJvZ3JhbUtleTogc3RyaW5nKXtcblx0XHR0aGlzLnByb2dyYW1LZXkgPSBwcm9ncmFtS2V5O1xuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XG5cdH1cblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZXMgYW55IGJ1ZmZlciBvYmplY3RzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHNoYWRlciB0eXBlLlxuXHQgKiBAcGFyYW0gZ2wgVGhlIFdlYkdMIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqL1xuXHRhYnN0cmFjdCBpbml0QnVmZmVyT2JqZWN0KCk6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIExvYWRzIGFueSB1bmlmb3Jtc1xuXHQgKiBAcGFyYW0gZ2wgVGhlIFdlYkdMIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqIEBwYXJhbSBvcHRpb25zIEluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3Qgd2UncmUgY3VycmVudGx5IHJlbmRlcmluZ1xuXHQgKi9cblx0YWJzdHJhY3QgcmVuZGVyKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBFeHRyYWN0cyB0aGUgb3B0aW9ucyBmcm9tIHRoZSBDYW52YXNOb2RlIGFuZCBnaXZlcyB0aGVtIHRvIHRoZSByZW5kZXIgZnVuY3Rpb25cblx0ICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gZ2V0IG9wdGlvbnMgZnJvbVxuXHQgKiBAcmV0dXJucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgb3B0aW9ucyB0aGF0IHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIHJlbmRlciBmdW5jdGlvblxuXHQgKi9cblx0Z2V0T3B0aW9ucyhub2RlOiBDYW52YXNOb2RlKTogUmVjb3JkPHN0cmluZywgYW55PiB7cmV0dXJuIHt9O31cbn0iLCJpbXBvcnQgTWF0NHg0IGZyb20gXCIuLi8uLi8uLi9EYXRhVHlwZXMvTWF0NHg0XCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vLi4vLi4vRGVidWcvRGVidWdcIjtcbmltcG9ydCBSZWN0IGZyb20gXCIuLi8uLi8uLi9Ob2Rlcy9HcmFwaGljcy9SZWN0XCI7XG5pbXBvcnQgTGFiZWwgZnJvbSBcIi4uLy4uLy4uL05vZGVzL1VJRWxlbWVudHMvTGFiZWxcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBRdWFkU2hhZGVyVHlwZSBmcm9tIFwiLi9RdWFkU2hhZGVyVHlwZVwiO1xuXG4vKiogKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExhYmVsU2hhZGVyVHlwZSBleHRlbmRzIFF1YWRTaGFkZXJUeXBlIHtcblxuXHRjb25zdHJ1Y3Rvcihwcm9ncmFtS2V5OiBzdHJpbmcpe1xuXHRcdHN1cGVyKHByb2dyYW1LZXkpO1xuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XG5cdH1cblxuXHRpbml0QnVmZmVyT2JqZWN0KCk6IHZvaWQge1xuXHRcdHRoaXMuYnVmZmVyT2JqZWN0S2V5ID0gXCJsYWJlbFwiO1xuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZUJ1ZmZlcih0aGlzLmJ1ZmZlck9iamVjdEtleSk7XG5cdH1cblxuXHRyZW5kZXIoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuXHRcdGNvbnN0IGJhY2tncm91bmRDb2xvciA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLnRvV2ViR0woKTtcblx0XHRjb25zdCBib3JkZXJDb2xvciA9IG9wdGlvbnMuYm9yZGVyQ29sb3IudG9XZWJHTCgpO1xuXG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldFNoYWRlclByb2dyYW0odGhpcy5wcm9ncmFtS2V5KTtcblx0XHRjb25zdCBidWZmZXIgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xuXG5cdFx0Z2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcblxuXHRcdGNvbnN0IHZlcnRleERhdGEgPSB0aGlzLmdldFZlcnRpY2VzKG9wdGlvbnMuc2l6ZS54LCBvcHRpb25zLnNpemUueSk7XG5cblx0XHRjb25zdCBGU0laRSA9IHZlcnRleERhdGEuQllURVNfUEVSX0VMRU1FTlQ7XG5cblx0XHQvLyBCaW5kIHRoZSBidWZmZXJcblx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcblx0XHRnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4RGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xuXG5cdFx0Ly8gQXR0cmlidXRlc1xuXHRcdGNvbnN0IGFfUG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBcImFfUG9zaXRpb25cIik7XG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlcihhX1Bvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiBGU0laRSwgMCAqIEZTSVpFKTtcblx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhX1Bvc2l0aW9uKTtcblxuXHRcdC8vIFVuaWZvcm1zXG5cdFx0Y29uc3QgdV9CYWNrZ3JvdW5kQ29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X0JhY2tncm91bmRDb2xvclwiKTtcblx0XHRnbC51bmlmb3JtNGZ2KHVfQmFja2dyb3VuZENvbG9yLCBiYWNrZ3JvdW5kQ29sb3IpO1xuXG4gICAgICAgIGNvbnN0IHVfQm9yZGVyQ29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X0JvcmRlckNvbG9yXCIpO1xuXHRcdGdsLnVuaWZvcm00ZnYodV9Cb3JkZXJDb2xvciwgYm9yZGVyQ29sb3IpO1xuXG4gICAgICAgIGNvbnN0IHVfTWF4U2l6ZSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfTWF4U2l6ZVwiKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmKHVfTWF4U2l6ZSwgLXZlcnRleERhdGFbMF0sIHZlcnRleERhdGFbMV0pO1xuXG5cdFx0Ly8gR2V0IHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuXHRcdC8vIFdlIHdhbnQgYSBzcXVhcmUgZm9yIG91ciByZW5kZXJpbmcgc3BhY2UsIHNvIGdldCB0aGUgbWF4aW11bSBkaW1lbnNpb24gb2Ygb3VyIHF1YWRcblx0XHRsZXQgbWF4RGltZW5zaW9uID0gTWF0aC5tYXgob3B0aW9ucy5zaXplLngsIG9wdGlvbnMuc2l6ZS55KTtcblxuICAgICAgICBjb25zdCB1X0JvcmRlcldpZHRoID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9Cb3JkZXJXaWR0aFwiKTtcblx0XHRnbC51bmlmb3JtMWYodV9Cb3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aC9tYXhEaW1lbnNpb24pO1xuXG4gICAgICAgIGNvbnN0IHVfQm9yZGVyUmFkaXVzID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9Cb3JkZXJSYWRpdXNcIik7XG5cdFx0Z2wudW5pZm9ybTFmKHVfQm9yZGVyUmFkaXVzLCBvcHRpb25zLmJvcmRlclJhZGl1cy9tYXhEaW1lbnNpb24pO1xuXG5cdFx0Ly8gVGhlIHNpemUgb2YgdGhlIHJlbmRlcmluZyBzcGFjZSB3aWxsIGJlIGEgc3F1YXJlIHdpdGggdGhpcyBtYXhpbXVtIGRpbWVuc2lvblxuXHRcdGxldCBzaXplID0gbmV3IFZlYzIobWF4RGltZW5zaW9uLCBtYXhEaW1lbnNpb24pLnNjYWxlKDIvb3B0aW9ucy53b3JsZFNpemUueCwgMi9vcHRpb25zLndvcmxkU2l6ZS55KTtcblxuXHRcdC8vIENlbnRlciBvdXIgdHJhbnNsYXRpb25zIGFyb3VuZCAoMCwgMClcblx0XHRjb25zdCB0cmFuc2xhdGVYID0gKG9wdGlvbnMucG9zaXRpb24ueCAtIG9wdGlvbnMub3JpZ2luLnggLSBvcHRpb25zLndvcmxkU2l6ZS54LzIpL21heERpbWVuc2lvbjtcblx0XHRjb25zdCB0cmFuc2xhdGVZID0gLShvcHRpb25zLnBvc2l0aW9uLnkgLSBvcHRpb25zLm9yaWdpbi55IC0gb3B0aW9ucy53b3JsZFNpemUueS8yKS9tYXhEaW1lbnNpb247XG5cblx0XHQvLyBDcmVhdGUgb3VyIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuXHRcdHRoaXMudHJhbnNsYXRpb24udHJhbnNsYXRlKG5ldyBGbG9hdDMyQXJyYXkoW3RyYW5zbGF0ZVgsIHRyYW5zbGF0ZVldKSk7XG5cdFx0dGhpcy5zY2FsZS5zY2FsZShzaXplKTtcblx0XHR0aGlzLnJvdGF0aW9uLnJvdGF0ZShvcHRpb25zLnJvdGF0aW9uKTtcblx0XHRsZXQgdHJhbnNmb3JtYXRpb24gPSBNYXQ0eDQuTVVMVCh0aGlzLnRyYW5zbGF0aW9uLCB0aGlzLnNjYWxlLCB0aGlzLnJvdGF0aW9uKTtcblxuXHRcdC8vIFBhc3MgdGhlIHRyYW5zbGF0aW9uIG1hdHJpeCB0byBvdXIgc2hhZGVyXG5cdFx0Y29uc3QgdV9UcmFuc2Zvcm0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X1RyYW5zZm9ybVwiKTtcblx0XHRnbC51bmlmb3JtTWF0cml4NGZ2KHVfVHJhbnNmb3JtLCBmYWxzZSwgdHJhbnNmb3JtYXRpb24udG9BcnJheSgpKTtcblxuXHRcdC8vIERyYXcgdGhlIHF1YWRcblx0XHRnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgcmVuZGVyaW5nIHNwYWNlIGFsd2F5cyBoYXMgdG8gYmUgYSBzcXVhcmUsIHNvIG1ha2Ugc3VyZSBpdHMgc3F1YXJlIHcuci50IHRvIHRoZSBsYXJnZXN0IGRpbWVuc2lvblxuXHQgKiBAcGFyYW0gdyBUaGUgd2lkdGggb2YgdGhlIHF1YWQgaW4gcGl4ZWxzXG5cdCAqIEBwYXJhbSBoIFRoZSBoZWlnaHQgb2YgdGhlIHF1YWQgaW4gcGl4ZWxzXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHRoZSB2ZXJ0aWNlcyBvZiB0aGUgcXVhZFxuXHQgKi9cblx0Z2V0VmVydGljZXModzogbnVtYmVyLCBoOiBudW1iZXIpOiBGbG9hdDMyQXJyYXkge1xuXHRcdGxldCB4LCB5O1xuXG5cdFx0aWYoaCA+IHcpe1xuXHRcdFx0eSA9IDAuNTtcblx0XHRcdHggPSB3LygyKmgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR4ID0gMC41O1xuXHRcdFx0eSA9IGgvKDIqdyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xuXHRcdFx0LXgsICB5LFxuXHRcdFx0LXgsIC15LFxuXHRcdFx0IHgsICB5LFxuXHRcdFx0IHgsIC15XG5cdFx0XSk7XG5cdH1cblxuXHRnZXRPcHRpb25zKHJlY3Q6IExhYmVsKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG5cdFx0bGV0IG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7XG5cdFx0XHRwb3NpdGlvbjogcmVjdC5wb3NpdGlvbixcblx0XHRcdGJhY2tncm91bmRDb2xvcjogcmVjdC5jYWxjdWxhdGVCYWNrZ3JvdW5kQ29sb3IoKSxcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiByZWN0LmNhbGN1bGF0ZUJvcmRlckNvbG9yKCksXG4gICAgICAgICAgICBib3JkZXJXaWR0aDogcmVjdC5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogcmVjdC5ib3JkZXJSYWRpdXMsXG5cdFx0XHRzaXplOiByZWN0LnNpemUsXG5cdFx0XHRyb3RhdGlvbjogcmVjdC5yb3RhdGlvblxuXHRcdH1cblxuXHRcdHJldHVybiBvcHRpb25zO1xuXHR9XG59IiwiaW1wb3J0IERlYnVnIGZyb20gXCIuLi8uLi8uLi9EZWJ1Zy9EZWJ1Z1wiO1xuaW1wb3J0IFBvaW50IGZyb20gXCIuLi8uLi8uLi9Ob2Rlcy9HcmFwaGljcy9Qb2ludFwiO1xuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xuaW1wb3J0IFJlbmRlcmluZ1V0aWxzIGZyb20gXCIuLi8uLi8uLi9VdGlscy9SZW5kZXJpbmdVdGlsc1wiO1xuaW1wb3J0IFNoYWRlclR5cGUgZnJvbSBcIi4uL1NoYWRlclR5cGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9pbnRTaGFkZXJUeXBlIGV4dGVuZHMgU2hhZGVyVHlwZSB7XG5cblx0cHJvdGVjdGVkIGJ1ZmZlck9iamVjdEtleTogc3RyaW5nO1xuXG5cdGNvbnN0cnVjdG9yKHByb2dyYW1LZXk6IHN0cmluZyl7XG5cdFx0c3VwZXIocHJvZ3JhbUtleSk7XG5cdH1cblxuXHRpbml0QnVmZmVyT2JqZWN0KCk6IHZvaWQge1xuXHRcdHRoaXMuYnVmZmVyT2JqZWN0S2V5ID0gXCJwb2ludFwiO1xuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZUJ1ZmZlcih0aGlzLmJ1ZmZlck9iamVjdEtleSk7XG5cdH1cblxuXHRyZW5kZXIoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuXHRcdGxldCBwb3NpdGlvbiA9IFJlbmRlcmluZ1V0aWxzLnRvV2ViR0xDb29yZHMob3B0aW9ucy5wb3NpdGlvbiwgb3B0aW9ucy5vcmlnaW4sIG9wdGlvbnMud29ybGRTaXplKTtcblx0XHRsZXQgY29sb3IgPSBSZW5kZXJpbmdVdGlscy50b1dlYkdMQ29sb3Iob3B0aW9ucy5jb2xvcik7XG5cblx0XHRjb25zdCBwcm9ncmFtID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0U2hhZGVyUHJvZ3JhbSh0aGlzLnByb2dyYW1LZXkpO1xuXHRcdGNvbnN0IGJ1ZmZlciA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldEJ1ZmZlcih0aGlzLmJ1ZmZlck9iamVjdEtleSk7XG5cblx0XHRnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuXG5cdFx0Y29uc3QgdmVydGV4RGF0YSA9IHBvc2l0aW9uO1xuXG5cdFx0Y29uc3QgRlNJWkUgPSB2ZXJ0ZXhEYXRhLkJZVEVTX1BFUl9FTEVNRU5UO1xuXG5cdFx0Ly8gQmluZCB0aGUgYnVmZmVyXG5cdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG5cdFx0Z2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHZlcnRleERhdGEsIGdsLlNUQVRJQ19EUkFXKTtcblxuXHRcdC8vIEF0dHJpYnV0ZXNcblx0XHRjb25zdCBhX1Bvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgXCJhX1Bvc2l0aW9uXCIpO1xuXHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYV9Qb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogRlNJWkUsIDAgKiBGU0laRSk7XG5cdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYV9Qb3NpdGlvbik7XG5cblx0XHQvLyBVbmlmb3Jtc1xuXHRcdGNvbnN0IHVfQ29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X0NvbG9yXCIpO1xuXHRcdGdsLnVuaWZvcm00ZnYodV9Db2xvciwgY29sb3IpO1xuXG5cdFx0Y29uc3QgdV9Qb2ludFNpemUgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X1BvaW50U2l6ZVwiKTtcblx0XHRnbC51bmlmb3JtMWYodV9Qb2ludFNpemUsIG9wdGlvbnMucG9pbnRTaXplKTtcblxuXHRcdGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCAwLCAxKTtcblx0fVxuXG5cdGdldE9wdGlvbnMocG9pbnQ6IFBvaW50KTogUmVjb3JkPHN0cmluZywgYW55PiB7XG5cdFx0bGV0IG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7XG5cdFx0XHRwb3NpdGlvbjogcG9pbnQucG9zaXRpb24sXG5cdFx0XHRjb2xvcjogcG9pbnQuY29sb3IsXG5cdFx0XHRwb2ludFNpemU6IHBvaW50LnNpemUsXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9wdGlvbnM7XG5cdH1cbn0iLCJpbXBvcnQgTWF0NHg0IGZyb20gXCIuLi8uLi8uLi9EYXRhVHlwZXMvTWF0NHg0XCI7XG5pbXBvcnQgU2hhZGVyVHlwZSBmcm9tIFwiLi4vU2hhZGVyVHlwZVwiO1xuXG4vKiogUmVwcmVzZW50cyBhbnkgV2ViR0wgb2JqZWN0cyB0aGF0IGhhdmUgYSBxdWFkIG1lc2ggKGkuZS4gYSByZWN0YW5ndWxhciBnYW1lIG9iamVjdCBjb21wb3NlZCBvZiBvbmx5IHR3byB0cmlhbmdsZXMpICovXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBRdWFkU2hhZGVyVHlwZSBleHRlbmRzIFNoYWRlclR5cGUge1xuXHQvKiogVGhlIGtleSB0byB0aGUgYnVmZmVyIG9iamVjdCBmb3IgdGhpcyBzaGFkZXIgKi9cblx0cHJvdGVjdGVkIGJ1ZmZlck9iamVjdEtleTogc3RyaW5nO1xuXG5cdC8qKiBUaGUgc2NhbGUgbWF0cmljICovXG5cdHByb3RlY3RlZCBzY2FsZTogTWF0NHg0O1xuXG5cdC8qKiBUaGUgcm90YXRpb24gbWF0cml4ICovXG5cdHByb3RlY3RlZCByb3RhdGlvbjogTWF0NHg0O1xuXG5cdC8qKiBUaGUgdHJhbnNsYXRpb24gbWF0cml4ICovXG5cdHByb3RlY3RlZCB0cmFuc2xhdGlvbjogTWF0NHg0O1xuXG5cdGNvbnN0cnVjdG9yKHByb2dyYW1LZXk6IHN0cmluZyl7XG5cdFx0c3VwZXIocHJvZ3JhbUtleSk7XG5cblx0XHR0aGlzLnNjYWxlID0gTWF0NHg0LklERU5USVRZO1xuXHRcdHRoaXMucm90YXRpb24gPSBNYXQ0eDQuSURFTlRJVFk7XG5cdFx0dGhpcy50cmFuc2xhdGlvbiA9IE1hdDR4NC5JREVOVElUWTtcblx0fVxufSIsImltcG9ydCBNYXQ0eDQgZnJvbSBcIi4uLy4uLy4uL0RhdGFUeXBlcy9NYXQ0eDRcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IFJlY3QgZnJvbSBcIi4uLy4uLy4uL05vZGVzL0dyYXBoaWNzL1JlY3RcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBRdWFkU2hhZGVyVHlwZSBmcm9tIFwiLi9RdWFkU2hhZGVyVHlwZVwiO1xuXG4vKiogKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlY3RTaGFkZXJUeXBlIGV4dGVuZHMgUXVhZFNoYWRlclR5cGUge1xuXG5cdGNvbnN0cnVjdG9yKHByb2dyYW1LZXk6IHN0cmluZyl7XG5cdFx0c3VwZXIocHJvZ3JhbUtleSk7XG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcblx0fVxuXG5cdGluaXRCdWZmZXJPYmplY3QoKTogdm9pZCB7XG5cdFx0dGhpcy5idWZmZXJPYmplY3RLZXkgPSBcInJlY3RcIjtcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlci5jcmVhdGVCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xuXHR9XG5cblx0cmVuZGVyKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcblx0XHRjb25zdCBjb2xvciA9IG9wdGlvbnMuY29sb3IudG9XZWJHTCgpO1xuXG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldFNoYWRlclByb2dyYW0odGhpcy5wcm9ncmFtS2V5KTtcblx0XHRjb25zdCBidWZmZXIgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xuXG5cdFx0Z2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcblxuXHRcdGNvbnN0IHZlcnRleERhdGEgPSB0aGlzLmdldFZlcnRpY2VzKG9wdGlvbnMuc2l6ZS54LCBvcHRpb25zLnNpemUueSk7XG5cblx0XHRjb25zdCBGU0laRSA9IHZlcnRleERhdGEuQllURVNfUEVSX0VMRU1FTlQ7XG5cblx0XHQvLyBCaW5kIHRoZSBidWZmZXJcblx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcblx0XHRnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4RGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xuXG5cdFx0Ly8gQXR0cmlidXRlc1xuXHRcdGNvbnN0IGFfUG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBcImFfUG9zaXRpb25cIik7XG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlcihhX1Bvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiBGU0laRSwgMCAqIEZTSVpFKTtcblx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhX1Bvc2l0aW9uKTtcblxuXHRcdC8vIFVuaWZvcm1zXG5cdFx0Y29uc3QgdV9Db2xvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfQ29sb3JcIik7XG5cdFx0Z2wudW5pZm9ybTRmdih1X0NvbG9yLCBjb2xvcik7XG5cblx0XHQvLyBHZXQgdHJhbnNmb3JtYXRpb24gbWF0cml4XG5cdFx0Ly8gV2Ugd2FudCBhIHNxdWFyZSBmb3Igb3VyIHJlbmRlcmluZyBzcGFjZSwgc28gZ2V0IHRoZSBtYXhpbXVtIGRpbWVuc2lvbiBvZiBvdXIgcXVhZFxuXHRcdGxldCBtYXhEaW1lbnNpb24gPSBNYXRoLm1heChvcHRpb25zLnNpemUueCwgb3B0aW9ucy5zaXplLnkpO1xuXG5cdFx0Ly8gVGhlIHNpemUgb2YgdGhlIHJlbmRlcmluZyBzcGFjZSB3aWxsIGJlIGEgc3F1YXJlIHdpdGggdGhpcyBtYXhpbXVtIGRpbWVuc2lvblxuXHRcdGxldCBzaXplID0gbmV3IFZlYzIobWF4RGltZW5zaW9uLCBtYXhEaW1lbnNpb24pLnNjYWxlKDIvb3B0aW9ucy53b3JsZFNpemUueCwgMi9vcHRpb25zLndvcmxkU2l6ZS55KTtcblxuXHRcdC8vIENlbnRlciBvdXIgdHJhbnNsYXRpb25zIGFyb3VuZCAoMCwgMClcblx0XHRjb25zdCB0cmFuc2xhdGVYID0gKG9wdGlvbnMucG9zaXRpb24ueCAtIG9wdGlvbnMub3JpZ2luLnggLSBvcHRpb25zLndvcmxkU2l6ZS54LzIpL21heERpbWVuc2lvbjtcblx0XHRjb25zdCB0cmFuc2xhdGVZID0gLShvcHRpb25zLnBvc2l0aW9uLnkgLSBvcHRpb25zLm9yaWdpbi55IC0gb3B0aW9ucy53b3JsZFNpemUueS8yKS9tYXhEaW1lbnNpb247XG5cblx0XHQvLyBDcmVhdGUgb3VyIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuXHRcdHRoaXMudHJhbnNsYXRpb24udHJhbnNsYXRlKG5ldyBGbG9hdDMyQXJyYXkoW3RyYW5zbGF0ZVgsIHRyYW5zbGF0ZVldKSk7XG5cdFx0dGhpcy5zY2FsZS5zY2FsZShzaXplKTtcblx0XHR0aGlzLnJvdGF0aW9uLnJvdGF0ZShvcHRpb25zLnJvdGF0aW9uKTtcblx0XHRsZXQgdHJhbnNmb3JtYXRpb24gPSBNYXQ0eDQuTVVMVCh0aGlzLnRyYW5zbGF0aW9uLCB0aGlzLnNjYWxlLCB0aGlzLnJvdGF0aW9uKTtcblxuXHRcdC8vIFBhc3MgdGhlIHRyYW5zbGF0aW9uIG1hdHJpeCB0byBvdXIgc2hhZGVyXG5cdFx0Y29uc3QgdV9UcmFuc2Zvcm0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X1RyYW5zZm9ybVwiKTtcblx0XHRnbC51bmlmb3JtTWF0cml4NGZ2KHVfVHJhbnNmb3JtLCBmYWxzZSwgdHJhbnNmb3JtYXRpb24udG9BcnJheSgpKTtcblxuXHRcdC8vIERyYXcgdGhlIHF1YWRcblx0XHRnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcblx0fVxuXG5cblx0Lypcblx0XHRTbyBhcyBpdCB0dXJucyBvdXQsIFdlYkdMIGhhcyBhbiBpc3N1ZSB3aXRoIG5vbi1zcXVhcmUgcXVhZHMuXG5cdFx0SXQgZG9lc24ndCBsaWtlIHdoZW4geW91IGRvbid0IGhhdmUgYSAxLTEgc2NhbGUsIGFuZCByb3RhdGlvbnMgYXJlIGVudGlyZWx5IG1lc3NlZCB1cCBpZiB0aGlzIGlzIG5vdCB0aGUgY2FzZS5cblx0XHRUbyBzb2x2ZSB0aGlzLCBJIHVzZWQgdGhlIHNjYWxlIG9mIHRoZSBMQVJHRVNUIGRpbWVuc2lvbiBvZiB0aGUgcXVhZCB0byBtYWtlIGEgc3F1YXJlLCB0aGVuIGFkanVzdGVkIHRoZSB2ZXJ0ZXggY29vcmRpbmF0ZXMgaW5zaWRlIG9mIHRoYXQuXG5cdFx0QSBkaWFncmFtIG9mIHRoZSBzb2x1dGlvbiBmb2xsb3dzLlxuXG5cdFx0VGhlcmUgaXMgYSBib3VuZGluZyBzcXVhcmUgZm9yIHRoZSBxdWFkIHdpdGggZGltZW5zaW9ucyBoeGggKGluIHRoaXMgY2FzZSwgc2luY2UgaGVpZ2h0IGlzIHRoZSBsYXJnZXN0IGRpbWVuc2lvbikuXG5cdFx0VGhlIG9mZnNldCBpbiB0aGUgdmVydGljYWwgZGlyZWN0aW9uIGlzIHRoZXJlZm9yZSAwLjUsIGFzIGl0IGlzIG5vcm1hbGx5LlxuXHRcdEhvd2V2ZXIsIHRoZSBvZmZzZXQgaW4gdGhlIGhvcml6b250YWwgZGlyZWN0aW9uIGlzIG5vdCBzbyBzdHJhaWdodGZvcndhcmQsIGJ1dCBpc24ndCBjb25jZXB0dWFsbHkgaGFyZC5cblx0XHRBbGwgd2UgcmVhbGx5IGhhdmUgdG8gZG8gaXMgYSByYW5nZSBjaGFuZ2UgZnJvbSBbMCwgaGVpZ2h0LzJdIHRvIFswLCAwLjVdLCB3aGVyZSBvdXIgdmFsdWUgaXMgdCA9IHdpZHRoLzIsIGFuZCAwIDw9IHQgPD0gaGVpZ2h0LzIuXG5cblx0XHRTbyBub3cgd2UgaGF2ZSBvdXIgcmVjdCwgaW4gYSBzcGFjZSBzY2FsZWQgd2l0aCByZXNwZWN0IHRvIHRoZSBsYXJnZXN0IGRpbWVuc2lvbi5cblx0XHRSb3RhdGlvbnMgd29yayBhcyB5b3Ugd291bGQgZXhwZWN0LCBldmVuIGZvciBsb25nIHJlY3RhbmdsZXMuXG5cblx0XHRcdFx0XHQwLjVcblx0XHRcdF9fIF9fIF9fIF9fIF9fIF9fIF9fXG5cdFx0XHR8XHR8ODg4ODg4ODg4ODh8XHR8XG5cdFx0XHR8XHR8ODg4ODg4ODg4ODh8XHR8XG5cdFx0XHR8XHR8ODg4ODg4ODg4ODh8XHR8XG5cdFx0LTAuNXxfIF98ODg4ODg4ODg4ODh8XyBffDAuNVxuXHRcdFx0fFx0fDg4ODg4ODg4ODg4fFx0fFxuXHRcdFx0fFx0fDg4ODg4ODg4ODg4fFx0fFxuXHRcdFx0fFx0fDg4ODg4ODg4ODg4fFx0fFxuXHQgIFx0XHR8X19ffDg4ODg4ODg4ODg4fF9fX3xcblx0XHRcdCAgXHRcdC0wLjVcblxuXHRcdFRoZSBnZXRWZXJ0aWNlcyBmdW5jdGlvbiBiZWxvdyBkb2VzIGFzIGRlc2NyaWJlZCwgYW5kIGNvbnZlcnRzIHRoZSByYW5nZVxuXHQqL1xuXHQvKipcblx0ICogVGhlIHJlbmRlcmluZyBzcGFjZSBhbHdheXMgaGFzIHRvIGJlIGEgc3F1YXJlLCBzbyBtYWtlIHN1cmUgaXRzIHNxdWFyZSB3LnIudCB0byB0aGUgbGFyZ2VzdCBkaW1lbnNpb25cblx0ICogQHBhcmFtIHcgVGhlIHdpZHRoIG9mIHRoZSBxdWFkIGluIHBpeGVsc1xuXHQgKiBAcGFyYW0gaCBUaGUgaGVpZ2h0IG9mIHRoZSBxdWFkIGluIHBpeGVsc1xuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB0aGUgdmVydGljZXMgb2YgdGhlIHF1YWRcblx0ICovXG5cdGdldFZlcnRpY2VzKHc6IG51bWJlciwgaDogbnVtYmVyKTogRmxvYXQzMkFycmF5IHtcblx0XHRsZXQgeCwgeTtcblxuXHRcdGlmKGggPiB3KXtcblx0XHRcdHkgPSAwLjU7XG5cdFx0XHR4ID0gdy8oMipoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0eCA9IDAuNTtcblx0XHRcdHkgPSBoLygyKncpO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFtcblx0XHRcdC14LCAgeSxcblx0XHRcdC14LCAteSxcblx0XHRcdCB4LCAgeSxcblx0XHRcdCB4LCAteVxuXHRcdF0pO1xuXHR9XG5cblx0Z2V0T3B0aW9ucyhyZWN0OiBSZWN0KTogUmVjb3JkPHN0cmluZywgYW55PiB7XG5cdFx0bGV0IG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7XG5cdFx0XHRwb3NpdGlvbjogcmVjdC5wb3NpdGlvbixcblx0XHRcdGNvbG9yOiByZWN0LmNvbG9yLFxuXHRcdFx0c2l6ZTogcmVjdC5zaXplLFxuXHRcdFx0cm90YXRpb246IHJlY3Qucm90YXRpb25cblx0XHR9XG5cblx0XHRyZXR1cm4gb3B0aW9ucztcblx0fVxufSIsImltcG9ydCBNYXQ0eDQgZnJvbSBcIi4uLy4uLy4uL0RhdGFUeXBlcy9NYXQ0eDRcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IERlYnVnIGZyb20gXCIuLi8uLi8uLi9EZWJ1Zy9EZWJ1Z1wiO1xuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi8uLi8uLi9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi8uLi8uLi9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xuaW1wb3J0IFF1YWRTaGFkZXJUeXBlIGZyb20gXCIuL1F1YWRTaGFkZXJUeXBlXCI7XG5cbi8qKiBBIHNoYWRlciBmb3Igc3ByaXRlcyBhbmQgYW5pbWF0ZWQgc3ByaXRlcyAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3ByaXRlU2hhZGVyVHlwZSBleHRlbmRzIFF1YWRTaGFkZXJUeXBlIHtcblx0Y29uc3RydWN0b3IocHJvZ3JhbUtleTogc3RyaW5nKXtcblx0XHRzdXBlcihwcm9ncmFtS2V5KTtcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuXHR9XG5cblx0aW5pdEJ1ZmZlck9iamVjdCgpOiB2b2lkIHtcblx0XHR0aGlzLmJ1ZmZlck9iamVjdEtleSA9IFwic3ByaXRlXCI7XG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlQnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcblx0fVxuXG5cdHJlbmRlcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldFNoYWRlclByb2dyYW0odGhpcy5wcm9ncmFtS2V5KTtcblx0XHRjb25zdCBidWZmZXIgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xuXHRcdGNvbnN0IHRleHR1cmUgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRUZXh0dXJlKG9wdGlvbnMuaW1hZ2VLZXkpO1xuXG5cdFx0Z2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcblxuXHRcdGNvbnN0IHZlcnRleERhdGEgPSB0aGlzLmdldFZlcnRpY2VzKG9wdGlvbnMuc2l6ZS54LCBvcHRpb25zLnNpemUueSwgb3B0aW9ucy5zY2FsZSk7XG5cblx0XHRjb25zdCBGU0laRSA9IHZlcnRleERhdGEuQllURVNfUEVSX0VMRU1FTlQ7XG5cblx0XHQvLyBCaW5kIHRoZSBidWZmZXJcblx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcblx0XHRnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4RGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xuXG5cdFx0Ly8gQXR0cmlidXRlc1xuXHRcdGNvbnN0IGFfUG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBcImFfUG9zaXRpb25cIik7XG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlcihhX1Bvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDQgKiBGU0laRSwgMCAqIEZTSVpFKTtcblx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhX1Bvc2l0aW9uKTtcblxuXHRcdGNvbnN0IGFfVGV4Q29vcmQgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBcImFfVGV4Q29vcmRcIik7XG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlcihhX1RleENvb3JkLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDQgKiBGU0laRSwgMipGU0laRSk7XG5cdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYV9UZXhDb29yZCk7XG5cblx0XHQvLyBVbmlmb3Jtc1xuXHRcdC8vIEdldCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcblx0XHQvLyBXZSB3YW50IGEgc3F1YXJlIGZvciBvdXIgcmVuZGVyaW5nIHNwYWNlLCBzbyBnZXQgdGhlIG1heGltdW0gZGltZW5zaW9uIG9mIG91ciBxdWFkXG5cdFx0bGV0IG1heERpbWVuc2lvbiA9IE1hdGgubWF4KG9wdGlvbnMuc2l6ZS54LCBvcHRpb25zLnNpemUueSk7XG5cblx0XHQvLyBUaGUgc2l6ZSBvZiB0aGUgcmVuZGVyaW5nIHNwYWNlIHdpbGwgYmUgYSBzcXVhcmUgd2l0aCB0aGlzIG1heGltdW0gZGltZW5zaW9uXG5cdFx0bGV0IHNpemUgPSBuZXcgVmVjMihtYXhEaW1lbnNpb24sIG1heERpbWVuc2lvbikuc2NhbGUoMi9vcHRpb25zLndvcmxkU2l6ZS54LCAyL29wdGlvbnMud29ybGRTaXplLnkpO1xuXG5cdFx0Ly8gQ2VudGVyIG91ciB0cmFuc2xhdGlvbnMgYXJvdW5kICgwLCAwKVxuXHRcdGNvbnN0IHRyYW5zbGF0ZVggPSAob3B0aW9ucy5wb3NpdGlvbi54IC0gb3B0aW9ucy5vcmlnaW4ueCAtIG9wdGlvbnMud29ybGRTaXplLngvMikvbWF4RGltZW5zaW9uO1xuXHRcdGNvbnN0IHRyYW5zbGF0ZVkgPSAtKG9wdGlvbnMucG9zaXRpb24ueSAtIG9wdGlvbnMub3JpZ2luLnkgLSBvcHRpb25zLndvcmxkU2l6ZS55LzIpL21heERpbWVuc2lvbjtcblxuXHRcdC8vIENyZWF0ZSBvdXIgdHJhbnNmb3JtYXRpb24gbWF0cml4XG5cdFx0dGhpcy50cmFuc2xhdGlvbi50cmFuc2xhdGUobmV3IEZsb2F0MzJBcnJheShbdHJhbnNsYXRlWCwgdHJhbnNsYXRlWV0pKTtcblx0XHR0aGlzLnNjYWxlLnNjYWxlKHNpemUpO1xuXHRcdHRoaXMucm90YXRpb24ucm90YXRlKG9wdGlvbnMucm90YXRpb24pO1xuXHRcdGxldCB0cmFuc2Zvcm1hdGlvbiA9IE1hdDR4NC5NVUxUKHRoaXMudHJhbnNsYXRpb24sIHRoaXMuc2NhbGUsIHRoaXMucm90YXRpb24pO1xuXG5cdFx0Ly8gUGFzcyB0aGUgdHJhbnNsYXRpb24gbWF0cml4IHRvIG91ciBzaGFkZXJcblx0XHRjb25zdCB1X1RyYW5zZm9ybSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfVHJhbnNmb3JtXCIpO1xuXHRcdGdsLnVuaWZvcm1NYXRyaXg0ZnYodV9UcmFuc2Zvcm0sIGZhbHNlLCB0cmFuc2Zvcm1hdGlvbi50b0FycmF5KCkpO1xuXG5cdFx0Ly8gU2V0IHVwIG91ciBzYW1wbGVyIHdpdGggb3VyIGFzc2lnbmVkIHRleHR1cmUgdW5pdFxuXHRcdGNvbnN0IHVfU2FtcGxlciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfU2FtcGxlclwiKTtcblx0XHRnbC51bmlmb3JtMWkodV9TYW1wbGVyLCB0ZXh0dXJlKTtcblxuXHRcdC8vIFBhc3MgaW4gdGV4U2hpZnRcblx0XHRjb25zdCB1X3RleFNoaWZ0ID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV90ZXhTaGlmdFwiKTtcblx0XHRnbC51bmlmb3JtMmZ2KHVfdGV4U2hpZnQsIG9wdGlvbnMudGV4U2hpZnQpO1xuXG5cdFx0Ly8gUGFzcyBpbiB0ZXhTY2FsZVxuXHRcdGNvbnN0IHVfdGV4U2NhbGUgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X3RleFNjYWxlXCIpO1xuXHRcdGdsLnVuaWZvcm0yZnYodV90ZXhTY2FsZSwgb3B0aW9ucy50ZXhTY2FsZSk7XG5cblx0XHQvLyBEcmF3IHRoZSBxdWFkXG5cdFx0Z2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIHJlbmRlcmluZyBzcGFjZSBhbHdheXMgaGFzIHRvIGJlIGEgc3F1YXJlLCBzbyBtYWtlIHN1cmUgaXRzIHNxdWFyZSB3LnIudCB0byB0aGUgbGFyZ2VzdCBkaW1lbnNpb25cblx0ICogQHBhcmFtIHcgVGhlIHdpZHRoIG9mIHRoZSBxdWFkIGluIHBpeGVsc1xuXHQgKiBAcGFyYW0gaCBUaGUgaGVpZ2h0IG9mIHRoZSBxdWFkIGluIHBpeGVsc1xuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB0aGUgdmVydGljZXMgb2YgdGhlIHF1YWRcblx0ICovXG5cdGdldFZlcnRpY2VzKHc6IG51bWJlciwgaDogbnVtYmVyLCBzY2FsZTogRmxvYXQzMkFycmF5KTogRmxvYXQzMkFycmF5IHtcblx0XHRsZXQgeCwgeTtcblxuXHRcdGlmKGggPiB3KXtcblx0XHRcdHkgPSAwLjU7XG5cdFx0XHR4ID0gdy8oMipoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0eCA9IDAuNTtcblx0XHRcdHkgPSBoLygyKncpO1xuXHRcdH1cblxuXHRcdC8vIFNjYWxlIHRoZSByZW5kZXJpbmcgc3BhY2UgaWYgbmVlZGVkXG5cdFx0eCAqPSBzY2FsZVswXTtcblx0XHR5ICo9IHNjYWxlWzFdO1xuXG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xuXHRcdFx0LXgsICB5LCAwLjAsIDAuMCxcblx0XHRcdC14LCAteSwgMC4wLCAxLjAsXG5cdFx0XHQgeCwgIHksIDEuMCwgMC4wLFxuXHRcdFx0IHgsIC15LCAxLjAsIDEuMFxuXHRcdF0pO1xuXHR9XG5cblx0Z2V0T3B0aW9ucyhzcHJpdGU6IFNwcml0ZSk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuXHRcdGxldCB0ZXhTaGlmdDtcblx0XHRsZXQgdGV4U2NhbGU7XG5cblx0XHRpZihzcHJpdGUgaW5zdGFuY2VvZiBBbmltYXRlZFNwcml0ZSl7XG5cdFx0XHRsZXQgYW5pbWF0aW9uSW5kZXggPSBzcHJpdGUuYW5pbWF0aW9uLmdldEluZGV4QW5kQWR2YW5jZUFuaW1hdGlvbigpO1xuXHRcdFx0bGV0IG9mZnNldCA9IHNwcml0ZS5nZXRBbmltYXRpb25PZmZzZXQoYW5pbWF0aW9uSW5kZXgpO1xuXHRcdFx0dGV4U2hpZnQgPSBuZXcgRmxvYXQzMkFycmF5KFtvZmZzZXQueCAvIChzcHJpdGUuY29scyAqIHNwcml0ZS5zaXplLngpLCBvZmZzZXQueSAvIChzcHJpdGUucm93cyAqIHNwcml0ZS5zaXplLnkpXSk7XG5cdFx0XHR0ZXhTY2FsZSA9IG5ldyBGbG9hdDMyQXJyYXkoWzEvKHNwcml0ZS5jb2xzKSwgMS8oc3ByaXRlLnJvd3MpXSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRleFNoaWZ0ID0gbmV3IEZsb2F0MzJBcnJheShbMCwgMF0pO1xuXHRcdFx0dGV4U2NhbGUgPSBuZXcgRmxvYXQzMkFycmF5KFsxLCAxXSk7XG5cdFx0fVxuXG5cdFx0bGV0IG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7XG5cdFx0XHRwb3NpdGlvbjogc3ByaXRlLnBvc2l0aW9uLFxuXHRcdFx0cm90YXRpb246IHNwcml0ZS5yb3RhdGlvbixcblx0XHRcdHNpemU6IHNwcml0ZS5zaXplLFxuXHRcdFx0c2NhbGU6IHNwcml0ZS5zY2FsZS50b0FycmF5KCksXG5cdFx0XHRpbWFnZUtleTogc3ByaXRlLmltYWdlSWQsXG5cdFx0XHR0ZXhTaGlmdCxcblx0XHRcdHRleFNjYWxlXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9wdGlvbnM7XG5cdH1cbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XG5pbXBvcnQgUXVldWUgZnJvbSBcIi4uL0RhdGFUeXBlcy9RdWV1ZVwiO1xuaW1wb3J0IHsgVGlsZWRUaWxlbWFwRGF0YSB9IGZyb20gXCIuLi9EYXRhVHlwZXMvVGlsZXNldHMvVGlsZWREYXRhXCI7XG5pbXBvcnQgU3RyaW5nVXRpbHMgZnJvbSBcIi4uL1V0aWxzL1N0cmluZ1V0aWxzXCI7XG5pbXBvcnQgQXVkaW9NYW5hZ2VyIGZyb20gXCIuLi9Tb3VuZC9BdWRpb01hbmFnZXJcIjtcbmltcG9ydCBTcHJpdGVzaGVldCBmcm9tIFwiLi4vRGF0YVR5cGVzL1Nwcml0ZXNoZWV0XCI7XG5pbXBvcnQgV2ViR0xQcm9ncmFtVHlwZSBmcm9tIFwiLi4vRGF0YVR5cGVzL1JlbmRlcmluZy9XZWJHTFByb2dyYW1UeXBlXCI7XG5cbi8qKlxuICogVGhlIHJlc291cmNlIG1hbmFnZXIgZm9yIHRoZSBnYW1lIGVuZ2luZS5cbiAqIFRoZSByZXNvdXJjZSBtYW5hZ2VyIGludGVyZmFjZXMgd2l0aCB0aGUgbG9hZGFibGUgYXNzZXRzIG9mIGEgZ2FtZSBzdWNoIGFzIGltYWdlcywgZGF0YSBmaWxlcyxcbiAqIGFuZCBzb3VuZHMsIHdoaWNoIGFyZSBhbGwgZm91bmQgaW4gdGhlIGRpc3QgZm9sZGVyLlxuICogVGhpcyBjbGFzcyBjb250cm9scyBsb2FkaW5nIGFuZCB1cGRhdGVzIHRoZSBAcmVmZXJlbmNlW1NjZW5lXSB3aXRoIHRoZSBsb2FkaW5nIHByb2dyZXNzLCBzbyB0aGF0IHRoZSBzY2VuZSBkb2VzIFxuICogbm90IHN0YXJ0IGJlZm9yZSBhbGwgbmVjZXNzYXJ5IGFzc2V0cyBhcmUgbG9hZGVkLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXNvdXJjZU1hbmFnZXIge1xuICAgIC8vIEluc3RhbmNlIGZvciB0aGUgc2luZ2xldG9uIGNsYXNzXG4gICAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IFJlc291cmNlTWFuYWdlcjtcbiAgICBcbiAgICAvLyBCb29sZWFucyB0byBrZWVwIHRyYWNrIG9mIHdoZXRoZXIgb3Igbm90IHRoZSBSZXNvdXJjZU1hbmFnZXIgaXMgY3VycmVudGx5IGxvYWRpbmcgc29tZXRoaW5nXG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IGFueSByZXNvdXJjZXMgYXJlIGxvYWRpbmcgKi9cbiAgICBwcml2YXRlIGxvYWRpbmc6IGJvb2xlYW47XG4gICAgLyoqIEEgYm9vbGVhbiB0byBpbmRpY2F0ZSB0aGF0IHRoZSBhc3NldHMganVzdCBmaW5pc2hlZCBsb2FkaW5nICovXG4gICAgcHJpdmF0ZSBqdXN0TG9hZGVkOiBib29sZWFuO1xuXG4gICAgLy8gRnVuY3Rpb25zIHRvIGRvIHNvbWV0aGluZyB3aGVuIGxvYWRpbmcgcHJvZ3Jlc3NlcyBvciBpcyBjb21wbGV0ZWQgc3VjaCBhcyByZW5kZXIgYSBsb2FkaW5nIHNjcmVlblxuICAgIC8qKiBBIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gbG9hZGluZyBwcm9ncmVzc2VzICovXG4gICAgcHVibGljIG9uTG9hZFByb2dyZXNzOiBGdW5jdGlvbjtcbiAgICAvKiogQSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIGxvYWRpbmcgY29tcGxldGVzICovXG4gICAgcHVibGljIG9uTG9hZENvbXBsZXRlOiBGdW5jdGlvbjtcblxuXG4gICAgLyoqIE51bWJlciB0byBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IGltYWdlcyBuZWVkIHRvIGJlIGxvYWRlZCovXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9pbWFnZXNMb2FkZWQ6IG51bWJlcjtcbiAgICAvKiogTnVtYmVyIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgaW1hZ2VzIGFyZSBsb2FkZWQgKi9cbiAgICBwcml2YXRlIGxvYWRvbmx5X2ltYWdlc1RvTG9hZDogbnVtYmVyO1xuICAgIC8qKiBUaGUgcXVldWUgb2YgaW1hZ2VzIHdlIG11c3QgbG9hZCAqL1xuICAgIHByaXZhdGUgbG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWU6IFF1ZXVlPEtleVBhdGhQYWlyPjtcbiAgICAvKiogQSBtYXAgb2YgdGhlIGltYWdlcyB0aGF0IGFyZSBjdXJyZW50bHkgbG9hZGVkIGFuZCBiZWluZyB1c2VkIGJ5IHRoZSBzY2VuZS4gVGhlIHJlZmVyZW5jZSB0byB0aGVzZSBpbWFnZXMgb25seSBleGlzdCBoZXJlIGZvciBlYXN5IGNsZWFudXAuICovXG4gICAgcHJpdmF0ZSBpbWFnZXM6IE1hcDxIVE1MSW1hZ2VFbGVtZW50PjtcblxuICAgIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSB0aWxlbWFwcyBuZWVkIHRvIGJlIGxvYWRlZCAqL1xuICAgIHByaXZhdGUgbG9hZG9ubHlfc3ByaXRlc2hlZXRzTG9hZGVkOiBudW1iZXI7XG4gICAgLyoqIE51bWJlciB0byBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IHRpbGVtYXBzIGFyZSBsb2FkZWQgKi9cbiAgICBwcml2YXRlIGxvYWRvbmx5X3Nwcml0ZXNoZWV0c1RvTG9hZDogbnVtYmVyO1xuICAgIC8qKiBUaGUgcXVldWUgb2YgdGlsZW1hcHMgd2UgbXVzdCBsb2FkICovXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9zcHJpdGVzaGVldExvYWRpbmdRdWV1ZTogUXVldWU8S2V5UGF0aFBhaXI+O1xuICAgIC8qKiBBIG1hcCBvZiB0aGUgdGlsZW1hcHMgdGhhdCBhcmUgY3VycmVudGx5IGxvYWRlZCBhbmQgKHByZXN1bWFibHkpIGJlaW5nIHVzZWQgYnkgdGhlIHNjZW5lICovXG4gICAgcHJpdmF0ZSBzcHJpdGVzaGVldHM6IE1hcDxTcHJpdGVzaGVldD47XG5cbiAgICAvKiogTnVtYmVyIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgdGlsZW1hcHMgbmVlZCB0byBiZSBsb2FkZWQgKi9cbiAgICBwcml2YXRlIGxvYWRvbmx5X3RpbGVtYXBzTG9hZGVkOiBudW1iZXI7XG4gICAgLyoqIE51bWJlciB0byBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IHRpbGVtYXBzIGFyZSBsb2FkZWQgKi9cbiAgICBwcml2YXRlIGxvYWRvbmx5X3RpbGVtYXBzVG9Mb2FkOiBudW1iZXI7XG4gICAgLyoqIFRoZSBxdWV1ZSBvZiB0aWxlbWFwcyB3ZSBtdXN0IGxvYWQgKi9cbiAgICBwcml2YXRlIGxvYWRvbmx5X3RpbGVtYXBMb2FkaW5nUXVldWU6IFF1ZXVlPEtleVBhdGhQYWlyPjtcbiAgICAvKiogQSBtYXAgb2YgdGhlIHRpbGVtYXBzIHRoYXQgYXJlIGN1cnJlbnRseSBsb2FkZWQgYW5kIChwcmVzdW1hYmx5KSBiZWluZyB1c2VkIGJ5IHRoZSBzY2VuZSAqL1xuICAgIHByaXZhdGUgdGlsZW1hcHM6IE1hcDxUaWxlZFRpbGVtYXBEYXRhPjtcblxuICAgIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSBzb3VuZHMgbmVlZCB0byBiZSBsb2FkZWQgKi9cbiAgICBwcml2YXRlIGxvYWRvbmx5X2F1ZGlvTG9hZGVkOiBudW1iZXI7XG4gICAgLyoqIE51bWJlciB0byBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IHNvdW5kcyBhcmUgbG9hZGVkICovXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9hdWRpb1RvTG9hZDogbnVtYmVyO1xuICAgIC8qKiBUaGUgcXVldWUgb2Ygc291bmRzIHdlIG11c3QgbG9hZCAqL1xuICAgIHByaXZhdGUgbG9hZG9ubHlfYXVkaW9Mb2FkaW5nUXVldWU6IFF1ZXVlPEtleVBhdGhQYWlyPjtcbiAgICAvKiogQSBtYXAgb2YgdGhlIHNvdW5kcyB0aGF0IGFyZSBjdXJyZW50bHkgbG9hZGVkIGFuZCAocHJlc3VtYWJseSkgYmVpbmcgdXNlZCBieSB0aGUgc2NlbmUgKi9cbiAgICBwcml2YXRlIGF1ZGlvQnVmZmVyczogTWFwPEF1ZGlvQnVmZmVyPjtcblxuICAgIC8qKiBUaGUgdG90YWwgbnVtYmVyIG9mIFwidHlwZXNcIiBvZiB0aGluZ3MgdGhhdCBuZWVkIHRvIGJlIGxvYWRlZCAoaS5lLiBpbWFnZXMgYW5kIHRpbGVtYXBzKSAqL1xuICAgIHByaXZhdGUgbG9hZG9ubHlfdHlwZXNUb0xvYWQ6IG51bWJlcjtcblxuICAgIHByaXZhdGUgbG9hZG9ubHlfanNvbkxvYWRlZDogbnVtYmVyO1xuICAgIHByaXZhdGUgbG9hZG9ubHlfanNvblRvTG9hZDogbnVtYmVyO1xuICAgIHByaXZhdGUgbG9hZG9ubHlfanNvbkxvYWRpbmdRdWV1ZTogUXVldWU8S2V5UGF0aFBhaXI+O1xuICAgIHByaXZhdGUganNvbk9iamVjdHM6IE1hcDxSZWNvcmQ8c3RyaW5nLCBhbnk+PjtcblxuICAgIC8qICMjIyMjIyMjIyMgSU5GT1JNQVRJT04gU1BFQ0lBTCBUTyBXRUJHTCAjIyMjIyMjIyMjICovXG4gICAgcHJpdmF0ZSBnbF9XZWJHTEFjdGl2ZTogYm9vbGVhbjtcblxuICAgIHByaXZhdGUgbG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNMb2FkZWQ6IG51bWJlcjtcbiAgICBwcml2YXRlIGxvYWRvbmx5X2dsX1NoYWRlclByb2dyYW1zVG9Mb2FkOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBsb2Fkb25seV9nbF9TaGFkZXJMb2FkaW5nUXVldWU6IFF1ZXVlPEtleVBhdGhfU2hhZGVyPjtcblxuICAgIHByaXZhdGUgZ2xfU2hhZGVyUHJvZ3JhbXM6IE1hcDxXZWJHTFByb2dyYW1UeXBlPjtcblxuICAgIHByaXZhdGUgZ2xfVGV4dHVyZXM6IE1hcDxudW1iZXI+O1xuICAgIHByaXZhdGUgZ2xfTmV4dFRleHR1cmVJRDogbnVtYmVyO1xuICAgIHByaXZhdGUgZ2xfQnVmZmVyczogTWFwPFdlYkdMQnVmZmVyPjsgXG5cbiAgICBwcml2YXRlIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG5cbiAgICAvKiAjIyMjIyMjIyMjIFVOTE9BRElORyBBTkQgRVhDTFVTSU9OIExJU1QgIyMjIyMjIyMjIyAqL1xuICAgIC8qKiBBIGxpc3Qgb2YgcmVzb3VyY2VzIHRoYXQgd2lsbCBiZSB1bmxvYWRlZCBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHNjZW5lICovXG4gICAgcHJpdmF0ZSByZXNvdXJjZXNUb1VubG9hZDogQXJyYXk8UmVzb3VyY2VSZWZlcmVuY2U+O1xuXG4gICAgLyoqIEEgbGlzdCBvZiByZXNvdXJjZXMgdG8ga2VlcCB1bnRpbCBmdXJ0aGVyIG5vdGljZSAqL1xuICAgIHByaXZhdGUgcmVzb3VyY2VzVG9LZWVwOiBBcnJheTxSZXNvdXJjZVJlZmVyZW5jZT47XG5cbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmp1c3RMb2FkZWQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlc0xvYWRlZCA9IDA7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VzVG9Mb2FkID0gMDtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9pbWFnZUxvYWRpbmdRdWV1ZSA9IG5ldyBRdWV1ZSgpO1xuICAgICAgICB0aGlzLmltYWdlcyA9IG5ldyBNYXAoKTtcblxuICAgICAgICB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c0xvYWRlZCA9IDA7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzVG9Mb2FkID0gMDtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldExvYWRpbmdRdWV1ZSA9IG5ldyBRdWV1ZSgpO1xuICAgICAgICB0aGlzLnNwcml0ZXNoZWV0cyA9IG5ldyBNYXAoKTtcblxuICAgICAgICB0aGlzLmxvYWRvbmx5X3RpbGVtYXBzTG9hZGVkID0gMDtcbiAgICAgICAgdGhpcy5sb2Fkb25seV90aWxlbWFwc1RvTG9hZCA9IDA7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfdGlsZW1hcExvYWRpbmdRdWV1ZSA9IG5ldyBRdWV1ZSgpO1xuICAgICAgICB0aGlzLnRpbGVtYXBzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkZWQgPSAwO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2F1ZGlvVG9Mb2FkID0gMDtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRpbmdRdWV1ZSA9IG5ldyBRdWV1ZSgpO1xuICAgICAgICB0aGlzLmF1ZGlvQnVmZmVycyA9IG5ldyBNYXAoKTtcblxuICAgICAgICB0aGlzLmxvYWRvbmx5X2pzb25Mb2FkZWQgPSAwO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2pzb25Ub0xvYWQgPSAwO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2pzb25Mb2FkaW5nUXVldWUgPSBuZXcgUXVldWUoKTtcbiAgICAgICAgdGhpcy5qc29uT2JqZWN0cyA9IG5ldyBNYXAoKTtcblxuICAgICAgICB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlclByb2dyYW1zTG9hZGVkID0gMDtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc1RvTG9hZCA9IDA7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyTG9hZGluZ1F1ZXVlID0gbmV3IFF1ZXVlKCk7XG5cbiAgICAgICAgdGhpcy5nbF9TaGFkZXJQcm9ncmFtcyA9IG5ldyBNYXAoKTtcblxuICAgICAgICB0aGlzLmdsX1RleHR1cmVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmdsX05leHRUZXh0dXJlSUQgPSAwO1xuICAgICAgICB0aGlzLmdsX0J1ZmZlcnMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgdGhpcy5yZXNvdXJjZXNUb1VubG9hZCA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLnJlc291cmNlc1RvS2VlcCA9IG5ldyBBcnJheSgpO1xuICAgIH07XG5cbiAgICAvKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIFNJTkdMRVRPTiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIHRoaXMgY2xhc3Mgb3IgYSBuZXcgaW5zdGFuY2UgaWYgbm9uZSBleGlzdFxuICAgICAqIEByZXR1cm5zIFRoZSByZXNvdXJjZSBtYW5hZ2VyXG4gICAgICovXG4gICAgc3RhdGljIGdldEluc3RhbmNlKCk6IFJlc291cmNlTWFuYWdlciB7XG4gICAgICAgIGlmKCF0aGlzLmluc3RhbmNlKXtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgUmVzb3VyY2VNYW5hZ2VyKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcbiAgICB9XG5cbiAgICAvKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIFBVQkxJQyBGVU5DVElPTiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjKi9cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZXMgb3IgZGVhY3RpdmF0ZXMgdGhlIHVzZSBvZiBXZWJHTFxuICAgICAqIEBwYXJhbSBmbGFnIFRydWUgaWYgV2ViR0wgc2hvdWxkIGJlIHVzZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqIEBwYXJhbSBnbCBUaGUgaW5zdGFuY2Ugb2YgdGhlIGdyYXBoaWNzIGNvbnRleHQsIGlmIGFwcGxpY2FibGVcbiAgICAgKi9cbiAgICBwdWJsaWMgdXNlV2ViR0woZmxhZzogYm9vbGVhbiwgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCk6IHZvaWQge1xuICAgICAgICB0aGlzLmdsX1dlYkdMQWN0aXZlID0gZmxhZztcblxuICAgICAgICBpZih0aGlzLmdsX1dlYkdMQWN0aXZlKXtcbiAgICAgICAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGFuIGltYWdlIGZyb20gZmlsZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBhc3NvY2lhdGUgdGhlIGxvYWRlZCBpbWFnZSB3aXRoXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gdGhlIGltYWdlIHRvIGxvYWRcbiAgICAgKi9cbiAgICBwdWJsaWMgaW1hZ2Uoa2V5OiBzdHJpbmcsIHBhdGg6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlLmVucXVldWUoe2tleToga2V5LCBwYXRoOiBwYXRofSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgdGhlIHJlc291cmNlIG1hbmFnZXIgdG8ga2VlcCB0aGlzIHJlc291cmNlXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSByZXNvdXJjZVxuICAgICAqL1xuICAgIHB1YmxpYyBrZWVwSW1hZ2Uoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5rZWVwUmVzb3VyY2Uoa2V5LCBSZXNvdXJjZVR5cGUuSU1BR0UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIGxvYWRlZCBpbWFnZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgbG9hZGVkIGltYWdlXG4gICAgICogQHJldHVybnMgVGhlIGltYWdlIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMga2V5XG4gICAgICovXG4gICAgcHVibGljIGdldEltYWdlKGtleTogc3RyaW5nKTogSFRNTEltYWdlRWxlbWVudCB7XG4gICAgICAgIGxldCBpbWFnZSA9IHRoaXMuaW1hZ2VzLmdldChrZXkpO1xuICAgICAgICBpZihpbWFnZSA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIHRocm93IGBUaGVyZSBpcyBubyBpbWFnZSBhc3NvY2lhdGVkIHdpdGgga2V5IFwiJHtrZXl9XCJgXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGEgc3ByaXRlc2hlZXQgZnJvbSBmaWxlXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGFzc29jaWF0ZSB0aGUgbG9hZGVkIHNwcml0ZXNoZWV0IHdpdGhcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUgc3ByaXRlc2hlZXQgdG8gbG9hZFxuICAgICAqL1xuICAgIHB1YmxpYyBzcHJpdGVzaGVldChrZXk6IHN0cmluZywgcGF0aDogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRMb2FkaW5nUXVldWUuZW5xdWV1ZSh7a2V5OiBrZXksIHBhdGg6IHBhdGh9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZWxscyB0aGUgcmVzb3VyY2UgbWFuYWdlciB0byBrZWVwIHRoaXMgcmVzb3VyY2VcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHJlc291cmNlXG4gICAgICovXG4gICAgcHVibGljIGtlZXBTcHJpdGVzaGVldChrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLmtlZXBSZXNvdXJjZShrZXksIFJlc291cmNlVHlwZS5TUFJJVEVTSEVFVCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbG9hZGVkIHNwcml0ZXNoZWV0XG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBzcHJpdGVzaGVldCB0byBsb2FkXG4gICAgICogQHJldHVybnMgVGhlIGxvYWRlZCBTcHJpdGVzaGVldFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRTcHJpdGVzaGVldChrZXk6IHN0cmluZyk6IFNwcml0ZXNoZWV0IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ByaXRlc2hlZXRzLmdldChrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGFuIGF1ZGlvIGZpbGVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGxvYWRlZCBhdWRpbyBmaWxlXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gdGhlIGF1ZGlvIGZpbGUgdG8gbG9hZFxuICAgICAqL1xuICAgIHB1YmxpYyBhdWRpbyhrZXk6IHN0cmluZywgcGF0aDogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkaW5nUXVldWUuZW5xdWV1ZSh7a2V5OiBrZXksIHBhdGg6IHBhdGh9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZWxscyB0aGUgcmVzb3VyY2UgbWFuYWdlciB0byBrZWVwIHRoaXMgcmVzb3VyY2VcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHJlc291cmNlXG4gICAgICovXG4gICAgIHB1YmxpYyBrZWVwQXVkaW8oa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5rZWVwUmVzb3VyY2Uoa2V5LCBSZXNvdXJjZVR5cGUuQVVESU8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIGxvYWRlZCBhdWRpbyBmaWxlXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBhdWRpbyBmaWxlIHRvIGxvYWRcbiAgICAgKiBAcmV0dXJucyBUaGUgQXVkaW9CdWZmZXIgY3JlYXRlZCBmcm9tIHRoZSBsb2FkZWQgYXVkaW8gZmxlXG4gICAgICovXG4gICAgcHVibGljIGdldEF1ZGlvKGtleTogc3RyaW5nKTogQXVkaW9CdWZmZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5hdWRpb0J1ZmZlcnMuZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZCBhIHRpbGVtYXAgZnJvbSBhIGpzb24gZmlsZS4gQXV0b21hdGljYWxseSBsb2FkcyByZWxhdGVkIGltYWdlc1xuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgbG9hZGVkIHRpbGVtYXBcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUgdGlsZW1hcCB0byBsb2FkXG4gICAgICovXG4gICAgcHVibGljIHRpbGVtYXAoa2V5OiBzdHJpbmcsIHBhdGg6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRvbmx5X3RpbGVtYXBMb2FkaW5nUXVldWUuZW5xdWV1ZSh7a2V5OiBrZXksIHBhdGg6IHBhdGh9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZWxscyB0aGUgcmVzb3VyY2UgbWFuYWdlciB0byBrZWVwIHRoaXMgcmVzb3VyY2VcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHJlc291cmNlXG4gICAgICovXG4gICAgIHB1YmxpYyBrZWVwVGlsZW1hcChrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLmtlZXBSZXNvdXJjZShrZXksIFJlc291cmNlVHlwZS5USUxFTUFQKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyZWl2ZXMgYSBsb2FkZWQgdGlsZW1hcFxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgbG9hZGVkIHRpbGVtYXBcbiAgICAgKiBAcmV0dXJucyBUaGUgdGlsZW1hcCBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5XG4gICAgICovXG4gICAgcHVibGljIGdldFRpbGVtYXAoa2V5OiBzdHJpbmcpOiBUaWxlZFRpbGVtYXBEYXRhIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZW1hcHMuZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYW4gb2JqZWN0IGZyb20gYSBqc29uIGZpbGUuXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBsb2FkZWQgb2JqZWN0XG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gdGhlIGpzb24gZmlsZSB0byBsb2FkXG4gICAgICovXG4gICAgcHVibGljIG9iamVjdChrZXk6IHN0cmluZywgcGF0aDogc3RyaW5nKXtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9qc29uTG9hZGluZ1F1ZXVlLmVucXVldWUoe2tleToga2V5LCBwYXRoOiBwYXRofSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgdGhlIHJlc291cmNlIG1hbmFnZXIgdG8ga2VlcCB0aGlzIHJlc291cmNlXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSByZXNvdXJjZVxuICAgICAqL1xuICAgICBwdWJsaWMga2VlcE9iamVjdChrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLmtlZXBSZXNvdXJjZShrZXksIFJlc291cmNlVHlwZS5KU09OKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyZWl2ZXMgYSBsb2FkZWQgb2JqZWN0XG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBsb2FkZWQgb2JqZWN0XG4gICAgICogQHJldHVybnMgVGhlIG9iamVjdCBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5XG4gICAgICovXG4gICAgcHVibGljIGdldE9iamVjdChrZXk6IHN0cmluZyl7XG4gICAgICAgIHJldHVybiB0aGlzLmpzb25PYmplY3RzLmdldChrZXkpO1xuICAgIH1cblxuICAgIC8qICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgTE9BRCBGVU5DVElPTiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjKi9cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhbGwgcmVzb3VyY2VzIGN1cnJlbnRseSBpbiB0aGUgcXVldWVcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNhbCB3aGVuIHRoZSByZXNvdXJjZXMgYXJlIGZpbmlzaGVkIGxvYWRpbmdcbiAgICAgKi9cbiAgICBsb2FkUmVzb3VyY2VzRnJvbVF1ZXVlKGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRvbmx5X3R5cGVzVG9Mb2FkID0gNTtcblxuICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuXG4gICAgICAgIC8vIExvYWQgZXZlcnl0aGluZyBpbiB0aGUgcXVldWVzLiBUaWxlbWFwcyBoYXZlIHRvIGNvbWUgYmVmb3JlIGltYWdlcyBiZWNhdXNlIHRoZXkgd2lsbCBhZGQgbmV3IGltYWdlcyB0byB0aGUgcXVldWVcbiAgICAgICAgdGhpcy5sb2FkVGlsZW1hcHNGcm9tUXVldWUoKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2FkZWQgVGlsZW1hcHNcIik7XG4gICAgICAgICAgICB0aGlzLmxvYWRTcHJpdGVzaGVldHNGcm9tUXVldWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTG9hZGVkIFNwcml0ZXNoZWV0c1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRJbWFnZXNGcm9tUXVldWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWRlZCBJbWFnZXNcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZEF1ZGlvRnJvbVF1ZXVlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTG9hZGVkIEF1ZGlvXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkT2JqZWN0c0Zyb21RdWV1ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2FkZWQgT2JqZWN0c1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmdsX1dlYkdMQWN0aXZlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nbF9Mb2FkU2hhZGVyc0Zyb21RdWV1ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWRlZCBTaGFkZXJzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5pc2hMb2FkaW5nKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5pc2hMb2FkaW5nKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGZpbmlzaExvYWRpbmcoY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIC8vIERvbmUgbG9hZGluZ1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5qdXN0TG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICAvKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIFVOTE9BRCBGVU5DVElPTiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjKi9cbiAgICBcbiAgICBwcml2YXRlIGtlZXBSZXNvdXJjZShrZXk6IHN0cmluZywgdHlwZTogUmVzb3VyY2VUeXBlKTogdm9pZCB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiS2VlcCByZXNvdXJjZS4uLlwiKTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMucmVzb3VyY2VzVG9VbmxvYWQubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgbGV0IHJlc291cmNlID0gdGhpcy5yZXNvdXJjZXNUb1VubG9hZFtpXTtcbiAgICAgICAgICAgIGlmKHJlc291cmNlLmtleSA9PT0ga2V5ICYmIHJlc291cmNlLnJlc291cmNlVHlwZSA9PT0gdHlwZSl7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJGb3VuZCByZXNvdXJjZSBcIiArIGtleSArIFwiIG9mIHR5cGUgXCIgKyB0eXBlICsgXCIuIEtlZXBpbmcuXCIpO1xuICAgICAgICAgICAgICAgIGxldCByZXNvdXJjZVRvTW92ZSA9IHRoaXMucmVzb3VyY2VzVG9VbmxvYWQuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb3VyY2VzVG9LZWVwLnB1c2goLi4ucmVzb3VyY2VUb01vdmUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHJlZmVyZW5jZXMgdG8gYWxsIHJlc291cmNlcyBpbiB0aGUgcmVzb3VyY2UgbWFuYWdlclxuICAgICAqL1xuICAgIHVubG9hZEFsbFJlc291cmNlcygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuanVzdExvYWRlZCA9IGZhbHNlO1xuXG4gICAgICAgIGZvcihsZXQgcmVzb3VyY2Ugb2YgdGhpcy5yZXNvdXJjZXNUb1VubG9hZCl7XG4gICAgICAgICAgICAvLyBVbmxvYWQgdGhlIHJlc291cmNlXG4gICAgICAgICAgICB0aGlzLnVubG9hZFJlc291cmNlKHJlc291cmNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgdW5sb2FkUmVzb3VyY2UocmVzb3VyY2U6IFJlc291cmNlUmVmZXJlbmNlKTogdm9pZCB7XG4gICAgICAgIC8vIERlbGV0ZSB0aGUgcmVzb3VyY2UgaXRzZWxmXG4gICAgICAgIHN3aXRjaChyZXNvdXJjZS5yZXNvdXJjZVR5cGUpe1xuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZVR5cGUuSU1BR0U6XG4gICAgICAgICAgICAgICAgdGhpcy5pbWFnZXMuZGVsZXRlKHJlc291cmNlLmtleSk7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5nbF9XZWJHTEFjdGl2ZSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2xfVGV4dHVyZXMuZGVsZXRlKHJlc291cmNlLmtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZVR5cGUuVElMRU1BUDpcbiAgICAgICAgICAgICAgICB0aGlzLnRpbGVtYXBzLmRlbGV0ZShyZXNvdXJjZS5rZXkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZVR5cGUuU1BSSVRFU0hFRVQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzaGVldHMuZGVsZXRlKHJlc291cmNlLmtleSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFJlc291cmNlVHlwZS5BVURJTzpcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvQnVmZmVycy5kZWxldGUocmVzb3VyY2Uua2V5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VUeXBlLkpTT046XG4gICAgICAgICAgICAgICAgdGhpcy5qc29uT2JqZWN0cy5kZWxldGUocmVzb3VyY2Uua2V5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8qY2FzZSBSZXNvdXJjZVR5cGUuU0hBREVSOlxuICAgICAgICAgICAgICAgIHRoaXMuZ2xfU2hhZGVyUHJvZ3JhbXMuZ2V0KHJlc291cmNlLmtleSkuZGVsZXRlKHRoaXMuZ2wpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2xfU2hhZGVyUHJvZ3JhbXMuZGVsZXRlKHJlc291cmNlLmtleSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7Ki9cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlbGV0ZSBhbnkgZGVwZW5kZW5jaWVzXG4gICAgICAgIGZvcihsZXQgZGVwZW5kZW5jeSBvZiByZXNvdXJjZS5kZXBlbmRlbmNpZXMpe1xuICAgICAgICAgICAgdGhpcy51bmxvYWRSZXNvdXJjZShkZXBlbmRlbmN5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgV09SSyBGVU5DVElPTlMgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyovXG4gICAgLyoqXG4gICAgICogTG9hZHMgYWxsIHRpbGVtYXBzIGN1cnJlbnRseSBpbiB0aGUgdGlsZW1hcCBsb2FkaW5nIHF1ZXVlXG4gICAgICogQHBhcmFtIG9uRmluaXNoTG9hZGluZyBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGxvYWRpbmcgaXMgY29tcGxldGVcbiAgICAgKi9cbiAgICBwcml2YXRlIGxvYWRUaWxlbWFwc0Zyb21RdWV1ZShvbkZpbmlzaExvYWRpbmc6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfdGlsZW1hcHNUb0xvYWQgPSB0aGlzLmxvYWRvbmx5X3RpbGVtYXBMb2FkaW5nUXVldWUuZ2V0U2l6ZSgpO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X3RpbGVtYXBzTG9hZGVkID0gMDtcblxuICAgICAgICAvLyBJZiBubyBpdGVtcyB0byBsb2FkLCB3ZSdyZSBmaW5pc2hlZFxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X3RpbGVtYXBzVG9Mb2FkID09PSAwKXtcbiAgICAgICAgICAgIG9uRmluaXNoTG9hZGluZygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUodGhpcy5sb2Fkb25seV90aWxlbWFwTG9hZGluZ1F1ZXVlLmhhc0l0ZW1zKCkpe1xuICAgICAgICAgICAgbGV0IHRpbGVtYXAgPSB0aGlzLmxvYWRvbmx5X3RpbGVtYXBMb2FkaW5nUXVldWUuZGVxdWV1ZSgpO1xuICAgICAgICAgICAgdGhpcy5sb2FkVGlsZW1hcCh0aWxlbWFwLmtleSwgdGlsZW1hcC5wYXRoLCBvbkZpbmlzaExvYWRpbmcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYSBzaW5ndWxhciB0aWxlbWFwIFxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgdGlsZW1hcFxuICAgICAqIEBwYXJhbSBwYXRoVG9UaWxlbWFwSlNPTiBUaGUgcGF0aCB0byB0aGUgdGlsZW1hcCBKU09OIGZpbGVcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tJZkxhc3QgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhpcyBpcyB0aGUgbGFzdCB0aWxlbWFwIHRvIGxvYWRcbiAgICAgKi9cbiAgICBwcml2YXRlIGxvYWRUaWxlbWFwKGtleTogc3RyaW5nLCBwYXRoVG9UaWxlbWFwSlNPTjogc3RyaW5nLCBjYWxsYmFja0lmTGFzdDogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2FkVGV4dEZpbGUocGF0aFRvVGlsZW1hcEpTT04sIChmaWxlVGV4dDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICBsZXQgdGlsZW1hcE9iamVjdCA9IDxUaWxlZFRpbGVtYXBEYXRhPkpTT04ucGFyc2UoZmlsZVRleHQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBXZSBjYW4gcGFyc2UgdGhlIG9iamVjdCBsYXRlciAtIGl0J3MgbXVjaCBmYXN0ZXIgdGhhbiBsb2FkaW5nXG4gICAgICAgICAgICB0aGlzLnRpbGVtYXBzLmFkZChrZXksIHRpbGVtYXBPYmplY3QpO1xuICAgICAgICAgICAgbGV0IHJlc291cmNlID0gbmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLlRJTEVNQVApO1xuXG4gICAgICAgICAgICAvLyBHcmFiIHRoZSB0aWxlc2V0IGltYWdlcyB3ZSBuZWVkIHRvIGxvYWQgYW5kIGFkZCB0aGVtIHRvIHRoZSBpbWFnZWxvYWRpbmcgcXVldWVcbiAgICAgICAgICAgIGZvcihsZXQgdGlsZXNldCBvZiB0aWxlbWFwT2JqZWN0LnRpbGVzZXRzKXtcbiAgICAgICAgICAgICAgICBpZih0aWxlc2V0LmltYWdlKXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGtleSA9IHRpbGVzZXQuaW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXRoID0gU3RyaW5nVXRpbHMuZ2V0UGF0aEZyb21GaWxlUGF0aChwYXRoVG9UaWxlbWFwSlNPTikgKyBrZXk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUuZW5xdWV1ZSh7a2V5OiBrZXksIHBhdGg6IHBhdGgsIGlzRGVwZW5kZW5jeTogdHJ1ZX0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGlzIGltYWdlIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgdGlsZW1hcFxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS5hZGREZXBlbmRlbmN5KG5ldyBSZXNvdXJjZVJlZmVyZW5jZShrZXksIFJlc291cmNlVHlwZS5JTUFHRSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZih0aWxlc2V0LnRpbGVzKXtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCB0aWxlIG9mIHRpbGVzZXQudGlsZXMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGtleSA9IHRpbGUuaW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGF0aCA9IFN0cmluZ1V0aWxzLmdldFBhdGhGcm9tRmlsZVBhdGgocGF0aFRvVGlsZW1hcEpTT04pICsga2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2Fkb25seV9pbWFnZUxvYWRpbmdRdWV1ZS5lbnF1ZXVlKHtrZXk6IGtleSwgcGF0aDogcGF0aCwgaXNEZXBlbmRlbmN5OiB0cnVlfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGlzIGltYWdlIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgdGlsZW1hcFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UuYWRkRGVwZW5kZW5jeShuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoa2V5LCBSZXNvdXJjZVR5cGUuSU1BR0UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIHRoZSByZXNvdXJjZSByZWZlcmVuY2UgdG8gdGhlIGxpc3Qgb2YgcmVzb3VyY2UgdG8gdW5sb2FkXG4gICAgICAgICAgICB0aGlzLnJlc291cmNlc1RvVW5sb2FkLnB1c2gocmVzb3VyY2UpO1xuXG4gICAgICAgICAgICAvLyBGaW5pc2ggbG9hZGluZ1xuICAgICAgICAgICAgdGhpcy5maW5pc2hMb2FkaW5nVGlsZW1hcChjYWxsYmFja0lmTGFzdCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmlzaCBsb2FkaW5nIGEgdGlsZW1hcC4gQ2FsbHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlmIHRoaXMgaXMgdGhlIGxhc3QgdGlsZW1hcCBiZWluZyBsb2FkZWRcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhpcyBpcyB0aGUgbGFzdCB0aWxlbWFwIHRvIGxvYWRcbiAgICAgKi9cbiAgICBwcml2YXRlIGZpbmlzaExvYWRpbmdUaWxlbWFwKGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRvbmx5X3RpbGVtYXBzTG9hZGVkICs9IDE7XG5cbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV90aWxlbWFwc0xvYWRlZCA9PT0gdGhpcy5sb2Fkb25seV90aWxlbWFwc1RvTG9hZCl7XG4gICAgICAgICAgICAvLyBXZSdyZSBkb25lIGxvYWRpbmcgdGlsZW1hcHNcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhbGwgc3ByaXRlc2hlZXRzIGN1cnJlbnRseSBpbiB0aGUgc3ByaXRlc2hlZXQgbG9hZGluZyBxdWV1ZVxuICAgICAqIEBwYXJhbSBvbkZpbmlzaExvYWRpbmcgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgc3ByaXRlc2hlZXRzIGFyZSBkb25lIGxvYWRpbmdcbiAgICAgKi9cbiAgICBwcml2YXRlIGxvYWRTcHJpdGVzaGVldHNGcm9tUXVldWUob25GaW5pc2hMb2FkaW5nOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c1RvTG9hZCA9IHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRMb2FkaW5nUXVldWUuZ2V0U2l6ZSgpO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c0xvYWRlZCA9IDA7XG5cbiAgICAgICAgLy8gSWYgbm8gaXRlbXMgdG8gbG9hZCwgd2UncmUgZmluaXNoZWRcbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNUb0xvYWQgPT09IDApe1xuICAgICAgICAgICAgb25GaW5pc2hMb2FkaW5nKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSh0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0TG9hZGluZ1F1ZXVlLmhhc0l0ZW1zKCkpe1xuICAgICAgICAgICAgbGV0IHNwcml0ZXNoZWV0ID0gdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldExvYWRpbmdRdWV1ZS5kZXF1ZXVlKCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRTcHJpdGVzaGVldChzcHJpdGVzaGVldC5rZXksIHNwcml0ZXNoZWV0LnBhdGgsIG9uRmluaXNoTG9hZGluZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIHNpbmd1bGFyIHNwcml0ZXNoZWV0IFxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgc3ByaXRlc2hlZXQgdG8gbG9hZFxuICAgICAqIEBwYXJhbSBwYXRoVG9TcHJpdGVzaGVldEpTT04gVGhlIHBhdGggdG8gdGhlIHNwcml0ZXNoZWV0IEpTT04gZmlsZVxuICAgICAqIEBwYXJhbSBjYWxsYmFja0lmTGFzdCBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IHNwcml0ZXNoZWV0XG4gICAgICovXG4gICAgcHJpdmF0ZSBsb2FkU3ByaXRlc2hlZXQoa2V5OiBzdHJpbmcsIHBhdGhUb1Nwcml0ZXNoZWV0SlNPTjogc3RyaW5nLCBjYWxsYmFja0lmTGFzdDogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2FkVGV4dEZpbGUocGF0aFRvU3ByaXRlc2hlZXRKU09OLCAoZmlsZVRleHQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgbGV0IHNwcml0ZXNoZWV0ID0gPFNwcml0ZXNoZWV0PkpTT04ucGFyc2UoZmlsZVRleHQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBXZSBjYW4gcGFyc2UgdGhlIG9iamVjdCBsYXRlciAtIGl0J3MgbXVjaCBmYXN0ZXIgdGhhbiBsb2FkaW5nXG4gICAgICAgICAgICB0aGlzLnNwcml0ZXNoZWV0cy5hZGQoa2V5LCBzcHJpdGVzaGVldCk7XG5cbiAgICAgICAgICAgIGxldCByZXNvdXJjZSA9IG5ldyBSZXNvdXJjZVJlZmVyZW5jZShrZXksIFJlc291cmNlVHlwZS5TUFJJVEVTSEVFVCk7XG5cbiAgICAgICAgICAgIC8vIEdyYWIgdGhlIGltYWdlIHdlIG5lZWQgdG8gbG9hZCBhbmQgYWRkIGl0IHRvIHRoZSBpbWFnZWxvYWRpbmcgcXVldWVcbiAgICAgICAgICAgIGxldCBwYXRoID0gU3RyaW5nVXRpbHMuZ2V0UGF0aEZyb21GaWxlUGF0aChwYXRoVG9TcHJpdGVzaGVldEpTT04pICsgc3ByaXRlc2hlZXQuc3ByaXRlU2hlZXRJbWFnZTtcbiAgICAgICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUuZW5xdWV1ZSh7a2V5OiBzcHJpdGVzaGVldC5uYW1lLCBwYXRoOiBwYXRoLCBpc0RlcGVuZGVuY3k6IHRydWV9KTtcblxuICAgICAgICAgICAgcmVzb3VyY2UuYWRkRGVwZW5kZW5jeShuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoc3ByaXRlc2hlZXQubmFtZSwgUmVzb3VyY2VUeXBlLklNQUdFKSk7XG4gICAgICAgICAgICB0aGlzLnJlc291cmNlc1RvVW5sb2FkLnB1c2gocmVzb3VyY2UpO1xuXG4gICAgICAgICAgICAvLyBGaW5pc2ggbG9hZGluZ1xuICAgICAgICAgICAgdGhpcy5maW5pc2hMb2FkaW5nU3ByaXRlc2hlZXQoY2FsbGJhY2tJZkxhc3QpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5pc2ggbG9hZGluZyBhIHNwcml0ZXNoZWV0LiBDYWxscyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaWYgdGhpcyBpcyB0aGUgbGFzdCBzcHJpdGVzaGVldCBiZWluZyBsb2FkZWRcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhpcyBpcyB0aGUgbGFzdCBzcHJpdGVzaGVldCB0byBsb2FkXG4gICAgICovXG4gICAgcHJpdmF0ZSBmaW5pc2hMb2FkaW5nU3ByaXRlc2hlZXQoY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzTG9hZGVkICs9IDE7XG5cbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNMb2FkZWQgPT09IHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzVG9Mb2FkKXtcbiAgICAgICAgICAgIC8vIFdlJ3JlIGRvbmUgbG9hZGluZyBzcHJpdGVzaGVldHNcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhbGwgaW1hZ2VzIGN1cnJlbnRseSBpbiB0aGUgaW1hZ2UgbG9hZGluZyBxdWV1ZVxuICAgICAqIEBwYXJhbSBvbkZpbmlzaExvYWRpbmcgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGVyZSBhcmUgbm8gbW9yZSBpbWFnZXMgdG8gbG9hZFxuICAgICAqL1xuICAgIHByaXZhdGUgbG9hZEltYWdlc0Zyb21RdWV1ZShvbkZpbmlzaExvYWRpbmc6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VzVG9Mb2FkID0gdGhpcy5sb2Fkb25seV9pbWFnZUxvYWRpbmdRdWV1ZS5nZXRTaXplKCk7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VzTG9hZGVkID0gMDtcblxuICAgICAgICAvLyBJZiBubyBpdGVtcyB0byBsb2FkLCB3ZSdyZSBmaW5pc2hlZFxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X2ltYWdlc1RvTG9hZCA9PT0gMCl7XG4gICAgICAgICAgICBvbkZpbmlzaExvYWRpbmcoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlKHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUuaGFzSXRlbXMoKSl7XG4gICAgICAgICAgICBsZXQgaW1hZ2UgPSB0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlLmRlcXVldWUoKTtcbiAgICAgICAgICAgIHRoaXMubG9hZEltYWdlKGltYWdlLmtleSwgaW1hZ2UucGF0aCwgaW1hZ2UuaXNEZXBlbmRlbmN5LCBvbkZpbmlzaExvYWRpbmcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYSBzaW5ndWxhciBpbWFnZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaW1hZ2UgdG8gbG9hZFxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBpbWFnZSB0byBsb2FkXG4gICAgICogQHBhcmFtIGNhbGxiYWNrSWZMYXN0IFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3QgaW1hZ2VcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9hZEltYWdlKGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGlzRGVwZW5kZW5jeTogYm9vbGVhbiwgY2FsbGJhY2tJZkxhc3Q6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuXG4gICAgICAgIGltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIEFkZCB0byBsb2FkZWQgaW1hZ2VzXG4gICAgICAgICAgICB0aGlzLmltYWdlcy5hZGQoa2V5LCBpbWFnZSk7XG5cbiAgICAgICAgICAgIC8vIElmIG5vdCBhIGRlcGVuZGVuY3ksIHB1c2ggaXQgdG8gdGhlIHVubG9hZCBsaXN0LiBPdGhlcndpc2UgaXQncyBtYW5hZ2VkIGJ5IHNvbWV0aGluZyBlbHNlXG4gICAgICAgICAgICBpZighaXNEZXBlbmRlbmN5KXtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc291cmNlc1RvVW5sb2FkLnB1c2gobmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLklNQUdFKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIFdlYkdMIGlzIGFjdGl2ZSwgY3JlYXRlIGEgdGV4dHVyZVxuICAgICAgICAgICAgaWYodGhpcy5nbF9XZWJHTEFjdGl2ZSl7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVXZWJHTFRleHR1cmUoa2V5LCBpbWFnZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpbmlzaCBpbWFnZSBsb2FkXG4gICAgICAgICAgICB0aGlzLmZpbmlzaExvYWRpbmdJbWFnZShjYWxsYmFja0lmTGFzdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbWFnZS5zcmMgPSBwYXRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmlzaCBsb2FkaW5nIGFuIGltYWdlLiBJZiB0aGlzIGlzIHRoZSBsYXN0IGltYWdlLCBpdCBjYWxscyB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhpcyBpcyB0aGUgbGFzdCBpbWFnZVxuICAgICAqL1xuICAgIHByaXZhdGUgZmluaXNoTG9hZGluZ0ltYWdlKGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlc0xvYWRlZCArPSAxO1xuXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfaW1hZ2VzTG9hZGVkID09PSB0aGlzLmxvYWRvbmx5X2ltYWdlc1RvTG9hZCApe1xuICAgICAgICAgICAgLy8gV2UncmUgZG9uZSBsb2FkaW5nIGltYWdlc1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGFsbCBhdWRpbyBjdXJyZW50bHkgaW4gdGhlIHRpbGVtYXAgbG9hZGluZyBxdWV1ZVxuICAgICAqIEBwYXJhbSBvbkZpbmlzaExvYWRpbmcgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aWxlbWFwcyBhcmUgZG9uZSBsb2FkaW5nXG4gICAgICovXG4gICAgcHJpdmF0ZSBsb2FkQXVkaW9Gcm9tUXVldWUob25GaW5pc2hMb2FkaW5nOiBGdW5jdGlvbil7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfYXVkaW9Ub0xvYWQgPSB0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGluZ1F1ZXVlLmdldFNpemUoKTtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRlZCA9IDA7XG5cbiAgICAgICAgLy8gSWYgbm8gaXRlbXMgdG8gbG9hZCwgd2UncmUgZmluaXNoZWRcbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV9hdWRpb1RvTG9hZCA9PT0gMCl7XG4gICAgICAgICAgICBvbkZpbmlzaExvYWRpbmcoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlKHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkaW5nUXVldWUuaGFzSXRlbXMoKSl7XG4gICAgICAgICAgICBsZXQgYXVkaW8gPSB0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGluZ1F1ZXVlLmRlcXVldWUoKTtcbiAgICAgICAgICAgIHRoaXMubG9hZEF1ZGlvKGF1ZGlvLmtleSwgYXVkaW8ucGF0aCwgb25GaW5pc2hMb2FkaW5nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWQgYSBzaW5ndWxhciBhdWRpbyBmaWxlXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIHRoZSBhdWRpbyBmaWxlIHRvIGxvYWRcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUgYXVkaW8gZmlsZSB0byBsb2FkXG4gICAgICogQHBhcmFtIGNhbGxiYWNrSWZMYXN0IFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3QgYXVkaW8gZmlsZSB0byBsb2FkXG4gICAgICovXG4gICAgcHJpdmF0ZSBsb2FkQXVkaW8oa2V5OiBzdHJpbmcsIHBhdGg6IHN0cmluZywgY2FsbGJhY2tJZkxhc3Q6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIGxldCBhdWRpb0N0eCA9IEF1ZGlvTWFuYWdlci5nZXRJbnN0YW5jZSgpLmdldEF1ZGlvQ29udGV4dCgpO1xuXG4gICAgICAgIGxldCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHJlcXVlc3Qub3BlbignR0VUJywgcGF0aCwgdHJ1ZSk7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcblxuICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGF1ZGlvQ3R4LmRlY29kZUF1ZGlvRGF0YShyZXF1ZXN0LnJlc3BvbnNlLCAoYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRvIGxpc3Qgb2YgYXVkaW8gYnVmZmVyc1xuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9CdWZmZXJzLmFkZChrZXksIGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvdXJjZXNUb1VubG9hZC5wdXNoKG5ldyBSZXNvdXJjZVJlZmVyZW5jZShrZXksIFJlc291cmNlVHlwZS5BVURJTykpO1xuXG4gICAgICAgICAgICAgICAgLy8gRmluaXNoIGxvYWRpbmcgc291bmRcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaExvYWRpbmdBdWRpbyhjYWxsYmFja0lmTGFzdCk7XG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+e1xuICAgICAgICAgICAgICAgIHRocm93IFwiRXJyb3IgbG9hZGluZyBzb3VuZFwiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluaXNoIGxvYWRpbmcgYW4gYXVkaW8gZmlsZS4gQ2FsbHMgdGhlIGNhbGxiYWNrIGZ1bmN0b24gaWYgdGhpcyBpcyB0aGUgbGFzdCBhdWRpbyBzYW1wbGUgYmVpbmcgbG9hZGVkLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IGF1ZGlvIGZpbGUgdG8gbG9hZFxuICAgICAqL1xuICAgIHByaXZhdGUgZmluaXNoTG9hZGluZ0F1ZGlvKGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGVkICs9IDE7XG5cbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV9hdWRpb0xvYWRlZCA9PT0gdGhpcy5sb2Fkb25seV9hdWRpb1RvTG9hZCl7XG4gICAgICAgICAgICAvLyBXZSdyZSBkb25lIGxvYWRpbmcgYXVkaW9cbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhbGwgb2JqZWN0cyBjdXJyZW50bHkgaW4gdGhlIG9iamVjdCBsb2FkaW5nIHF1ZXVlXG4gICAgICogQHBhcmFtIG9uRmluaXNoTG9hZGluZyBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZXJlIGFyZSBubyBtb3JlIG9iamVjdHMgdG8gbG9hZFxuICAgICAqL1xuICAgIHByaXZhdGUgbG9hZE9iamVjdHNGcm9tUXVldWUob25GaW5pc2hMb2FkaW5nOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2pzb25Ub0xvYWQgPSB0aGlzLmxvYWRvbmx5X2pzb25Mb2FkaW5nUXVldWUuZ2V0U2l6ZSgpO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2pzb25Mb2FkZWQgPSAwO1xuXG4gICAgICAgIC8vIElmIG5vIGl0ZW1zIHRvIGxvYWQsIHdlJ3JlIGZpbmlzaGVkXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfanNvblRvTG9hZCA9PT0gMCl7XG4gICAgICAgICAgICBvbkZpbmlzaExvYWRpbmcoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlKHRoaXMubG9hZG9ubHlfanNvbkxvYWRpbmdRdWV1ZS5oYXNJdGVtcygpKXtcbiAgICAgICAgICAgIGxldCBvYmogPSB0aGlzLmxvYWRvbmx5X2pzb25Mb2FkaW5nUXVldWUuZGVxdWV1ZSgpO1xuICAgICAgICAgICAgdGhpcy5sb2FkT2JqZWN0KG9iai5rZXksIG9iai5wYXRoLCBvbkZpbmlzaExvYWRpbmcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYSBzaW5ndWxhciBvYmplY3RcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIG9iamVjdCB0byBsb2FkXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gdGhlIG9iamVjdCB0byBsb2FkXG4gICAgICogQHBhcmFtIGNhbGxiYWNrSWZMYXN0IFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3Qgb2JqZWN0XG4gICAgICovXG4gICAgcHVibGljIGxvYWRPYmplY3Qoa2V5OiBzdHJpbmcsIHBhdGg6IHN0cmluZywgY2FsbGJhY2tJZkxhc3Q6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZFRleHRGaWxlKHBhdGgsIChmaWxlVGV4dDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICBsZXQgb2JqID0gSlNPTi5wYXJzZShmaWxlVGV4dCk7XG4gICAgICAgICAgICB0aGlzLmpzb25PYmplY3RzLmFkZChrZXksIG9iaik7XG5cbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VzVG9VbmxvYWQucHVzaChuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoa2V5LCBSZXNvdXJjZVR5cGUuSlNPTikpO1xuXG4gICAgICAgICAgICB0aGlzLmZpbmlzaExvYWRpbmdPYmplY3QoY2FsbGJhY2tJZkxhc3QpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5pc2ggbG9hZGluZyBhbiBvYmplY3QuIElmIHRoaXMgaXMgdGhlIGxhc3Qgb2JqZWN0LCBpdCBjYWxscyB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhpcyBpcyB0aGUgbGFzdCBvYmplY3RcbiAgICAgKi9cbiAgICBwcml2YXRlIGZpbmlzaExvYWRpbmdPYmplY3QoY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfanNvbkxvYWRlZCArPSAxO1xuXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfanNvbkxvYWRlZCA9PT0gdGhpcy5sb2Fkb25seV9qc29uVG9Mb2FkKXtcbiAgICAgICAgICAgIC8vIFdlJ3JlIGRvbmUgbG9hZGluZyBvYmplY3RzXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogIyMjIyMjIyMjIyBXRUJHTCBTUEVDSUZJQyBGVU5DVElPTlMgIyMjIyMjIyMjIyAqL1xuXG4gICAgcHVibGljIGdldFRleHR1cmUoa2V5OiBzdHJpbmcpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5nbF9UZXh0dXJlcy5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0U2hhZGVyUHJvZ3JhbShrZXk6IHN0cmluZyk6IFdlYkdMUHJvZ3JhbSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdsX1NoYWRlclByb2dyYW1zLmdldChrZXkpLnByb2dyYW07XG4gICAgfVxuXG4gICAgcHVibGljIGdldEJ1ZmZlcihrZXk6IHN0cmluZyk6IFdlYkdMQnVmZmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2xfQnVmZmVycy5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNyZWF0ZVdlYkdMVGV4dHVyZShpbWFnZUtleTogc3RyaW5nLCBpbWFnZTogSFRNTEltYWdlRWxlbWVudCk6IHZvaWQge1xuICAgICAgICAvLyBHZXQgdGhlIHRleHR1cmUgSURcbiAgICAgICAgY29uc3QgdGV4dHVyZUlEID0gdGhpcy5nZXRUZXh0dXJlSUQodGhpcy5nbF9OZXh0VGV4dHVyZUlEKTtcblxuICAgICAgICAvLyBDcmVhdGUgdGhlIHRleHR1cmVcbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IHRoaXMuZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG4gICAgICAgIC8vIFNldCB1cCB0aGUgdGV4dHVyZVxuICAgICAgICAvLyBFbmFibGUgdGV4dHVyZTBcbiAgICAgICAgdGhpcy5nbC5hY3RpdmVUZXh0dXJlKHRleHR1cmVJRCk7XG5cbiAgICAgICAgLy8gQmluZCBvdXIgdGV4dHVyZSB0byB0ZXh0dXJlIDBcbiAgICAgICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuXG4gICAgICAgIC8vIFNldCB0aGUgdGV4dHVyZSBwYXJhbWV0ZXJzXG4gICAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLmdsLkxJTkVBUik7XG4gICAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMuZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMuZ2wuQ0xBTVBfVE9fRURHRSk7XG5cbiAgICAgICAgLy8gU2V0IHRoZSB0ZXh0dXJlIGltYWdlXG4gICAgICAgIHRoaXMuZ2wudGV4SW1hZ2UyRCh0aGlzLmdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuZ2wuUkdCQSwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlVOU0lHTkVEX0JZVEUsIGltYWdlKTtcblxuICAgICAgICAvLyBBZGQgdGhlIHRleHR1cmUgdG8gb3VyIG1hcCB3aXRoIHRoZSBzYW1lIGtleSBhcyB0aGUgaW1hZ2VcbiAgICAgICAgdGhpcy5nbF9UZXh0dXJlcy5hZGQoaW1hZ2VLZXksIHRoaXMuZ2xfTmV4dFRleHR1cmVJRCk7XG5cbiAgICAgICAgLy8gSW5jcmVtZW50IHRoZSBrZXlcbiAgICAgICAgdGhpcy5nbF9OZXh0VGV4dHVyZUlEICs9IDE7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUZXh0dXJlSUQoaWQ6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIC8vIFN0YXJ0IHdpdGggOSBjYXNlcyAtIHRoaXMgY2FuIGJlIGV4cGFuZGVkIGlmIG5lZWRlZCwgYnV0IGZvciB0aGUgYmVzdCBwZXJmb3JtYW5jZSxcbiAgICAgICAgLy8gVGV4dHVyZXMgc2hvdWxkIGJlIHN0aXRjaGVkIGludG8gYW4gYXRsYXNcbiAgICAgICAgc3dpdGNoKGlkKXtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTA7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiB0aGlzLmdsLlRFWFRVUkUxO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gdGhpcy5nbC5URVhUVVJFMjtcbiAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTM7XG4gICAgICAgICAgICBjYXNlIDQ6IHJldHVybiB0aGlzLmdsLlRFWFRVUkU0O1xuICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gdGhpcy5nbC5URVhUVVJFNTtcbiAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTY7XG4gICAgICAgICAgICBjYXNlIDc6IHJldHVybiB0aGlzLmdsLlRFWFRVUkU3O1xuICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gdGhpcy5nbC5URVhUVVJFODtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiB0aGlzLmdsLlRFWFRVUkU5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGNyZWF0ZUJ1ZmZlcihrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBpZih0aGlzLmdsX1dlYkdMQWN0aXZlKXtcbiAgICAgICAgICAgIGxldCBidWZmZXIgPSB0aGlzLmdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gICAgICAgICAgICB0aGlzLmdsX0J1ZmZlcnMuYWRkKGtleSwgYnVmZmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVucXVldWVzIGxvYWRpbmcgb2YgYSBuZXcgc2hhZGVyIHByb2dyYW1cbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHNoYWRlciBwcm9ncmFtXG4gICAgICogQHBhcmFtIHZTaGFkZXJGaWxlcGF0aCBcbiAgICAgKiBAcGFyYW0gZlNoYWRlckZpbGVwYXRoIFxuICAgICAqL1xuICAgIHB1YmxpYyBzaGFkZXIoa2V5OiBzdHJpbmcsIHZTaGFkZXJGaWxlcGF0aDogc3RyaW5nLCBmU2hhZGVyRmlsZXBhdGg6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBsZXQgc3BsaXRQYXRoID0gdlNoYWRlckZpbGVwYXRoLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgbGV0IGVuZCA9IHNwbGl0UGF0aFtzcGxpdFBhdGgubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYoZW5kICE9PSBcInZzaGFkZXJcIil7XG4gICAgICAgICAgICB0aHJvdyBgJHt2U2hhZGVyRmlsZXBhdGh9IGlzIG5vdCBhIHZhbGlkIHZlcnRleCBzaGFkZXIgLSBtdXN0IGVuZCBpbiBcIi52c2hhZGVyYDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNwbGl0UGF0aCA9IGZTaGFkZXJGaWxlcGF0aC5zcGxpdChcIi5cIik7XG4gICAgICAgIGVuZCA9IHNwbGl0UGF0aFtzcGxpdFBhdGgubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYoZW5kICE9PSBcImZzaGFkZXJcIil7XG4gICAgICAgICAgICB0aHJvdyBgJHtmU2hhZGVyRmlsZXBhdGh9IGlzIG5vdCBhIHZhbGlkIHZlcnRleCBzaGFkZXIgLSBtdXN0IGVuZCBpbiBcIi5mc2hhZGVyYDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwYXRocyA9IG5ldyBLZXlQYXRoX1NoYWRlcigpO1xuICAgICAgICBwYXRocy5rZXkgPSBrZXk7XG4gICAgICAgIHBhdGhzLnZwYXRoID0gdlNoYWRlckZpbGVwYXRoO1xuICAgICAgICBwYXRocy5mcGF0aCA9IGZTaGFkZXJGaWxlcGF0aDtcblxuICAgICAgICB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlckxvYWRpbmdRdWV1ZS5lbnF1ZXVlKHBhdGhzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZWxscyB0aGUgcmVzb3VyY2UgbWFuYWdlciB0byBrZWVwIHRoaXMgcmVzb3VyY2VcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHJlc291cmNlXG4gICAgICovXG4gICAgIHB1YmxpYyBrZWVwU2hhZGVyKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMua2VlcFJlc291cmNlKGtleSwgUmVzb3VyY2VUeXBlLklNQUdFKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdsX0xvYWRTaGFkZXJzRnJvbVF1ZXVlKG9uRmluaXNoTG9hZGluZzogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc1RvTG9hZCA9IHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyTG9hZGluZ1F1ZXVlLmdldFNpemUoKTtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc0xvYWRlZCA9IDA7XG5cbiAgICAgICAgLy8gSWYgd2ViR0wgaXNuJ2FjdGl2ZSBvciB0aGVyZSBhcmUgbm8gaXRlbXMgdG8gbG9hZCwgd2UncmUgZmluaXNoZWRcbiAgICAgICAgaWYoIXRoaXMuZ2xfV2ViR0xBY3RpdmUgfHwgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc1RvTG9hZCA9PT0gMCl7XG4gICAgICAgICAgICBvbkZpbmlzaExvYWRpbmcoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlKHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyTG9hZGluZ1F1ZXVlLmhhc0l0ZW1zKCkpe1xuICAgICAgICAgICAgbGV0IHNoYWRlciA9IHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyTG9hZGluZ1F1ZXVlLmRlcXVldWUoKTtcbiAgICAgICAgICAgIHRoaXMuZ2xfTG9hZFNoYWRlcihzaGFkZXIua2V5LCBzaGFkZXIudnBhdGgsIHNoYWRlci5mcGF0aCwgb25GaW5pc2hMb2FkaW5nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZ2xfTG9hZFNoYWRlcihrZXk6IHN0cmluZywgdnBhdGg6IHN0cmluZywgZnBhdGg6IHN0cmluZywgY2FsbGJhY2tJZkxhc3Q6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZFRleHRGaWxlKHZwYXRoLCAodkZpbGVUZXh0OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZTaGFkZXIgPSB2RmlsZVRleHQ7XG5cbiAgICAgICAgICAgIHRoaXMubG9hZFRleHRGaWxlKGZwYXRoLCAoZkZpbGVUZXh0OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmU2hhZGVyID0gZkZpbGVUZXh0XG5cbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBwcm9ncmFtIGFuZCBzaGFkZXJzXG4gICAgICAgICAgICAgICAgY29uc3QgW3NoYWRlclByb2dyYW0sIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJdID0gdGhpcy5jcmVhdGVTaGFkZXJQcm9ncmFtKHZTaGFkZXIsIGZTaGFkZXIpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgd3JhcHBlciB0eXBlXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvZ3JhbVdyYXBwZXIgPSBuZXcgV2ViR0xQcm9ncmFtVHlwZSgpO1xuICAgICAgICAgICAgICAgIHByb2dyYW1XcmFwcGVyLnByb2dyYW0gPSBzaGFkZXJQcm9ncmFtO1xuICAgICAgICAgICAgICAgIHByb2dyYW1XcmFwcGVyLnZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlcjtcbiAgICAgICAgICAgICAgICBwcm9ncmFtV3JhcHBlci5mcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRvIG91ciBtYXBcbiAgICAgICAgICAgICAgICB0aGlzLmdsX1NoYWRlclByb2dyYW1zLmFkZChrZXksIHByb2dyYW1XcmFwcGVyKTtcblxuICAgICAgICAgICAgICAgIHRoaXMucmVzb3VyY2VzVG9VbmxvYWQucHVzaChuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoa2V5LCBSZXNvdXJjZVR5cGUuU0hBREVSKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBGaW5pc2ggbG9hZGluZ1xuICAgICAgICAgICAgICAgIHRoaXMuZ2xfRmluaXNoTG9hZGluZ1NoYWRlcihjYWxsYmFja0lmTGFzdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnbF9GaW5pc2hMb2FkaW5nU2hhZGVyKGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlclByb2dyYW1zTG9hZGVkICs9IDE7XG5cbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc0xvYWRlZCA9PT0gdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc1RvTG9hZCl7XG4gICAgICAgICAgICAvLyBXZSdyZSBkb25lIGxvYWRpbmcgc2hhZGVyc1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlU2hhZGVyUHJvZ3JhbSh2U2hhZGVyU291cmNlOiBzdHJpbmcsIGZTaGFkZXJTb3VyY2U6IHN0cmluZyl7XG4gICAgICAgIGNvbnN0IHZlcnRleFNoYWRlciA9IHRoaXMubG9hZFZlcnRleFNoYWRlcih2U2hhZGVyU291cmNlKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmxvYWRGcmFnbWVudFNoYWRlcihmU2hhZGVyU291cmNlKTtcbiAgICBcbiAgICAgICAgaWYodmVydGV4U2hhZGVyID09PSBudWxsIHx8IGZyYWdtZW50U2hhZGVyID09PSBudWxsKXtcbiAgICAgICAgICAgIC8vIFdlIGhhZCBhIHByb2JsZW0gaW50aWFsaXppbmcgLSBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGEgc2hhZGVyIHByb2dyYW1cbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgICAgICBpZighcHJvZ3JhbSkge1xuICAgICAgICAgICAgLy8gRXJyb3IgY3JlYXRpbmdcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBjcmVhdGUgcHJvZ3JhbVwiKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIEF0dGFjaCBvdXIgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgdGhpcy5nbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgICAgICAgdGhpcy5nbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICAgIFxuICAgICAgICAvLyBMaW5rXG4gICAgICAgIHRoaXMuZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIGlmKCF0aGlzLmdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgdGhpcy5nbC5MSU5LX1NUQVRVUykpe1xuICAgICAgICAgICAgLy8gRXJyb3IgbGlua2luZ1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGxpbmsgcHJvZ3JhbTogXCIgKyBlcnJvcik7XG4gICAgXG4gICAgICAgICAgICAvLyBDbGVhbiB1cFxuICAgICAgICAgICAgdGhpcy5nbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICAgICAgdGhpcy5nbC5kZWxldGVTaGFkZXIodmVydGV4U2hhZGVyKTtcbiAgICAgICAgICAgIHRoaXMuZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIFdlIHN1Y2Nlc3NmdWxseSBjcmVhdGUgYSBwcm9ncmFtXG4gICAgICAgIHJldHVybiBbcHJvZ3JhbSwgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcl07XG4gICAgfVxuICAgIFxuICAgIHByaXZhdGUgbG9hZFZlcnRleFNoYWRlcihzaGFkZXJTb3VyY2U6IHN0cmluZyk6IFdlYkdMU2hhZGVye1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgdmVydGV4IHNoYWRlclxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkU2hhZGVyKHRoaXMuZ2wuVkVSVEVYX1NIQURFUiwgc2hhZGVyU291cmNlKTtcbiAgICB9XG4gICAgXG4gICAgcHJpdmF0ZSBsb2FkRnJhZ21lbnRTaGFkZXIoc2hhZGVyU291cmNlOiBzdHJpbmcpOiBXZWJHTFNoYWRlcntcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGZyYWdtZW50IHNoYWRlclxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkU2hhZGVyKHRoaXMuZ2wuRlJBR01FTlRfU0hBREVSLCBzaGFkZXJTb3VyY2UpO1x0XG4gICAgfVxuICAgIFxuICAgIHByaXZhdGUgbG9hZFNoYWRlcih0eXBlOiBudW1iZXIsIHNoYWRlclNvdXJjZTogc3RyaW5nKTogV2ViR0xTaGFkZXJ7XG4gICAgICAgIGNvbnN0IHNoYWRlciA9IHRoaXMuZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuICAgIFxuICAgICAgICAvLyBJZiB3ZSBjb3VsZG4ndCBjcmVhdGUgdGhlIHNoYWRlciwgZXJyb3JcbiAgICAgICAgaWYoc2hhZGVyID09PSBudWxsKXtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVuYWJsZSB0byBjcmVhdGUgc2hhZGVyXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gQWRkIHRoZSBzb3VyY2UgdG8gdGhlIHNoYWRlciBhbmQgY29tcGlsZVxuICAgICAgICB0aGlzLmdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNoYWRlclNvdXJjZSk7XG4gICAgICAgIHRoaXMuZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICAgIFxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlcmUgd2VyZSBubyBlcnJvcnMgZHVyaW5nIHRoaXMgcHJvY2Vzc1xuICAgICAgICBpZighdGhpcy5nbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCB0aGlzLmdsLkNPTVBJTEVfU1RBVFVTKSl7XG4gICAgICAgICAgICAvLyBOb3QgY29tcGlsZWQgLSBlcnJvclxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBjb21waWxlIHNoYWRlcjogXCIgKyBlcnJvcik7XG4gICAgXG4gICAgICAgICAgICAvLyBDbGVhbiB1cFxuICAgICAgICAgICAgdGhpcy5nbC5kZWxldGVTaGFkZXIoc2hhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIFN1Y2Vzcywgc28gcmV0dXJuIHRoZSBzaGFkZXJcbiAgICAgICAgcmV0dXJuIHNoYWRlcjtcbiAgICB9XG5cbiAgICAvKiAjIyMjIyMjIyMjIEdFTkVSQUwgTE9BRElORyBGVU5DVElPTlMgIyMjIyMjIyMjIyAqL1xuXG4gICAgcHJpdmF0ZSBsb2FkVGV4dEZpbGUodGV4dEZpbGVQYXRoOiBzdHJpbmcsIGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICBsZXQgeG9iajogWE1MSHR0cFJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgeG9iai5vdmVycmlkZU1pbWVUeXBlKFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICAgICAgeG9iai5vcGVuKCdHRVQnLCB0ZXh0RmlsZVBhdGgsIHRydWUpO1xuICAgICAgICB4b2JqLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICgoeG9iai5yZWFkeVN0YXRlID09IDQpICYmICh4b2JqLnN0YXR1cyA9PSAyMDApKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soeG9iai5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB4b2JqLnNlbmQobnVsbCk7XG4gICAgfVxuXG4gICAgLyogIyMjIyMjIyMjIyBMT0FESU5HIEJBUiBJTkZPICMjIyMjIyMjIyMgKi9cblxuICAgIHByaXZhdGUgZ2V0TG9hZFBlcmNlbnQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmxvYWRvbmx5X3RpbGVtYXBzTG9hZGVkL3RoaXMubG9hZG9ubHlfdGlsZW1hcHNUb0xvYWRcbiAgICAgICAgICAgICsgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNMb2FkZWQvdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNUb0xvYWRcbiAgICAgICAgICAgICsgdGhpcy5sb2Fkb25seV9pbWFnZXNMb2FkZWQvdGhpcy5sb2Fkb25seV9pbWFnZXNUb0xvYWRcbiAgICAgICAgICAgICsgdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRlZC90aGlzLmxvYWRvbmx5X2F1ZGlvVG9Mb2FkKVxuICAgICAgICAgICAgLyB0aGlzLmxvYWRvbmx5X3R5cGVzVG9Mb2FkO1xuICAgIH1cblxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBpZih0aGlzLmxvYWRpbmcpe1xuICAgICAgICAgICAgaWYodGhpcy5vbkxvYWRQcm9ncmVzcyl7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkxvYWRQcm9ncmVzcyh0aGlzLmdldExvYWRQZXJjZW50KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYodGhpcy5qdXN0TG9hZGVkKXtcbiAgICAgICAgICAgIHRoaXMuanVzdExvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYodGhpcy5vbkxvYWRDb21wbGV0ZSl7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkxvYWRDb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEEgY2xhc3MgcmVwcmVzZW50aW5nIGEgcmVmZXJlbmNlIHRvIGEgcmVzb3VyY2UuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIHRoZSBleGVtcHRpb24gbGlzdCB0byBhc3N1cmUgYXNzZXRzIGFuZCB0aGVpciBkZXBlbmRlbmNpZXMgZG9uJ3QgZ2V0XG4gKiBkZXN0cm95ZWQgaWYgdGhleSBhcmUgc3RpbGwgbmVlZGVkLlxuICovXG5jbGFzcyBSZXNvdXJjZVJlZmVyZW5jZSB7XG4gICAga2V5OiBzdHJpbmc7XG4gICAgcmVzb3VyY2VUeXBlOiBSZXNvdXJjZVR5cGU7XG4gICAgZGVwZW5kZW5jaWVzOiBBcnJheTxSZXNvdXJjZVJlZmVyZW5jZT47XG5cbiAgICBjb25zdHJ1Y3RvcihrZXk6IHN0cmluZywgcmVzb3VyY2VUeXBlOiBSZXNvdXJjZVR5cGUpe1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5yZXNvdXJjZVR5cGUgPSByZXNvdXJjZVR5cGU7XG4gICAgICAgIHRoaXMuIGRlcGVuZGVuY2llcyA9IG5ldyBBcnJheSgpO1xuICAgIH1cblxuICAgIGFkZERlcGVuZGVuY3kocmVzb3VyY2U6IFJlc291cmNlUmVmZXJlbmNlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzLnB1c2gocmVzb3VyY2UpO1xuICAgIH1cbn1cblxuXG5lbnVtIFJlc291cmNlVHlwZSB7XG4gICAgSU1BR0UgPSBcIklNQUdFXCIsXG4gICAgVElMRU1BUCA9IFwiVElMRU1BUFwiLFxuICAgIFNQUklURVNIRUVUID0gXCJTUFJJVEVTSEVFVFwiLFxuICAgIEFVRElPID0gXCJBVURJT1wiLFxuICAgIEpTT04gPSBcIkpTT05cIixcbiAgICBTSEFERVIgPSBcIlNIQURFUlwiXG59XG5cbi8qKlxuICogQSBwYWlyIHJlcHJlc2VudGluZyBhIGtleSBhbmQgdGhlIHBhdGggb2YgdGhlIHJlc291cmNlIHRvIGxvYWRcbiAqL1xuY2xhc3MgS2V5UGF0aFBhaXIge1xuICAgIGtleTogc3RyaW5nO1xuICAgIHBhdGg6IHN0cmluZztcbiAgICBpc0RlcGVuZGVuY3k/OiBib29sZWFuID0gZmFsc2U7XG59XG5cbmNsYXNzIEtleVBhdGhfU2hhZGVyIHtcbiAgICBrZXk6IHN0cmluZztcbiAgICB2cGF0aDogc3RyaW5nO1xuICAgIGZwYXRoOiBzdHJpbmc7XG59IiwiaW1wb3J0IFZpZXdwb3J0IGZyb20gXCIuL1ZpZXdwb3J0XCI7XG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lL1NjZW5lXCI7XG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XG5cbi8qKlxuICogQW4gYWJzdHJhY3QgaW50ZXJmYWNlIG9mIGEgU2NlbmVHcmFwaC5cbiAqIEV4cG9zZXMgbWV0aG9kcyBmb3IgdXNlIGJ5IG90aGVyIGNvZGUsIGJ1dCBsZWF2ZXMgdGhlIGltcGxlbWVudGF0aW9uIHVwIHRvIHRoZSBzdWJjbGFzc2VzLlxuICogVGhlIFNjZW5lR3JhcGggbWFuYWdlcyB0aGUgcG9zaXRpb25zIG9mIGFsbCBHYW1lTm9kZXMsIGFuZCBjYW4gZWFzaWx5IHBydW5lIGEgdmlzaWJsZSBzZXQgZm9yIHJlbmRlcmluZy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgU2NlbmVHcmFwaCB7XG5cdC8qKlx0QSByZWZlcmVuY2UgdG8gdGhlIHZpZXdwb3J0ICovXG5cdHByb3RlY3RlZCB2aWV3cG9ydDogVmlld3BvcnQ7XG5cdC8qKlx0QSBtYXAgb2YgQ2FudmFzTm9kZXMgaW4gdGhpcyBTY2VuZUdyYXBoICovXG5cdHByb3RlY3RlZCBub2RlTWFwOiBBcnJheTxDYW52YXNOb2RlPjtcblx0LyoqIEEgY291bnRlciBvZiBJRHMgZm9yIG5vZGVzIGluIHRoaXMgU2NlbmVHcmFwaCAqL1xuXHRwcm90ZWN0ZWQgaWRDb3VudGVyOiBudW1iZXI7XG5cdC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgU2NlbmUgdGhpcyBTY2VuZUdyYXBoIGJlbG9uZ3MgdG8gKi9cblx0cHJvdGVjdGVkIHNjZW5lOiBTY2VuZTtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyBTY2VuZUdyYXBoXG5cdCAqIEBwYXJhbSB2aWV3cG9ydCBUaGUgdmlld3BvcnRcblx0ICogQHBhcmFtIHNjZW5lIFRoZSBTY2VuZSB0aGlzIFNjZW5lR3JhcGggYmVsb25ncyB0b1xuXHQgKi9cbiAgICBjb25zdHJ1Y3Rvcih2aWV3cG9ydDogVmlld3BvcnQsIHNjZW5lOiBTY2VuZSl7XG5cdFx0dGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuXHRcdHRoaXMuc2NlbmUgPSBzY2VuZTtcblx0XHR0aGlzLm5vZGVNYXAgPSBuZXcgQXJyYXkoKTtcblx0XHR0aGlzLmlkQ291bnRlciA9IDA7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBBZGQgYSBub2RlIHRvIHRoZSBTY2VuZUdyYXBoXG5cdCAqIEBwYXJhbSBub2RlIFRoZSBDYW52YXNOb2RlIHRvIGFkZCB0byB0aGUgU2NlbmVHcmFwaFxuXHQgKiBAcmV0dXJucyBUaGUgU2NlbmVHcmFwaCBJRCBvZiB0aGlzIG5ld2x5IGFkZGVkIENhbnZhc05vZGVcblx0ICovXG4gICAgYWRkTm9kZShub2RlOiBDYW52YXNOb2RlKTogbnVtYmVyIHtcblx0XHR0aGlzLm5vZGVNYXBbbm9kZS5pZF0gPSBub2RlO1xuXHRcdHRoaXMuYWRkTm9kZVNwZWNpZmljKG5vZGUsIHRoaXMuaWRDb3VudGVyKTtcblx0XHR0aGlzLmlkQ291bnRlciArPSAxO1xuXHRcdHJldHVybiB0aGlzLmlkQ291bnRlciAtIDE7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFuIG92ZXJyaWRhYmxlIG1ldGhvZCB0byBhZGQgYSBDYW52YXNOb2RlIHRvIHRoZSBzcGVjaWZpYyBkYXRhIHN0cnVjdHVyZSBvZiB0aGUgU2NlbmVHcmFwaFxuXHQgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byBhZGQgdG8gdGhlIGRhdGEgc3RydWN0dXJlXG5cdCAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIENhbnZhc05vZGVcblx0ICovXG5cdHByb3RlY3RlZCBhYnN0cmFjdCBhZGROb2RlU3BlY2lmaWMobm9kZTogQ2FudmFzTm9kZSwgaWQ6IG51bWJlcik6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYSBub2RlIGZyb20gdGhlIFNjZW5lR3JhcGhcblx0ICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXG5cdCAqL1xuICAgIHJlbW92ZU5vZGUobm9kZTogQ2FudmFzTm9kZSk6IHZvaWQge1xuXHRcdC8vIEZpbmQgYW5kIHJlbW92ZSBub2RlIGluIE8obilcblx0XHR0aGlzLm5vZGVNYXBbbm9kZS5pZF0gPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5yZW1vdmVOb2RlU3BlY2lmaWMobm9kZSwgbm9kZS5pZCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBvZiByZW1vdmluZyBhIG5vZGVcblx0ICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXG5cdCAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIG5vZGUgdG8gcmVtb3ZlXG5cdCAqL1xuXHRwcm90ZWN0ZWQgYWJzdHJhY3QgcmVtb3ZlTm9kZVNwZWNpZmljKG5vZGU6IENhbnZhc05vZGUsIGlkOiBudW1iZXIpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBHZXQgYSBzcGVjaWZpYyBub2RlIHVzaW5nIGl0cyBpZFxuXHQgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBDYW52YXNOb2RlIHRvIHJldHJpZXZlXG5cdCAqIEByZXR1cm5zIFRoZSBub2RlIHdpdGggdGhpcyBJRFxuXHQgKi9cblx0Z2V0Tm9kZShpZDogbnVtYmVyKTogQ2FudmFzTm9kZSB7XG5cdFx0cmV0dXJuIHRoaXMubm9kZU1hcFtpZF07XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbm9kZXMgYXQgc3BlY2lmaWMgY29vcmRpbmF0ZXNcblx0ICogQHBhcmFtIHZlY09yWCBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBwb3NpdGlvbiwgb3IgdGhlIGNvb3JkaW5hdGVzIGluIGEgVmVjMlxuXHQgKiBAcGFyYW0geSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBwb3NpdGlvblxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBub2RlcyBmb3VuZCBhdCB0aGUgcG9zaXRpb24gcHJvdmlkZWRcblx0ICovXG4gICAgZ2V0Tm9kZXNBdCh2ZWNPclg6IFZlYzIgfCBudW1iZXIsIHk6IG51bWJlciA9IG51bGwpOiBBcnJheTxDYW52YXNOb2RlPiB7XG5cdFx0aWYodmVjT3JYIGluc3RhbmNlb2YgVmVjMil7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXROb2Rlc0F0Q29vcmRzKHZlY09yWC54LCB2ZWNPclgueSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLmdldE5vZGVzQXRDb29yZHModmVjT3JYLCB5KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbm9kZXMgdGhhdCBvdmVybGFwIGEgc3BlY2lmaWMgYm91bmRhcnlcblx0ICogQHBhcmFtIGJvdW5kYXJ5IFRoZSByZWdpb24gdG8gY2hlY2tcblx0ICogQHJldHVybnMgQW4gYXJyYXkgb2Ygbm9kZXMgZm91bmQgb3ZlcmxhcHBpbmcgdGhlIHByb3ZpZGVkIGJvdW5kYXJ5XG5cdCAqL1xuXHRhYnN0cmFjdCBnZXROb2Rlc0luUmVnaW9uKGJvdW5kYXJ5OiBBQUJCKTogQXJyYXk8Q2FudmFzTm9kZT47XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhbGwgbm9kZXMgaW4gdGhlIFNjZW5lR3JhcGhcblx0ICogQHJldHVybnMgQW4gQXJyYXkgY29udGFpbmluZyBhbGwgbm9kZXMgaW4gdGhlIFNjZW5lR3JhcGhcblx0ICovXG5cdGdldEFsbE5vZGVzKCk6IEFycmF5PENhbnZhc05vZGU+IHtcblx0XHRsZXQgYXJyID0gbmV3IEFycmF5PENhbnZhc05vZGU+KCk7XG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHRoaXMubm9kZU1hcC5sZW5ndGg7IGkrKyl7XG5cdFx0XHRpZih0aGlzLm5vZGVNYXBbaV0gIT09IHVuZGVmaW5lZCl7XG5cdFx0XHRcdGFyci5wdXNoKHRoaXMubm9kZU1hcFtpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBhcnI7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIG9mIGdldHRpbmcgYSBub2RlIGF0IGNlcnRhaW4gY29vcmRpbmF0ZXNcblx0ICogQHBhcmFtIHggVGhlIHgtY29vcmRpbmF0ZXMgb2YgdGhlIG5vZGVcblx0ICogQHBhcmFtIHkgVGhlIHktY29vcmRpbmF0ZXMgb2YgdGhlIG5vZGVcblx0ICovXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGdldE5vZGVzQXRDb29yZHMoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBBcnJheTxDYW52YXNOb2RlPjtcblxuXHRhYnN0cmFjdCB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkO1xuXHRcblx0YWJzdHJhY3QgcmVuZGVyKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogdm9pZDtcblxuXHQvKipcblx0ICogR2V0cyB0aGUgdmlzaWJsZSBzZXQgb2YgQ2FudmFzTm9kZXMgYmFzZWQgb24gdGhlIEByZWZlcmVuY2VbVmlld3BvcnRdXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIHZpc2libGUgbm9kZXMgaW4gdGhlIFNjZW5lR3JhcGhcblx0ICovXG4gICAgYWJzdHJhY3QgZ2V0VmlzaWJsZVNldCgpOiBBcnJheTxDYW52YXNOb2RlPjtcbn0iLCJpbXBvcnQgU2NlbmVHcmFwaCBmcm9tIFwiLi9TY2VuZUdyYXBoXCI7XG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xuaW1wb3J0IFZpZXdwb3J0IGZyb20gXCIuL1ZpZXdwb3J0XCI7XG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lL1NjZW5lXCI7XG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XG5pbXBvcnQgU3RhdHMgZnJvbSBcIi4uL0RlYnVnL1N0YXRzXCI7XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgYSBTY2VuZUdyYXBoIHRoYXQgc2ltcGx5IHN0b3JlZCBDYW52YXNOb2RlcyBpbiBhbiBhcnJheS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NlbmVHcmFwaEFycmF5IGV4dGVuZHMgU2NlbmVHcmFwaCB7XG4gICAgLyoqIFRoZSBsaXN0IG9mIENhbnZhc05vZGVzIGluIHRoaXMgU2NlbmVHcmFwaCAqL1xuICAgIHByaXZhdGUgbm9kZUxpc3Q6IEFycmF5PENhbnZhc05vZGU+O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTY2VuZUdyYXBoQXJyYXlcbiAgICAgKiBAcGFyYW0gdmlld3BvcnQgVGhlIFZpZXdwb3J0XG4gICAgICogQHBhcmFtIHNjZW5lIFRoZSBTY2VuZSB0aGlzIFNjZW5lR3JhcGggYmVsb25ncyB0b1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZpZXdwb3J0OiBWaWV3cG9ydCwgc2NlbmU6IFNjZW5lKXtcbiAgICAgICAgc3VwZXIodmlld3BvcnQsIHNjZW5lKTtcblxuICAgICAgICB0aGlzLm5vZGVMaXN0ID0gbmV3IEFycmF5PENhbnZhc05vZGU+KCk7XG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgcHJvdGVjdGVkIGFkZE5vZGVTcGVjaWZpYyhub2RlOiBDYW52YXNOb2RlLCBpZDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMubm9kZUxpc3QucHVzaChub2RlKTtcbiAgICB9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBwcm90ZWN0ZWQgcmVtb3ZlTm9kZVNwZWNpZmljKG5vZGU6IENhbnZhc05vZGUsIGlkOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5ub2RlTGlzdC5pbmRleE9mKG5vZGUpO1xuICAgICAgICBpZihpbmRleCA+IC0xKXtcbiAgICAgICAgICAgIHRoaXMubm9kZUxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEBvdmVycmlkZVxuICAgIGdldE5vZGVzQXRDb29yZHMoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBBcnJheTxDYW52YXNOb2RlPiB7XG4gICAgICAgIGxldCByZXN1bHRzID0gW107XG5cbiAgICAgICAgZm9yKGxldCBub2RlIG9mIHRoaXMubm9kZUxpc3Qpe1xuICAgICAgICAgICAgaWYobm9kZS5jb250YWlucyh4LCB5KSl7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgZ2V0Tm9kZXNJblJlZ2lvbihib3VuZGFyeTogQUFCQik6IEFycmF5PENhbnZhc05vZGU+IHtcbiAgICAgICAgbGV0IHQwID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGxldCByZXN1bHRzID0gW107XG5cbiAgICAgICAgZm9yKGxldCBub2RlIG9mIHRoaXMubm9kZUxpc3Qpe1xuICAgICAgICAgICAgaWYoYm91bmRhcnkub3ZlcmxhcHMobm9kZS5ib3VuZGFyeSkpe1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdDEgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgU3RhdHMubG9nKFwic2dxdWVyeVwiLCAodDEtdDApKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgbGV0IHQwID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGZvcihsZXQgbm9kZSBvZiB0aGlzLm5vZGVMaXN0KXtcbiAgICAgICAgICAgIGlmKCFub2RlLmdldExheWVyKCkuaXNQYXVzZWQoKSl7XG4gICAgICAgICAgICAgICAgbm9kZS51cGRhdGUoZGVsdGFUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdDEgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgU3RhdHMubG9nKFwic2d1cGRhdGVcIiwgKHQxLXQwKSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogdm9pZCB7fVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgZ2V0VmlzaWJsZVNldCgpOiBBcnJheTxDYW52YXNOb2RlPiB7XG4gICAgICAgIGxldCB2aXNpYmxlU2V0ID0gbmV3IEFycmF5PENhbnZhc05vZGU+KCk7XG5cbiAgICAgICAgZm9yKGxldCBub2RlIG9mIHRoaXMubm9kZUxpc3Qpe1xuICAgICAgICAgICAgaWYoIW5vZGUuZ2V0TGF5ZXIoKS5pc0hpZGRlbigpICYmIG5vZGUudmlzaWJsZSAmJiB0aGlzLnZpZXdwb3J0LmluY2x1ZGVzKG5vZGUpKXtcbiAgICAgICAgICAgICAgICB2aXNpYmxlU2V0LnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmlzaWJsZVNldDtcbiAgICB9XG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uL05vZGVzL0dhbWVOb2RlXCI7XG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vVXRpbHMvTWF0aFV0aWxzXCI7XG5pbXBvcnQgUXVldWUgZnJvbSBcIi4uL0RhdGFUeXBlcy9RdWV1ZVwiO1xuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xuaW1wb3J0IElucHV0IGZyb20gXCIuLi9JbnB1dC9JbnB1dFwiO1xuaW1wb3J0IFBhcmFsbGF4TGF5ZXIgZnJvbSBcIi4uL1NjZW5lL0xheWVycy9QYXJhbGxheExheWVyXCI7XG5pbXBvcnQgVUlMYXllciBmcm9tIFwiLi4vU2NlbmUvTGF5ZXJzL1VJTGF5ZXJcIjtcblxuLyoqXG4gKiBUaGUgdmlld3BvcnQgb2YgdGhlIGdhbWUuIENvcnJlc3BvbmRzIHRvIHRoZSB2aXNpYmxlIHdpbmRvdyBkaXNwbGF5ZWQgaW4gdGhlIGJyb3dzZXIuXG4gKiBUaGUgdmlld3BvcnQga2VlcHMgdHJhY2sgb2YgaXRzIHBvc2l0aW9uIGluIHRoZSBnYW1lIHdvcmxkLCBhbmQgY2FuIGFjdCBhcyBhIGNhbWVyYSB0byBmb2xsb3cgb2JqZWN0cy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlld3BvcnQge1xuICAgIC8qKiBUaGUgQUFCQiB0aGF0IGNvbnRhaW5zIHRoZSBwb3NpdGlvbiBhbmQgc2l6ZSBvZiB0aGUgdmlld3BvcnQgdmlldyAqL1xuICAgIHByaXZhdGUgdmlldzogQUFCQjtcbiAgICAvKiogVGhlIGJvdW5kYXJ5IGZvciB0aGUgdmlld3BvcnQuIFRoaXMgcmVwcmVzZW50cyB0aGUgbGltaXRzIHRvIHdoZXJlIHRoZSB2aWV3cG9ydCBjYW4gZ28gKi9cbiAgICBwcml2YXRlIGJvdW5kYXJ5OiBBQUJCO1xuICAgIC8qKiBUaGUgR2FtZU5vZGUgdGhlIFZpZXdwb3J0IGlzIGZvbGxvd2luZyAqL1xuICAgIHByaXZhdGUgZm9sbG93aW5nOiBHYW1lTm9kZTtcbiAgICAvKiogVGhlIHBvc2l0aW9uIHRoZSBHYW1lTm9kZSBpcyBmb2N1c2luZyBvbi4gVGhpcyBpcyBvdmVycmlkZGVuIGlmIFwiZm9sbG93aW5nXCIgaXMgc2V0LiAqL1xuICAgIHByaXZhdGUgZm9jdXM6IFZlYzI7XG5cbiAgICAvKiogQSBxdWV1ZSBvZiBwcmV2aW91cyBwb3NpdGlvbnMgb2Ygd2hhdCB0aGlzIHZpZXdwb3J0IGlzIGZvbGxvd2luZy4gVXNlZCBmb3Igc21vb3RoaW5nIHZpZXdwb3J0IG1vdmVtZW50ICovXG4gICAgcHJpdmF0ZSBsYXN0UG9zaXRpb25zOiBRdWV1ZTxWZWMyPjtcblxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIHByZXZpb3VzIHBvc2l0aW9ucyB0aGlzIHZpZXdwb3J0IHRyYWNrcyAqL1xuICAgIHByaXZhdGUgc21vb3RoaW5nRmFjdG9yOiBudW1iZXI7XG5cbiAgICAvKiogQSBib29sZWFuIHRoYSByZXByZXNlbnRzIHdoZXRoZXIgdGhlIHBsYXllciBjYW4gem9vbSBieSBzY3JvbGxpbmcgd2l0aCB0aGUgbW91c2Ugd2hlZWwgKi9cbiAgICBwcml2YXRlIHNjcm9sbFpvb21FbmFibGVkOiBib29sZWFuO1xuXG4gICAgLyoqIFRoZSBhbW91bnQgdGhhdCBpcyB6b29tZWQgaW4gb3Igb3V0LiAqL1xuICAgIHByaXZhdGUgWk9PTV9GQUNUT1I6IG51bWJlciA9IDEuMjtcblxuICAgIC8qKiBUaGUgc2l6ZSBvZiB0aGUgY2FudmFzICovXG4gICAgcHJpdmF0ZSBjYW52YXNTaXplOiBWZWMyO1xuXG4gICAgY29uc3RydWN0b3IoY2FudmFzU2l6ZTogVmVjMiwgem9vbUxldmVsOiBudW1iZXIpe1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgQUFCQihWZWMyLlpFUk8sIFZlYzIuWkVSTyk7XG4gICAgICAgIHRoaXMuYm91bmRhcnkgPSBuZXcgQUFCQihWZWMyLlpFUk8sIFZlYzIuWkVSTyk7XG4gICAgICAgIHRoaXMubGFzdFBvc2l0aW9ucyA9IG5ldyBRdWV1ZSgpO1xuICAgICAgICB0aGlzLnNtb290aGluZ0ZhY3RvciA9IDEwO1xuICAgICAgICB0aGlzLnNjcm9sbFpvb21FbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FudmFzU2l6ZSA9IFZlYzIuWkVSTztcbiAgICAgICAgdGhpcy5mb2N1cyA9IFZlYzIuWkVSTztcblxuICAgICAgICAvLyBTZXQgdGhlIHNpemUgb2YgdGhlIGNhbnZhc1xuICAgICAgICB0aGlzLnNldENhbnZhc1NpemUoY2FudmFzU2l6ZSk7XG5cbiAgICAgICAgLy8gU2V0IHRoZSBzaXplIG9mIHRoZSB2aWV3cG9ydFxuICAgICAgICB0aGlzLnNldFNpemUoY2FudmFzU2l6ZSk7XG4gICAgICAgIHRoaXMuc2V0Wm9vbUxldmVsKHpvb21MZXZlbCk7XG5cbiAgICAgICAgLy8gU2V0IHRoZSBjZW50ZXIgKGFuZCBtYWtlIHRoZSB2aWV3cG9ydCBzdGF5IHRoZXJlKVxuICAgICAgICB0aGlzLnNldENlbnRlcih0aGlzLnZpZXcuaGFsZlNpemUuY2xvbmUoKSk7XG4gICAgICAgIHRoaXMuc2V0Rm9jdXModGhpcy52aWV3LmhhbGZTaXplLmNsb25lKCkpO1xuICAgIH1cblxuICAgIC8qKiBFbmFibGVzIHRoZSB2aWV3cG9ydCB0byB6b29tIGluIGFuZCBvdXQgKi9cbiAgICBlbmFibGVab29tKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnNjcm9sbFpvb21FbmFibGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcmV0dXJucyBUaGUgY2VudGVyIG9mIHRoZSB2aWV3cG9ydCBhcyBhIFZlYzJcbiAgICAgKi9cbiAgICBnZXRDZW50ZXIoKTogVmVjMiB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuY2VudGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgVmVjMiB3aXRoIHRoZSBvcmlnaW4gb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHJldHVybnMgVGhlIHRvcCBsZWZ0IGNvcm5kZXIgb2YgdGhlIFZpZXBvcnQgYXMgYSBWZWMyXG4gICAgICovXG4gICAgZ2V0T3JpZ2luKCk6IFZlYzIge1xuICAgICAgICByZXR1cm4gbmV3IFZlYzIodGhpcy52aWV3LmxlZnQsIHRoaXMudmlldy50b3ApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJlZ2lvbiB2aXNpYmxlIHRvIHRoaXMgdmlld3BvcnRcbiAgICAgKiBAcmV0dXJucyBUaGUgQUFCQiBjb250YWluaW5nIHRoZSByZWdpb24gdmlzaWJsZSB0byB0aGUgdmlld3BvcnRcbiAgICAgKi9cbiAgICBnZXRWaWV3KCk6IEFBQkIge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcG9zaXRpb24gb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHZlY09yWCBUaGUgbmV3IHBvc2l0aW9uIG9yIHRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIG5ldyBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB5IFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIG5ldyBwb3NpdGlvblxuICAgICAqL1xuICAgIHNldENlbnRlcih2ZWNPclg6IFZlYzIgfCBudW1iZXIsIHk6IG51bWJlciA9IG51bGwpOiB2b2lkIHtcbiAgICAgICAgbGV0IHBvczogVmVjMjtcblx0XHRpZih2ZWNPclggaW5zdGFuY2VvZiBWZWMyKXtcbiAgICAgICAgICAgIHBvcyA9IHZlY09yWDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvcyA9IG5ldyBWZWMyKHZlY09yWCwgeSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZpZXcuY2VudGVyID0gcG9zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIHZpZXdwb3J0IGFzIGEgVmVjMlxuICAgICAqIEByZXR1cm5zIFRoZSBoYWxmLXNpemUgb2YgdGhlIHZpZXdwb3J0IGFzIGEgVmVjMlxuICAgICAqL1xuICAgIGdldEhhbGZTaXplKCk6IFZlYzIge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmdldEhhbGZTaXplKCk7XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNpemUgb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHZlY09yWCBUaGUgbmV3IHdpZHRoIG9mIHRoZSB2aWV3cG9ydCBvciB0aGUgbmV3IHNpemUgYXMgYSBWZWMyXG4gICAgICogQHBhcmFtIHkgVGhlIG5ldyBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0XG4gICAgICovXG4gICAgc2V0U2l6ZSh2ZWNPclg6IFZlYzIgfCBudW1iZXIsIHk6IG51bWJlciA9IG51bGwpOiB2b2lkIHtcblx0XHRpZih2ZWNPclggaW5zdGFuY2VvZiBWZWMyKXtcblx0XHRcdHRoaXMudmlldy5zZXRIYWxmU2l6ZSh2ZWNPclguc2NhbGVkKDEvMikpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnZpZXcuc2V0SGFsZlNpemUobmV3IFZlYzIodmVjT3JYLzIsIHkvMikpO1xuXHRcdH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBoYWxmLXNpemUgb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHZlY09yWCBUaGUgbmV3IGhhbGYtd2lkdGggb2YgdGhlIHZpZXdwb3J0IG9yIHRoZSBuZXcgaGFsZi1zaXplIGFzIGEgVmVjMlxuICAgICAqIEBwYXJhbSB5IFRoZSBuZXcgaGVpZ2h0IG9mIHRoZSB2aWV3cG9ydFxuICAgICAqL1xuICAgIHNldEhhbGZTaXplKHZlY09yWDogVmVjMiB8IG51bWJlciwgeTogbnVtYmVyID0gbnVsbCk6IHZvaWQge1xuXHRcdGlmKHZlY09yWCBpbnN0YW5jZW9mIFZlYzIpe1xuXHRcdFx0dGhpcy52aWV3LnNldEhhbGZTaXplKHZlY09yWC5jbG9uZSgpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy52aWV3LnNldEhhbGZTaXplKG5ldyBWZWMyKHZlY09yWCwgeSkpO1xuXHRcdH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB2aWV3cG9ydCB3aXRoIHRoZSBzaXplIG9mIHRoZSBjdXJyZW50IENhbnZhc1xuICAgICAqIEBwYXJhbSB2ZWNPclggVGhlIHdpZHRoIG9mIHRoZSBjYW52YXMsIG9yIHRoZSBjYW52YXMgc2l6ZSBhcyBhIFZlYzJcbiAgICAgKiBAcGFyYW0geSBUaGUgaGVpZ2h0IG9mIHRoZSBjYW52YXNcbiAgICAgKi9cbiAgICBzZXRDYW52YXNTaXplKHZlY09yWDogVmVjMiB8IG51bWJlciwgeTogbnVtYmVyID0gbnVsbCk6IHZvaWQge1xuXHRcdGlmKHZlY09yWCBpbnN0YW5jZW9mIFZlYzIpe1xuXHRcdFx0dGhpcy5jYW52YXNTaXplID0gdmVjT3JYLmNsb25lKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuY2FudmFzU2l6ZSA9IG5ldyBWZWMyKHZlY09yWCwgeSk7XG5cdFx0fVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHpvb20gbGV2ZWwgb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHpvb20gVGhlIHpvb20gbGV2ZWxcbiAgICAgKi9cbiAgICBzZXRab29tTGV2ZWwoem9vbTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMudmlldy5oYWxmU2l6ZS5jb3B5KHRoaXMuY2FudmFzU2l6ZS5zY2FsZWQoMS96b29tLzIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB6b29tIGxldmVsIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqIEByZXR1cm5zIFRoZSB6b29tIGxldmVsXG4gICAgICovXG4gICAgZ2V0Wm9vbUxldmVsKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhc1NpemUueC90aGlzLnZpZXcuaHcvMlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNtb290aGluZyBmYWN0b3IgZm9yIHRoZSB2aWV3cG9ydCBtb3ZlbWVudC5cbiAgICAgKiBAcGFyYW0gc21vb3RoaW5nRmFjdG9yIFRoZSBzbW9vdGhpbmcgZmFjdG9yIGZvciB0aGUgdmlld3BvcnRcbiAgICAgKi9cbiAgICBzZXRTbW9vdGhpbmdGYWN0b3Ioc21vb3RoaW5nRmFjdG9yOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgaWYoc21vb3RoaW5nRmFjdG9yIDwgMSkgc21vb3RoaW5nRmFjdG9yID0gMTtcbiAgICAgICAgdGhpcy5zbW9vdGhpbmdGYWN0b3IgPSBzbW9vdGhpbmdGYWN0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgdGhlIHZpZXdwb3J0IHRvIGZvY3VzIG9uIGEgcG9pbnQuIE92ZXJpZGRlbiBieSBcImZvbGxvd2luZ1wiLlxuICAgICAqIEBwYXJhbSBmb2N1cyBUaGUgcG9pbnQgdGhlICB2aWV3cG9ydCBzaG91bGQgZm9jdXMgb25cbiAgICAgKi9cbiAgICBzZXRGb2N1cyhmb2N1czogVmVjMik6IHZvaWQge1xuICAgICAgICB0aGlzLmZvY3VzLmNvcHkoZm9jdXMpO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIENhbnZhc05vZGUgaXMgaW5zaWRlIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIGNoZWNrXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgbm9kZSBpcyBjdXJyZW50bHkgdmlzaWJsZSBpbiB0aGUgdmlld3BvcnQsIGZhbHNlIGlmIG5vdFxuICAgICAqL1xuICAgIGluY2x1ZGVzKG5vZGU6IENhbnZhc05vZGUpOiBib29sZWFuIHtcbiAgICAgICAgbGV0IHBhcmFsbGF4ID0gbm9kZS5nZXRMYXllcigpIGluc3RhbmNlb2YgUGFyYWxsYXhMYXllciB8fCBub2RlLmdldExheWVyKCkgaW5zdGFuY2VvZiBVSUxheWVyID8gKDxQYXJhbGxheExheWVyPm5vZGUuZ2V0TGF5ZXIoKSkucGFyYWxsYXggOiBuZXcgVmVjMigxLCAxKTtcbiAgICAgICAgbGV0IGNlbnRlciA9IHRoaXMudmlldy5jZW50ZXIuY2xvbmUoKTtcbiAgICAgICAgdGhpcy52aWV3LmNlbnRlci5tdWx0KHBhcmFsbGF4KTtcbiAgICAgICAgbGV0IG92ZXJsYXBzID0gdGhpcy52aWV3Lm92ZXJsYXBzKG5vZGUuYm91bmRhcnkpO1xuICAgICAgICB0aGlzLnZpZXcuY2VudGVyID0gY2VudGVyXG4gICAgICAgIHJldHVybiBvdmVybGFwcztcbiAgICB9XG5cblx0Ly8gVE9ETzogUHV0IHNvbWUgZXJyb3IgaGFuZGxpbmcgb24gdGhpcyBmb3IgdHJ5aW5nIHRvIG1ha2UgdGhlIGJvdW5kcyB0b28gc21hbGwgZm9yIHRoZSB2aWV3cG9ydFxuICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIHByb2JhYmx5IGJlIGRvbmUgYXV0b21hdGljYWxseSwgb3Igc2hvdWxkIGNvbnNpZGVyIHRoZSBhc3BlY3QgcmF0aW8gb3Igc29tZXRoaW5nXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYm91bmRzIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSBsb3dlclggVGhlIGxlZnQgZWRnZSBvZiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcGFyYW0gbG93ZXJZIFRoZSB0b3AgZWRnZSBvZiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcGFyYW0gdXBwZXJYIFRoZSByaWdodCBlZGdlIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSB1cHBlclkgVGhlIGJvdHRvbSBlZGdlIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqL1xuICAgIHNldEJvdW5kcyhsb3dlclg6IG51bWJlciwgbG93ZXJZOiBudW1iZXIsIHVwcGVyWDogbnVtYmVyLCB1cHBlclk6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBsZXQgaHdpZHRoID0gKHVwcGVyWCAtIGxvd2VyWCkvMjtcbiAgICAgICAgbGV0IGhoZWlnaHQgPSAodXBwZXJZIC0gbG93ZXJZKS8yO1xuICAgICAgICBsZXQgeCA9IGxvd2VyWCArIGh3aWR0aDtcbiAgICAgICAgbGV0IHkgPSBsb3dlclkgKyBoaGVpZ2h0O1xuICAgICAgICB0aGlzLmJvdW5kYXJ5LmNlbnRlci5zZXQoeCwgeSk7XG4gICAgICAgIHRoaXMuYm91bmRhcnkuaGFsZlNpemUuc2V0KGh3aWR0aCwgaGhlaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZSB0aGUgdmlld3BvcnQgZm9sbG93IHRoZSBzcGVjaWZpZWQgR2FtZU5vZGVcbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgR2FtZU5vZGUgdG8gZm9sbG93XG4gICAgICovXG4gICAgZm9sbG93KG5vZGU6IEdhbWVOb2RlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZm9sbG93aW5nID0gbm9kZTtcbiAgICB9XG5cbiAgICB1cGRhdGVWaWV3KCk6IHZvaWQge1xuICAgICAgICBpZih0aGlzLmxhc3RQb3NpdGlvbnMuZ2V0U2l6ZSgpID4gdGhpcy5zbW9vdGhpbmdGYWN0b3Ipe1xuICAgICAgICAgICAgdGhpcy5sYXN0UG9zaXRpb25zLmRlcXVldWUoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gR2V0IHRoZSBhdmVyYWdlIG9mIHRoZSBsYXN0IDEwIHBvc2l0aW9uc1xuICAgICAgICBsZXQgcG9zID0gVmVjMi5aRVJPO1xuICAgICAgICB0aGlzLmxhc3RQb3NpdGlvbnMuZm9yRWFjaChwb3NpdGlvbiA9PiBwb3MuYWRkKHBvc2l0aW9uKSk7XG4gICAgICAgIHBvcy5zY2FsZSgxL3RoaXMubGFzdFBvc2l0aW9ucy5nZXRTaXplKCkpO1xuXG4gICAgICAgIC8vIFNldCB0aGlzIHBvc2l0aW9uIGVpdGhlciB0byB0aGUgb2JqZWN0IG9yIHRvIGl0cyBib3VuZHNcbiAgICAgICAgcG9zLnggPSBNYXRoVXRpbHMuY2xhbXAocG9zLngsIHRoaXMuYm91bmRhcnkubGVmdCArIHRoaXMudmlldy5odywgdGhpcy5ib3VuZGFyeS5yaWdodCAtIHRoaXMudmlldy5odyk7XG4gICAgICAgIHBvcy55ID0gTWF0aFV0aWxzLmNsYW1wKHBvcy55LCB0aGlzLmJvdW5kYXJ5LnRvcCArIHRoaXMudmlldy5oaCwgdGhpcy5ib3VuZGFyeS5ib3R0b20gLSB0aGlzLnZpZXcuaGgpO1xuXG4gICAgICAgIC8vIEFzc3VyZSB0aGVyZSBhcmUgbm8gbGluZXMgaW4gdGhlIHRpbGVtYXBcbiAgICAgICAgcG9zLnggPSBNYXRoLmZsb29yKHBvcy54KTtcbiAgICAgICAgcG9zLnkgPSBNYXRoLmZsb29yKHBvcy55KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMudmlldy5jZW50ZXIuY29weShwb3MpO1xuICAgIH1cblxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICAvLyBJZiB6b29tIGlzIGVuYWJsZWRcbiAgICAgICAgaWYodGhpcy5zY3JvbGxab29tRW5hYmxlZCl7XG4gICAgICAgICAgICBpZihJbnB1dC5kaWRKdXN0U2Nyb2xsKCkpe1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50U2l6ZSA9IHRoaXMudmlldy5nZXRIYWxmU2l6ZSgpLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgaWYoSW5wdXQuZ2V0U2Nyb2xsRGlyZWN0aW9uKCkgPCAwKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gWm9vbSBpblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2l6ZS5zY2FsZSgxL3RoaXMuWk9PTV9GQUNUT1IpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFpvb20gb3V0XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaXplLnNjYWxlKHRoaXMuWk9PTV9GQUNUT1IpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRTaXplLnggPiB0aGlzLmJvdW5kYXJ5Lmh3KXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZhY3RvciA9IHRoaXMuYm91bmRhcnkuaHcvY3VycmVudFNpemUueDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNpemUueCA9IHRoaXMuYm91bmRhcnkuaHc7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaXplLnkgKj0gZmFjdG9yO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRTaXplLnkgPiB0aGlzLmJvdW5kYXJ5LmhoKXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZhY3RvciA9IHRoaXMuYm91bmRhcnkuaGgvY3VycmVudFNpemUueTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNpemUueSA9IHRoaXMuYm91bmRhcnkuaGg7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaXplLnggKj0gZmFjdG9yO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5zZXRIYWxmU2l6ZShjdXJyZW50U2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB2aWV3cG9ydCBpcyBmb2xsb3dpbmcgYW4gb2JqZWN0XG4gICAgICAgIGlmKHRoaXMuZm9sbG93aW5nKXtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBvdXIgbGlzdCBvZiBwcmV2aW91cyBwb3NpdGlvbnNcbiAgICAgICAgICAgIHRoaXMubGFzdFBvc2l0aW9ucy5lbnF1ZXVlKHRoaXMuZm9sbG93aW5nLnBvc2l0aW9uLmNsb25lKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sYXN0UG9zaXRpb25zLmVucXVldWUodGhpcy5mb2N1cyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZVZpZXcoKTtcbiAgICB9XG59IiwiaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZVwiO1xuaW1wb3J0IFVJRWxlbWVudCBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50XCI7XG5pbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY1wiO1xuaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi4vLi4vTm9kZXMvU3ByaXRlcy9TcHJpdGVcIjtcbmltcG9ydCBBbmltYXRlZFNwcml0ZSBmcm9tIFwiLi4vLi4vTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZVwiO1xuaW1wb3J0IHsgR3JhcGhpY1R5cGUgfSBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvR3JhcGhpY1R5cGVzXCI7XG5pbXBvcnQgeyBVSUVsZW1lbnRUeXBlIH0gZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvVUlFbGVtZW50VHlwZXNcIjtcbmltcG9ydCBQb2ludCBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvUG9pbnRcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEJ1dHRvbiBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9CdXR0b25cIjtcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xuaW1wb3J0IFNsaWRlciBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9TbGlkZXJcIjtcbmltcG9ydCBUZXh0SW5wdXQgZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvVGV4dElucHV0XCI7XG5pbXBvcnQgUmVjdCBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvUmVjdFwiO1xuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xuaW1wb3J0IExpbmUgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL0xpbmVcIjtcbmltcG9ydCBQYXJ0aWNsZSBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvUGFydGljbGVcIjtcblxuLy8gQGlnbm9yZVBhZ2VcblxuLyoqXG4gKiBBIGZhY3RvcnkgdGhhdCBhYnN0cmFjdHMgYWRkaW5nIEByZWZlcmVuY2VbQ2FudmFzTm9kZV1zIHRvIHRoZSBAcmVmZXJlbmNlW1NjZW5lXS5cbiAqIEFjY2VzcyBtZXRob2RzIGluIHRoaXMgZmFjdG9yeSB0aHJvdWdoIFNjZW5lLmFkZC5bbWV0aG9kTmFtZV0oKS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FudmFzTm9kZUZhY3Rvcnkge1xuXHRwcm90ZWN0ZWQgc2NlbmU6IFNjZW5lO1xuXHRwcm90ZWN0ZWQgcmVzb3VyY2VNYW5hZ2VyOiBSZXNvdXJjZU1hbmFnZXI7XG5cblx0aW5pdChzY2VuZTogU2NlbmUpOiB2b2lkIHtcblx0XHR0aGlzLnNjZW5lID0gc2NlbmU7XG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGFuIGluc3RhbmNlIG9mIGEgVUlFbGVtZW50IHRvIHRoZSBjdXJyZW50IHNjZW5lIC0gaS5lLiBhbnkgY2xhc3MgdGhhdCBleHRlbmRzIFVJRWxlbWVudFxuXHQgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiBVSUVsZW1lbnQgdG8gYWRkXG5cdCAqIEBwYXJhbSBsYXllck5hbWUgVGhlIGxheWVyIHRvIGFkZCB0aGUgVUlFbGVtZW50IHRvXG5cdCAqIEBwYXJhbSBvcHRpb25zIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBmZWVkIHRvIHRoZSBjb25zdHJ1Y3RvclxuXHQgKiBAcmV0dXJucyBBIG5ldyBVSUVsZW1lbnRcblx0ICovXG5cdGFkZFVJRWxlbWVudCA9ICh0eXBlOiBzdHJpbmcgfCBVSUVsZW1lbnRUeXBlLCBsYXllck5hbWU6IHN0cmluZywgb3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiBVSUVsZW1lbnQgPT4ge1xuXHRcdC8vIEdldCB0aGUgbGF5ZXJcblx0XHRsZXQgbGF5ZXIgPSB0aGlzLnNjZW5lLmdldExheWVyKGxheWVyTmFtZSk7XG5cblx0XHRsZXQgaW5zdGFuY2U6IFVJRWxlbWVudDtcblxuXHRcdHN3aXRjaCh0eXBlKXtcblx0XHRcdGNhc2UgVUlFbGVtZW50VHlwZS5CVVRUT046XG5cdFx0XHRcdGluc3RhbmNlID0gdGhpcy5idWlsZEJ1dHRvbihvcHRpb25zKTtcblx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBVSUVsZW1lbnRUeXBlLkxBQkVMOlxuXHRcdFx0XHRpbnN0YW5jZSA9IHRoaXMuYnVpbGRMYWJlbChvcHRpb25zKTtcblx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBVSUVsZW1lbnRUeXBlLlNMSURFUjpcblx0XHRcdFx0aW5zdGFuY2UgPSB0aGlzLmJ1aWxkU2xpZGVyKG9wdGlvbnMpO1xuXHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFVJRWxlbWVudFR5cGUuVEVYVF9JTlBVVDpcblx0XHRcdFx0aW5zdGFuY2UgPSB0aGlzLmJ1aWxkVGV4dElucHV0KG9wdGlvbnMpO1xuXHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyBgVUlFbGVtZW50VHlwZSAnJHt0eXBlfScgZG9lcyBub3QgZXhpc3QsIG9yIGlzIHJlZ2lzdGVyZWQgaW5jb3JyZWN0bHkuYFxuXHRcdH1cblxuXHRcdGluc3RhbmNlLnNldFNjZW5lKHRoaXMuc2NlbmUpO1xuXHRcdGluc3RhbmNlLmlkID0gdGhpcy5zY2VuZS5nZW5lcmF0ZUlkKCk7XG5cdFx0dGhpcy5zY2VuZS5nZXRTY2VuZUdyYXBoKCkuYWRkTm9kZShpbnN0YW5jZSk7XG5cblx0XHQvLyBBZGQgaW5zdGFuY2UgdG8gbGF5ZXJcblx0XHRsYXllci5hZGROb2RlKGluc3RhbmNlKVxuXG5cdFx0cmV0dXJuIGluc3RhbmNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBzcHJpdGUgdG8gdGhlIGN1cnJlbnQgc2NlbmVcblx0ICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpbWFnZSB0aGUgc3ByaXRlIHdpbGwgcmVwcmVzZW50XG5cdCAqIEBwYXJhbSBsYXllck5hbWUgVGhlIGxheWVyIG9uIHdoaWNoIHRvIGFkZCB0aGUgc3ByaXRlXG5cdCAqIEByZXR1cm5zIEEgbmV3IFNwcml0ZVxuXHQgKi9cblx0YWRkU3ByaXRlID0gKGtleTogc3RyaW5nLCBsYXllck5hbWU6IHN0cmluZyk6IFNwcml0ZSA9PiB7XG5cdFx0bGV0IGxheWVyID0gdGhpcy5zY2VuZS5nZXRMYXllcihsYXllck5hbWUpO1xuXG5cdFx0bGV0IGluc3RhbmNlID0gbmV3IFNwcml0ZShrZXkpO1xuXG5cdFx0Ly8gQWRkIGluc3RhbmNlIHRvIHNjZW5lXG5cdFx0aW5zdGFuY2Uuc2V0U2NlbmUodGhpcy5zY2VuZSk7XG5cdFx0aW5zdGFuY2UuaWQgPSB0aGlzLnNjZW5lLmdlbmVyYXRlSWQoKTtcblxuXHRcdGlmKCEodGhpcy5zY2VuZS5pc1BhcmFsbGF4TGF5ZXIobGF5ZXJOYW1lKSB8fCB0aGlzLnNjZW5lLmlzVUlMYXllcihsYXllck5hbWUpKSl7XG5cdFx0XHR0aGlzLnNjZW5lLmdldFNjZW5lR3JhcGgoKS5hZGROb2RlKGluc3RhbmNlKTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gQWRkIGluc3RhbmNlIHRvIGxheWVyXG5cdFx0bGF5ZXIuYWRkTm9kZShpbnN0YW5jZSk7XG5cblx0XHRyZXR1cm4gaW5zdGFuY2U7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhbiBBbmltYXRlZFNwcml0ZSB0byB0aGUgY3VycmVudCBzY2VuZVxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGltYWdlIHRoZSBzcHJpdGUgd2lsbCByZXByZXNlbnRcblx0ICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgb24gd2hpY2ggdG8gYWRkIHRoZSBzcHJpdGVcblx0ICogQHJldHVybnMgQSBuZXcgQW5pbWF0ZWRTcHJpdGVcblx0ICovXG5cdGFkZEFuaW1hdGVkU3ByaXRlID0gKGtleTogc3RyaW5nLCBsYXllck5hbWU6IHN0cmluZyk6IEFuaW1hdGVkU3ByaXRlID0+IHtcblx0XHRsZXQgbGF5ZXIgPSB0aGlzLnNjZW5lLmdldExheWVyKGxheWVyTmFtZSk7XG5cdFx0bGV0IHNwcml0ZXNoZWV0ID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0U3ByaXRlc2hlZXQoa2V5KTtcblx0XHRsZXQgaW5zdGFuY2UgPSBuZXcgQW5pbWF0ZWRTcHJpdGUoc3ByaXRlc2hlZXQpO1xuXG5cdFx0Ly8gQWRkIGluc3RhbmNlIGZvIHNjZW5lXG5cdFx0aW5zdGFuY2Uuc2V0U2NlbmUodGhpcy5zY2VuZSk7XG5cdFx0aW5zdGFuY2UuaWQgPSB0aGlzLnNjZW5lLmdlbmVyYXRlSWQoKTtcblx0XHRcblx0XHRpZighKHRoaXMuc2NlbmUuaXNQYXJhbGxheExheWVyKGxheWVyTmFtZSkgfHwgdGhpcy5zY2VuZS5pc1VJTGF5ZXIobGF5ZXJOYW1lKSkpe1xuXHRcdFx0dGhpcy5zY2VuZS5nZXRTY2VuZUdyYXBoKCkuYWRkTm9kZShpbnN0YW5jZSk7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIGluc3RhbmNlIHRvIGxheWVyXG5cdFx0bGF5ZXIuYWRkTm9kZShpbnN0YW5jZSk7XG5cblx0XHRyZXR1cm4gaW5zdGFuY2U7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIG5ldyBncmFwaGljIGVsZW1lbnQgdG8gdGhlIGN1cnJlbnQgU2NlbmVcblx0ICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgZ3JhcGhpYyB0byBhZGRcblx0ICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgb24gd2hpY2ggdG8gYWRkIHRoZSBncmFwaGljXG5cdCAqIEBwYXJhbSBvcHRpb25zIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBzZW5kIHRvIHRoZSBncmFwaGljIGNvbnN0cnVjdG9yXG5cdCAqIEByZXR1cm5zIEEgbmV3IEdyYXBoaWNcblx0ICovXG5cdGFkZEdyYXBoaWMgPSAodHlwZTogR3JhcGhpY1R5cGUgfCBzdHJpbmcsIGxheWVyTmFtZTogc3RyaW5nLCBvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IEdyYXBoaWMgPT4ge1xuXHRcdC8vIEdldCB0aGUgbGF5ZXJcblx0XHRsZXQgbGF5ZXIgPSB0aGlzLnNjZW5lLmdldExheWVyKGxheWVyTmFtZSk7XG5cblx0XHRsZXQgaW5zdGFuY2U6IEdyYXBoaWM7XG5cblx0XHRzd2l0Y2godHlwZSl7XG5cdFx0XHRjYXNlIEdyYXBoaWNUeXBlLlBPSU5UOlxuXHRcdFx0XHRpbnN0YW5jZSA9IHRoaXMuYnVpbGRQb2ludChvcHRpb25zKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIEdyYXBoaWNUeXBlLkxJTkU6XG5cdFx0XHRcdGluc3RhbmNlID0gdGhpcy5idWlsZExpbmUob3B0aW9ucyk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBHcmFwaGljVHlwZS5SRUNUOlxuXHRcdFx0XHRpbnN0YW5jZSA9IHRoaXMuYnVpbGRSZWN0KG9wdGlvbnMpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgR3JhcGhpY1R5cGUuUEFSVElDTEU6XG5cdFx0XHRcdGluc3RhbmNlID0gdGhpcy5idWlsZFBhcnRpY2xlKG9wdGlvbnMpO1xuXHRcdFx0XHRicmVhaztcdFx0XHRcdFxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgYEdyYXBoaWNUeXBlICcke3R5cGV9JyBkb2VzIG5vdCBleGlzdCwgb3IgaXMgcmVnaXN0ZXJlZCBpbmNvcnJlY3RseS5gXG5cdFx0fVxuXG5cdFx0Ly8gQWRkIGluc3RhbmNlIHRvIHNjZW5lXG5cdFx0aW5zdGFuY2Uuc2V0U2NlbmUodGhpcy5zY2VuZSk7XG5cdFx0aW5zdGFuY2UuaWQgPSB0aGlzLnNjZW5lLmdlbmVyYXRlSWQoKTtcblxuXHRcdGlmKCEodGhpcy5zY2VuZS5pc1BhcmFsbGF4TGF5ZXIobGF5ZXJOYW1lKSB8fCB0aGlzLnNjZW5lLmlzVUlMYXllcihsYXllck5hbWUpKSl7XG5cdFx0XHR0aGlzLnNjZW5lLmdldFNjZW5lR3JhcGgoKS5hZGROb2RlKGluc3RhbmNlKTtcblx0XHR9XG5cblx0XHQvLyBBZGQgaW5zdGFuY2UgdG8gbGF5ZXJcblx0XHRsYXllci5hZGROb2RlKGluc3RhbmNlKTtcblxuXHRcdHJldHVybiBpbnN0YW5jZTtcblx0fVxuXG5cdC8qIC0tLS0tLS0tLS0gQlVJTERFUlMgLS0tLS0tLS0tLSAqL1xuXG5cdGJ1aWxkQnV0dG9uKG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogQnV0dG9uIHtcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiQnV0dG9uXCIsIG9wdGlvbnMsIFwicG9zaXRpb25cIiwgVmVjMiwgXCJWZWMyXCIpO1xuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJCdXR0b25cIiwgb3B0aW9ucywgXCJ0ZXh0XCIsIFwic3RyaW5nXCIpO1xuXG5cdFx0cmV0dXJuIG5ldyBCdXR0b24ob3B0aW9ucy5wb3NpdGlvbiwgb3B0aW9ucy50ZXh0KTtcblx0fVxuXG5cdGJ1aWxkTGFiZWwob3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiBMYWJlbCB7XG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIkxhYmVsXCIsIG9wdGlvbnMsIFwicG9zaXRpb25cIiwgVmVjMiwgXCJWZWMyXCIpO1xuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJMYWJlbFwiLCBvcHRpb25zLCBcInRleHRcIiwgXCJzdHJpbmdcIik7XG5cblx0XHRyZXR1cm4gbmV3IExhYmVsKG9wdGlvbnMucG9zaXRpb24sIG9wdGlvbnMudGV4dClcblx0fVxuXG5cdGJ1aWxkU2xpZGVyKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBTbGlkZXIge1xuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJTbGlkZXJcIiwgb3B0aW9ucywgXCJwb3NpdGlvblwiLCBWZWMyLCBcIlZlYzJcIik7XG5cblx0XHRsZXQgaW5pdFZhbHVlID0gMDtcblx0XHRpZihvcHRpb25zLnZhbHVlICE9PSB1bmRlZmluZWQpe1xuXHRcdFx0aW5pdFZhbHVlID0gb3B0aW9ucy52YWx1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IFNsaWRlcihvcHRpb25zLnBvc2l0aW9uLCBpbml0VmFsdWUpO1xuXHR9XG5cblx0YnVpbGRUZXh0SW5wdXQob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IFRleHRJbnB1dCB7XG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIlRleHRJbnB1dFwiLCBvcHRpb25zLCBcInBvc2l0aW9uXCIsIFZlYzIsIFwiVmVjMlwiKTtcblxuXHRcdHJldHVybiBuZXcgVGV4dElucHV0KG9wdGlvbnMucG9zaXRpb24pO1xuXHR9XG5cblx0YnVpbGRQb2ludChvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IFBvaW50IHtcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiUG9pbnRcIiwgb3B0aW9ucywgXCJwb3NpdGlvblwiLCBWZWMyLCBcIlZlYzJcIik7XG5cblx0XHRyZXR1cm4gbmV3IFBvaW50KG9wdGlvbnMucG9zaXRpb24pO1xuXHR9XG5cblx0YnVpbGRQYXJ0aWNsZShvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IFBvaW50IHtcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiUGFydGljbGVcIiwgb3B0aW9ucywgXCJwb3NpdGlvblwiLCBWZWMyLCBcIlZlYzJcIik7XG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIlBhcnRpY2xlXCIsIG9wdGlvbnMsIFwic2l6ZVwiLCBWZWMyLCBcIlZlYzJcIik7XG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIlBhcnRpY2xlXCIsIG9wdGlvbnMsIFwibWFzc1wiLCBcIm51bWJlclwiLCBcIm51bWJlclwiKTtcblxuXHRcdC8vQ2hhbmdlZCBmb3IgdGVzdGluZ1xuXHRcdHJldHVybiBuZXcgUGFydGljbGUob3B0aW9ucy5wb3NpdGlvbiwgb3B0aW9ucy5zaXplLCBvcHRpb25zLm1hc3MpO1xuXHR9XG5cblx0YnVpbGRMaW5lKG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUG9pbnQge1xuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJMaW5lXCIsIG9wdGlvbnMsIFwic3RhcnRcIiwgVmVjMiwgXCJWZWMyXCIpO1xuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJMaW5lXCIsIG9wdGlvbnMsIFwiZW5kXCIsIFZlYzIsIFwiVmVjMlwiKTtcblxuXHRcdHJldHVybiBuZXcgTGluZShvcHRpb25zLnN0YXJ0LCBvcHRpb25zLmVuZCk7XG5cdH1cblxuXHRidWlsZFJlY3Qob3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiBSZWN0IHtcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiUmVjdFwiLCBvcHRpb25zLCBcInBvc2l0aW9uXCIsIFZlYzIsIFwiVmVjMlwiKTtcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiUmVjdFwiLCBvcHRpb25zLCBcInNpemVcIiwgVmVjMiwgXCJWZWMyXCIpO1xuXG5cdFx0cmV0dXJuIG5ldyBSZWN0KG9wdGlvbnMucG9zaXRpb24sIG9wdGlvbnMuc2l6ZSk7XG5cdH1cblxuXHQvKiAtLS0tLS0tLS0tIEVSUk9SIEhBTkRMSU5HIC0tLS0tLS0tLS0gKi9cblxuXHRjaGVja0lmUHJvcEV4aXN0czxUPihvYmplY3ROYW1lOiBzdHJpbmcsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4sIHByb3A6IHN0cmluZywgdHlwZTogKG5ldyAoLi4uYXJnczogYW55KSA9PiBUKSB8IHN0cmluZywgdHlwZU5hbWU/OiBzdHJpbmcpe1xuXHRcdGlmKCFvcHRpb25zIHx8IG9wdGlvbnNbcHJvcF0gPT09IHVuZGVmaW5lZCl7XG5cdFx0XHQvLyBDaGVjayB0aGF0IHRoZSBvcHRpb25zIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5XG5cdFx0XHR0aHJvdyBgJHtvYmplY3ROYW1lfSBvYmplY3QgcmVxdWlyZXMgYXJndW1lbnQgJHtwcm9wfSBvZiB0eXBlICR7dHlwZU5hbWV9LCBidXQgbm9uZSB3YXMgcHJvdmlkZWQuYDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gQ2hlY2sgdGhhdCB0aGUgcHJvcGVydHkgaGFzIHRoZSBjb3JyZWN0IHR5cGVcblx0XHRcdGlmKCh0eXBlb2YgdHlwZSkgPT09IFwic3RyaW5nXCIpe1xuXHRcdFx0XHRpZighKHR5cGVvZiBvcHRpb25zW3Byb3BdID09PSB0eXBlKSl7XG5cdFx0XHRcdFx0dGhyb3cgYCR7b2JqZWN0TmFtZX0gb2JqZWN0IHJlcXVpcmVzIGFyZ3VtZW50ICR7cHJvcH0gb2YgdHlwZSAke3R5cGV9LCBidXQgcHJvdmlkZWQgJHtwcm9wfSB3YXMgbm90IG9mIHR5cGUgJHt0eXBlfS5gO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYodHlwZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKXtcblx0XHRcdFx0Ly8gSWYgdHlwZSBpcyBhIGNvbnN0cnVjdG9yLCBjaGVjayBhZ2FpbnN0IHRoYXRcblx0XHRcdFx0aWYoIShvcHRpb25zW3Byb3BdIGluc3RhbmNlb2YgdHlwZSkpe1xuXHRcdFx0XHRcdHRocm93IGAke29iamVjdE5hbWV9IG9iamVjdCByZXF1aXJlcyBhcmd1bWVudCAke3Byb3B9IG9mIHR5cGUgJHt0eXBlTmFtZX0sIGJ1dCBwcm92aWRlZCAke3Byb3B9IHdhcyBub3Qgb2YgdHlwZSAke3R5cGVOYW1lfS5gO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBgJHtvYmplY3ROYW1lfSBvYmplY3QgcmVxdWlyZXMgYXJndW1lbnQgJHtwcm9wfSBvZiB0eXBlICR7dHlwZU5hbWV9LCBidXQgcHJvdmlkZWQgJHtwcm9wfSB3YXMgbm90IG9mIHR5cGUgJHt0eXBlTmFtZX0uYDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0iLCJpbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lXCI7XG5pbXBvcnQgQ2FudmFzTm9kZUZhY3RvcnkgZnJvbSBcIi4vQ2FudmFzTm9kZUZhY3RvcnlcIjtcbmltcG9ydCBUaWxlbWFwRmFjdG9yeSBmcm9tIFwiLi9UaWxlbWFwRmFjdG9yeVwiO1xuaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uLy4uL05vZGVzL1RpbGVtYXBcIjtcbmltcG9ydCB7IFVJRWxlbWVudFR5cGUgfSBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9VSUVsZW1lbnRUeXBlc1wiO1xuaW1wb3J0IFVJRWxlbWVudCBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50XCI7XG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi8uLi9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xuaW1wb3J0IHsgR3JhcGhpY1R5cGUgfSBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvR3JhcGhpY1R5cGVzXCI7XG5pbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY1wiO1xuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi8uLi9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBMYXllciBmcm9tIFwiLi4vTGF5ZXJcIjtcblxuLyoqXG4gKiBUaGUgbWFuYWdlciBvZiBhbGwgZmFjdG9yaWVzIHVzZWQgZm9yIGFkZGluZyBAcmVmZXJlbmNlW0dhbWVOb2RlXXMgdG8gdGhlIEByZWZlcmVuY2VbU2NlbmVdLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGYWN0b3J5TWFuYWdlciB7XG5cbiAgICAvLyBDb25zdHJ1Y3RvcnMgYXJlIGNhbGxlZCBoZXJlIHRvIGFsbG93IGFzc2lnbm1lbnQgb2YgdGhlaXIgZnVuY3Rpb25zIHRvIGZ1bmN0aW9ucyBpbiB0aGlzIGNsYXNzXG4gICAgcHJpdmF0ZSBjYW52YXNOb2RlRmFjdG9yeTogQ2FudmFzTm9kZUZhY3RvcnkgPSBuZXcgQ2FudmFzTm9kZUZhY3RvcnkoKTtcbiAgICBwcml2YXRlIHRpbGVtYXBGYWN0b3J5OiBUaWxlbWFwRmFjdG9yeSA9IG5ldyBUaWxlbWFwRmFjdG9yeSgpO1xuXG4gICAgY29uc3RydWN0b3Ioc2NlbmU6IFNjZW5lLCB0aWxlbWFwczogQXJyYXk8VGlsZW1hcD4pe1xuICAgICAgICB0aGlzLmNhbnZhc05vZGVGYWN0b3J5LmluaXQoc2NlbmUpO1xuICAgICAgICB0aGlzLnRpbGVtYXBGYWN0b3J5LmluaXQoc2NlbmUsIHRpbGVtYXBzKTtcbiAgICB9XG5cbiAgICAvLyBFeHBvc2UgYWxsIG9mIHRoZSBmYWN0b3JpZXMgdGhyb3VnaCB0aGUgZmFjdG9yeSBtYW5hZ2VyXG4gICAgLyoqXG5cdCAqIEFkZHMgYW4gaW5zdGFuY2Ugb2YgYSBVSUVsZW1lbnQgdG8gdGhlIGN1cnJlbnQgc2NlbmUgLSBpLmUuIGFueSBjbGFzcyB0aGF0IGV4dGVuZHMgVUlFbGVtZW50XG5cdCAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIFVJRWxlbWVudCB0byBhZGRcblx0ICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgdG8gYWRkIHRoZSBVSUVsZW1lbnQgdG9cblx0ICogQHBhcmFtIG9wdGlvbnMgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIGZlZWQgdG8gdGhlIGNvbnN0cnVjdG9yXG5cdCAqIEByZXR1cm5zIEEgbmV3IFVJRWxlbWVudFxuXHQgKi9cbiAgICB1aUVsZW1lbnQodHlwZTogc3RyaW5nIHwgVUlFbGVtZW50VHlwZSwgbGF5ZXJOYW1lOiBzdHJpbmcsIG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogVUlFbGVtZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzTm9kZUZhY3RvcnkuYWRkVUlFbGVtZW50KHR5cGUsIGxheWVyTmFtZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG5cdCAqIEFkZHMgYSBzcHJpdGUgdG8gdGhlIGN1cnJlbnQgc2NlbmVcblx0ICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpbWFnZSB0aGUgc3ByaXRlIHdpbGwgcmVwcmVzZW50XG5cdCAqIEBwYXJhbSBsYXllck5hbWUgVGhlIGxheWVyIG9uIHdoaWNoIHRvIGFkZCB0aGUgc3ByaXRlXG5cdCAqIEByZXR1cm5zIEEgbmV3IFNwcml0ZVxuXHQgKi9cblx0c3ByaXRlKGtleTogc3RyaW5nLCBsYXllck5hbWU6IHN0cmluZyk6IFNwcml0ZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhc05vZGVGYWN0b3J5LmFkZFNwcml0ZShrZXksIGxheWVyTmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG5cdCAqIEFkZHMgYW4gQW5pbWF0ZWRTcHJpdGUgdG8gdGhlIGN1cnJlbnQgc2NlbmVcblx0ICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpbWFnZSB0aGUgc3ByaXRlIHdpbGwgcmVwcmVzZW50XG5cdCAqIEBwYXJhbSBsYXllck5hbWUgVGhlIGxheWVyIG9uIHdoaWNoIHRvIGFkZCB0aGUgc3ByaXRlXG5cdCAqIEByZXR1cm5zIEEgbmV3IEFuaW1hdGVkU3ByaXRlXG5cdCAqL1xuXHRhbmltYXRlZFNwcml0ZShrZXk6IHN0cmluZywgbGF5ZXJOYW1lOiBzdHJpbmcpOiBBbmltYXRlZFNwcml0ZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhc05vZGVGYWN0b3J5LmFkZEFuaW1hdGVkU3ByaXRlKGtleSwgbGF5ZXJOYW1lKTtcbiAgICB9XG5cbiAgICAvKipcblx0ICogQWRkcyBhIG5ldyBncmFwaGljIGVsZW1lbnQgdG8gdGhlIGN1cnJlbnQgU2NlbmVcblx0ICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgZ3JhcGhpYyB0byBhZGRcblx0ICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgb24gd2hpY2ggdG8gYWRkIHRoZSBncmFwaGljXG5cdCAqIEBwYXJhbSBvcHRpb25zIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBzZW5kIHRvIHRoZSBncmFwaGljIGNvbnN0cnVjdG9yXG5cdCAqIEByZXR1cm5zIEEgbmV3IEdyYXBoaWNcblx0ICovXG5cdGdyYXBoaWModHlwZTogR3JhcGhpY1R5cGUgfCBzdHJpbmcsIGxheWVyTmFtZTogc3RyaW5nLCBvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IEdyYXBoaWMge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXNOb2RlRmFjdG9yeS5hZGRHcmFwaGljKHR5cGUsIGxheWVyTmFtZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHRpbGVtYXAgdG8gdGhlIHNjZW5lXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBsb2FkZWQgdGlsZW1hcCB0byBsb2FkXG4gICAgICogQHBhcmFtIGNvbnN0ciBUaGUgY29uc3RydWN0b3Igb2YgdGhlIGRlc2lyZWQgdGlsZW1hcFxuICAgICAqIEBwYXJhbSBhcmdzIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHNlbmQgdG8gdGhlIHRpbGVtYXAgY29uc3RydWN0b3JcbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBMYXllcnMsIGVhY2ggb2Ygd2hpY2ggY29udGFpbnMgYSBsYXllciBvZiB0aGUgdGlsZW1hcCBhcyBpdHMgb3duIFRpbGVtYXAgaW5zdGFuY2UuXG4gICAgICovXG5cdHRpbGVtYXAoa2V5OiBzdHJpbmcsIHNjYWxlPzogVmVjMik6IEFycmF5PExheWVyPiB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbGVtYXBGYWN0b3J5LmFkZChrZXksIHNjYWxlKTtcbiAgICB9XG59IiwiaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZVwiO1xuaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uLy4uL05vZGVzL1RpbGVtYXBcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBPcnRob2dvbmFsVGlsZW1hcCBmcm9tIFwiLi4vLi4vTm9kZXMvVGlsZW1hcHMvT3J0aG9nb25hbFRpbGVtYXBcIjtcbmltcG9ydCBMYXllciBmcm9tIFwiLi4vTGF5ZXJcIjtcbmltcG9ydCBUaWxlc2V0IGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVGlsZXNldHMvVGlsZXNldFwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgeyBUaWxlZENvbGxlY3Rpb25UaWxlIH0gZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlZERhdGFcIjtcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uLy4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XG5pbXBvcnQgUG9zaXRpb25HcmFwaCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL0dyYXBocy9Qb3NpdGlvbkdyYXBoXCI7XG5pbXBvcnQgTmF2bWVzaCBmcm9tIFwiLi4vLi4vUGF0aGZpbmRpbmcvTmF2bWVzaFwiO1xuXG4vLyBAaWdub3JlUGFnZVxuXG4vKipcbiAqIEEgZmFjdG9yeSB0aGF0IGFic3RyYWN0cyBhZGRpbmcgQHJlZmVyZW5jZVtUaWxlbWFwXXMgdG8gdGhlIEByZWZlcmVuY2VbU2NlbmVdLlxuICogQWNjZXNzIG1ldGhvZHMgaW4gdGhpcyBmYWN0b3J5IHRocm91Z2ggU2NlbmUuYWRkLlttZXRob2ROYW1lXSgpLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaWxlbWFwRmFjdG9yeSB7XG4gICAgcHJpdmF0ZSBzY2VuZTogU2NlbmU7XG4gICAgcHJpdmF0ZSB0aWxlbWFwczogQXJyYXk8VGlsZW1hcD47XG4gICAgcHJpdmF0ZSByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcbiAgICBcbiAgICBpbml0KHNjZW5lOiBTY2VuZSwgdGlsZW1hcHM6IEFycmF5PFRpbGVtYXA+KTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICAgICAgdGhpcy50aWxlbWFwcyA9IHRpbGVtYXBzO1xuICAgICAgICB0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuICAgIH1cblxuICAgIC8vIFRPRE8gLSBUaGlzIGlzIHNwZWNpZmljYWxseSBjYXRlcmVkIHRvIFRpbGVkIHRpbGVtYXBzIHJpZ2h0IG5vdy4gSW4gdGhlIGZ1dHVyZSxcbiAgICAvLyBpdCB3b3VsZCBiZSBnb29kIHRvIGhhdmUgYSBcInBhcnNlVGlsZW1hcFwiIGZ1bmN0aW9uIHRoYXQgd291bGQgY29udmVydCB0aGUgdGlsZW1hcFxuICAgIC8vIGRhdGEgaW50byBhIHN0YW5kYXJkIGZvcm1hdC4gVGhpcyBjb3VsZCBhbGxvdyBmb3Igc3VwcG9ydCBmcm9tIG90aGVyIHByb2dyYW1zXG4gICAgLy8gb3IgdGhlIGRldmVsb3BtZW50IG9mIGFuIGludGVybmFsIGxldmVsIGJ1aWxkZXIgdG9vbFxuICAgIC8qKlxuICAgICAqIEFkZHMgYSB0aWxlbWFwIHRvIHRoZSBzY2VuZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgbG9hZGVkIHRpbGVtYXAgdG8gbG9hZFxuICAgICAqIEBwYXJhbSBjb25zdHIgVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBkZXNpcmVkIHRpbGVtYXBcbiAgICAgKiBAcGFyYW0gYXJncyBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBzZW5kIHRvIHRoZSB0aWxlbWFwIGNvbnN0cnVjdG9yXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgTGF5ZXJzLCBlYWNoIG9mIHdoaWNoIGNvbnRhaW5zIGEgbGF5ZXIgb2YgdGhlIHRpbGVtYXAgYXMgaXRzIG93biBUaWxlbWFwIGluc3RhbmNlLlxuICAgICAqL1xuXHRhZGQgPSAoa2V5OiBzdHJpbmcsIHNjYWxlOiBWZWMyID0gbmV3IFZlYzIoMSwgMSkpOiBBcnJheTxMYXllcj4gPT4ge1xuICAgICAgICAvLyBHZXQgVGlsZW1hcCBEYXRhXG4gICAgICAgIGxldCB0aWxlbWFwRGF0YSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldFRpbGVtYXAoa2V5KTtcblxuICAgICAgICAvLyBTZXQgdGhlIGNvbnN0cnVjdG9yIGZvciB0aGlzIHRpbGVtYXAgdG8gZWl0aGVyIGJlIG9ydGhvZ3JhcGhpYyBvciBpc29tZXRyaWNcbiAgICAgICAgbGV0IGNvbnN0cjogbmV3KC4uLmFyZ3M6IGFueSkgPT4gVGlsZW1hcDtcbiAgICAgICAgaWYodGlsZW1hcERhdGEub3JpZW50YXRpb24gPT09IFwib3J0aG9ncmFwaGljXCIpe1xuICAgICAgICAgICAgY29uc3RyID0gT3J0aG9nb25hbFRpbGVtYXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBObyBpc29tZXRyaWMgdGlsZW1hcCBzdXBwb3J0IHJpZ2h0IG5vdywgc28gT3J0aG9ncmFwaGljIHRpbGVtYXBcbiAgICAgICAgICAgIGNvbnN0ciA9IE9ydGhvZ29uYWxUaWxlbWFwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgcmV0dXJuIHZhbHVlIGFycmF5XG4gICAgICAgIGxldCBzY2VuZUxheWVycyA9IG5ldyBBcnJheTxMYXllcj4oKTtcblxuICAgICAgICAvLyBDcmVhdGUgYWxsIG9mIHRoZSB0aWxlc2V0cyBmb3IgdGhpcyB0aWxlbWFwXG4gICAgICAgIGxldCB0aWxlc2V0cyA9IG5ldyBBcnJheTxUaWxlc2V0PigpO1xuXG4gICAgICAgIGxldCBjb2xsZWN0aW9uVGlsZXMgPSBuZXcgQXJyYXk8VGlsZWRDb2xsZWN0aW9uVGlsZT4oKTtcblxuICAgICAgICBmb3IobGV0IHRpbGVzZXQgb2YgdGlsZW1hcERhdGEudGlsZXNldHMpe1xuICAgICAgICAgICAgaWYodGlsZXNldC5pbWFnZSl7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHN0YW5kYXJkIHRpbGVzZXQgYW5kIG5vdCBhIGNvbGxlY3Rpb24sIGNyZWF0ZSBhIHRpbGVzZXQgZm9yIGl0LlxuICAgICAgICAgICAgICAgIC8vIFRPRE8gLSBXZSBhcmUgaWdub3JpbmcgY29sbGVjdGlvbiB0aWxlc2V0cyBmb3Igbm93LiBUaGlzIGlzIGxpa2VseSBub3QgYSBncmVhdCBpZGVhIGluIHByYWN0aWNlLFxuICAgICAgICAgICAgICAgIC8vIGFzIHRoZW9yZXRpY2FsbHkgc29tZW9uZSBjb3VsZCB3YW50IHRvIHVzZSBvbmUgZm9yIGEgc3RhbmRhcmQgdGlsZW1hcC4gV2UgYXJlIGFzc3VtaW5nIGZvciBub3dcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHdlIG9ubHkgd2FudCB0byB1c2UgdGhlbSBmb3Igb2JqZWN0IGxheWVyc1xuICAgICAgICAgICAgICAgIHRpbGVzZXRzLnB1c2gobmV3IFRpbGVzZXQodGlsZXNldCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aWxlc2V0LnRpbGVzLmZvckVhY2godGlsZSA9PiB0aWxlLmlkICs9IHRpbGVzZXQuZmlyc3RnaWQpO1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25UaWxlcy5wdXNoKC4uLnRpbGVzZXQudGlsZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9vcCBvdmVyIHRoZSBsYXllcnMgb2YgdGhlIHRpbGVtYXAgYW5kIGNyZWF0ZSB0aWxlZGxheWVycyBvciBvYmplY3QgbGF5ZXJzXG4gICAgICAgIGZvcihsZXQgbGF5ZXIgb2YgdGlsZW1hcERhdGEubGF5ZXJzKXtcblxuICAgICAgICAgICAgbGV0IHNjZW5lTGF5ZXI7XG4gICAgICAgICAgICBsZXQgaXNQYXJhbGxheExheWVyID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgZGVwdGggPSAwO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihsYXllci5wcm9wZXJ0aWVzKXtcbiAgICAgICAgICAgICAgICBmb3IobGV0IHByb3Agb2YgbGF5ZXIucHJvcGVydGllcyl7XG4gICAgICAgICAgICAgICAgICAgIGlmKHByb3AubmFtZSA9PT0gXCJQYXJhbGxheFwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUGFyYWxsYXhMYXllciA9IHByb3AudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihwcm9wLm5hbWUgPT09IFwiRGVwdGhcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGggPSBwcm9wLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihpc1BhcmFsbGF4TGF5ZXIpe1xuICAgICAgICAgICAgICAgIHNjZW5lTGF5ZXIgPSB0aGlzLnNjZW5lLmFkZFBhcmFsbGF4TGF5ZXIobGF5ZXIubmFtZSwgbmV3IFZlYzIoMSwgMSksIGRlcHRoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NlbmVMYXllciA9IHRoaXMuc2NlbmUuYWRkTGF5ZXIobGF5ZXIubmFtZSwgZGVwdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihsYXllci50eXBlID09PSBcInRpbGVsYXllclwiKXtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgdGlsZW1hcCBvYmplY3QgZm9yIHRoZSBsYXllclxuICAgICAgICAgICAgICAgIGxldCB0aWxlbWFwID0gbmV3IGNvbnN0cih0aWxlbWFwRGF0YSwgbGF5ZXIsIHRpbGVzZXRzLCBzY2FsZSk7XG4gICAgICAgICAgICAgICAgdGlsZW1hcC5pZCA9IHRoaXMuc2NlbmUuZ2VuZXJhdGVJZCgpO1xuICAgICAgICAgICAgICAgIHRpbGVtYXAuc2V0U2NlbmUodGhpcy5zY2VuZSk7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRpbGVtYXAgdG8gc2NlbmVcbiAgICAgICAgICAgICAgICB0aGlzLnRpbGVtYXBzLnB1c2godGlsZW1hcCk7XG4gICAgXG4gICAgICAgICAgICAgICAgc2NlbmVMYXllci5hZGROb2RlKHRpbGVtYXApO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIFJlZ2lzdGVyIHRpbGVtYXAgd2l0aCBwaHlzaWNzIGlmIGl0J3MgY29sbGlkYWJsZVxuICAgICAgICAgICAgICAgIGlmKHRpbGVtYXAuaXNDb2xsaWRhYmxlKXtcbiAgICAgICAgICAgICAgICAgICAgdGlsZW1hcC5hZGRQaHlzaWNzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYobGF5ZXIucHJvcGVydGllcyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGl0ZW0gb2YgbGF5ZXIucHJvcGVydGllcyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS5uYW1lID09PSBcIkdyb3VwXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlbWFwLnNldEdyb3VwKGl0ZW0udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBsZXQgaXNOYXZtZXNoUG9pbnRzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGV0IG5hdm1lc2hOYW1lO1xuICAgICAgICAgICAgICAgIGxldCBlZGdlcztcbiAgICAgICAgICAgICAgICBpZihsYXllci5wcm9wZXJ0aWVzKXtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBwcm9wIG9mIGxheWVyLnByb3BlcnRpZXMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYocHJvcC5uYW1lID09PSBcIk5hdm1lc2hQb2ludHNcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNOYXZtZXNoUG9pbnRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihwcm9wLm5hbWUgPT09IFwibmFtZVwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZtZXNoTmFtZSA9IHByb3AudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHJvcC5uYW1lID09PSBcImVkZ2VzXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VzID0gcHJvcC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKGlzTmF2bWVzaFBvaW50cyl7XG4gICAgICAgICAgICAgICAgICAgIGxldCBnID0gbmV3IFBvc2l0aW9uR3JhcGgoKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IG9iaiBvZiBsYXllci5vYmplY3RzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGcuYWRkUG9zaXRpb25lZE5vZGUobmV3IFZlYzIob2JqLngsIG9iai55KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGVkZ2Ugb2YgZWRnZXMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZy5hZGRFZGdlKGVkZ2UuZnJvbSwgZWRnZS50byk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLmdldE5hdmlnYXRpb25NYW5hZ2VyKCkuYWRkTmF2aWdhYmxlRW50aXR5KG5hdm1lc2hOYW1lLCBuZXcgTmF2bWVzaChnKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTGF5ZXIgaXMgYW4gb2JqZWN0IGxheWVyLCBzbyBhZGQgZWFjaCBvYmplY3QgYXMgYSBzcHJpdGUgdG8gYSBuZXcgbGF5ZXJcbiAgICAgICAgICAgICAgICBmb3IobGV0IG9iaiBvZiBsYXllci5vYmplY3RzKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgb2JqIGlzIGNvbGxpZGFibGVcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhhc1BoeXNpY3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzQ29sbGlkYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXNUcmlnZ2VyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvbkVudGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9uRXhpdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0cmlnZ2VyR3JvdXAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZ3JvdXAgPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKG9iai5wcm9wZXJ0aWVzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgcHJvcCBvZiBvYmoucHJvcGVydGllcyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocHJvcC5uYW1lID09PSBcIkhhc1BoeXNpY3NcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1BoeXNpY3MgPSBwcm9wLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihwcm9wLm5hbWUgPT09IFwiQ29sbGlkYWJsZVwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDb2xsaWRhYmxlID0gcHJvcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHJvcC5uYW1lID09PSBcIkdyb3VwXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cCA9IHByb3AudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJJc1RyaWdnZXJcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVHJpZ2dlciA9IHByb3AudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJUcmlnZ2VyR3JvdXBcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXJHcm91cCA9IHByb3AudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJUcmlnZ2VyT25FbnRlclwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FbnRlciA9IHByb3AudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJUcmlnZ2VyT25FeGl0XCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkV4aXQgPSBwcm9wLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBzcHJpdGU6IFNwcml0ZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBvYmogaXMgYSB0aWxlIGZyb20gYSB0aWxlc2V0XG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgdGlsZXNldCBvZiB0aWxlc2V0cyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aWxlc2V0Lmhhc1RpbGUob2JqLmdpZCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvYmplY3QgaXMgYSB0aWxlIGZyb20gdGhpcyBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW1hZ2VLZXkgPSB0aWxlc2V0LmdldEltYWdlS2V5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IHRpbGVzZXQuZ2V0SW1hZ2VPZmZzZXRGb3JUaWxlKG9iai5naWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZSA9IHRoaXMuc2NlbmUuYWRkLnNwcml0ZShpbWFnZUtleSwgbGF5ZXIubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNpemUgPSB0aWxlc2V0LmdldFRpbGVTaXplKCkuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUucG9zaXRpb24uc2V0KChvYmoueCArIHNpemUueC8yKSpzY2FsZS54LCAob2JqLnkgLSBzaXplLnkvMikqc2NhbGUueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnNldEltYWdlT2Zmc2V0KG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnNpemUuY29weShzaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuc2NhbGUuc2V0KHNjYWxlLngsIHNjYWxlLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IGluIGEgdGlsZXNldCwgbXVzdCBjb3JyZXNwb25kIHRvIGEgY29sbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICBpZighc3ByaXRlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgdGlsZSBvZiBjb2xsZWN0aW9uVGlsZXMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG9iai5naWQgPT09IHRpbGUuaWQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW1hZ2VLZXkgPSB0aWxlLmltYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUgPSB0aGlzLnNjZW5lLmFkZC5zcHJpdGUoaW1hZ2VLZXksIGxheWVyLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUucG9zaXRpb24uc2V0KChvYmoueCArIHRpbGUuaW1hZ2V3aWR0aC8yKSpzY2FsZS54LCAob2JqLnkgLSB0aWxlLmltYWdlaGVpZ2h0LzIpKnNjYWxlLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuc2NhbGUuc2V0KHNjYWxlLngsIHNjYWxlLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdyB3ZSBoYXZlIHNwcml0ZS4gQXNzb2NpYXRlIGl0IHdpdGggb3VyIHBoeXNpY3Mgb2JqZWN0IGlmIHRoZXJlIGlzIG9uZVxuICAgICAgICAgICAgICAgICAgICBpZihoYXNQaHlzaWNzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgdGhlIHNwcml0ZSBhIHN0YXRpYyBwaHlzaWNzIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLmFkZFBoeXNpY3Moc3ByaXRlLmJvdW5kYXJ5LmNsb25lKCksIFZlYzIuWkVSTywgaXNDb2xsaWRhYmxlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zZXRHcm91cChncm91cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihpc1RyaWdnZXIgJiYgdHJpZ2dlckdyb3VwICE9PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuc2V0VHJpZ2dlcih0cmlnZ2VyR3JvdXAsIG9uRW50ZXIsIG9uRXhpdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgICBzY2VuZUxheWVycy5wdXNoKHNjZW5lTGF5ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNjZW5lTGF5ZXJzO1xuXHR9XG59IiwiaW1wb3J0IFNjZW5lIGZyb20gXCIuL1NjZW5lXCI7XG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuLi9VdGlscy9NYXRoVXRpbHNcIjtcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vTm9kZXMvR2FtZU5vZGVcIjtcblxuXG4vKipcbiAqIEEgbGF5ZXIgaW4gdGhlIHNjZW5lLiBMYXllcnMgYXJlIHVzZWQgZm9yIHNvcnRpbmcgQHJlZmVyZW5jZVtHYW1lTm9kZV1zIGJ5IGRlcHRoLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYXllciB7XG4gICAgLyoqIFRoZSBzY2VuZSB0aGlzIGxheWVyIGJlbG9uZ3MgdG8gKi9cbiAgICBwcm90ZWN0ZWQgc2NlbmU6IFNjZW5lO1xuXG4gICAgLyoqIFRoZSBuYW1lIG9mIHRoaXMgbGF5ZXIgKi9cbiAgICBwcm90ZWN0ZWQgbmFtZTogc3RyaW5nO1xuXG4gICAgLyoqIFdoZXRoZXIgdGhpcyBsYXllciBpcyBwYXVzZWQgb3Igbm90ICovXG4gICAgcHJvdGVjdGVkIHBhdXNlZDogYm9vbGVhbjtcblxuICAgIC8qKiBXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgaGlkZGVuIGZyb20gYmVpbmcgcmVuZGVyZWQgb3Igbm90ICovXG4gICAgcHJvdGVjdGVkIGhpZGRlbjogYm9vbGVhbjtcblxuICAgIC8qKiBUaGUgZ2xvYmFsIGFscGhhIGxldmVsIG9mIHRoaXMgbGF5ZXIgKi9cbiAgICBwcm90ZWN0ZWQgYWxwaGE6IG51bWJlcjtcblxuICAgIC8qKiBBbiBhcnJheSBvZiB0aGUgR2FtZU5vZGVzIHRoYXQgYmVsb25nIHRvIHRoaXMgbGF5ZXIgKi9cbiAgICBwcm90ZWN0ZWQgaXRlbXM6IEFycmF5PEdhbWVOb2RlPjtcblxuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIGxheWVyIHNob3VsZCBiZSB5c29ydGVkICovXG4gICAgcHJvdGVjdGVkIHlTb3J0OiBib29sZWFuO1xuXG4gICAgLyoqIFRoZSBkZXB0aCBvZiB0aGlzIGxheWVyIGNvbXBhcmVkIHRvIG90aGVyIGxheWVycyAqL1xuICAgIHByb3RlY3RlZCBkZXB0aDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBsYXllci4gVG8gZG8gdGhpcyBpbiBhIGdhbWUsIHVzZSB0aGUgYWRkTGF5ZXIoKSBtZXRob2QgaW4gQHJlZnJlbmNlW1NjZW5lXVxuICAgICAqIEBwYXJhbSBzY2VuZSBUaGUgc2NlbmUgdG8gYWRkIHRoZSBsYXllciB0b1xuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBsYXllclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNjZW5lOiBTY2VuZSwgbmFtZTogc3RyaW5nKXtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFscGhhID0gMTtcbiAgICAgICAgdGhpcy5pdGVtcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLnlTb3J0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVwdGggPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJlaXZlcyB0aGUgbmFtZSBvZiB0aGUgbGF5ZXJcbiAgICAgKiBAcmV0dXJucyBUaGUgbmFtZSBvZiB0aGUgbGF5ZXJcbiAgICAgKi9cbiAgICBnZXROYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGF1c2VzL1VucGF1c2VzIHRoZSBsYXllci4gQWZmZWN0cyBhbGwgZWxlbWVudHMgaW4gdGhpcyBsYXllclxuICAgICAqIEBwYXJhbSBwYXVzZVZhbHVlIFRydWUgaWYgdGhlIGxheWVyIHNob3VsZCBiZSBwYXVzZWQsIGZhbHNlIGlmIG5vdFxuICAgICAqL1xuICAgIHNldFBhdXNlZChwYXVzZVZhbHVlOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMucGF1c2VkID0gcGF1c2VWYWx1ZTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbGF5ZXIgaXMgcGF1c2VkXG4gICAgICovXG4gICAgaXNQYXVzZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdXNlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBvcGFjaXR5IG9mIHRoZSBsYXllclxuICAgICAqIEBwYXJhbSBhbHBoYSBUaGUgbmV3IG9wYWNpdHkgdmFsdWUgaW4gdGhlIHJhbmdlIFswLCAxXVxuICAgICAqL1xuICAgIHNldEFscGhhKGFscGhhOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hbHBoYSA9IE1hdGhVdGlscy5jbGFtcChhbHBoYSwgMCwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgbGF5ZXJcbiAgICAgKiBAcmV0dXJucyBUaGUgb3BhY2l0eVxuICAgICAqL1xuICAgIGdldEFscGhhKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmFscGhhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxheWVyJ3MgaGlkZGVuIHZhbHVlLiBJZiBoaWRkZW4sIGEgbGF5ZXIgd2lsbCBub3QgYmUgcmVuZGVyZWQsIGJ1dCB3aWxsIHN0aWxsIHVwZGF0ZVxuICAgICAqIEBwYXJhbSBoaWRkZW4gVGhlIGhpZGRlbiB2YWx1ZSBvZiB0aGUgbGF5ZXJcbiAgICAgKi9cbiAgICBzZXRIaWRkZW4oaGlkZGVuOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaGlkZGVuID0gaGlkZGVuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhpZGVlbiB2YWx1ZSBvZiB0aGUgbHlhZXJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBzY2VuZSBpcyBoaWRkZW4sIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGlzSGlkZGVuKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5oaWRkZW47XG4gICAgfVxuXG4gICAgLyoqIFBhdXNlcyB0aGlzIHNjZW5lIGFuZCBoaWRlcyBpdCAqL1xuICAgIGRpc2FibGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5oaWRkZW4gPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKiBVbnBhdXNlcyB0aGlzIGxheWVyIGFuZCBtYWtlcyBpdCB2aXNpYmxlICovXG4gICAgZW5hYmxlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgd2hldGhlciBvciBub3QgdGhlIHNjZW5lIHdpbGwgeVNvcnQgYXV0b21hdGljYWxseS5cbiAgICAgKiB5U29ydGluZyBtZWFucyB0aGF0IENhbnZhc05vZGVzIG9uIHRoaXMgbGF5ZXIgd2lsbCBoYXZlIHRoZWlyIGRlcHRoIHNvcnRlZCBkZXBlbmRpbmcgb24gdGhlaXIgeS12YWx1ZS5cbiAgICAgKiBUaGlzIG1lYW5zIHRoYXQgaWYgYW4gb2JqZWN0IGlzIFwiaGlnaGVyXCIgaW4gdGhlIHNjZW5lLCBpdCB3aWxsIHNvcnQgYmVoaW5kIG9iamVjdHMgdGhhdCBhcmUgXCJsb3dlclwiLlxuICAgICAqIFRoaXMgaXMgdXNlZnVsIGZvciAzLzQgdmlldyBnYW1lcywgb3Igc2ltaWxhciBzaXR1YXRpb25zLCB3aGVyZSB5b3Ugc29tZXRpbWVzIHdhbnQgdG8gYmUgaW4gZnJvbnQgb2Ygb2JqZWN0cyxcbiAgICAgKiBhbmQgb3RoZXIgdGltZXMgd2FudCB0byBiZSBiZWhpbmQgdGhlIHNhbWUgb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0geVNvcnQgVHJ1ZSBpZiB5U29ydGluZyBzaG91bGQgYmUgYWN0aXZlLCBmYWxzZSBpZiBub3RcbiAgICAgKi9cbiAgICBzZXRZU29ydCh5U29ydDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLnlTb3J0ID0geVNvcnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgeVNvcnQgc3RhdHVzIG9mIHRoZSBzY2VuZVxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgeVNvcnRpbmcgaXMgb2NjdXJyaW5nLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBnZXRZU29ydCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueVNvcnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZGVwdGggb2YgdGhlIGxheWVyIGNvbXBhcmVkIHRvIG90aGVyIGxheWVycy4gQSBsYXJnZXIgbnVtYmVyIG1lYW5zIHRoZSBsYXllciB3aWxsIGJlIGNsb3NlciB0byB0aGUgc2NyZWVuLlxuICAgICAqIEBwYXJhbSBkZXB0aCBUaGUgZGVwdGggb2YgdGhlIGxheWVyLlxuICAgICAqL1xuICAgIHNldERlcHRoKGRlcHRoOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZGVwdGggb2YgdGhlIGxheWVyLlxuICAgICAqIEByZXR1cm5zIFRoZSBkZXB0aFxuICAgICAqL1xuICAgIGdldERlcHRoKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBub2RlIHRvIHRoaXMgbGF5ZXJcbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byBhZGQgdG8gdGhpcyBsYXllci5cbiAgICAgKi9cbiAgICBhZGROb2RlKG5vZGU6IEdhbWVOb2RlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaXRlbXMucHVzaChub2RlKTtcbiAgICAgICAgbm9kZS5zZXRMYXllcih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgbm9kZSBmcm9tIHRoaXMgbGF5ZXJcbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byByZW1vdmVcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIHdhcyByZW1vdmVkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICByZW1vdmVOb2RlKG5vZGU6IEdhbWVOb2RlKTogdm9pZCB7XG4gICAgICAgIC8vIEZpbmQgYW5kIHJlbW92ZSB0aGUgbm9kZVxuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLml0ZW1zLmluZGV4T2Yobm9kZSk7XG5cbiAgICAgICAgaWYoaW5kZXggIT09IC0xKXtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIG5vZGUuc2V0TGF5ZXIodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJlaXZlcyBhbGwgR2FtZU5vZGVzIGZyb20gdGhpcyBsYXllclxuICAgICAqIEByZXR1cm5zIGFuIEFycmF5IHRoYXQgY29udGFpbnMgYWxsIG9mIHRoZSBHYW1lTm9kZXMgaW4gdGhpcyBsYXllci5cbiAgICAgKi9cbiAgICBnZXRJdGVtcygpOiBBcnJheTxHYW1lTm9kZT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcztcbiAgICB9XG59IiwiaW1wb3J0IExheWVyIGZyb20gXCIuLi9MYXllclwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lXCI7XG5cbi8qKlxuICogQW4gZXh0ZW5zaW9uIG9mIGEgTGF5ZXIgdGhhdCBoYXMgYSBwYXJhbGxheCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFyYWxsYXhMYXllciBleHRlbmRzIExheWVyIHtcblx0LyoqIFRoZSB2YWx1ZSBvZiB0aGUgcGFyYWxsYXggb2YgdGhlIExheWVyICovXG5cdHBhcmFsbGF4OiBWZWMyO1xuXHRcblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgUGFyYWxsYXhMYXllci5cblx0ICogVXNlIGFkZFBhcmFsbGF4TGF5ZXIoKSBpbiBAcmVmZXJlbmNlW1NjZW5lXSB0byBhZGQgYSBsYXllciBvZiB0aGlzIHR5cGUgdG8geW91ciBnYW1lLlxuXHQgKiBAcGFyYW0gc2NlbmUgVGhlIFNjZW5lIHRvIGFkZCB0aGlzIFBhcmFsbGF4TGF5ZXIgdG9cblx0ICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIFBhcmFsbGF4TGF5ZXJcblx0ICogQHBhcmFtIHBhcmFsbGF4IFRoZSBwYXJhbGxheCBsZXZlbFxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc2NlbmU6IFNjZW5lLCBuYW1lOiBzdHJpbmcsIHBhcmFsbGF4OiBWZWMyKXtcblx0XHRzdXBlcihzY2VuZSwgbmFtZSk7XG5cdFx0dGhpcy5wYXJhbGxheCA9IHBhcmFsbGF4O1xuXHR9XG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lXCI7XG5pbXBvcnQgUGFyYWxsYXhMYXllciBmcm9tIFwiLi9QYXJhbGxheExheWVyXCI7XG5cbi8qKlxuICogQSBMYXllciBzdHJpY3RseSB0byBiZSB1c2VkIGZvciBtYW5hZ2luZyBVSUVsZW1lbnRzLlxuICogVGhpcyBpcyBpbnRlbmRlZCB0byBiZSBhIExheWVyIHRoYXQgYWx3YXlzIHN0YXlzIGluIHRoZSBzYW1lIHBsYWNlLFxuICogYW5kIHRodXMgcmVuZGVycyB0aGluZ3MgbGlrZSBhIEhVRCBvciBhbiBpbnZlbnRvcnkgd2l0aG91dCB0YWtpbmcgaW50byBjb25zaWRlcmF0aW9uIHRoZSBcXHJlZmVyZW5jZVtWaWV3cG9ydF0gc2Nyb2xsLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVSUxheWVyIGV4dGVuZHMgUGFyYWxsYXhMYXllciB7XG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IFVJTGF5ZXIuXG5cdCAqIFVzZSBhZGRVSUxheWVyKCkgaW4gQHJlZmVyZW5jZVtTY2VuZV0gdG8gYWRkIGEgbGF5ZXIgb2YgdGhpcyB0eXBlIHRvIHlvdXIgZ2FtZS5cblx0ICogQHBhcmFtIHNjZW5lIFRoZSBTY2VuZSB0byBhZGQgdGhpcyBVSUxheWVyIHRvXG5cdCAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBVSUxheWVyXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihzY2VuZTogU2NlbmUsIG5hbWU6IHN0cmluZyl7XG5cdFx0c3VwZXIoc2NlbmUsIG5hbWUsIFZlYzIuWkVSTyk7XG5cdH1cbn0iLCJpbXBvcnQgTGF5ZXIgZnJvbSBcIi4vTGF5ZXJcIjtcbmltcG9ydCBWaWV3cG9ydCBmcm9tIFwiLi4vU2NlbmVHcmFwaC9WaWV3cG9ydFwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgU2NlbmVHcmFwaCBmcm9tIFwiLi4vU2NlbmVHcmFwaC9TY2VuZUdyYXBoXCI7XG5pbXBvcnQgUGh5c2ljc01hbmFnZXIgZnJvbSBcIi4uL1BoeXNpY3MvUGh5c2ljc01hbmFnZXJcIjtcbmltcG9ydCBCYXNpY1BoeXNpY3NNYW5hZ2VyIGZyb20gXCIuLi9QaHlzaWNzL0Jhc2ljUGh5c2ljc01hbmFnZXJcIjtcbmltcG9ydCBTY2VuZUdyYXBoQXJyYXkgZnJvbSBcIi4uL1NjZW5lR3JhcGgvU2NlbmVHcmFwaEFycmF5XCI7XG5pbXBvcnQgRmFjdG9yeU1hbmFnZXIgZnJvbSBcIi4vRmFjdG9yaWVzL0ZhY3RvcnlNYW5hZ2VyXCI7XG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vTm9kZXMvVGlsZW1hcFwiO1xuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xuaW1wb3J0IEdhbWUgZnJvbSBcIi4uL0xvb3AvR2FtZVwiO1xuaW1wb3J0IFNjZW5lTWFuYWdlciBmcm9tIFwiLi9TY2VuZU1hbmFnZXJcIjtcbmltcG9ydCBSZWNlaXZlciBmcm9tIFwiLi4vRXZlbnRzL1JlY2VpdmVyXCI7XG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vRXZlbnRzL0VtaXR0ZXJcIjtcbmltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VcGRhdGVhYmxlXCI7XG5pbXBvcnQgTmF2aWdhdGlvbk1hbmFnZXIgZnJvbSBcIi4uL1BhdGhmaW5kaW5nL05hdmlnYXRpb25NYW5hZ2VyXCI7XG5pbXBvcnQgQUlNYW5hZ2VyIGZyb20gXCIuLi9BSS9BSU1hbmFnZXJcIjtcbmltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcbmltcG9ydCBQYXJhbGxheExheWVyIGZyb20gXCIuL0xheWVycy9QYXJhbGxheExheWVyXCI7XG5pbXBvcnQgVUlMYXllciBmcm9tIFwiLi9MYXllcnMvVUlMYXllclwiO1xuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uL05vZGVzL0NhbnZhc05vZGVcIjtcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vTm9kZXMvR2FtZU5vZGVcIjtcbmltcG9ydCBTY2VuZU9wdGlvbnMgZnJvbSBcIi4vU2NlbmVPcHRpb25zXCI7XG5pbXBvcnQgUmVuZGVyaW5nTWFuYWdlciBmcm9tIFwiLi4vUmVuZGVyaW5nL1JlbmRlcmluZ01hbmFnZXJcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vRGVidWcvRGVidWdcIjtcbmltcG9ydCBUaW1lck1hbmFnZXIgZnJvbSBcIi4uL1RpbWluZy9UaW1lck1hbmFnZXJcIjtcbmltcG9ydCBUd2Vlbk1hbmFnZXIgZnJvbSBcIi4uL1JlbmRlcmluZy9BbmltYXRpb25zL1R3ZWVuTWFuYWdlclwiO1xuaW1wb3J0IFBhcnRpY2xlU3lzdGVtTWFuYWdlciBmcm9tIFwiLi4vUmVuZGVyaW5nL0FuaW1hdGlvbnMvUGFydGljbGVTeXN0ZW1NYW5hZ2VyXCI7XG5cbi8qKlxuICogU2NlbmVzIGFyZSB0aGUgbWFpbiBjb250YWluZXIgaW4gdGhlIGdhbWUgZW5naW5lLlxuICogWW91ciBtYWluIHNjZW5lIGlzIHRoZSBjdXJyZW50IGxldmVsIG9yIG1lbnUgb2YgdGhlIGdhbWUsIGFuZCB3aWxsIGNvbnRhaW4gYWxsIG9mIHRoZSBHYW1lTm9kZXMgbmVlZGVkLlxuICogU2NlbmVzIHByb3ZpZGUgYW4gZWFzeSB3YXkgdG8gbG9hZCBhc3NldHMsIGFkZCBhc3NldHMgdG8gdGhlIGdhbWUgd29ybGQsIGFuZCB1bmxvYWQgYXNzZXRzLFxuICogYW5kIGhhdmUgbGlmZWN5Y2xlIG1ldGhvZHMgZXhwb3NlZCBmb3IgdGhlc2UgZnVuY3Rpb25zLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2VuZSBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xuICAgIC8qKiBUaGUgc2l6ZSBvZiB0aGUgZ2FtZSB3b3JsZC4gKi9cbiAgICBwcm90ZWN0ZWQgd29ybGRTaXplOiBWZWMyO1xuXG4gICAgLyoqIFRoZSB2aWV3cG9ydC4gKi9cbiAgICBwcm90ZWN0ZWQgdmlld3BvcnQ6IFZpZXdwb3J0O1xuXG4gICAgLyoqIEEgZmxhZyB0aGF0IHJlcHJlc2VudHMgd2hldGhlciB0aGlzIHNjZW5lIGlzIHJ1bm5pbmcgb3Igbm90LiAqL1xuICAgIHByb3RlY3RlZCBydW5uaW5nOiBib29sZWFuO1xuXG4gICAgLyoqIFRoZSBtYW5hZ2VyIG9mIHRoaXMgc2NlbmUuICovXG4gICAgcHJvdGVjdGVkIHNjZW5lTWFuYWdlcjogU2NlbmVNYW5hZ2VyO1xuXG4gICAgLyoqIFRoZSByZWNlaXZlciBmb3IgdGhpcyBzY2VuZS4gKi9cbiAgICBwcm90ZWN0ZWQgcmVjZWl2ZXI6IFJlY2VpdmVyO1xuXG4gICAgLyoqIFRoZSBlbWl0dGVyIGZvciB0aGlzIHNjZW5lLiAqL1xuICAgIHByb3RlY3RlZCBlbWl0dGVyOiBFbWl0dGVyO1xuXG4gICAgLyoqIFRoaXMgbGlzdCBvZiB0aWxlbWFwcyBpbiB0aGlzIHNjZW5lLiAqL1xuICAgIHByb3RlY3RlZCB0aWxlbWFwczogQXJyYXk8VGlsZW1hcD47XG5cbiAgICAvKiogQSBtYXAgZnJvbSBsYXllciBuYW1lcyB0byB0aGUgbGF5ZXJzIHRoZW1zZWx2ZXMgKi9cbiAgICBwcm90ZWN0ZWQgbGF5ZXJzOiBNYXA8TGF5ZXI+O1xuXG4gICAgLyoqIEEgbWFwIGZyb20gcGFyYWxsYXggbGF5ZXIgbmFtZXMgdG8gdGhlIHBhcmFsbGF4IGxheWVycyB0aGVtc2VsdmVzICovXG4gICAgcHJvdGVjdGVkIHBhcmFsbGF4TGF5ZXJzOiBNYXA8UGFyYWxsYXhMYXllcj47XG5cbiAgICAvKiogQSBtYXAgZnJvbSB1aUxheWVyIG5hbWVzIHRvIHRoZSB1aUxheWVycyB0aGVtc2VsdmVzICovXG4gICAgcHJvdGVjdGVkIHVpTGF5ZXJzOiBNYXA8VUlMYXllcj47XG5cbiAgICAvKiogVGhlIHNjZW5lIGdyYXBoIG9mIHRoZSBTY2VuZSovXG4gICAgcHJvdGVjdGVkIHNjZW5lR3JhcGg6IFNjZW5lR3JhcGg7XG5cbiAgICAvKiogVGhlIHBoeXNpY3MgbWFuYWdlciBvZiB0aGUgU2NlbmUgKi9cbiAgICBwcm90ZWN0ZWQgcGh5c2ljc01hbmFnZXI6IFBoeXNpY3NNYW5hZ2VyO1xuICAgIFxuICAgIC8qKiBUaGUgbmF2aWdhdGlvbiBtYW5hZ2VyIG9mIHRoZSBTY2VuZSAqL1xuICAgIHByb3RlY3RlZCBuYXZNYW5hZ2VyOiBOYXZpZ2F0aW9uTWFuYWdlcjtcblxuICAgIC8qKiBUaGUgQUkgbWFuYWdlciBvZiB0aGUgU2NlbmUgKi9cbiAgICBwcm90ZWN0ZWQgYWlNYW5hZ2VyOiBBSU1hbmFnZXI7XG5cbiAgICAvKiogVGhlIHJlbmRlcmluZ01hbmFnZXIgb2YgdGhlIHNjZW5lICovXG4gICAgcHJvdGVjdGVkIHJlbmRlcmluZ01hbmFnZXI6IFJlbmRlcmluZ01hbmFnZXI7XG5cbiAgICAvKiogQW4gaW50ZXJmYWNlIHRoYXQgYWxsb3dzIHRoZSBhZGRpbmcgb2YgZGlmZmVyZW50IG5vZGVzIHRvIHRoZSBzY2VuZSAqL1xuICAgIHB1YmxpYyBhZGQ6IEZhY3RvcnlNYW5hZ2VyO1xuXG4gICAgLyoqIEFuIGludGVyZmFjZSB0aGF0IGFsbG93cyB0aGUgbG9hZGluZyBvZiBkaWZmZXJlbnQgZmlsZXMgZm9yIHVzZSBpbiB0aGUgc2NlbmUuIEFuIGFsaWFzIGZvciByZXNvdXJjZU1hbmFnZXIgKi9cbiAgICBwdWJsaWMgbG9hZDogUmVzb3VyY2VNYW5hZ2VyO1xuXG4gICAgLyoqIEFuIGludGVyZmFjZSB0aGF0IGFsbG93cyB0aGUgbG9hZGluZyBhbmQgdW5sb2FkaW5nIG9mIGRpZmZlcmVudCBmaWxlcyBmb3IgdXNlIGluIHRoZSBzY2VuZSAqL1xuICAgIHB1YmxpYyByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcblxuICAgIC8qKiBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGlzIHNjZW5lICovXG4gICAgcHVibGljIHNjZW5lT3B0aW9uczogU2NlbmVPcHRpb25zO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTY2VuZS4gVG8gYWRkIGEgbmV3IFNjZW5lIGluIHlvdXIgZ2FtZSwgdXNlIGNoYW5nZVRvU2NlbmUoKSBpbiBAcmVmZXJlbmNlW1NjZW5lTWFuYWdlcl1cbiAgICAgKiBAcGFyYW0gdmlld3BvcnQgVGhlIHZpZXdwb3J0IG9mIHRoZSBnYW1lXG4gICAgICogQHBhcmFtIHNjZW5lTWFuYWdlciBUaGUgU2NlbmVNYW5hZ2VyIHRoYXQgb3ducyB0aGlzIFNjZW5lXG4gICAgICogQHBhcmFtIHJlbmRlcmluZ01hbmFnZXIgVGhlIFJlbmRlcmluZ01hbmFnZXIgdGhhdCB3aWxsIGhhbmRsZSB0aGlzIFNjZW5lJ3MgcmVuZGVyaW5nXG4gICAgICogQHBhcmFtIGdhbWUgVGhlIGluc3RhbmNlIG9mIHRoZSBHYW1lXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIFNjZW5lIGluaXRpYWxpemF0aW9uXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iodmlld3BvcnQ6IFZpZXdwb3J0LCBzY2VuZU1hbmFnZXI6IFNjZW5lTWFuYWdlciwgcmVuZGVyaW5nTWFuYWdlcjogUmVuZGVyaW5nTWFuYWdlciwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pil7XG4gICAgICAgIHRoaXMuc2NlbmVPcHRpb25zID0gU2NlbmVPcHRpb25zLnBhcnNlKG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHt9IDogb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy53b3JsZFNpemUgPSBuZXcgVmVjMig1MDAsIDUwMCk7XG4gICAgICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgICAgdGhpcy52aWV3cG9ydC5zZXRCb3VuZHMoMCwgMCwgMjU2MCwgMTI4MCk7XG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNjZW5lTWFuYWdlciA9IHNjZW5lTWFuYWdlcjtcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IG5ldyBSZWNlaXZlcigpO1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuXG4gICAgICAgIHRoaXMudGlsZW1hcHMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5zY2VuZUdyYXBoID0gbmV3IFNjZW5lR3JhcGhBcnJheSh0aGlzLnZpZXdwb3J0LCB0aGlzKTtcblxuICAgICAgICB0aGlzLmxheWVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy51aUxheWVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5wYXJhbGxheExheWVycyA9IG5ldyBNYXAoKTtcblxuICAgICAgICB0aGlzLnBoeXNpY3NNYW5hZ2VyID0gbmV3IEJhc2ljUGh5c2ljc01hbmFnZXIodGhpcy5zY2VuZU9wdGlvbnMucGh5c2ljcyk7XG4gICAgICAgIHRoaXMubmF2TWFuYWdlciA9IG5ldyBOYXZpZ2F0aW9uTWFuYWdlcigpO1xuICAgICAgICB0aGlzLmFpTWFuYWdlciA9IG5ldyBBSU1hbmFnZXIoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJpbmdNYW5hZ2VyID0gcmVuZGVyaW5nTWFuYWdlcjtcblxuICAgICAgICB0aGlzLmFkZCA9IG5ldyBGYWN0b3J5TWFuYWdlcih0aGlzLCB0aGlzLnRpbGVtYXBzKTtcblxuICAgICAgICB0aGlzLmxvYWQgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKVxuICAgICAgICB0aGlzLnJlc291cmNlTWFuYWdlciA9IHRoaXMubG9hZDtcblxuICAgICAgICAvLyBHZXQgdGhlIHRpbWVyIG1hbmFnZXIgYW5kIGNsZWFyIGFueSBleGlzdGluZyB0aW1lcnNcbiAgICAgICAgVGltZXJNYW5hZ2VyLmdldEluc3RhbmNlKCkuY2xlYXJUaW1lcnMoKTtcbiAgICB9XG5cbiAgICAvKiogQSBsaWZlY3ljbGUgbWV0aG9kIHRoYXQgZ2V0cyBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgYSBuZXcgc2NlbmUgaXMgY3JlYXRlZCwgYmVmb3JlIGFueXRoaW5nIGVsc2UuICovXG4gICAgaW5pdFNjZW5lKGluaXQ6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHt9XG5cbiAgICAvKiogQSBsaWZlY3ljbGUgbWV0aG9kIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbiBhIG5ldyBzY2VuZSBpcyBjcmVhdGVkLiBMb2FkIGFsbCBmaWxlcyB5b3Ugd2lzaCB0byBhY2Nlc3MgaW4gdGhlIHNjZW5lIGhlcmUuICovXG4gICAgbG9hZFNjZW5lKCk6IHZvaWQge31cblxuICAgIC8qKiBBIGxpZmVjeWNsZSBtZXRob2QgY2FsbGVkIHN0cmljdGx5IGFmdGVyIGxvYWRTY2VuZSgpLiBDcmVhdGUgYW55IGdhbWUgb2JqZWN0cyB5b3Ugd2lzaCB0byB1c2UgaW4gdGhlIHNjZW5lIGhlcmUuICovXG4gICAgc3RhcnRTY2VuZSgpOiB2b2lkIHt9XG5cbiAgICAvKipcbiAgICAgKiBBIGxpZmVjeWNsZSBtZXRob2QgY2FsbGVkIGV2ZXJ5IGZyYW1lIG9mIHRoZSBnYW1lLiBUaGlzIGlzIHdoZXJlIHlvdSBjYW4gZHluYW1pY2FsbHkgZG8gdGhpbmdzIGxpa2UgYWRkIGluIG5ldyBlbmVtaWVzXG4gICAgICogQHBhcmFtIGRlbHRhIFRoZSB0aW1lIHRoaXMgZnJhbWUgcmVwcmVzZW50c1xuICAgICAqL1xuICAgIHVwZGF0ZVNjZW5lKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7fVxuXG4gICAgLyoqIEEgbGlmZWN5Y2xlIG1ldGhvZCB0aGF0IGdldHMgY2FsbGVkIG9uIHNjZW5lIGRlc3RydWN0aW9uLiBTcGVjaWZ5IHdoaWNoIGZpbGVzIHlvdSBubyBsb25nZXIgbmVlZCBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLiAqL1xuICAgIHVubG9hZFNjZW5lKCk6IHZvaWQge31cblxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLnVwZGF0ZVNjZW5lKGRlbHRhVCk7XG5cbiAgICAgICAgLy8gRG8gdGltZSB1cGRhdGVzXG4gICAgICAgIFRpbWVyTWFuYWdlci5nZXRJbnN0YW5jZSgpLnVwZGF0ZShkZWx0YVQpO1xuXG4gICAgICAgIC8vIERvIGFsbCBBSSB1cGRhdGVzXG4gICAgICAgIHRoaXMuYWlNYW5hZ2VyLnVwZGF0ZShkZWx0YVQpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBhbGwgcGh5c2ljcyBvYmplY3RzXG4gICAgICAgIHRoaXMucGh5c2ljc01hbmFnZXIudXBkYXRlKGRlbHRhVCk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGFsbCBjYW52YXMgb2JqZWN0c1xuICAgICAgICB0aGlzLnNjZW5lR3JhcGgudXBkYXRlKGRlbHRhVCk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGFsbCB0aWxlbWFwc1xuICAgICAgICB0aGlzLnRpbGVtYXBzLmZvckVhY2godGlsZW1hcCA9PiB7XG4gICAgICAgICAgICBpZighdGlsZW1hcC5nZXRMYXllcigpLmlzUGF1c2VkKCkpe1xuICAgICAgICAgICAgICAgIHRpbGVtYXAudXBkYXRlKGRlbHRhVCk7XG4gICAgICAgICAgICB9IFxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBhbGwgdHdlZW5zXG4gICAgICAgIFR3ZWVuTWFuYWdlci5nZXRJbnN0YW5jZSgpLnVwZGF0ZShkZWx0YVQpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBhbGwgcGFydGljbGUgc3lzdGVtc1xuICAgICAgICBQYXJ0aWNsZVN5c3RlbU1hbmFnZXIuZ2V0SW5zdGFuY2UoKS51cGRhdGUoZGVsdGFUKTtcblxuICAgICAgICAvLyBVcGRhdGUgdmlld3BvcnRcbiAgICAgICAgdGhpcy52aWV3cG9ydC51cGRhdGUoZGVsdGFUKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb2xsZWN0cyByZW5kZXJhYmxlIHNldHMgYW5kIGNvb3JkaW5hdGVzIHdpdGggdGhlIFJlbmRlcmluZ01hbmFnZXIgdG8gZHJhdyB0aGUgU2NlbmVcbiAgICAgKi9cbiAgICByZW5kZXIoKTogdm9pZCB7XG4gICAgICAgIC8vIEdldCB0aGUgdmlzaWJsZSBzZXQgb2Ygbm9kZXNcbiAgICAgICAgbGV0IHZpc2libGVTZXQgPSB0aGlzLnNjZW5lR3JhcGguZ2V0VmlzaWJsZVNldCgpO1xuXG4gICAgICAgIC8vIEFkZCBwYXJhbGxheCBsYXllciBpdGVtcyB0byB0aGUgdmlzaWJsZSBzZXQgKHdlJ3JlIHJlbmRlcmluZyB0aGVtIGFsbCBmb3Igbm93KVxuICAgICAgICB0aGlzLnBhcmFsbGF4TGF5ZXJzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCBwTGF5ZXIgPSB0aGlzLnBhcmFsbGF4TGF5ZXJzLmdldChrZXkpO1xuICAgICAgICAgICAgZm9yKGxldCBub2RlIG9mIHBMYXllci5nZXRJdGVtcygpKXtcbiAgICAgICAgICAgICAgICBpZihub2RlIGluc3RhbmNlb2YgQ2FudmFzTm9kZSl7XG4gICAgICAgICAgICAgICAgICAgIHZpc2libGVTZXQucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNlbmQgdGhlIHZpc2libGUgc2V0LCB0aWxlbWFwcywgYW5kIHVpTGF5ZXJzIHRvIHRoZSByZW5kZXJlclxuICAgICAgICB0aGlzLnJlbmRlcmluZ01hbmFnZXIucmVuZGVyKHZpc2libGVTZXQsIHRoaXMudGlsZW1hcHMsIHRoaXMudWlMYXllcnMpO1xuXG4gICAgICAgIGxldCBub2RlcyA9IHRoaXMuc2NlbmVHcmFwaC5nZXRBbGxOb2RlcygpO1xuICAgICAgICB0aGlzLnRpbGVtYXBzLmZvckVhY2godGlsZW1hcCA9PiB0aWxlbWFwLnZpc2libGUgPyBub2Rlcy5wdXNoKHRpbGVtYXApIDogMCk7XG4gICAgICAgIERlYnVnLnNldE5vZGVzKG5vZGVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzY2VuZSBhcyBydW5uaW5nIG9yIG5vdFxuICAgICAqIEBwYXJhbSBydW5uaW5nIFRydWUgaWYgdGhlIFNjZW5lIHNob3VsZCBiZSBydW5uaW5nLCBmYWxzZSBpZiBub3RcbiAgICAgKi9cbiAgICBzZXRSdW5uaW5nKHJ1bm5pbmc6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gcnVubmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBTY2VuZSBpcyBydW5uaW5nXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgc2NlbmUgaXMgcnVubmluZywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgaXNSdW5uaW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5ydW5uaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBub2RlIGZyb20gdGhpcyBTY2VuZVxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZVxuICAgICAqL1xuICAgIHJlbW92ZShub2RlOiBHYW1lTm9kZSk6IHZvaWQge1xuICAgICAgICAvLyBSZW1vdmUgZnJvbSB0aGUgc2NlbmUgZ3JhcGhcbiAgICAgICAgaWYobm9kZSBpbnN0YW5jZW9mIENhbnZhc05vZGUpe1xuICAgICAgICAgICAgdGhpcy5zY2VuZUdyYXBoLnJlbW92ZU5vZGUobm9kZSk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qKiBEZXN0cm95cyB0aGlzIHNjZW5lIGFuZCBhbGwgbm9kZXMgaW4gaXQgKi9cbiAgICBkZXN0cm95KCk6IHZvaWQge1xuICAgICAgICBmb3IobGV0IG5vZGUgb2YgdGhpcy5zY2VuZUdyYXBoLmdldEFsbE5vZGVzKCkpe1xuICAgICAgICAgICAgbm9kZS5kZXN0cm95KCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IobGV0IHRpbGVtYXAgb2YgdGhpcy50aWxlbWFwcyl7XG4gICAgICAgICAgICB0aWxlbWFwLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVjZWl2ZXIuZGVzdHJveSgpO1xuXG4gICAgICAgIGRlbGV0ZSB0aGlzLnNjZW5lR3JhcGg7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnBoeXNpY3NNYW5hZ2VyO1xuICAgICAgICBkZWxldGUgdGhpcy5uYXZNYW5hZ2VyO1xuICAgICAgICBkZWxldGUgdGhpcy5haU1hbmFnZXI7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnJlY2VpdmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgbGF5ZXIgdG8gdGhlIHNjZW5lIGFuZCByZXR1cm5zIGl0XG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIG5ldyBsYXllclxuICAgICAqIEBwYXJhbSBkZXB0aCBUaGUgZGVwdGggb2YgdGhlIGxheWVyXG4gICAgICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQgTGF5ZXJcbiAgICAgKi9cbiAgICBhZGRMYXllcihuYW1lOiBzdHJpbmcsIGRlcHRoPzogbnVtYmVyKTogTGF5ZXIge1xuICAgICAgICBpZih0aGlzLmxheWVycy5oYXMobmFtZSkgfHwgdGhpcy5wYXJhbGxheExheWVycy5oYXMobmFtZSkgfHwgdGhpcy51aUxheWVycy5oYXMobmFtZSkpe1xuICAgICAgICAgICAgdGhyb3cgYExheWVyIHdpdGggbmFtZSAke25hbWV9IGFscmVhZHkgZXhpc3RzYDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsYXllciA9IG5ldyBMYXllcih0aGlzLCBuYW1lKTtcblxuICAgICAgICB0aGlzLmxheWVycy5hZGQobmFtZSwgbGF5ZXIpO1xuXG4gICAgICAgIGlmKGRlcHRoKXtcbiAgICAgICAgICAgIGxheWVyLnNldERlcHRoKGRlcHRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IHBhcmFsbGF4IGxheWVyIHRvIHRoaXMgc2NlbmUgYW5kIHJldHVybnMgaXRcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcGFyYWxsYXggbGF5ZXJcbiAgICAgKiBAcGFyYW0gcGFyYWxsYXggVGhlIHBhcmFsbGF4IGxldmVsXG4gICAgICogQHBhcmFtIGRlcHRoIFRoZSBkZXB0aCBvZiB0aGUgbGF5ZXJcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3bHkgY3JlYXRlZCBQYXJhbGxheExheWVyXG4gICAgICovXG4gICAgYWRkUGFyYWxsYXhMYXllcihuYW1lOiBzdHJpbmcsIHBhcmFsbGF4OiBWZWMyLCBkZXB0aD86IG51bWJlcik6IFBhcmFsbGF4TGF5ZXIge1xuICAgICAgICBpZih0aGlzLmxheWVycy5oYXMobmFtZSkgfHwgdGhpcy5wYXJhbGxheExheWVycy5oYXMobmFtZSkgfHwgdGhpcy51aUxheWVycy5oYXMobmFtZSkpe1xuICAgICAgICAgICAgdGhyb3cgYExheWVyIHdpdGggbmFtZSAke25hbWV9IGFscmVhZHkgZXhpc3RzYDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsYXllciA9IG5ldyBQYXJhbGxheExheWVyKHRoaXMsIG5hbWUsIHBhcmFsbGF4KTtcblxuICAgICAgICB0aGlzLnBhcmFsbGF4TGF5ZXJzLmFkZChuYW1lLCBsYXllcik7XG5cbiAgICAgICAgaWYoZGVwdGgpe1xuICAgICAgICAgICAgbGF5ZXIuc2V0RGVwdGgoZGVwdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgVUlMYXllciB0byB0aGUgc2NlbmVcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbmV3IFVJbGF5ZXJcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3bHkgY3JlYXRlZCBVSUxheWVyXG4gICAgICovXG4gICAgYWRkVUlMYXllcihuYW1lOiBzdHJpbmcpOiBVSUxheWVyIHtcbiAgICAgICAgaWYodGhpcy5sYXllcnMuaGFzKG5hbWUpIHx8IHRoaXMucGFyYWxsYXhMYXllcnMuaGFzKG5hbWUpIHx8IHRoaXMudWlMYXllcnMuaGFzKG5hbWUpKXtcbiAgICAgICAgICAgIHRocm93IGBMYXllciB3aXRoIG5hbWUgJHtuYW1lfSBhbHJlYWR5IGV4aXN0c2A7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGF5ZXIgPSBuZXcgVUlMYXllcih0aGlzLCBuYW1lKTtcblxuICAgICAgICB0aGlzLnVpTGF5ZXJzLmFkZChuYW1lLCBsYXllcik7XG5cbiAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBsYXllciBmcm9tIHRoZSBzY2VuZSBieSBuYW1lIGlmIGl0IGV4aXN0cy5cbiAgICAgKiBUaGlzIGNhbiBiZSBhIExheWVyIG9yIGFueSBvZiBpdHMgc3ViY2xhc3Nlc1xuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBsYXllclxuICAgICAqIEByZXR1cm5zIFRoZSBMYXllciBmb3VuZCB3aXRoIHRoYXQgbmFtZVxuICAgICAqL1xuICAgIGdldExheWVyKG5hbWU6IHN0cmluZyk6IExheWVyIHtcbiAgICAgICAgaWYodGhpcy5sYXllcnMuaGFzKG5hbWUpKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheWVycy5nZXQobmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZih0aGlzLnBhcmFsbGF4TGF5ZXJzLmhhcyhuYW1lKSl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJhbGxheExheWVycy5nZXQobmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZih0aGlzLnVpTGF5ZXJzLmhhcyhuYW1lKSl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51aUxheWVycy5nZXQobmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBgUmVxdWVzdGVkIGxheWVyICR7bmFtZX0gZG9lcyBub3QgZXhpc3QuYDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGxheWVyIGlzIGEgUGFyYWxsYXhMYXllclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBsYXllclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhpcyBsYXllciBpcyBhIFBhcmFsbGF4TGF5ZXJcbiAgICAgKi9cbiAgICBpc1BhcmFsbGF4TGF5ZXIobmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFsbGF4TGF5ZXJzLmhhcyhuYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBsYXllciBpcyBhIFVJTGF5ZXJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbGF5ZXJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoaXMgbGF5ZXIgaXMgUGFyYWxsYXhMYXllclxuICAgICAqL1xuICAgIGlzVUlMYXllcihuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudWlMYXllcnMuaGFzKG5hbWUpO1xuICAgIH0gICAgXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0cmFuc2xhdGlvbiBvZiB0aGlzIG5vZGUgd2l0aCByZXNwZWN0IHRvIGNhbWVyYSBzcGFjZSAoZHVlIHRvIHRoZSB2aWV3cG9ydCBtb3ZpbmcpLlxuICAgICAqIFRoaXMgdmFsdWUgaXMgYWZmZWN0ZWQgYnkgdGhlIHBhcmFsbGF4IGxldmVsIG9mIHRoZSBAcmVmZXJlbmNlW0xheWVyXSB0aGUgbm9kZSBpcyBvbi5cbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byBjaGVjayB0aGUgdmlld3BvcnQgd2l0aCByZXNwZWN0IHRvXG4gICAgICogQHJldHVybnMgQSBWZWMyIGNvbnRhaW5pbmcgdGhlIHRyYW5zbGF0aW9uIG9mIHZpZXdwb3J0IHdpdGggcmVzcGVjdCB0byB0aGlzIG5vZGUuXG4gICAgICovXG4gICAgZ2V0Vmlld1RyYW5zbGF0aW9uKG5vZGU6IEdhbWVOb2RlKTogVmVjMiB7XG4gICAgICAgIGxldCBsYXllciA9IG5vZGUuZ2V0TGF5ZXIoKTtcblxuICAgICAgICBpZihsYXllciBpbnN0YW5jZW9mIFBhcmFsbGF4TGF5ZXIgfHwgbGF5ZXIgaW5zdGFuY2VvZiBVSUxheWVyKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdwb3J0LmdldE9yaWdpbigpLm11bHQobGF5ZXIucGFyYWxsYXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnQuZ2V0T3JpZ2luKCk7XG4gICAgICAgIH1cblx0fVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2NhbGUgbGV2ZWwgb2YgdGhlIHZpZXdcbiAgICAgKiBAcmV0dXJucyBUaGUgem9vbSBsZXZlbCBvZiB0aGUgdmlld3BvcnRcbiAgICAqL1xuXHRnZXRWaWV3U2NhbGUoKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy52aWV3cG9ydC5nZXRab29tTGV2ZWwoKTtcblx0fVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVmlld3BvcnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc2NlbmVcbiAgICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBWaWV3cG9ydFxuICAgICAqL1xuICAgIGdldFZpZXdwb3J0KCk6IFZpZXdwb3J0IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgd29ybGQgc2l6ZSBvZiB0aGlzIFNjZW5lXG4gICAgICogQHJldHVybnMgVGhlIHdvcmxkIHNpemUgaW4gYSBWZWMyXG4gICAgICovXG4gICAgZ2V0V29ybGRTaXplKCk6IFZlYzIge1xuICAgICAgICByZXR1cm4gdGhpcy53b3JsZFNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgU2NlbmVHcmFwaCBhc3NvY2lhdGVkIHdpdGggdGhpcyBTY2VuZVxuICAgICAqIEByZXR1cm5zIFRoZSBTY2VuZUdyYXBoXG4gICAgICovXG4gICAgZ2V0U2NlbmVHcmFwaCgpOiBTY2VuZUdyYXBoIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NlbmVHcmFwaDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBQaHlzaWNzTWFuYWdlciBhc3NvY2lhdGVkIHdpdGggdGhpcyBTY2VuZVxuICAgICAqIEByZXR1cm5zIFRoZSBQaHlzaWNzTWFuYWdlclxuICAgICAqL1xuICAgIGdldFBoeXNpY3NNYW5hZ2VyKCk6IFBoeXNpY3NNYW5hZ2VyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGh5c2ljc01hbmFnZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgTmF2aWdhdGlvbk1hbmFnZXIgYXNzb2NpYXRlZCB3aXRoIHRoaXMgU2NlbmVcbiAgICAgKiBAcmV0dXJucyBUaGUgTmF2aWdhdGlvbk1hbmFnZXJcbiAgICAgKi9cbiAgICBnZXROYXZpZ2F0aW9uTWFuYWdlcigpOiBOYXZpZ2F0aW9uTWFuYWdlciB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdk1hbmFnZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgQUlNYW5hZ2VyIGFzc29jaWF0ZWQgd2l0aCB0aGlzIFNjZW5lXG4gICAgICogQHJldHVybnMgVGhlIEFJTWFuYWdlclxuICAgICAqL1xuICAgIGdldEFJTWFuYWdlcigpOiBBSU1hbmFnZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5haU1hbmFnZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGFuIElEIGZvciBhIEdhbWVOb2RlXG4gICAgICogQHJldHVybnMgVGhlIG5ldyBJRFxuICAgICAqL1xuICAgIGdlbmVyYXRlSWQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NlbmVNYW5hZ2VyLmdlbmVyYXRlSWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBUaWxlbWFwIGluIHRoaXMgU2NlbmVcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgVGlsZW1hcFxuICAgICAqIEByZXR1cm5zIFRoZSBUaWxlbWFwLCBpZiBvbmUgdGhpcyBuYW1lIGV4aXN0cywgb3RoZXJ3aXNlIG51bGxcbiAgICAgKi9cbiAgICBnZXRUaWxlbWFwKG5hbWU6IHN0cmluZyk6IFRpbGVtYXAge1xuICAgICAgICBmb3IobGV0IHRpbGVtYXAgb2YgdGhpcyAudGlsZW1hcHMpe1xuICAgICAgICAgICAgaWYodGlsZW1hcC5uYW1lID09PSBuYW1lKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGlsZW1hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn0iLCJpbXBvcnQgU2NlbmUgZnJvbSBcIi4vU2NlbmVcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBWaWV3cG9ydCBmcm9tIFwiLi4vU2NlbmVHcmFwaC9WaWV3cG9ydFwiO1xuaW1wb3J0IFJlbmRlcmluZ01hbmFnZXIgZnJvbSBcIi4uL1JlbmRlcmluZy9SZW5kZXJpbmdNYW5hZ2VyXCI7XG5pbXBvcnQgTWVtb3J5VXRpbHMgZnJvbSBcIi4uL1V0aWxzL01lbW9yeVV0aWxzXCI7XG5cbi8qKlxuICogVGhlIFNjZW5lTWFuYWdlciBhY3RzIGFzIGFuIGludGVyZmFjZSB0byBjcmVhdGUgU2NlbmVzLCBhbmQgaGFuZGxlcyB0aGUgbGlmZWN5Y2xlIG1ldGhvZHMgb2YgU2NlbmVzLlxuICogSXQgZ2l2ZXMgU2NlbmVzIGFjY2VzcyB0byBpbmZvcm1hdGlvbiB0aGV5IG5lZWQgZnJvbSB0aGUgQHJlZmVyZW5jZVtHYW1lXSBjbGFzcyB3aGlsZSBrZWVwaW5nIGEgbGF5ZXIgb2Ygc2VwYXJhdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NlbmVNYW5hZ2VyIHtcblx0LyoqIFRoZSBjdXJyZW50IFNjZW5lIG9mIHRoZSBnYW1lICovXG5cdHByb3RlY3RlZCBjdXJyZW50U2NlbmU6IFNjZW5lO1xuXG5cdC8qKiBUaGUgVmlld3BvcnQgb2YgdGhlIGdhbWUgKi9cblx0cHJvdGVjdGVkIHZpZXdwb3J0OiBWaWV3cG9ydDtcblxuXHQvKiogQSByZWZlcmVuY2UgdG8gdGhlIFJlc291cmNlTWFuYWdlciAqL1xuXHRwcm90ZWN0ZWQgcmVzb3VyY2VNYW5hZ2VyOiBSZXNvdXJjZU1hbmFnZXI7XG5cblx0LyoqIEEgY291bnRlciB0byBrZWVwIHRyYWNrIG9mIGdhbWUgaWRzICovXG5cdHByb3RlY3RlZCBpZENvdW50ZXI6IG51bWJlcjtcblxuXHQvKiogVGhlIFJlbmRlcmluZ01hbmFnZXIgb2YgdGhlIGdhbWUgKi9cblx0cHJvdGVjdGVkIHJlbmRlcmluZ01hbmFnZXI6IFJlbmRlcmluZ01hbmFnZXI7XG5cblx0LyoqIEZvciBjb25zaXN0ZW5jeSwgb25seSBjaGFuZ2Ugc2NlbmVzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHVwZGF0ZSBjeWNsZSAqL1xuXHRwcm90ZWN0ZWQgcGVuZGluZ1NjZW5lOiBTY2VuZTtcblx0cHJvdGVjdGVkIHBlbmRpbmdTY2VuZUluaXQ6IFJlY29yZDxzdHJpbmcsIGFueT47XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgU2NlbmVNYW5hZ2VyXG5cdCAqIEBwYXJhbSB2aWV3cG9ydCBUaGUgVmlld3BvcnQgb2YgdGhlIGdhbWVcblx0ICogQHBhcmFtIGdhbWUgVGhlIEdhbWUgaW5zdGFuY2Vcblx0ICogQHBhcmFtIHJlbmRlcmluZ01hbmFnZXIgVGhlIFJlbmRlcmluZ01hbmFnZXIgb2YgdGhlIGdhbWVcblx0ICovXG5cdGNvbnN0cnVjdG9yKHZpZXdwb3J0OiBWaWV3cG9ydCwgcmVuZGVyaW5nTWFuYWdlcjogUmVuZGVyaW5nTWFuYWdlcil7XG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcblx0XHR0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG5cdFx0dGhpcy5yZW5kZXJpbmdNYW5hZ2VyID0gcmVuZGVyaW5nTWFuYWdlcjtcblx0XHR0aGlzLmlkQ291bnRlciA9IDA7XG5cdFx0dGhpcy5wZW5kaW5nU2NlbmUgPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZCBhIHNjZW5lIGFzIHRoZSBtYWluIHNjZW5lLlxuXHQgKiBVc2UgdGhpcyBtZXRob2QgaWYgeW91J3ZlIGNyZWF0ZWQgYSBzdWJjbGFzcyBvZiBTY2VuZSwgYW5kIHlvdSB3YW50IHRvIGFkZCBpdCBhcyB0aGUgbWFpbiBTY2VuZS5cblx0ICogQHBhcmFtIGNvbnN0ciBUaGUgY29uc3RydWN0b3Igb2YgdGhlIHNjZW5lIHRvIGFkZFxuXHQgKiBAcGFyYW0gaW5pdCBBbiBvYmplY3QgdG8gcGFzcyB0byB0aGUgaW5pdCBmdW5jdGlvbiBvZiB0aGUgbmV3IHNjZW5lXG5cdCAqL1xuXHRwdWJsaWMgY2hhbmdlVG9TY2VuZTxUIGV4dGVuZHMgU2NlbmU+KGNvbnN0cjogbmV3ICguLi5hcmdzOiBhbnkpID0+IFQsIGluaXQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuXHRcdGNvbnNvbGUubG9nKFwiQ3JlYXRpbmcgdGhlIG5ldyBzY2VuZSAtIGNoYW5nZSBpcyBwZW5kaW5nIHVudGlsIG5leHQgdXBkYXRlXCIpO1xuXHRcdHRoaXMucGVuZGluZ1NjZW5lID0gbmV3IGNvbnN0cih0aGlzLnZpZXdwb3J0LCB0aGlzLCB0aGlzLnJlbmRlcmluZ01hbmFnZXIsIG9wdGlvbnMpO1xuXHRcdHRoaXMucGVuZGluZ1NjZW5lSW5pdCA9IGluaXQ7XG5cdH1cblxuXHRwcm90ZWN0ZWQgZG9TY2VuZUNoYW5nZSgpe1xuXHRcdGNvbnNvbGUubG9nKFwiUGVyZm9ybWluZyBzY2VuZSBjaGFuZ2VcIik7XG5cdFx0dGhpcy52aWV3cG9ydC5zZXRDZW50ZXIodGhpcy52aWV3cG9ydC5nZXRIYWxmU2l6ZSgpLngsIHRoaXMudmlld3BvcnQuZ2V0SGFsZlNpemUoKS55KTtcblx0XHRcblx0XHRpZih0aGlzLmN1cnJlbnRTY2VuZSl7XG5cdFx0XHRjb25zb2xlLmxvZyhcIlVubG9hZGluZyBvbGQgc2NlbmVcIilcblx0XHRcdHRoaXMuY3VycmVudFNjZW5lLnVubG9hZFNjZW5lKCk7XG5cblx0XHRcdGNvbnNvbGUubG9nKFwiRGVzdHJveWluZyBvbGQgc2NlbmVcIik7XG5cdFx0XHR0aGlzLmN1cnJlbnRTY2VuZS5kZXN0cm95KCk7XG5cdFx0fVxuXG5cdFx0Y29uc29sZS5sb2coXCJVbmxvYWRpbmcgb2xkIHJlc291cmNlcy4uLlwiKTtcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlci51bmxvYWRBbGxSZXNvdXJjZXMoKTtcblxuXHRcdC8vIE1ha2UgdGhlIHBlbmRpbmcgc2NlbmUgdGhlIGN1cnJlbnQgb25lXG5cdFx0dGhpcy5jdXJyZW50U2NlbmUgPSB0aGlzLnBlbmRpbmdTY2VuZTtcblxuXHRcdC8vIE1ha2UgdGhlIHBlbmRpbmcgc2NlbmUgbnVsbFxuXHRcdHRoaXMucGVuZGluZ1NjZW5lID0gbnVsbDtcblxuXHRcdC8vIEluaXQgdGhlIHNjZW5lXG5cdFx0dGhpcy5jdXJyZW50U2NlbmUuaW5pdFNjZW5lKHRoaXMucGVuZGluZ1NjZW5lSW5pdCk7XG5cblx0XHQvLyBFbnF1ZXVlIGFsbCBzY2VuZSBhc3NldCBsb2Fkc1xuXHRcdHRoaXMuY3VycmVudFNjZW5lLmxvYWRTY2VuZSgpO1xuXG5cdFx0Ly8gTG9hZCBhbGwgYXNzZXRzXG5cdFx0Y29uc29sZS5sb2coXCJTdGFydGluZyBTY2VuZSBMb2FkXCIpO1xuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyLmxvYWRSZXNvdXJjZXNGcm9tUXVldWUoKCkgPT4ge1xuXHRcdFx0Y29uc29sZS5sb2coXCJTdGFydGluZyBTY2VuZVwiKTtcblx0XHRcdHRoaXMuY3VycmVudFNjZW5lLnN0YXJ0U2NlbmUoKTtcblx0XHRcdHRoaXMuY3VycmVudFNjZW5lLnNldFJ1bm5pbmcodHJ1ZSk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLnJlbmRlcmluZ01hbmFnZXIuc2V0U2NlbmUodGhpcy5jdXJyZW50U2NlbmUpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogR2VuZXJhdGVzIGEgdW5pcXVlIElEXG5cdCAqIEByZXR1cm5zIEEgbmV3IElEXG5cdCAqL1xuXHRwdWJsaWMgZ2VuZXJhdGVJZCgpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLmlkQ291bnRlcisrO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbmRlcnMgdGhlIGN1cnJlbnQgU2NlbmVcblx0ICovXG5cdHB1YmxpYyByZW5kZXIoKTogdm9pZCB7XG5cdFx0aWYodGhpcy5jdXJyZW50U2NlbmUpe1xuXHRcdFx0dGhpcy5jdXJyZW50U2NlbmUucmVuZGVyKCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGN1cnJlbnQgU2NlbmVcblx0ICogQHBhcmFtIGRlbHRhVCBUaGUgdGltZXN0ZXAgb2YgdGhlIFNjZW5lXG5cdCAqL1xuXHRwdWJsaWMgdXBkYXRlKGRlbHRhVDogbnVtYmVyKXtcblx0XHRpZih0aGlzLnBlbmRpbmdTY2VuZSAhPT0gbnVsbCl7XG5cdFx0XHR0aGlzLmRvU2NlbmVDaGFuZ2UoKTtcblx0XHR9XG5cblx0XHRpZih0aGlzLmN1cnJlbnRTY2VuZSAmJiB0aGlzLmN1cnJlbnRTY2VuZS5pc1J1bm5pbmcoKSl7XG5cdFx0XHR0aGlzLmN1cnJlbnRTY2VuZS51cGRhdGUoZGVsdGFUKTtcblx0XHR9XG5cdH1cbn0iLCJpbXBvcnQgQXJyYXlVdGlscyBmcm9tIFwiLi4vVXRpbHMvQXJyYXlVdGlsc1wiO1xuXG4vLyBAaWdub3JlUGFnZVxuXG4vKipcbiAqIFRoZSBvcHRpb25zIHRvIGdpdmUgYSBAcmVmZXJlbmNlW1NjZW5lXSBmb3IgaW5pdGlhbGl6YXRpb25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NlbmVPcHRpb25zIHtcbiAgICBwaHlzaWNzOiB7XG4gICAgICAgIGdyb3VwczogQXJyYXk8c3RyaW5nPixcbiAgICAgICAgY29sbGlzaW9uczogQXJyYXk8QXJyYXk8bnVtYmVyPj47XG4gICAgfVxuXG4gICAgc3RhdGljIHBhcnNlKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBTY2VuZU9wdGlvbnN7XG4gICAgICAgIGxldCBzT3B0ID0gbmV3IFNjZW5lT3B0aW9ucygpO1xuXG4gICAgICAgIGlmKG9wdGlvbnMucGh5c2ljcyA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIHNPcHQucGh5c2ljcyA9IHtncm91cHM6IHVuZGVmaW5lZCwgY29sbGlzaW9uczogdW5kZWZpbmVkfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNPcHQucGh5c2ljcyA9IG9wdGlvbnMucGh5c2ljcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzT3B0O1xuICAgIH1cbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4uL0V2ZW50cy9SZWNlaXZlclwiO1xuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xuaW1wb3J0IHsgR2FtZUV2ZW50VHlwZSB9IGZyb20gXCIuLi9FdmVudHMvR2FtZUV2ZW50VHlwZVwiO1xuXG4vKipcbiAqIE1hbmFnZXMgYW55IHNvdW5kcyBvciBtdXNpYyBuZWVkZWQgZm9yIHRoZSBnYW1lLlxuICogVGhyb3VnaCB0aGUgRXZlbnRRdWV1ZSwgZXhwb3NlcyBpbnRlcmZhY2UgdG8gcGxheSBzb3VuZHMgc28gR2FtZU5vZGVzIGNhbiBhY3RpdmF0ZSBzb3VuZHMgd2l0aG91dFxuICogbmVlZGluZyBkaXJlY3QgcmVmZXJlbmNlcyB0byB0aGUgYXVkaW8gc3lzdGVtXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1ZGlvTWFuYWdlciB7XG4gICAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IEF1ZGlvTWFuYWdlcjtcblxuICAgIC8qKiBUaGUgZXZlbnQgcmVjZWl2ZXIgb2YgdGhpcyBBdWRpb01hbmFnZXIgKi9cbiAgICBwcml2YXRlIHJlY2VpdmVyOiBSZWNlaXZlcjtcblxuICAgIC8qKiBBIE1hcCBvZiB0aGUgbmFtZXMgb2YgY3VycmVudGx5IHBsYXlpbmcgKG9yIHBhdXNlZCkgc291bmRzIHRvIHRoZWlyIEF1ZGlvQnVmZmVycyAqL1xuICAgIHByaXZhdGUgY3VycmVudFNvdW5kczogTWFwPEF1ZGlvQnVmZmVyU291cmNlTm9kZT47XG5cbiAgICBwcml2YXRlIGF1ZGlvQ3R4OiBBdWRpb0NvbnRleHQ7XG5cbiAgICBwcml2YXRlIGdhaW5Ob2RlczogQXJyYXk8R2Fpbk5vZGU+O1xuXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLmluaXRBdWRpbygpO1xuICAgICAgICB0aGlzLnJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKCk7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKFtcbiAgICAgICAgICAgIEdhbWVFdmVudFR5cGUuUExBWV9TT1VORCxcbiAgICAgICAgICAgIEdhbWVFdmVudFR5cGUuU1RPUF9TT1VORCxcbiAgICAgICAgICAgIEdhbWVFdmVudFR5cGUuUExBWV9NVVNJQyxcbiAgICAgICAgICAgIEdhbWVFdmVudFR5cGUuUExBWV9TRlgsXG4gICAgICAgICAgICBHYW1lRXZlbnRUeXBlLk1VVEVfQ0hBTk5FTCxcbiAgICAgICAgICAgIEdhbWVFdmVudFR5cGUuVU5NVVRFX0NIQU5ORUxcbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMuY3VycmVudFNvdW5kcyA9IG5ldyBNYXAoKTtcblxuICAgICAgICB0aGlzLmdhaW5Ob2RlcyA9IG5ldyBBcnJheTxHYWluTm9kZT4oTUFYX0FVRElPX0NIQU5ORUxTKTtcbiAgICAgICAgdGhpcy5pbml0R2Fpbk5vZGVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpbnN0YW5jZSBvZiB0aGUgQXVkaW9NYW5hZ2VyIGNsYXNzIG9yIGNyZWF0ZSBhIG5ldyBvbmUgaWYgbm9uZSBleGlzdHNcbiAgICAgKiBAcmV0dXJucyBUaGUgQXVkaW9NYW5hZ2VyXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBBdWRpb01hbmFnZXIge1xuICAgICAgICBpZighdGhpcy5pbnN0YW5jZSl7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IEF1ZGlvTWFuYWdlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSB3ZWJBdWRpbyBjb250ZXh0XG4gICAgICovXG4gICAgcHJpdmF0ZSBpbml0QXVkaW8oKTogdm9pZCB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aW5kb3cuQXVkaW9Db250ZXh0ID0gd2luZG93LkF1ZGlvQ29udGV4dDsvLyB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0OyBcbiAgICAgICAgICAgIHRoaXMuYXVkaW9DdHggPSBuZXcgQXVkaW9Db250ZXh0KCk7IFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1dlYiBBdWRpbyBBUEkgc3VjY2Vzc2Z1bGx5IGxvYWRlZCcpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignV2ViIEF1ZGlvIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpOyBcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaW5pdEdhaW5Ob2RlcygpOiB2b2lkIHtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IE1BWF9BVURJT19DSEFOTkVMUzsgaSsrKXtcbiAgICAgICAgICAgIHRoaXMuZ2Fpbk5vZGVzW2ldID0gdGhpcy5hdWRpb0N0eC5jcmVhdGVHYWluKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGF1ZGlvIGNvbnRleHRcbiAgICAgKiBAcmV0dXJucyBUaGUgQXVkaW9Db250ZXh0XG4gICAgICovXG4gICAgcHVibGljIGdldEF1ZGlvQ29udGV4dCgpOiBBdWRpb0NvbnRleHQge1xuICAgICAgICByZXR1cm4gdGhpcy5hdWRpb0N0eDtcbiAgICB9XG5cbiAgICAvKlxuICAgICAgICBBY2NvcmRpbmcgdG8gdGhlIE1ETiwgY3JlYXRlIGEgbmV3IHNvdW5kIGZvciBldmVyeSBjYWxsOlxuXG4gICAgICAgIEFuIEF1ZGlvQnVmZmVyU291cmNlTm9kZSBjYW4gb25seSBiZSBwbGF5ZWQgb25jZTsgYWZ0ZXIgZWFjaCBjYWxsIHRvIHN0YXJ0KCksIHlvdSBoYXZlIHRvIGNyZWF0ZSBhIG5ldyBub2RlXG4gICAgICAgIGlmIHlvdSB3YW50IHRvIHBsYXkgdGhlIHNhbWUgc291bmQgYWdhaW4uIEZvcnR1bmF0ZWx5LCB0aGVzZSBub2RlcyBhcmUgdmVyeSBpbmV4cGVuc2l2ZSB0byBjcmVhdGUsIGFuZCB0aGVcbiAgICAgICAgYWN0dWFsIEF1ZGlvQnVmZmVycyBjYW4gYmUgcmV1c2VkIGZvciBtdWx0aXBsZSBwbGF5cyBvZiB0aGUgc291bmQuIEluZGVlZCwgeW91IGNhbiB1c2UgdGhlc2Ugbm9kZXMgaW4gYVxuICAgICAgICBcImZpcmUgYW5kIGZvcmdldFwiIG1hbm5lcjogY3JlYXRlIHRoZSBub2RlLCBjYWxsIHN0YXJ0KCkgdG8gYmVnaW4gcGxheWluZyB0aGUgc291bmQsIGFuZCBkb24ndCBldmVuIGJvdGhlciB0b1xuICAgICAgICBob2xkIGEgcmVmZXJlbmNlIHRvIGl0LiBJdCB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgZ2FyYmFnZS1jb2xsZWN0ZWQgYXQgYW4gYXBwcm9wcmlhdGUgdGltZSwgd2hpY2ggd29uJ3QgYmVcbiAgICAgICAgdW50aWwgc29tZXRpbWUgYWZ0ZXIgdGhlIHNvdW5kIGhhcyBmaW5pc2hlZCBwbGF5aW5nLlxuICAgICovXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBzb3VuZCBmcm9tIHRoZSBrZXkgb2YgYSBsb2FkZWQgYXVkaW8gZmlsZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgbG9hZGVkIGF1ZGlvIGZpbGUgdG8gY3JlYXRlIGEgbmV3IHNvdW5kIGZvclxuICAgICAqIEByZXR1cm5zIFRoZSBuZXdseSBjcmVhdGVkIEF1ZGlvQnVmZmVyXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVNvdW5kKGtleTogc3RyaW5nLCBob2xkUmVmZXJlbmNlOiBib29sZWFuLCBjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlLCBvcHRpb25zOiBNYXA8YW55Pik6IEF1ZGlvQnVmZmVyU291cmNlTm9kZSB7XG4gICAgICAgIC8vIEdldCBhdWRpbyBidWZmZXJcbiAgICAgICAgbGV0IGJ1ZmZlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLmdldEF1ZGlvKGtleSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgc291bmQgc291cmNlXG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmF1ZGlvQ3R4LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpOyBcbiAgICAgIFxuICAgICAgICAvLyBUZWxsIHRoZSBzb3VyY2Ugd2hpY2ggc291bmQgdG8gcGxheVxuICAgICAgICBzb3VyY2UuYnVmZmVyID0gYnVmZmVyOyAgICAgICAgICAgICAgIFxuICAgICAgXG4gICAgICAgIC8vIEFkZCBhbnkgYWRkaXRpb25hbCBub2Rlc1xuICAgICAgICBjb25zdCBub2RlczogQXJyYXk8QXVkaW9Ob2RlPiA9IFtzb3VyY2VdO1xuXG4gICAgICAgIC8vIERvIGFueSBhZGRpdGlvbmFsIG5vZGVzIGhlcmU/XG4gICAgICAgIC8vIE9mIGNvdXJzZSwgdGhlcmUgYXJlbid0IGFueSBzdXBwb3J0ZWQgeWV0Li4uXG5cbiAgICAgICAgLy8gQWRkIHRoZSBnYWluIG5vZGUgZm9yIHRoaXMgY2hhbm5lbFxuICAgICAgICBub2Rlcy5wdXNoKHRoaXMuZ2Fpbk5vZGVzW2NoYW5uZWxdKTtcblxuICAgICAgICAvLyBDb25uZWN0IGFueSBub2RlcyBhbG9uZyB0aGUgcGF0aFxuICAgICAgICBmb3IobGV0IGkgPSAxOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgbm9kZXNbaS0xXS5jb25uZWN0KG5vZGVzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbm5lY3QgdGhlIHNvdXJjZSB0byB0aGUgY29udGV4dCdzIGRlc3RpbmF0aW9uXG4gICAgICAgIG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdLmNvbm5lY3QodGhpcy5hdWRpb0N0eC5kZXN0aW5hdGlvbik7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBsYXkgdGhlIHNvdW5kIHNwZWNpZmllZCBieSB0aGUga2V5XG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBzb3VuZCB0byBwbGF5XG4gICAgICogQHBhcmFtIGxvb3AgQSBib29sZWFuIGZvciB3aGV0aGVyIG9yIG5vdCB0byBsb29wIHRoZSBzb3VuZFxuICAgICAqIEBwYXJhbSBob2xkUmVmZXJlbmNlIEEgYm9vbGVhbiBmb3Igd2hldGhlciBvciBub3Qgd2Ugd2FudCB0byBob2xkIG9uIHRvIGEgcmVmZXJlbmNlIG9mIHRoZSBhdWRpbyBub2RlLiBUaGlzIGlzIGdvb2QgZm9yIHBsYXlpbmcgbXVzaWMgb24gYSBsb29wIHRoYXQgd2lsbCBldmVudHVhbGx5IG5lZWQgdG8gYmUgc3RvcHBlZC5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcGxheVNvdW5kKGtleTogc3RyaW5nLCBsb29wOiBib29sZWFuLCBob2xkUmVmZXJlbmNlOiBib29sZWFuLCBjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlLCBvcHRpb25zOiBNYXA8YW55Pik6IHZvaWQge1xuICAgICAgICBsZXQgc291bmQgPSB0aGlzLmNyZWF0ZVNvdW5kKGtleSwgaG9sZFJlZmVyZW5jZSwgY2hhbm5lbCwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYobG9vcCl7XG4gICAgICAgICAgICBzb3VuZC5sb29wID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBhIHJlZmVyZW5jZSBvZiB0aGUgbmV3IHNvdW5kIHRvIGEgbWFwLiBUaGlzIHdpbGwgYWxsb3cgdXMgdG8gc3RvcCBhIGxvb3Bpbmcgb3IgbG9uZyBzb3VuZCBhdCBhIGxhdGVyIHRpbWVcbiAgICAgICAgaWYoaG9sZFJlZmVyZW5jZSl7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTb3VuZHMuYWRkKGtleSwgc291bmQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzb3VuZC5zdGFydCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIHNvdW5kIHNwZWNpZmllZCBieSB0aGUga2V5XG4gICAgICovXG4gICAgcHJvdGVjdGVkIHN0b3BTb3VuZChrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBsZXQgc291bmQgPSB0aGlzLmN1cnJlbnRTb3VuZHMuZ2V0KGtleSk7XG4gICAgICAgIGlmKHNvdW5kKXtcbiAgICAgICAgICAgIHNvdW5kLnN0b3AoKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNvdW5kcy5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBtdXRlQ2hhbm5lbChjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlKXtcbiAgICAgICAgdGhpcy5nYWluTm9kZXNbY2hhbm5lbF0uZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLCB0aGlzLmF1ZGlvQ3R4LmN1cnJlbnRUaW1lKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgdW5tdXRlQ2hhbm5lbChjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlKXtcbiAgICAgICAgdGhpcy5nYWluTm9kZXNbY2hhbm5lbF0uZ2Fpbi5zZXRWYWx1ZUF0VGltZSgxLCB0aGlzLmF1ZGlvQ3R4LmN1cnJlbnRUaW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2b2x1bWUgb2YgYSBjaGFubmVsIHVzaW5nIHRoZSBHYWluTm9kZSBmb3IgdGhhdCBjaGFubmVsLiBGb3IgbW9yZVxuICAgICAqIGluZm9ybWF0aW9uIG9uIEdhaW5Ob2Rlcywgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9HYWluTm9kZVxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBhdWRpbyBjaGFubmVsIHRvIHNldCB0aGUgdm9sdW1lIGZvclxuICAgICAqIEBwYXJhbSB2b2x1bWUgVGhlIHZvbHVtZSBvZiB0aGUgY2hhbm5lbC4gMCBpcyBtdXRlZC4gVmFsdWVzIGJlbG93IHplcm8gd2lsbCBiZSBzZXQgdG8gemVyby5cbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0Vm9sdW1lKGNoYW5uZWw6IEF1ZGlvQ2hhbm5lbFR5cGUsIHZvbHVtZTogbnVtYmVyKXtcbiAgICAgICAgaWYodm9sdW1lIDwgMCl7XG4gICAgICAgICAgICB2b2x1bWUgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYW0gPSBBdWRpb01hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgYW0uZ2Fpbk5vZGVzW2NoYW5uZWxdLmdhaW4uc2V0VmFsdWVBdFRpbWUodm9sdW1lLCBhbS5hdWRpb0N0eC5jdXJyZW50VGltZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgR2Fpbk5vZGUgZm9yIHRoaXMgY2hhbm5lbC5cbiAgICAgKiBMZWFybiBtb3JlIGFib3V0IEdhaW5Ob2RlcyBoZXJlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9HYWluTm9kZVxuICAgICAqIERPTidUIFVTRSBUSElTIFVOTEVTUyBZT1UgS05PVyBXSEFUIFlPVSdSRSBET0lOR1xuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBjaGFubmVsXG4gICAgICogQHJldHVybnMgVGhlIEdhaW5Ob2RlIGZvciB0aGUgc3BlY2lmaWVkIGNoYW5uZWxcbiAgICAgKi9cbiAgICBnZXRDaGFubmVsR2Fpbk5vZGUoY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSl7XG4gICAgICAgIHJldHVybiB0aGlzLmdhaW5Ob2Rlc1tjaGFubmVsXTtcbiAgICB9XG4gICAgXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIC8vIFBsYXkgZWFjaCBhdWRpbyBjbGlwIHJlcXVlc3RlZFxuICAgICAgICAvLyBUT0RPIC0gQWRkIGxvZ2ljIHRvIG1lcmdlIHNvdW5kcyBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgb2YgdGhlIHNhbWUga2V5XG4gICAgICAgIHdoaWxlKHRoaXMucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpe1xuICAgICAgICAgICAgbGV0IGV2ZW50ID0gdGhpcy5yZWNlaXZlci5nZXROZXh0RXZlbnQoKTtcbiAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuUExBWV9TT1VORCB8fCBldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlBMQVlfTVVTSUMgfHwgZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5QTEFZX1NGWCl7XG4gICAgICAgICAgICAgICAgbGV0IHNvdW5kS2V5ID0gZXZlbnQuZGF0YS5nZXQoXCJrZXlcIik7XG4gICAgICAgICAgICAgICAgbGV0IGxvb3AgPSBldmVudC5kYXRhLmdldChcImxvb3BcIik7XG4gICAgICAgICAgICAgICAgbGV0IGhvbGRSZWZlcmVuY2UgPSBldmVudC5kYXRhLmdldChcImhvbGRSZWZlcmVuY2VcIik7XG5cbiAgICAgICAgICAgICAgICBsZXQgY2hhbm5lbCA9IEF1ZGlvQ2hhbm5lbFR5cGUuREVGQVVMVDtcblxuICAgICAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuUExBWV9NVVNJQyl7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwgPSBBdWRpb0NoYW5uZWxUeXBlLk1VU0lDO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihHYW1lRXZlbnRUeXBlLlBMQVlfU0ZYKXtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbCA9IEF1ZGlvQ2hhbm5lbFR5cGUuU0ZYO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihldmVudC5kYXRhLmhhcyhcImNoYW5uZWxcIikpe1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsID0gZXZlbnQuZGF0YS5nZXQoXCJjaGFubmVsXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMucGxheVNvdW5kKHNvdW5kS2V5LCBsb29wLCBob2xkUmVmZXJlbmNlLCBjaGFubmVsLCBldmVudC5kYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5TVE9QX1NPVU5EKXtcbiAgICAgICAgICAgICAgICBsZXQgc291bmRLZXkgPSBldmVudC5kYXRhLmdldChcImtleVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BTb3VuZChzb3VuZEtleSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuTVVURV9DSEFOTkVMKXtcbiAgICAgICAgICAgICAgICB0aGlzLm11dGVDaGFubmVsKGV2ZW50LmRhdGEuZ2V0KFwiY2hhbm5lbFwiKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuVU5NVVRFX0NIQU5ORUwpe1xuICAgICAgICAgICAgICAgIHRoaXMudW5tdXRlQ2hhbm5lbChldmVudC5kYXRhLmdldChcImNoYW5uZWxcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZW51bSBBdWRpb0NoYW5uZWxUeXBlIHtcbiAgICBERUZBVUxUID0gMCxcbiAgICBTRlggPSAxLFxuICAgIE1VU0lDID0gMixcbiAgICBDVVNUT01fMSA9IDMsXG4gICAgQ1VTVE9NXzIgPSA0LFxuICAgIENVU1RPTV8zID0gNSxcbiAgICBDVVNUT01fNCA9IDYsXG4gICAgQ1VTVE9NXzUgPSA3LFxuICAgIENVU1RPTV82ID0gOCxcbiAgICBDVVNUT01fNyA9IDksXG4gICAgQ1VTVE9NXzggPSAxMCxcbiAgICBDVVNUT01fOSA9IDExLFxufVxuXG5leHBvcnQgY29uc3QgTUFYX0FVRElPX0NIQU5ORUxTID0gMTI7IiwiaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uL1V0aWxzL01hdGhVdGlsc1wiO1xuaW1wb3J0IFRpbWVyTWFuYWdlciBmcm9tIFwiLi9UaW1lck1hbmFnZXJcIjtcblxuLyoqICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lciBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xuXG4gICAgLyoqIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoaXMgdGltZXIgKi9cbiAgICBwcm90ZWN0ZWQgc3RhdGU6IFRpbWVyU3RhdGU7XG4gICAgXG4gICAgLyoqIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhpcyB0aW1lciBlbmRzICovXG4gICAgcHJvdGVjdGVkIG9uRW5kOiBGdW5jdGlvbjtcblxuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIHRpbWVyIHNob3VsZCBsb29wICovXG4gICAgcHJvdGVjdGVkIGxvb3A6IGJvb2xlYW47XG5cbiAgICAvKiogVGhlIHRvdGFsIGFtb3VudCBvZiB0aW1lIHRoaXMgdGltZXIgcnVucyBmb3IgKi9cbiAgICB0b3RhbFRpbWU6IG51bWJlcjtcblxuICAgIC8qKiBUaGUgYW1vdW50IG9mIHRpbWUgbGVmdCBvbiB0aGUgY3VycmVudCBydW4gKi9cbiAgICBwcm90ZWN0ZWQgdGltZUxlZnQ6IG51bWJlcjtcblxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRoaXMgdGltZXIgaGFzIGJlZW4gcnVuICovXG4gICAgcHJvdGVjdGVkIG51bVJ1bnM6IG51bWJlcjtcblxuICAgIGNvbnN0cnVjdG9yKHRpbWU6IG51bWJlciwgb25FbmQ/OiBGdW5jdGlvbiwgbG9vcDogYm9vbGVhbiA9IGZhbHNlKXtcbiAgICAgICAgLy8gUmVnaXN0ZXIgdGhpcyB0aW1lclxuICAgICAgICBUaW1lck1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5hZGRUaW1lcih0aGlzKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMudG90YWxUaW1lID0gdGltZTtcbiAgICAgICAgdGhpcy50aW1lTGVmdCA9IDA7XG4gICAgICAgIHRoaXMub25FbmQgPSBvbkVuZDtcbiAgICAgICAgdGhpcy5sb29wID0gbG9vcDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFRpbWVyU3RhdGUuU1RPUFBFRDtcbiAgICAgICAgdGhpcy5udW1SdW5zID0gMDtcbiAgICB9XG5cbiAgICBpc1N0b3BwZWQoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IFRpbWVyU3RhdGUuU1RPUFBFRDtcbiAgICB9XG5cbiAgICBpc1BhdXNlZCgpe1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gVGltZXJTdGF0ZS5QQVVTRUQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGlzIHRpbWVyIGhhcyBiZWVuIHJ1biBiZWZvcmVcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIGl0IGhhcyBiZWVuIHJ1biBhdCBsZWFzdCBvbmNlIChhZnRlciB0aGUgbGF0ZXN0IHJlc2V0KSwgYW5kIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGhhc1J1bigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtUnVucyA+IDA7XG4gICAgfVxuXG4gICAgc3RhcnQodGltZT86IG51bWJlcil7XG4gICAgICAgIGlmKHRpbWUgIT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICB0aGlzLnRvdGFsVGltZSA9IHRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IFRpbWVyU3RhdGUuQUNUSVZFO1xuICAgICAgICB0aGlzLnRpbWVMZWZ0ID0gdGhpcy50b3RhbFRpbWU7XG4gICAgfVxuXG4gICAgLyoqIFJlc2V0cyB0aGlzIHRpbWVyLiBTZXRzIHRoZSBwcm9ncmVzcyBiYWNrIHRvIHplcm8sIGFuZCBzZXRzIHRoZSBudW1iZXIgb2YgcnVucyBiYWNrIHRvIHplcm8gKi9cbiAgICByZXNldCgpe1xuICAgICAgICB0aGlzLnRpbWVMZWZ0ID0gdGhpcy50b3RhbFRpbWU7XG4gICAgICAgIHRoaXMubnVtUnVucyA9IDA7XG4gICAgfVxuXG4gICAgcGF1c2UoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBUaW1lclN0YXRlLlBBVVNFRDtcbiAgICB9XG5cbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpe1xuICAgICAgICBpZih0aGlzLnN0YXRlID09PSBUaW1lclN0YXRlLkFDVElWRSl7XG4gICAgICAgICAgICB0aGlzLnRpbWVMZWZ0IC09IGRlbHRhVCoxMDAwO1xuXG4gICAgICAgICAgICBpZih0aGlzLnRpbWVMZWZ0IDw9IDApe1xuICAgICAgICAgICAgICAgIHRoaXMudGltZUxlZnQgPSBNYXRoVXRpbHMuY2xhbXBMb3cwKHRoaXMudGltZUxlZnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZW5kKCl7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgc3RhdGVcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFRpbWVyU3RhdGUuU1RPUFBFRDtcbiAgICAgICAgdGhpcy5udW1SdW5zICs9IDE7XG5cbiAgICAgICAgLy8gQ2FsbCB0aGUgZW5kIGZ1bmN0aW9uIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgICBpZih0aGlzLm9uRW5kKXtcbiAgICAgICAgICAgIHRoaXMub25FbmQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvb3AgaWYgd2Ugd2FudCB0b1xuICAgICAgICBpZih0aGlzLmxvb3Ape1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFRpbWVyU3RhdGUuQUNUSVZFO1xuICAgICAgICAgICAgdGhpcy50aW1lTGVmdCA9IHRoaXMudG90YWxUaW1lO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKTogc3RyaW5ne1xuICAgICAgICByZXR1cm4gXCJUaW1lcjogXCIgKyB0aGlzLnN0YXRlICsgXCIgLSBUaW1lIExlZnQ6IFwiICsgdGhpcy50aW1lTGVmdCArIFwibXMgb2YgXCIgKyB0aGlzLnRvdGFsVGltZSArIFwibXNcIjtcbiAgICB9XG59XG5cbmV4cG9ydCBlbnVtIFRpbWVyU3RhdGUge1xuICAgIEFDVElWRSA9IFwiQUNUSVZFXCIsXG4gICAgUEFVU0VEID0gXCJQQVVTRURcIixcbiAgICBTVE9QUEVEID0gXCJTVE9QUEVEXCJcbn0iLCJpbXBvcnQgVXBkYXRlYWJsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvVXBkYXRlYWJsZVwiO1xuaW1wb3J0IFRpbWVyIGZyb20gXCIuL1RpbWVyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbWVyTWFuYWdlciBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xuXG4gICAgcHJvdGVjdGVkIHRpbWVyczogQXJyYXk8VGltZXI+O1xuXG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy50aW1lcnMgPSBuZXcgQXJyYXkoKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc3RhdGljIGluc3RhbmNlOiBUaW1lck1hbmFnZXI7XG5cbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogVGltZXJNYW5hZ2VyIHtcbiAgICAgICAgaWYoIXRoaXMuaW5zdGFuY2Upe1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBUaW1lck1hbmFnZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlO1xuICAgIH1cblxuICAgIGFkZFRpbWVyKHRpbWVyOiBUaW1lcil7XG4gICAgICAgIHRoaXMudGltZXJzLnB1c2godGltZXIpO1xuICAgIH1cblxuICAgIGNsZWFyVGltZXJzKCl7XG4gICAgICAgIHRoaXMudGltZXJzID0gbmV3IEFycmF5KCk7XG4gICAgfVxuXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMudGltZXJzLmZvckVhY2godGltZXIgPT4gdGltZXIudXBkYXRlKGRlbHRhVCkpO1xuICAgIH1cbn0iLCJpbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuL01hdGhVdGlsc1wiO1xuXG4vLyBUT0RPOiBUaGlzIHNob3VsZCBiZSBtb3ZlZCB0byB0aGUgZGF0YXR5cGVzIGZvbGRlclxuLyoqXG4gKiBBIENvbG9yIHV0aWwgY2xhc3MgdGhhdCBrZWVwcyB0cmFjayBvZiBjb2xvcnMgbGlrZSBhIHZlY3RvciwgYnV0IGNhbiBiZSBjb252ZXJ0ZWQgaW50byBhIHN0cmluZyBmb3JtYXRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29sb3Ige1xuXHQvKiogVGhlIHJlZCB2YWx1ZSAqL1xuXHRwdWJsaWMgcjogbnVtYmVyO1xuXHQvKiogVGhlIGdyZWVuIHZhbHVlICovXG5cdHB1YmxpYyBnOiBudW1iZXI7XG5cdC8qKiBUaGUgYmx1ZSB2YWx1ZSAqL1xuXHRwdWJsaWMgYjogbnVtYmVyO1xuXHQvKiogVGhlIGFscGhhIHZhbHVlICovXG5cdHB1YmxpYyBhOiBudW1iZXI7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgY29sb3Jcblx0ICogQHBhcmFtIHIgUmVkXG5cdCAqIEBwYXJhbSBnIEdyZWVuXG5cdCAqIEBwYXJhbSBiIEJsdWVcblx0ICogQHBhcmFtIGEgQWxwaGFcblx0ICovXG5cdGNvbnN0cnVjdG9yKHI6IG51bWJlciA9IDAsIGc6IG51bWJlciA9IDAsIGI6IG51bWJlciA9IDAsIGE6IG51bWJlciA9IDEpe1xuICAgICAgICB0aGlzLnIgPSByO1xuICAgICAgICB0aGlzLmcgPSBnO1xuICAgICAgICB0aGlzLmIgPSBiO1xuICAgICAgICB0aGlzLmEgPSBhO1xuXHR9XG5cblx0LyoqXHRcblx0ICogVHJhbnNwYXJlbnQgY29sb3Jcblx0ICogQHJldHVybnMgcmdiYSgwLCAwLCAwLCAwKVxuXHQgKi9cblx0c3RhdGljIGdldCBUUkFOU1BBUkVOVCgpOiBDb2xvciB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcigwLCAwLCAwLCAwKTtcblx0fVxuXHRcblx0LyoqXHRcblx0ICogUmVkIGNvbG9yXG5cdCAqIEByZXR1cm5zIHJnYigyNTUsIDAsIDApXG5cdCAqL1xuXHRzdGF0aWMgZ2V0IFJFRCgpOiBDb2xvciB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcigyNTUsIDAsIDAsIDEpO1xuXHR9XG5cblx0LyoqXHRcblx0ICogR3JlZW4gY29sb3Jcblx0ICogQHJldHVybnMgcmdiKDAsIDI1NSwgMClcblx0ICovXG5cdHN0YXRpYyBnZXQgR1JFRU4oKTogQ29sb3Ige1xuXHRcdHJldHVybiBuZXcgQ29sb3IoMCwgMjU1LCAwLCAxKTtcblx0fVxuXG5cdC8qKlx0XG5cdCAqIEJsdWUgY29sb3Jcblx0ICogQHJldHVybnMgcmdiKDAsIDAsIDI1NSlcblx0ICovXG5cdHN0YXRpYyBnZXQgQkxVRSgpOiBDb2xvciB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcigwLCAwLCAyNTUsIDEpO1xuXHR9XG5cblx0LyoqXHRcblx0ICogWWVsbG93IGNvbG9yXG5cdCAqIEByZXR1cm5zIHJnYigyNTUsIDI1NSwgMClcblx0ICovXG5cdHN0YXRpYyBnZXQgWUVMTE9XKCk6IENvbG9yIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKDI1NSwgMjU1LCAwLCAxKTtcblx0fVxuXG5cdC8qKlx0XG5cdCAqIE1hZ2VudGEgY29sb3Jcblx0ICogQHJldHVybnMgcmdiKDI1NSwgMCwgMjU1KVxuXHQgKi9cblx0c3RhdGljIGdldCBNQUdFTlRBKCk6IENvbG9yIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKDI1NSwgMCwgMjU1LCAxKTtcblx0fVxuXG5cdC8qKlx0XG5cdCAqIEN5YW4gY29sb3Jcblx0ICogQHJldHVybnMgcmdiKDAsIDI1NSwgMjU1KVxuXHQgKi9cblx0c3RhdGljIGdldCBDWUFOKCk6IENvbG9yIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKDAsIDI1NSwgMjU1LCAxKTtcblx0fVxuXG5cdC8qKlx0XG5cdCAqIFdoaXRlIGNvbG9yXG5cdCAqIEByZXR1cm5zIHJnYigyNTUsIDI1NSwgMjU1KVxuXHQgKi9cblx0c3RhdGljIGdldCBXSElURSgpOiBDb2xvciB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcigyNTUsIDI1NSwgMjU1LCAxKTtcblx0fSBcblxuXHQvKipcdFxuXHQgKiBCbGFjayBjb2xvclxuXHQgKiBAcmV0dXJucyByZ2IoMCwgMCwgMClcblx0ICovXG5cdHN0YXRpYyBnZXQgQkxBQ0soKTogQ29sb3Ige1xuXHRcdHJldHVybiBuZXcgQ29sb3IoMCwgMCwgMCwgMSk7XG5cdH1cblxuXHQvKipcdFxuXHQgKiBPcmFuZ2UgY29sb3Jcblx0ICogQHJldHVybnMgcmdiKDI1NSwgMTAwLCAwKVxuXHQgKi9cblx0c3RhdGljIGdldCBPUkFOR0UoKTogQ29sb3Ige1xuXHRcdHJldHVybiBuZXcgQ29sb3IoMjU1LCAxMDAsIDAsIDEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGNvbG9yIHRvIHRoZSB2YWx1ZXMgcHJvdmlkZWRcblx0ICogQHBhcmFtIHIgUmVkXG5cdCAqIEBwYXJhbSBnIEdyZWVuXG5cdCAqIEBwYXJhbSBiIEJsdWVcblx0ICogQHBhcmFtIGEgQWxwaGFcblx0ICovXG5cdHNldChyOiBudW1iZXIsIGc6IG51bWJlciwgYjogbnVtYmVyLCBhOiBudW1iZXIgPSAxKTogdm9pZCB7XG5cdFx0dGhpcy5yID0gcjtcblx0XHR0aGlzLmcgPSBnO1xuXHRcdHRoaXMuYiA9IGI7XG5cdFx0dGhpcy5hID0gYTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IGNvbG9yIHNsaWdodGx5IGxpZ2h0ZXIgdGhhbiB0aGUgY3VycmVudCBjb2xvclxuXHQgKiBAcmV0dXJucyBBIG5ldyBsaWdodGVyIENvbG9yXG5cdCAqL1xuXHRsaWdodGVuKCk6IENvbG9yIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKE1hdGhVdGlscy5jbGFtcCh0aGlzLnIgKyA0MCwgMCwgMjU1KSwgTWF0aFV0aWxzLmNsYW1wKHRoaXMuZyArIDQwLCAwLCAyNTUpLCBNYXRoVXRpbHMuY2xhbXAodGhpcy5iICsgNDAsIDAsIDI1NSksIE1hdGhVdGlscy5jbGFtcCh0aGlzLmEgKyAxMCwgMCwgMjU1KSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIG5ldyBjb2xvciBzbGlnaHRseSBkYXJrZXIgdGhhbiB0aGUgY3VycmVudCBjb2xvclxuXHQgKiBAcmV0dXJucyBBIG5ldyBkYXJrZXIgQ29sb3Jcblx0ICovXG5cdGRhcmtlbigpOiBDb2xvciB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcihNYXRoVXRpbHMuY2xhbXAodGhpcy5yIC0gNDAsIDAsIDI1NSksIE1hdGhVdGlscy5jbGFtcCh0aGlzLmcgLSA0MCwgMCwgMjU1KSwgTWF0aFV0aWxzLmNsYW1wKHRoaXMuYiAtIDQwLCAwLCAyNTUpLCBNYXRoVXRpbHMuY2xhbXAodGhpcy5hICsgMTAsIDAsIDI1NSkpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB0aGlzIGNvbG9yIGFzIGFuIGFycmF5XG5cdCAqIEByZXR1cm5zIFtyLCBnLCBiLCBhXVxuXHQgKi9cblx0dG9BcnJheSgpOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSB7XG5cdFx0cmV0dXJuIFt0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmFdO1xuXHR9XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgY29sb3IgYXMgYSBzdHJpbmcgb2YgdGhlIGZvcm0gI1JSR0dCQlxuXHQgKiBAcmV0dXJucyAjUlJHR0JCXG5cdCAqL1xuXHR0b1N0cmluZygpOiBzdHJpbmcge1xuXHRcdHJldHVybiBcIiNcIiArIE1hdGhVdGlscy50b0hleCh0aGlzLnIsIDIpICsgTWF0aFV0aWxzLnRvSGV4KHRoaXMuZywgMikgKyBNYXRoVXRpbHMudG9IZXgodGhpcy5iLCAyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjb2xvciBhcyBhIHN0cmluZyBvZiB0aGUgZm9ybSByZ2IociwgZywgYilcblx0ICogQHJldHVybnMgcmdiKHIsIGcsIGIpXG5cdCAqL1xuXHR0b1N0cmluZ1JHQigpOiBzdHJpbmcge1xuXHRcdHJldHVybiBcInJnYihcIiArIHRoaXMuci50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5nLnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLmIudG9TdHJpbmcoKSArIFwiKVwiO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGNvbG9yIGFzIGEgc3RyaW5nIG9mIHRoZSBmb3JtIHJnYmEociwgZywgYiwgYSlcblx0ICogQHJldHVybnMgcmdiYShyLCBnLCBiLCBhKVxuXHQgKi9cblx0dG9TdHJpbmdSR0JBKCk6IHN0cmluZyB7XG5cdFx0aWYodGhpcy5hID09PSAwKXtcblx0XHRcdHJldHVybiB0aGlzLnRvU3RyaW5nUkdCKCk7XG5cdFx0fVxuXHRcdHJldHVybiBcInJnYmEoXCIgKyB0aGlzLnIudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuZy50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5iLnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLmEudG9TdHJpbmcoKSArXCIpXCJcblx0fVxuXG5cdC8qKlxuXHQgKiBUdXJucyB0aGlzIGNvbG9yIGludG8gYSBmbG9hdDMyQXJyYXkgYW5kIGNoYW5nZXMgY29sb3IgcmFuZ2UgdG8gWzAuMCwgMS4wXVxuXHQgKiBAcmV0dXJucyBhIEZsb2F0MzJBcnJheSBjb250YWluaW5nIHRoZSBjb2xvclxuXHQgKi9cblx0dG9XZWJHTCgpOiBGbG9hdDMyQXJyYXkge1xuXHRcdHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFtcblx0XHRcdHRoaXMuci8yNTUsXG5cdFx0XHR0aGlzLmcvMjU1LFxuXHRcdFx0dGhpcy5iLzI1NSxcblx0XHRcdHRoaXMuYVxuXHRcdF0pO1xuXHR9XG5cblx0c3RhdGljIGZyb21TdHJpbmdIZXgoc3RyOiBzdHJpbmcpOiBDb2xvciB7XG5cdFx0bGV0IGkgPSAwO1xuXHRcdGlmKHN0ci5jaGFyQXQoMCkgPT0gXCIjXCIpIGkrPSAxO1xuXHRcdGxldCByID0gTWF0aFV0aWxzLmZyb21IZXgoc3RyLnN1YnN0cmluZyhpLCBpKzIpKTtcblx0XHRsZXQgZyA9IE1hdGhVdGlscy5mcm9tSGV4KHN0ci5zdWJzdHJpbmcoaSsyLCBpKzQpKTtcblx0XHRsZXQgYiA9IE1hdGhVdGlscy5mcm9tSGV4KHN0ci5zdWJzdHJpbmcoaSs0LCBpKzYpKTtcblx0XHRyZXR1cm4gbmV3IENvbG9yKHIsIGcsIGIpO1xuXHR9XG59IiwiLy8gQGlnbm9yZVBhZ2VcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWFzZUZ1bmN0aW9ucyB7XG5cbiAgICBzdGF0aWMgZWFzZUluT3V0U2luZSh4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gLShNYXRoLmNvcyhNYXRoLlBJICogeCkgLSAxKSAvIDI7XG4gICAgfVxuXG4gICAgc3RhdGljIGVhc2VPdXRJblNpbmUoeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHggPCAwLjUgPyAtTWF0aC5jb3MoTWF0aC5QSSooeCArIDAuNSkpLzIgOiAtTWF0aC5jb3MoTWF0aC5QSSooeCAtIDAuNSkpLzIgKyAxO1xuICAgIH1cblxuICAgIHN0YXRpYyBlYXNlT3V0U2luZSh4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTWF0aC5zaW4oKHggKiBNYXRoLlBJKSAvIDIpO1xuICAgIH1cblxuICAgIHN0YXRpYyBlYXNlSW5TaW5lKHg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiAxIC0gTWF0aC5jb3MoKHggKiBNYXRoLlBJKSAvIDIpOyBcbiAgICB9XG5cbiAgICBzdGF0aWMgZWFzZUluT3V0UXVpbnQoeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHggPCAwLjUgPyAxNiAqIHggKiB4ICogeCAqIHggKiB4IDogMSAtIE1hdGgucG93KC0yICogeCArIDIsIDUpIC8gMjsgICAgXG4gICAgfVxuXG4gICAgc3RhdGljIGVhc2VJbk91dFF1YWQoeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHggPCAwLjUgPyAyICogeCAqIHggOiAxIC0gTWF0aC5wb3coLTIgKiB4ICsgMiwgMikgLyAyO1xuICAgIH1cblxuICAgIHN0YXRpYyBlYXNlT3V0SW5RdWFkKHg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB4IDwgMC41ID8gdGhpcy5lYXNlT3V0SW5fT3V0UG93KHgsIDIpIDogdGhpcy5lYXNlT3V0SW5fSW5Qb3coeCwgMik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZWFzZU91dEluX091dFBvdyh4OiBudW1iZXIsIHBvdzogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIDAuNSAtIE1hdGgucG93KC0yICogeCArIDEsIHBvdykgLyAyO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGVhc2VPdXRJbl9JblBvdyh4OiBudW1iZXIsIHBvdzogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIDAuNSArIE1hdGgucG93KDIgKiB4IC0gMSwgcG93KSAvIDI7XG4gICAgfVxufVxuXG5leHBvcnQgZW51bSBFYXNlRnVuY3Rpb25UeXBlIHtcbiAgICAvLyBTSU5FXG4gICAgSU5fT1VUX1NJTkUgPSBcImVhc2VJbk91dFNpbmVcIixcbiAgICBPVVRfSU5fU0lORSA9IFwiZWFzZU91dEluU2luZVwiLFxuICAgIElOX1NJTkUgPSBcImVhc2VJblNpbmVcIixcbiAgICBPVVRfU0lORSA9IFwiZWFzZU91dFNpbmVcIixcblxuICAgIC8vIFFVQURcbiAgICBJTl9PVVRfUVVBRCA9IFwiZWFzZUluT3V0UXVhZFwiLFxuICAgIE9VVF9JTl9RVUFEID0gXCJlYXNlT3V0SW5RdWFkXCIsXG5cbiAgICAvLyBRVUlOVFxuICAgIElOX09VVF9RVUlOVCA9IFwiZWFzZUluT3V0UXVpbnRcIlxufSIsImltcG9ydCBHcmFwaCBmcm9tIFwiLi4vRGF0YVR5cGVzL0dyYXBocy9HcmFwaFwiO1xuaW1wb3J0IEVkZ2VOb2RlIGZyb20gXCIuLi9EYXRhVHlwZXMvR3JhcGhzL0VkZ2VOb2RlXCI7XG5cbi8qKiBBIGNsYXNzIHRvIHByb3ZpZGVzIHNvbWUgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIGdyYXBocyAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JhcGhVdGlscyB7XG5cblx0LyoqXG5cdCAqIEFuIGltcGxlbWVudGF0aW9uIG9mIERqaWtzdHJhJ3Mgc2hvcnRlc3QgcGF0aCBhbGdvcml0aG0gYmFzZWQgb24gdGhlIG9uZSBkZXNjcmliZWQgaW4gVGhlIEFsZ29yaXRobSBEZXNpZ24gTWFudWFsLlxuXHQgKiBAcGFyYW0gZyBUaGUgZ3JhcGhcblx0ICogQHBhcmFtIHN0YXJ0IFRoZSBudW1iZXIgdG8gc3RhcnQgdGhlIHNob3J0ZXN0IHBhdGggZnJvbVxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIHRoZSBwYXJlbnQgb2YgZWFjaCBub2RlIG9mIHRoZSBHcmFwaCBpbiB0aGUgc2hvcnRlc3QgcGF0aC5cblx0ICovXG5cdHN0YXRpYyBkamlrc3RyYShnOiBHcmFwaCwgc3RhcnQ6IG51bWJlcik6IEFycmF5PG51bWJlcj4ge1xuXHRcdGxldCBpOiBudW1iZXI7XHRcdC8vIENvdW50ZXJcblx0XHRsZXQgcDogRWRnZU5vZGU7XHQvLyBQb2ludGVyIHRvIGVkZ2Vub2RlXG5cdFx0bGV0IGluVHJlZTogQXJyYXk8Ym9vbGVhbj4gPSBuZXcgQXJyYXkoZy5udW1WZXJ0aWNlcyk7XG5cdFx0bGV0IGRpc3RhbmNlOiBBcnJheTxudW1iZXI+ID0gbmV3IEFycmF5KGcubnVtVmVydGljZXMpO1xuXHRcdGxldCBwYXJlbnQ6IEFycmF5PG51bWJlcj4gPSBuZXcgQXJyYXkoZy5udW1WZXJ0aWNlcyk7XG5cdFx0bGV0IHY6IG51bWJlcjtcdFx0Ly8gQ3VycmVudCB2ZXJ0ZXggdG8gcHJvY2Vzc1xuXHRcdGxldCB3OiBudW1iZXI7IFx0XHQvLyBDYW5kaWRhdGUgZm9yIG5leHQgdmVydGV4XG5cdFx0bGV0IHdlaWdodDogbnVtYmVyO1x0Ly8gRWRnZSB3ZWlnaHRcblx0XHRsZXQgZGlzdDtcdFx0XHQvLyBCZXN0IGN1cnJlbnQgZGlzdGFuY2UgZnJvbSBzdGFydFxuXG5cdFx0Zm9yKGkgPSAwOyBpIDwgZy5udW1WZXJ0aWNlczsgaSsrKXtcblx0XHRcdGluVHJlZVtpXSA9IGZhbHNlO1xuXHRcdFx0ZGlzdGFuY2VbaV0gPSBJbmZpbml0eTtcblx0XHRcdHBhcmVudFtpXSA9IC0xO1xuXHRcdH1cblxuXHRcdGRpc3RhbmNlW3N0YXJ0XSA9IDA7XG5cdFx0diA9IHN0YXJ0O1xuXG5cdFx0d2hpbGUoIWluVHJlZVt2XSl7XG5cdFx0XHRpblRyZWVbdl0gPSB0cnVlO1xuXHRcdFx0cCA9IGcuZWRnZXNbdl07XG5cblx0XHRcdHdoaWxlKHAgIT09IG51bGwpe1xuXHRcdFx0XHR3ID0gcC55O1xuXHRcdFx0XHR3ZWlnaHQgPSBwLndlaWdodDtcblxuXHRcdFx0XHRpZihkaXN0YW5jZVt3XSA+IGRpc3RhbmNlW3ZdICsgd2VpZ2h0KXtcblx0XHRcdFx0XHRkaXN0YW5jZVt3XSA9IGRpc3RhbmNlW3ZdICsgd2VpZ2h0O1xuXHRcdFx0XHRcdHBhcmVudFt3XSA9IHY7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwID0gcC5uZXh0O1xuXHRcdFx0fVxuXG5cdFx0XHR2ID0gMDtcblxuXHRcdFx0ZGlzdCA9IEluZmluaXR5O1xuXG5cdFx0XHRmb3IoaSA9IDA7IGkgPD0gZy5udW1WZXJ0aWNlczsgaSsrKXtcblx0XHRcdFx0aWYoIWluVHJlZVtpXSAmJiBkaXN0ID4gZGlzdGFuY2VbaV0pe1xuXHRcdFx0XHRcdGRpc3QgPSBkaXN0YW5jZTtcblx0XHRcdFx0XHR2ID0gaTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBwYXJlbnQ7XG5cblx0fVxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuXG4vKiogQSBjbGFzcyBjb250YWluaW5nIHNvbWUgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIG1hdGggb3BlcmF0aW9ucyAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWF0aFV0aWxzIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzaWduIG9mIHRoZSB2YWx1ZSBwcm92aWRlZFxuICAgICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBleHRyYWN0IHRoZSBzaWduIGZyb21cbiAgICAgKiBAcmV0dXJucyAtMSBpZiB0aGUgbnVtYmVyIGlzIGxlc3MgdGhhbiAwLCAxIG90aGVyd2lzZVxuICAgICAqL1xuICAgIHN0YXRpYyBzaWduKHg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB4IDwgMCA/IC0xIDogMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHggaXMgYmV0d2VlbiBhIGFuZCBiXG4gICAgICogQHBhcmFtIGEgVGhlIG1pbiBib3VuZFxuICAgICAqIEBwYXJhbSBiIFRoZSBtYXggYm91bmRcbiAgICAgKiBAcGFyYW0geCBUaGUgdmFsdWUgdG8gY2hlY2tcbiAgICAgKiBAcGFyYW0gZXhjbHVzaXZlIFdoZXRoZXIgb3Igbm90IGEgYW5kIGIgYXJlIGV4Y2x1c2l2ZSBib3VuZHNcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHggaXMgYmV0d2VlbiBhIGFuZCBiLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgYmV0d2VlbihhOiBudW1iZXIsIGI6IG51bWJlciwgeDogbnVtYmVyLCBleGNsdXNpdmU/OiBib29sZWFuKTogYm9vbGVhbiB7XG4gICAgICAgIGlmKGV4Y2x1c2l2ZSl7XG4gICAgICAgICAgICByZXR1cm4gKGEgPCB4KSAmJiAoeCA8IGIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChhIDw9IHgpICYmICh4IDw9IGIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xhbXBzIHRoZSB2YWx1ZSB4IHRvIHRoZSByYW5nZSBbbWluLCBtYXhdLCByb3VuZGluZyB1cCBvciBkb3duIGlmIG5lZWRlZFxuICAgICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBiZSBjbGFtcGVkXG4gICAgICogQHBhcmFtIG1pbiBUaGUgbWluIG9mIHRoZSByYW5nZVxuICAgICAqIEBwYXJhbSBtYXggVGhlIG1heCBvZiB0aGUgcmFuZ2VcbiAgICAgKiBAcmV0dXJucyB4LCBpZiBpdCBpcyBiZXR3ZWVuIG1pbiBhbmQgbWF4LCBvciBtaW4vbWF4IGlmIGl0IGV4Y2VlZHMgdGhlaXIgYm91bmRzXG4gICAgICovXG4gICAgc3RhdGljIGNsYW1wKHg6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgaWYoeCA8IG1pbikgcmV0dXJuIG1pbjtcbiAgICAgICAgaWYoeCA+IG1heCkgcmV0dXJuIG1heDtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xhbXBzIHRoZSB2YWx1ZSB4IHRvIHRoZSByYW5nZSBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0geCBUaGUgdmFsdWUgdG8gYmUgY2xhbXBlZFxuICAgICAqIEByZXR1cm5zIHgsIGlmIGl0IGlzIGJldHdlZW4gMCBhbmQgMSwgb3IgMC8xIGlmIGl0IGV4Y2VlZHMgdGhlaXIgYm91bmRzXG4gICAgICovXG4gICAgc3RhdGljIGNsYW1wMDEoeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIE1hdGhVdGlscy5jbGFtcCh4LCAwLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGFtcHMgdGhlIGxvd2VyIGVuZCBvZiB0aGUgdmFsdWUgb2YgeCB0byB0aGUgcmFuZ2UgdG8gbWluXG4gICAgICogQHBhcmFtIHggVGhlIHZhbHVlIHRvIGJlIGNsYW1wZWRcbiAgICAgKiBAcGFyYW0gbWluIFRoZSBtaW5pbXVtIGFsbG93ZWQgdmFsdWUgb2YgeFxuICAgICAqIEByZXR1cm5zIHgsIGlmIGl0IGlzIGdyZWF0ZXIgdGhhbiBtaW4sIG90aGVyd2lzZSBtaW5cbiAgICAgKi9cbiAgICBzdGF0aWMgY2xhbXBMb3coeDogbnVtYmVyLCBtaW46IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB4IDwgbWluID8gbWluIDogeDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGFtcHMgdGhlIGxvd2VyIGVuZCBvZiB0aGUgdmFsdWUgb2YgeCB0byB6ZXJvXG4gICAgICogQHBhcmFtIHggVGhlIHZhbHVlIHRvIGJlIGNsYW1wZWRcbiAgICAgKiBAcmV0dXJucyB4LCBpZiBpdCBpcyBncmVhdGVyIHRoYW4gMCwgb3RoZXJ3aXNlIDBcbiAgICAgKi9cbiAgICBzdGF0aWMgY2xhbXBMb3cwKHg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBNYXRoVXRpbHMuY2xhbXBMb3coeCwgMCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGNsYW1wTWFnbml0dWRlKHY6IFZlYzIsIG06IG51bWJlcik6IFZlYzIge1xuICAgICAgICBpZih2Lm1hZ1NxKCkgPiBtKm0pe1xuICAgICAgICAgICAgcmV0dXJuIHYuc2NhbGVUbyhtKTtcbiAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgY2hhbmdlUmFuZ2UoeDogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIsIG5ld01pbjogbnVtYmVyLCBuZXdNYXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlcnAobmV3TWluLCBuZXdNYXgsIHRoaXMuaW52TGVycChtaW4sIG1heCwgeCkpO1xuICAgIH1cblxuICAgIC8qKlxuXHQgKiBMaW5lYXIgSW50ZXJwb2xhdGlvblxuXHQgKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmFsdWUgZm9yIHRoZSBpbnRlcnBvbGF0aW9uIGJvdW5kXG5cdCAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmFsdWUgZm9yIHRoZSBpbnRlcnBvbGF0aW9uIGJvdW5kXG5cdCAqIEBwYXJhbSB0IFRoZSB0aW1lIHdlIGFyZSBpbnRlcnBvbGF0aW5nIHRvXG4gICAgICogQHJldHVybnMgVGhlIHZhbHVlIGJldHdlZW4gYSBhbmQgYiBhdCB0aW1lIHRcblx0ICovXG5cdHN0YXRpYyBsZXJwKGE6IG51bWJlciwgYjogbnVtYmVyLCB0OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gYSArIHQgKiAoYiAtIGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludmVyc2UgTGluZWFyIEludGVycG9sYXRpb24uIEZpbmRzIHRoZSB0aW1lIGF0IHdoaWNoIGEgdmFsdWUgYmV0d2VlbiBhIGFuZCBiIHdvdWxkIG9jY3VyXG4gICAgICogQHBhcmFtIGEgVGhlIGZpcnN0IHZhbHVlIGZvciB0aGUgaW50ZXJwb2xhdGlvbiBib3VuZFxuICAgICAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmFsdWUgZm9yIHRoZSBpbnRlcnBvbGF0aW9uIGJvdW5kXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBjdXJyZW50IHZhbHVlXG4gICAgICogQHJldHVybnMgVGhlIHRpbWUgYXQgd2hpY2ggdGhlIGN1cnJlbnQgdmFsdWUgb2NjdXJzIGJldHdlZW4gYSBhbmQgYlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnZMZXJwKGE6IG51bWJlciwgYjogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKXtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAtIGEpLyhiIC0gYSk7XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIEN1dHMgb2ZmIGRlY2ltYWwgcG9pbnRzIG9mIGEgbnVtYmVyIGFmdGVyIGEgc3BlY2lmaWVkIHBsYWNlXG4gICAgICogQHBhcmFtIG51bSBUaGUgbnVtYmVyIHRvIGZsb29yXG4gICAgICogQHBhcmFtIHBsYWNlIFRoZSBsYXN0IGRlY2ltYWwgcGxhY2Ugb2YgdGhlIG5ldyBudW1iZXJcbiAgICAgKiBAcmV0dXJucyBUaGUgZmxvb3JlZCBudW1iZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgZmxvb3JUb1BsYWNlKG51bTogbnVtYmVyLCBwbGFjZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgaWYocGxhY2UgPT09IDApe1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmYWN0b3IgPSAxMDtcbiAgICAgICAgd2hpbGUocGxhY2UgPiAxKXtcbiAgICAgICAgICAgIGZhY3RvciAhPSAxMDtcbiAgICAgICAgICAgIHBsYWNlLS07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW0qZmFjdG9yKS9mYWN0b3I7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbnVtYmVyIGZyb20gYSBoZXggc3RyaW5nXG4gICAgICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGhleCBudW1iZXJcbiAgICAgKiBAcmV0dXJucyB0aGUgbnVtYmVyIGluIGRlY2ltYWwgcmVwcmVzZW50ZWQgYnkgdGhlIGhleCBzdHJpbmdcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUhleChzdHI6IHN0cmluZyk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChzdHIsIDE2KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgYXMgYSBoZXhhZGVjaW1hbFxuICAgICAqIEBwYXJhbSBudW0gVGhlIG51bWJlciB0byBjb252ZXJ0IHRvIGhleFxuICAgICAqIEBwYXJhbSBtaW5MZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgcmV0dXJuZWQgaGV4IHN0cmluZyAoYWRkcyB6ZXJvIHBhZGRpbmcgaWYgbmVlZGVkKVxuICAgICAqIEByZXR1cm5zIFRoZSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIG51bWJlciBhcyBhIHN0cmluZ1xuICAgICAqL1xuICAgIHN0YXRpYyB0b0hleChudW06IG51bWJlciwgbWluTGVuZ3RoOiBudW1iZXIgPSBudWxsKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IGZhY3RvciA9IDE7XG4gICAgICAgIHdoaWxlKGZhY3RvcioxNiA8IG51bSl7XG4gICAgICAgICAgICBmYWN0b3IgKj0gMTY7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGhleFN0ciA9IFwiXCI7XG4gICAgICAgIHdoaWxlKGZhY3RvciA+PSAxKXtcbiAgICAgICAgICAgIGxldCBkaWdpdCA9IE1hdGguZmxvb3IobnVtL2ZhY3Rvcik7XG4gICAgICAgICAgICBoZXhTdHIgKz0gTWF0aFV0aWxzLnRvSGV4RGlnaXQoZGlnaXQpO1xuICAgICAgICAgICAgbnVtIC09IGRpZ2l0ICogZmFjdG9yO1xuICAgICAgICAgICAgZmFjdG9yIC89IDE2O1xuXHRcdH1cblx0XHRcblx0XHRpZihtaW5MZW5ndGggIT09IG51bGwpe1xuXHRcdFx0d2hpbGUoaGV4U3RyLmxlbmd0aCA8IG1pbkxlbmd0aCl7XG5cdFx0XHRcdGhleFN0ciA9IFwiMFwiICsgaGV4U3RyO1xuXHRcdFx0fVxuXHRcdH1cblxuICAgICAgICByZXR1cm4gaGV4U3RyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgZGlnaXQgdG8gaGV4YWRlY2ltYWwuIEluIHRoaXMgY2FzZSwgYSBkaWdpdCBpcyBiZXR3ZWVuIDAgYW5kIDE1IGluY2x1c2l2ZVxuICAgICAqIEBwYXJhbSBudW0gVGhlIGRpZ2l0IHRvIGNvbnZlcnQgdG8gaGV4YWRlY2ltYWxcbiAgICAgKiBAcmV0dXJucyBUaGUgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkaWdpdCBhcyBhIHN0cmluZ1xuICAgICAqL1xuICAgIHN0YXRpYyB0b0hleERpZ2l0KG51bTogbnVtYmVyKTogc3RyaW5nIHtcbiAgICAgICAgaWYobnVtIDwgMTApe1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyBudW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg2NSArIG51bSAtIDEwKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi9Db2xvclwiO1xuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi9NYXRoVXRpbHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyaW5nVXRpbHMge1xuXHRzdGF0aWMgdG9XZWJHTENvb3Jkcyhwb2ludDogVmVjMiwgb3JpZ2luOiBWZWMyLCB3b3JsZFNpemU6IFZlYzIpOiBGbG9hdDMyQXJyYXkge1xuXHRcdHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFtcblx0XHRcdE1hdGhVdGlscy5jaGFuZ2VSYW5nZShwb2ludC54LCBvcmlnaW4ueCwgb3JpZ2luLnggKyB3b3JsZFNpemUueCwgLTEsIDEpLFxuXHRcdFx0TWF0aFV0aWxzLmNoYW5nZVJhbmdlKHBvaW50LnksIG9yaWdpbi55LCBvcmlnaW4ueSArIHdvcmxkU2l6ZS55LCAxLCAtMSlcblx0XHRdKTtcblx0fVxuXG5cdHN0YXRpYyB0b1dlYkdMU2NhbGUoc2l6ZTogVmVjMiwgd29ybGRTaXplOiBWZWMyKTogRmxvYXQzMkFycmF5IHtcblx0XHRyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXG5cdFx0XHQyKnNpemUueC93b3JsZFNpemUueCxcblx0XHRcdDIqc2l6ZS55L3dvcmxkU2l6ZS55LFxuXHRcdF0pO1xuXHR9XG5cblx0c3RhdGljIHRvV2ViR0xDb2xvcihjb2xvcjogQ29sb3IpOiBGbG9hdDMyQXJyYXkge1xuXHRcdHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFtcblx0XHRcdE1hdGhVdGlscy5jaGFuZ2VSYW5nZShjb2xvci5yLCAwLCAyNTUsIDAsIDEpLFxuXHRcdFx0TWF0aFV0aWxzLmNoYW5nZVJhbmdlKGNvbG9yLmcsIDAsIDI1NSwgMCwgMSksXG5cdFx0XHRNYXRoVXRpbHMuY2hhbmdlUmFuZ2UoY29sb3IuYiwgMCwgMjU1LCAwLCAxKSxcblx0XHRcdGNvbG9yLmFcblx0XHRdKTtcblx0fVxufSIsIi8qKiBTb21lIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBkZWFsaW5nIHdpdGggc3RyaW5ncyAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RyaW5nVXRpbHMge1xuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSBwYXRoIGZyb20gYSBmaWxlcGF0aCB0aGF0IGluY2x1ZGVzIHRoZSBmaWxlXG4gICAgICogQHBhcmFtIGZpbGVQYXRoIHRoZSBmaWxlcGF0aCB0byBleHRyYWN0IHRoZSBwYXRoIGZyb21cbiAgICAgKiBAcmV0dXJucyBUaGUgcGF0aCBwb3J0aW9uIG9mIHRoZSBmaWxlcGF0aCBwcm92aWRlZFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRQYXRoRnJvbUZpbGVQYXRoKGZpbGVQYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBsZXQgc3BsaXRQYXRoID0gZmlsZVBhdGguc3BsaXQoXCIvXCIpO1xuICAgICAgICBzcGxpdFBhdGgucG9wKCk7XG4gICAgICAgIHNwbGl0UGF0aC5wdXNoKFwiXCIpO1xuICAgICAgICByZXR1cm4gc3BsaXRQYXRoLmpvaW4oXCIvXCIpO1xuICAgIH1cbn0iLCJleHBvcnQgZW51bSBodzRfTmFtZXMge1xyXG4gIE5BVk1FU0ggPSBcIm5hdm1lc2hcIixcclxufVxyXG5cclxuZXhwb3J0IGVudW0gaHc0X0V2ZW50cyB7XHJcbiAgU0hPVF9GSVJFRCA9IFwiU0hPVF9GSVJFRFwiLFxyXG4gIFVOTE9BRF9BU1NFVCA9IFwiVU5MT0FEX0FTU0VUXCIsXHJcbiAgU1dBUF9QTEFZRVIgPSBcIlNXQVBfUExBWUVSXCIsXHJcbiAgUkVBQ0hFRF9DSEVDS1BPSU5UID0gXCJSRUFDSEVEX0NIRUNLUE9JTlRcIixcclxufVxyXG5cclxuZXhwb3J0IGVudW0gaHc0X1N0YXR1c2VzIHtcclxuICBJTl9SQU5HRSA9IFwiSU5fUkFOR0VcIixcclxuICBMT1dfSEVBTFRIID0gXCJMT1dfSEVBTFRIXCIsXHJcbiAgQ0FOX1JFVFJFQVQgPSBcIkNBTl9SRVRSRUFUXCIsXHJcbiAgQ0FOX0JFUlNFUksgPSBcIkNBTl9CRVJTRVJLXCIsXHJcbiAgUkVBQ0hFRF9HT0FMID0gXCJHT0FMXCIsXHJcbn1cclxuIiwiaW1wb3J0IEdhbWUgZnJvbSBcIi4vV29sZmllMkQvTG9vcC9HYW1lXCI7XG5pbXBvcnQgbWFpblNjZW5lIGZyb20gXCIuL21heWhlbUZpbGVzL1NjZW5lL01haW5TY2VuZVwiO1xuaW1wb3J0IFJlZ2lzdHJ5TWFuYWdlciBmcm9tIFwiLi9Xb2xmaWUyRC9SZWdpc3RyeS9SZWdpc3RyeU1hbmFnZXJcIjtcbmltcG9ydCBXZWFwb25UZW1wbGF0ZVJlZ2lzdHJ5IGZyb20gXCIuL1dvbGZpZTJEL1JlZ2lzdHJ5L1dlYXBvblJlZ2lzdHJ5XCI7XG5pbXBvcnQgV2VhcG9uVHlwZVJlZ2lzdHJ5IGZyb20gXCIuL1dvbGZpZTJEL1JlZ2lzdHJ5L1dlYXBvblR5cGVSZWdpc3RyeVwiO1xuaW1wb3J0IE1haW5NZW51IGZyb20gXCIuL21heWhlbUZpbGVzL1NjZW5lL01haW5NZW51XCI7XG5pbXBvcnQgR29hcEFjdGlvblBsYW5uZXIgZnJvbSBcIi4vV29sZmllMkQvQUkvR29hcEFjdGlvblBsYW5uZXJcIjtcblxuLy8gVGhlIG1haW4gZnVuY3Rpb24gaXMgeW91ciBlbnRyeXBvaW50IGludG8gV29sZmllMkQuIFNwZWNpZnkgeW91ciBmaXJzdCBzY2VuZSBhbmQgYW55IG9wdGlvbnMgaGVyZS5cbihmdW5jdGlvbiBtYWluKCl7XG4gICAgLy8gUnVuIGFueSB0ZXN0c1xuICAgIHJ1blRlc3RzKCk7XG5cbiAgICAvLyBTZXQgdXAgb3B0aW9ucyBmb3Igb3VyIGdhbWVcbiAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgY2FudmFzU2l6ZToge3g6IDEyMDAsIHk6IDgwMH0sICAgICAgICAgIC8vIFRoZSBzaXplIG9mIHRoZSBnYW1lXG4gICAgICAgIGNsZWFyQ29sb3I6IHtyOiAwLjEsIGc6IDAuMSwgYjogMC4xfSwgICAvLyBUaGUgY29sb3IgdGhlIGdhbWUgY2xlYXJzIHRvXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge25hbWU6IFwiZm9yd2FyZFwiLCBrZXlzOiBbXCJ3XCJdfSxcbiAgICAgICAgICAgIHtuYW1lOiBcImJhY2t3YXJkXCIsIGtleXM6IFtcInNcIl19LFxuICAgICAgICAgICAge25hbWU6IFwibGVmdFwiLCBrZXlzOiBbXCJhXCJdfSxcbiAgICAgICAgICAgIHtuYW1lOiBcInJpZ2h0XCIsIGtleXM6IFtcImRcIl19LFxuICAgICAgICAgICAge25hbWU6IFwicGlja3VwXCIsIGtleXM6IFtcImVcIl19LFxuICAgICAgICAgICAge25hbWU6IFwiZHJvcFwiLCBrZXlzOiBbXCJxXCJdfSxcbiAgICAgICAgICAgIHtuYW1lOiBcInNsb3QxXCIsIGtleXM6IFtcIjFcIl19LFxuICAgICAgICAgICAge25hbWU6IFwic2xvdDJcIiwga2V5czogW1wiMlwiXX0sXG4gICAgICAgIF0sXG4gICAgICAgIHVzZVdlYkdMOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAvLyBUZWxsIHRoZSBnYW1lIHdlIHdhbnQgdG8gdXNlIHdlYmdsXG4gICAgICAgIHNob3dEZWJ1ZzogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZXRoZXIgdG8gc2hvdyBkZWJ1ZyBtZXNzYWdlcy4gWW91IGNhbiBjaGFuZ2UgdGhpcyB0byB0cnVlIGlmIHlvdSB3YW50XG4gICAgfVxuXG4gICAgLy8gU2V0IHVwIGN1c3RvbSByZWdpc3RyaWVzXG4gICAgbGV0IHdlYXBvblRlbXBsYXRlUmVnaXN0cnkgPSBuZXcgV2VhcG9uVGVtcGxhdGVSZWdpc3RyeSgpO1xuICAgIFJlZ2lzdHJ5TWFuYWdlci5hZGRDdXN0b21SZWdpc3RyeShcIndlYXBvblRlbXBsYXRlc1wiLCB3ZWFwb25UZW1wbGF0ZVJlZ2lzdHJ5KTtcbiAgICBcbiAgICBsZXQgd2VhcG9uVHlwZVJlZ2lzdHJ5ID0gbmV3IFdlYXBvblR5cGVSZWdpc3RyeSgpO1xuICAgIFJlZ2lzdHJ5TWFuYWdlci5hZGRDdXN0b21SZWdpc3RyeShcIndlYXBvblR5cGVzXCIsIHdlYXBvblR5cGVSZWdpc3RyeSk7XG5cbiAgICAvLyBDcmVhdGUgYSBnYW1lIHdpdGggdGhlIG9wdGlvbnMgc3BlY2lmaWVkXG4gICAgY29uc3QgZ2FtZSA9IG5ldyBHYW1lKG9wdGlvbnMpO1xuXG4gICAgLy8gU3RhcnQgb3VyIGdhbWVcbiAgICBnYW1lLnN0YXJ0KE1haW5NZW51LCB7fSk7XG59KSgpO1xuXG5mdW5jdGlvbiBydW5UZXN0cygpe1xuICAgIFxufTsiLCJpbXBvcnQgR29hcEFjdGlvblBsYW5uZXIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0FJL0dvYXBBY3Rpb25QbGFubmVyXCI7XHJcbmltcG9ydCBTdGF0ZU1hY2hpbmVBSSBmcm9tIFwiLi4vLi4vV29sZmllMkQvQUkvU3RhdGVNYWNoaW5lQUlcIjtcclxuaW1wb3J0IFN0YXRlTWFjaGluZUdvYXBBSSBmcm9tIFwiLi4vLi4vV29sZmllMkQvQUkvU3RhdGVNYWNoaW5lR29hcEFJXCI7XHJcbmltcG9ydCBHb2FwQWN0aW9uIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvSW50ZXJmYWNlcy9Hb2FwQWN0aW9uXCI7XHJcbmltcG9ydCBBQUJCIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcclxuaW1wb3J0IFN0YWNrIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvU3RhY2tcIjtcclxuaW1wb3J0IFN0YXRlIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvU3RhdGUvU3RhdGVcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRcIjtcclxuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcclxuaW1wb3J0IE9ydGhvZ29uYWxUaWxlbWFwIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9UaWxlbWFwcy9PcnRob2dvbmFsVGlsZW1hcFwiO1xyXG5pbXBvcnQgTmF2aWdhdGlvblBhdGggZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1BhdGhmaW5kaW5nL05hdmlnYXRpb25QYXRoXCI7XHJcbmltcG9ydCBXZWFwb24gZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL2l0ZW1zL1dlYXBvblwiO1xyXG5pbXBvcnQgeyBodzRfRXZlbnRzLCBodzRfTmFtZXMsIGh3NF9TdGF0dXNlcyB9IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9jb25zdGFudHNcIjtcclxuaW1wb3J0IEJhdHRsZXJBSSBmcm9tIFwiLi9CYXR0bGVyQUlcIjtcclxuaW1wb3J0IEFsZXJ0IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9BSS9FbmVteVN0YXRlcy9BbGVydFwiO1xyXG5pbXBvcnQgQWN0aXZlIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9BSS9FbmVteVN0YXRlcy9BY3RpdmVcIjtcclxuaW1wb3J0IEd1YXJkIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9BSS9FbmVteVN0YXRlcy9HdWFyZFwiO1xyXG5pbXBvcnQgUGF0cm9sIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9BSS9FbmVteVN0YXRlcy9QYXRyb2xcIjtcclxuaW1wb3J0IExhYmVsIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW5lbXlBSSBleHRlbmRzIFN0YXRlTWFjaGluZUdvYXBBSSBpbXBsZW1lbnRzIEJhdHRsZXJBSSB7XHJcbiAgICAvKiogVGhlIG93bmVyIG9mIHRoaXMgQUkgKi9cclxuICAgIG93bmVyOiBBbmltYXRlZFNwcml0ZTtcclxuXHJcbiAgICAvKiogVGhlIHRvdGFsIHBvc3NpYmxlIGFtb3VudCBvZiBoZWFsdGggdGhpcyBlbnRpdHkgaGFzICovXHJcbiAgICBtYXhIZWFsdGg6IG51bWJlcjtcclxuXHJcbiAgICAvKiogVGhlIGN1cnJlbnQgYW1vdW50IG9mIGhlYWx0aCB0aGlzIGVudGl0eSBoYXMgKi9cclxuICAgIGhlYWx0aDogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBUaGUgZGVmYXVsdCBtb3ZlbWVudCBzcGVlZCBvZiB0aGlzIEFJICovXHJcbiAgICBzcGVlZDogbnVtYmVyID0gMjA7XHJcblxyXG4gICAgLyoqIFRoZSB3ZWFwb24gdGhpcyBBSSBoYXMgKi9cclxuICAgIHdlYXBvbjogV2VhcG9uO1xyXG5cclxuICAgIC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgcGxheWVyIG9iamVjdCAqL1xyXG4gICAgcGxheWVyMTogR2FtZU5vZGU7XHJcblxyXG4gICAgLyoqIEEgcmVmZXJlbmNlIHRvIHRoZSBwbGF5ZXIgb2JqZWN0ICovXHJcbiAgICBwbGF5ZXIyOiBHYW1lTm9kZTtcclxuXHJcbiAgICAvLyBUaGUgY3VycmVudCBrbm93biBwb3NpdGlvbiBvZiB0aGUgcGxheWVyXHJcbiAgICBwbGF5ZXJQb3M6IFZlYzI7XHJcblxyXG4gICAgLy8gVGhlIGxhc3Qga25vd24gcG9zaXRpb24gb2YgdGhlIHBsYXllclxyXG4gICAgbGFzdFBsYXllclBvczogVmVjMjtcclxuXHJcbiAgICAvLyBBdHRhY2sgcmFuZ2VcclxuICAgIGluUmFuZ2U6IG51bWJlcjtcclxuXHJcbiAgICAvLyBQYXRoIHRvIHBsYXllclxyXG4gICAgcGF0aDogTmF2aWdhdGlvblBhdGg7XHJcblxyXG4gICAgLy8gUGF0aCBhd2F5IGZyb20gcGxheWVyXHJcbiAgICByZXRyZWF0UGF0aDogTmF2aWdhdGlvblBhdGg7XHJcblxyXG4gICAgaW5pdGlhbGl6ZUFJKG93bmVyOiBBbmltYXRlZFNwcml0ZSwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMub3duZXIgPSBvd25lcjtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdE1vZGUgPT09IFwiZ3VhcmRcIikge1xyXG4gICAgICAgICAgICAvLyBHdWFyZCBtb2RlXHJcbiAgICAgICAgICAgIHRoaXMuYWRkU3RhdGUoRW5lbXlTdGF0ZXMuREVGQVVMVCwgbmV3IEd1YXJkKHRoaXMsIG93bmVyLCBvcHRpb25zLmd1YXJkUG9zaXRpb24pKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBQYXRyb2wgbW9kZVxyXG4gICAgICAgICAgICB0aGlzLmFkZFN0YXRlKEVuZW15U3RhdGVzLkRFRkFVTFQsIG5ldyBQYXRyb2wodGhpcywgb3duZXIsIG9wdGlvbnMucGF0cm9sUm91dGUpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYWRkU3RhdGUoRW5lbXlTdGF0ZXMuQUxFUlQsIG5ldyBBbGVydCh0aGlzLCBvd25lcikpO1xyXG4gICAgICAgIHRoaXMuYWRkU3RhdGUoRW5lbXlTdGF0ZXMuVEFSR0VUSU5HLCBuZXcgQWN0aXZlKHRoaXMsIG93bmVyKSk7XHJcblxyXG4gICAgICAgIHRoaXMubWF4SGVhbHRoID0gb3B0aW9ucy5oZWFsdGg7XHJcblxyXG4gICAgICAgIHRoaXMuaGVhbHRoID0gb3B0aW9ucy5oZWFsdGg7XHJcblxyXG4gICAgICAgIHRoaXMud2VhcG9uID0gb3B0aW9ucy53ZWFwb247XHJcblxyXG4gICAgICAgIHRoaXMucGxheWVyMSA9IG9wdGlvbnMucGxheWVyMTtcclxuXHJcbiAgICAgICAgdGhpcy5pblJhbmdlID0gb3B0aW9ucy5pblJhbmdlO1xyXG5cclxuICAgICAgICB0aGlzLmdvYWwgPSBvcHRpb25zLmdvYWw7XHJcblxyXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzO1xyXG5cclxuICAgICAgICB0aGlzLnBvc3NpYmxlQWN0aW9ucyA9IG9wdGlvbnMuYWN0aW9ucztcclxuXHJcbiAgICAgICAgdGhpcy5wbGFuID0gbmV3IFN0YWNrPEdvYXBBY3Rpb24+KCk7XHJcblxyXG4gICAgICAgIHRoaXMucGxhbm5lciA9IG5ldyBHb2FwQWN0aW9uUGxhbm5lcigpO1xyXG5cclxuICAgICAgICAvLyBJbml0aWFsaXplIHRvIHRoZSBkZWZhdWx0IHN0YXRlXHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKEVuZW15U3RhdGVzLkRFRkFVTFQpO1xyXG5cclxuICAgICAgICB0aGlzLmdldFBsYXllclBvc2l0aW9uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgYWN0aXZhdGUob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQgeyB9XHJcblxyXG4gICAgZGFtYWdlKGRhbWFnZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5oZWFsdGggLT0gZGFtYWdlO1xyXG5cclxuICAgICAgICAvLyBJZiB3ZSdyZSBsb3cgZW5vdWdoLCBhZGQgTG93IEhlYWx0aCBzdGF0dXMgdG8gZW5lbXlcclxuICAgICAgICBpZiAodGhpcy5oZWFsdGggPD0gTWF0aC5mbG9vcih0aGlzLm1heEhlYWx0aC8yKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U3RhdHVzLmluZGV4T2YoaHc0X1N0YXR1c2VzLkxPV19IRUFMVEgpID09PSAtMSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGF0dXMucHVzaChodzRfU3RhdHVzZXMuTE9XX0hFQUxUSCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIGhlYWx0aCBnb2VzIGJlbG93IDAsIGRpc2FibGUgQUkgYW5kIGZpcmUgZW5lbXlEaWVkIGV2ZW50XHJcbiAgICAgICAgaWYgKHRoaXMuaGVhbHRoIDw9IDApIHtcclxuICAgICAgICAgICAgdGhpcy5vd25lci5zZXRBSUFjdGl2ZShmYWxzZSwge30pO1xyXG4gICAgICAgICAgICB0aGlzLm93bmVyLmlzQ29sbGlkYWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLm93bmVyLnZpc2libGUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQoXCJlbmVteURpZWRcIiwge2VuZW15OiB0aGlzLm93bmVyfSlcclxuXHJcbiAgICAgICAgICAgIC8vIGlmIChNYXRoLnJhbmRvbSgpIDwgMC4yKSB7XHJcbiAgICAgICAgICAgIC8vICAgICAvLyBTcGF3biBhIGhlYWx0aHBhY2tcclxuICAgICAgICAgICAgLy8gICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQoXCJoZWFsdGhwYWNrXCIsIHsgcG9zaXRpb246IHRoaXMub3duZXIucG9zaXRpb24gfSk7XHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc1BsYXllclZpc2libGUocG9zOiBWZWMyKTogVmVjMntcclxuICAgICAgICAvL0NoZWNrIGlmIG9uZSBwbGF5ZXIgaXMgdmlzaWJsZSwgdGFraW5nIGludG8gYWNjb3VudCB3YWxsc1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIG5ldyBwbGF5ZXIgbG9jYXRpb25cclxuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLm93bmVyLnBvc2l0aW9uLmNsb25lKCk7XHJcbiAgICAgICAgbGV0IGRlbHRhID0gcG9zLmNsb25lKCkuc3ViKHN0YXJ0KTtcclxuXHJcbiAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSB0aWxlbWFwIHJlZ2lvbiB1bnRpbCB3ZSBmaW5kIGEgY29sbGlzaW9uXHJcbiAgICAgICAgbGV0IG1pblggPSBNYXRoLm1pbihzdGFydC54LCBwb3MueCk7XHJcbiAgICAgICAgbGV0IG1heFggPSBNYXRoLm1heChzdGFydC54LCBwb3MueCk7XHJcbiAgICAgICAgbGV0IG1pblkgPSBNYXRoLm1pbihzdGFydC55LCBwb3MueSk7XHJcbiAgICAgICAgbGV0IG1heFkgPSBNYXRoLm1heChzdGFydC55LCBwb3MueSk7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgd2FsbCB0aWxlbWFwXHJcbiAgICAgICAgbGV0IHdhbGxzID0gPE9ydGhvZ29uYWxUaWxlbWFwPnRoaXMub3duZXIuZ2V0U2NlbmUoKS5nZXRMYXllcihcIldhbGxcIikuZ2V0SXRlbXMoKVswXTtcclxuXHJcbiAgICAgICAgbGV0IG1pbkluZGV4ID0gd2FsbHMuZ2V0Q29sUm93QXQobmV3IFZlYzIobWluWCwgbWluWSkpO1xyXG4gICAgICAgIGxldCBtYXhJbmRleCA9IHdhbGxzLmdldENvbFJvd0F0KG5ldyBWZWMyKG1heFgsIG1heFkpKTtcclxuXHJcbiAgICAgICAgbGV0IHRpbGVTaXplID0gd2FsbHMuZ2V0VGlsZVNpemUoKTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgY29sID0gbWluSW5kZXgueDsgY29sIDw9IG1heEluZGV4Lng7IGNvbCsrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IG1pbkluZGV4Lnk7IHJvdyA8PSBtYXhJbmRleC55OyByb3crKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHdhbGxzLmlzVGlsZUNvbGxpZGFibGUoY29sLCByb3cpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBwb3NpdGlvbiBvZiB0aGlzIHRpbGVcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdGlsZVBvcyA9IG5ldyBWZWMyKGNvbCAqIHRpbGVTaXplLnggKyB0aWxlU2l6ZS54IC8gMiwgcm93ICogdGlsZVNpemUueSArIHRpbGVTaXplLnkgLyAyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgY29sbGlkZXIgZm9yIHRoaXMgdGlsZVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2xsaWRlciA9IG5ldyBBQUJCKHRpbGVQb3MsIHRpbGVTaXplLnNjYWxlZCgxIC8gMikpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgaGl0ID0gY29sbGlkZXIuaW50ZXJzZWN0U2VnbWVudChzdGFydCwgZGVsdGEsIFZlYzIuWkVSTyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoaXQgIT09IG51bGwgJiYgc3RhcnQuZGlzdGFuY2VTcVRvKGhpdC5wb3MpIDwgc3RhcnQuZGlzdGFuY2VTcVRvKHBvcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGl0IGEgd2FsbCwgd2UgY2FuJ3Qgc2VlIHRoZSBwbGF5ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcG9zO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFBsYXllclBvc2l0aW9uKCk6IFZlYzIge1xyXG4gICAgICAgIC8vR2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgY2xvc2VzdCBwbGF5ZXIgaW4gc2lnaHRcclxuICAgICAgICBsZXQgcG9zID0gdGhpcy5wbGF5ZXIxLnBvc2l0aW9uO1xyXG4gICAgICAgIGxldCBwb3NpdGlvbjEgPSB0aGlzLmlzUGxheWVyVmlzaWJsZShwb3MpO1xyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggcGxheWVyIHBvc2l0aW9uIHRvIHJldHVyblxyXG4gICAgICAgIGlmIChwb3NpdGlvbjEgPT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcG9zaXRpb24xO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcil7XHJcbiAgICAgICAgc3VwZXIudXBkYXRlKGRlbHRhVCk7XHJcblxyXG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIHBsYW4gdGhhdCBpcyBleGVjdXRlZCBpbiB0aGUgQWN0aXZlIHN0YXRlLCBzbyB3aGVuZXZlciB3ZSBkb24ndCBoYXZlIGEgcGxhbiwgYWNxdWlyZSBhIG5ldyBvbmUgZ2l2ZW4gdGhlIGN1cnJlbnQgc3RhdHVzZXMgdGhlIGVuZW15IGhhc1xyXG4gICAgICAgIGlmICh0aGlzLnBsYW4uaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIC8vZ2V0IGEgbmV3IHBsYW5cclxuICAgICAgICAgICAgdGhpcy5wbGFuID0gdGhpcy5wbGFubmVyLnBsYW4oaHc0X1N0YXR1c2VzLlJFQUNIRURfR09BTCwgdGhpcy5wb3NzaWJsZUFjdGlvbnMsIHRoaXMuY3VycmVudFN0YXR1cywgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZW51bSBFbmVteVN0YXRlcyB7XHJcbiAgICBERUZBVUxUID0gXCJkZWZhdWx0XCIsXHJcbiAgICBBTEVSVCA9IFwiYWxlcnRcIixcclxuICAgIFRBUkdFVElORyA9IFwidGFyZ2V0aW5nXCIsXHJcbiAgICBQUkVWSU9VUyA9IFwicHJldmlvdXNcIlxyXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRcIjtcclxuaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9FdmVudHMvUmVjZWl2ZXJcIjtcclxuaW1wb3J0IElucHV0IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9JbnB1dC9JbnB1dFwiO1xyXG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcclxuaW1wb3J0IE5hdmlnYXRpb25QYXRoIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9QYXRoZmluZGluZy9OYXZpZ2F0aW9uUGF0aFwiO1xyXG5pbXBvcnQgVGltZXIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1RpbWluZy9UaW1lclwiO1xyXG5pbXBvcnQgSW52ZW50b3J5TWFuYWdlciBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvSW52ZW50b3J5TWFuYWdlclwiO1xyXG5pbXBvcnQgSGVhbHRocGFjayBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvaXRlbXMvSGVhbHRocGFja1wiO1xyXG5pbXBvcnQgSXRlbSBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvaXRlbXMvSXRlbVwiO1xyXG5pbXBvcnQgU2xpY2UgZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL2l0ZW1zL1dlYXBvblR5cGVzL1NsaWNlXCI7XHJcbmltcG9ydCBXZWFwb24gZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL2l0ZW1zL1dlYXBvblwiO1xyXG5pbXBvcnQgeyBodzRfRXZlbnRzLCBodzRfTmFtZXMgfSBmcm9tIFwiLi4vLi4vV29sZmllMkQvY29uc3RhbnRzXCI7XHJcbmltcG9ydCBCYXR0bGVyQUkgZnJvbSBcIi4vQmF0dGxlckFJXCI7XHJcbmltcG9ydCBMYXNlckd1biBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvaXRlbXMvV2VhcG9uVHlwZXMvTGFzZXJHdW5cIjtcclxuaW1wb3J0IFNlbWlBdXRvR3VuIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9pdGVtcy9XZWFwb25UeXBlcy9TZW1pQXV0b0d1blwiO1xyXG5pbXBvcnQgTWF4SGVhbHRoIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9pdGVtcy9NYXhIZWFsdGhcIjtcclxuaW1wb3J0IEF0dGFja0RhbWFnZSBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvaXRlbXMvQXR0YWNrRGFtYWdlXCI7XHJcbmltcG9ydCBBdHRhY2tTcGVlZCBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvaXRlbXMvQXR0YWNrU3BlZWRcIjtcclxuaW1wb3J0IFNwZWVkIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9pdGVtcy9TcGVlZFwiO1xyXG5pbXBvcnQgQ2hlY2twb2ludCBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvaXRlbXMvQ2hlY2twb2ludFwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1NjZW5lL1NjZW5lXCI7XHJcbmltcG9ydCBDaGVja3BvaW50Q2xlYXJlZCBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvaXRlbXMvQ2hlY2twb2ludENsZWFyZWRcIjtcclxuaW1wb3J0IEVtaXR0ZXIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0V2ZW50cy9FbWl0dGVyXCI7XHJcbmltcG9ydCBTdGF0ZU1hY2hpbmVHb2FwQUkgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0FJL1N0YXRlTWFjaGluZUdvYXBBSVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGxheWVyQ29udHJvbGxlclxyXG4gIGV4dGVuZHMgU3RhdGVNYWNoaW5lR29hcEFJXHJcbiAgaW1wbGVtZW50cyBCYXR0bGVyQUlcclxue1xyXG4gIC8vIEZpZWxkcyBmcm9tIEJhdHRsZXJBSVxyXG4gIGhlYWx0aDogbnVtYmVyO1xyXG5cclxuICBtYXhIZWFsdGg6IG51bWJlcjtcclxuXHJcbiAgLy8gVGhlIGFjdHVhbCBwbGF5ZXIgc3ByaXRlXHJcbiAgb3duZXI6IEFuaW1hdGVkU3ByaXRlO1xyXG5cclxuICBkaXJlY3Rpb246IFZlYzI7XHJcblxyXG4gIC8vIEF0dGFjayByYW5nZVxyXG4gIHJhbmdlOiBudW1iZXI7XHJcblxyXG4gIC8vIEN1cnJlbnQgdGFyZ2V0ZWQgZW5lbXlcclxuICB0YXJnZXQ6IFZlYzI7XHJcblxyXG4gIC8vIFVzZWQgZm9yIHN3YXBwaW5nIGNvbnRyb2wgYmV0d2VlbiBib3RoIHBsYXllcnNcclxuICBpbnB1dEVuYWJsZWQ6IGJvb2xlYW47XHJcblxyXG4gIC8vIFRoZSBpbnZlbnRvcnkgb2YgdGhlIHBsYXllclxyXG4gIGludmVudG9yeTogSW52ZW50b3J5TWFuYWdlcjtcclxuXHJcbiAgLyoqIEEgbGlzdCBvZiBpdGVtcyBpbiB0aGUgZ2FtZSB3b3JsZCAqL1xyXG4gIHByaXZhdGUgaXRlbXM6IEFycmF5PEl0ZW0+O1xyXG5cclxuICAvLyBNb3ZlbWVudFxyXG4gIHByaXZhdGUgc3BlZWQ6IG51bWJlcjtcclxuXHJcbiAgcHJpdmF0ZSBsb29rRGlyZWN0aW9uOiBWZWMyO1xyXG4gIHByaXZhdGUgcGF0aDogTmF2aWdhdGlvblBhdGg7XHJcblxyXG4gIHdlYXBvbjogV2VhcG9uO1xyXG4gIGJ1ZmZBY3RpdmVTdGF0dXM6IEFycmF5PFN0cmluZz47XHJcbiAgZW1pdHRlcjogRW1pdHRlcjtcclxuXHJcbiAgc2hvb3RpbmdUaW1lcjogVGltZXI7XHJcblxyXG4gIGluaXRpYWxpemVBSShvd25lcjogQW5pbWF0ZWRTcHJpdGUsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuICAgIHRoaXMub3duZXIgPSBvd25lcjtcclxuICAgIHRoaXMubG9va0RpcmVjdGlvbiA9IFZlYzIuWkVSTztcclxuICAgIHRoaXMuc3BlZWQgPSBvcHRpb25zLnNwZWVkO1xyXG4gICAgdGhpcy5oZWFsdGggPSBvcHRpb25zLmhlYWx0aDtcclxuICAgIHRoaXMubWF4SGVhbHRoID0gb3B0aW9ucy5tYXhIZWFsdGg7XHJcbiAgICB0aGlzLmlucHV0RW5hYmxlZCA9IG9wdGlvbnMuaW5wdXRFbmFibGVkO1xyXG4gICAgdGhpcy5yYW5nZSA9IG9wdGlvbnMucmFuZ2U7XHJcblxyXG4gICAgdGhpcy5pdGVtcyA9IG9wdGlvbnMuaXRlbXM7XHJcbiAgICB0aGlzLmludmVudG9yeSA9IG9wdGlvbnMuaW52ZW50b3J5O1xyXG5cclxuICAgIC8vZGVmaW5lZCBieSBkYW9cclxuICAgIHRoaXMud2VhcG9uID0gb3B0aW9ucy53ZWFwb247XHJcbiAgICB0aGlzLnNob290aW5nVGltZXIgPSB0aGlzLndlYXBvbi5jb29sZG93blRpbWVyO1xyXG4gIH1cclxuXHJcbiAgYWN0aXZhdGUob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge31cclxuXHJcbiAgaGFuZGxlRXZlbnQoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge1xyXG4gICAgLy8gSWYgb3VyIGlkIG1hdGNoZXMgdGhpcyBwbGF5ZXIsIHNldCBib29sZWFuIGFuZCB1cGRhdGUgaW52ZW50b3J5IFVJXHJcbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gaHc0X0V2ZW50cy5TV0FQX1BMQVlFUikge1xyXG4gICAgICBpZiAoZXZlbnQuZGF0YS5nZXQoXCJpZFwiKSA9PT0gdGhpcy5vd25lci5pZCkge1xyXG4gICAgICAgIHRoaXMuaW5wdXRFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmludmVudG9yeS5zZXRBY3RpdmUodHJ1ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5pbnB1dEVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmludmVudG9yeS5zZXRBY3RpdmUoZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyAgIHRoaXMgaXMgdXNlIHRvIHNob290XHJcbiAgaGFuZGxlVXNlSXRlbSgpOiB2b2lkIHtcclxuICAgIGxldCBpdGVtID0gdGhpcy5pbnZlbnRvcnkuZ2V0SXRlbSgpO1xyXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gaXRlbSBpbiB0aGUgY3VycmVudCBzbG90LCB1c2UgaXRcclxuICAgIGlmIChpdGVtKSB7XHJcbiAgICAgIGl0ZW0udXNlKHRoaXMub3duZXIsIFwicGxheWVyXCIsIHRoaXMubG9va0RpcmVjdGlvbik7XHJcbiAgICAgIGlmICh0aGlzLmxvb2tEaXJlY3Rpb24ueCA+IDApIHtcclxuICAgICAgICB0aGlzLm93bmVyLmFuaW1hdGlvbi5wbGF5KFwiZmFjZV9yaWdodFwiKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLm93bmVyLmFuaW1hdGlvbi5wbGF5KFwiZmFjZV9sZWZ0XCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLy9hZnRlciBwaWNraW5nIHVwIGFwcGx5IHRoZSBidWZmIGFuZCBkZXN0cm95IHRoZSBpdGVtXHJcbiAgaGFuZGxlQXBwbHlCdWZmRWZmZWN0KGl0ZW06IEl0ZW0pOiB2b2lkIHtcclxuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgSGVhbHRocGFjaykge1xyXG4gICAgICAoPEJhdHRsZXJBST50aGlzLm93bmVyLl9haSkubWF4SGVhbHRoICs9IDU7XHJcbiAgICAgICg8QmF0dGxlckFJPnRoaXMub3duZXIuX2FpKS5oZWFsdGggKz0gNTtcclxuICAgIH1cclxuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgQXR0YWNrRGFtYWdlKSB7XHJcbiAgICAgIHRoaXMud2VhcG9uLnR5cGUuZGFtYWdlICs9IDU7XHJcbiAgICB9XHJcbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEF0dGFja1NwZWVkKSB7XHJcbiAgICAgIHRoaXMud2VhcG9uLmNvb2xkb3duVGltZXIgPSBuZXcgVGltZXIoXHJcbiAgICAgICAgdGhpcy53ZWFwb24uY29vbGRvd25UaW1lci50b3RhbFRpbWUgKiAwLjhcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgU3BlZWQpIHtcclxuICAgICAgdGhpcy5zcGVlZCArPSA0MDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIE1heEhlYWx0aCkge1xyXG4gICAgICAoPEJhdHRsZXJBST50aGlzLm93bmVyLl9haSkuaGVhbHRoICs9IDU7XHJcbiAgICAgIGlmIChcclxuICAgICAgICAoPEJhdHRsZXJBST50aGlzLm93bmVyLl9haSkuaGVhbHRoID5cclxuICAgICAgICAoPEJhdHRsZXJBST50aGlzLm93bmVyLl9haSkubWF4SGVhbHRoXHJcbiAgICAgICkge1xyXG4gICAgICAgICg8QmF0dGxlckFJPnRoaXMub3duZXIuX2FpKS5oZWFsdGggPSAoPEJhdHRsZXJBST4oXHJcbiAgICAgICAgICB0aGlzLm93bmVyLl9haVxyXG4gICAgICAgICkpLm1heEhlYWx0aDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBDaGVja3BvaW50KSB7XHJcbiAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQoXCJjaGVja3BvaW50X2NsZWFyZWRcIiwge1xyXG4gICAgICAgIHBvc2l0aW9uOiBuZXcgVmVjMihpdGVtLnNwcml0ZS5wb3NpdGlvbi54LCBpdGVtLnNwcml0ZS5wb3NpdGlvbi55KSxcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KFwibmV3YnVmZlwiLCB7IGJ1ZmY6IGl0ZW0gfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIShpdGVtIGluc3RhbmNlb2YgQ2hlY2twb2ludENsZWFyZWQpKSB7XHJcbiAgICAgIGl0ZW0ubW92ZVNwcml0ZShuZXcgVmVjMig5OTk5LCA5OTk5KSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGhhbmRsZVBpY2tVcEl0ZW0oKTogdm9pZCB7XHJcbiAgICBmb3IgKGxldCBpdGVtIG9mIHRoaXMuaXRlbXMpIHtcclxuICAgICAgaWYgKHRoaXMub3duZXIuY29sbGlzaW9uU2hhcGUub3ZlcmxhcHMoaXRlbS5zcHJpdGUuYm91bmRhcnkpKSB7XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgdGhpcy5oYW5kbGVBcHBseUJ1ZmZFZmZlY3QoaXRlbSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICB3aGlsZSAodGhpcy5yZWNlaXZlci5oYXNOZXh0RXZlbnQoKSkge1xyXG4gICAgICB0aGlzLmhhbmRsZUV2ZW50KHRoaXMucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KCkpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuaW5wdXRFbmFibGVkICYmIHRoaXMuaGVhbHRoID4gMCkge1xyXG4gICAgICBpZiAoSW5wdXQuaXNNb3VzZVByZXNzZWQoMCkpIHtcclxuICAgICAgICBpZiAodGhpcy53ZWFwb24uY29vbGRvd25UaW1lci5pc1N0b3BwZWQoKSkge1xyXG4gICAgICAgICAgdGhpcy5sb29rRGlyZWN0aW9uID0gdGhpcy5vd25lci5wb3NpdGlvbi5kaXJUbyhcclxuICAgICAgICAgICAgSW5wdXQuZ2V0R2xvYmFsTW91c2VQb3NpdGlvbigpXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgdGhpcy5oYW5kbGVVc2VJdGVtKCk7XHJcbiAgICAgICAgICB0aGlzLndlYXBvbi5jb29sZG93blRpbWVyLnN0YXJ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoSW5wdXQuaXNNb3VzZUp1c3RQcmVzc2VkKDIpKSB7XHJcbiAgICAgICAgdGhpcy5vd25lci5wb3NpdGlvbiA9IElucHV0LmdldEdsb2JhbE1vdXNlUG9zaXRpb24oKTtcclxuICAgICAgICAvL3RoaXMucGF0aCA9IHRoaXMub3duZXIuZ2V0U2NlbmUoKS5nZXROYXZpZ2F0aW9uTWFuYWdlcigpLmdldFBhdGgoaHc0X05hbWVzLk5BVk1FU0gsIHRoaXMub3duZXIucG9zaXRpb24sIElucHV0LmdldEdsb2JhbE1vdXNlUG9zaXRpb24oKSwgdHJ1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChcclxuICAgICAgICAvLyBJbnB1dC5pc01vdXNlSnVzdFByZXNzZWQoMClcclxuICAgICAgICBJbnB1dC5pc0tleVByZXNzZWQoXCJhXCIpIHx8XHJcbiAgICAgICAgSW5wdXQuaXNLZXlQcmVzc2VkKFwid1wiKSB8fFxyXG4gICAgICAgIElucHV0LmlzS2V5UHJlc3NlZChcInNcIikgfHxcclxuICAgICAgICBJbnB1dC5pc0tleVByZXNzZWQoXCJkXCIpXHJcbiAgICAgICkge1xyXG4gICAgICAgIGxldCBwbGF5ZXJQb3MgPSB0aGlzLm93bmVyLnBvc2l0aW9uLmNsb25lKCk7XHJcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBWZWMyLlpFUk87XHJcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24ueCA9XHJcbiAgICAgICAgICAoSW5wdXQuaXNLZXlQcmVzc2VkKFwiYVwiKSA/IC0xIDogMCkgK1xyXG4gICAgICAgICAgKElucHV0LmlzS2V5UHJlc3NlZChcImRcIikgPyAxIDogMCk7XHJcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24ueSA9XHJcbiAgICAgICAgICAoSW5wdXQuaXNLZXlQcmVzc2VkKFwid1wiKSA/IC0xIDogMCkgK1xyXG4gICAgICAgICAgKElucHV0LmlzS2V5UHJlc3NlZChcInNcIikgPyAxIDogMCk7XHJcblxyXG4gICAgICAgIHRoaXMuZGlyZWN0aW9uLnggKj0gdGhpcy5zcGVlZDtcclxuICAgICAgICB0aGlzLmRpcmVjdGlvbi55ICo9IHRoaXMuc3BlZWQ7XHJcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24ubm9ybWFsaXplKCk7XHJcbiAgICAgICAgaWYgKElucHV0LmlzS2V5SnVzdFByZXNzZWQoXCJkXCIpKSB7XHJcbiAgICAgICAgICB0aGlzLm93bmVyLmFuaW1hdGlvbi5wbGF5KFwicnVuX3JpZ2h0XCIsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoSW5wdXQuaXNLZXlKdXN0UHJlc3NlZChcImFcIikpIHtcclxuICAgICAgICAgIHRoaXMub3duZXIuYW5pbWF0aW9uLnBsYXkoXCJydW5fbGVmdFwiLCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBuZXdQb3MgPSBwbGF5ZXJQb3MuY2xvbmUoKS5hZGQodGhpcy5kaXJlY3Rpb24uc2NhbGUoMykpO1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHRoaXMub3duZXJcclxuICAgICAgICAgIC5nZXRTY2VuZSgpXHJcbiAgICAgICAgICAuZ2V0TmF2aWdhdGlvbk1hbmFnZXIoKVxyXG4gICAgICAgICAgLmdldFBhdGgoaHc0X05hbWVzLk5BVk1FU0gsIHRoaXMub3duZXIucG9zaXRpb24sIG5ld1BvcywgdHJ1ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5vd25lci5hbmltYXRpb24uc3RvcCgpO1xyXG4gICAgICAgIGlmICh0aGlzLmRpcmVjdGlvbikge1xyXG4gICAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uLnggPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3duZXIuYW5pbWF0aW9uLnBsYXkoXCJmYWNlX3JpZ2h0XCIpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5vd25lci5hbmltYXRpb24ucGxheShcImZhY2VfbGVmdFwiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGZvciBzbG90IGNoYW5nZVxyXG4gICAgICBpZiAoSW5wdXQuaXNKdXN0UHJlc3NlZChcInNsb3QxXCIpKSB7XHJcbiAgICAgICAgdGhpcy5pbnZlbnRvcnkuY2hhbmdlU2xvdCgwKTtcclxuICAgICAgfSBlbHNlIGlmIChJbnB1dC5pc0p1c3RQcmVzc2VkKFwic2xvdDJcIikpIHtcclxuICAgICAgICB0aGlzLmludmVudG9yeS5jaGFuZ2VTbG90KDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9Nb3ZlIG9uIHBhdGggaWYgc2VsZWN0ZWRcclxuICAgIGlmICh0aGlzLnBhdGggIT0gbnVsbCkge1xyXG4gICAgICBpZiAodGhpcy5wYXRoLmlzRG9uZSgpKSB7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gbnVsbDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLm93bmVyLm1vdmVPblBhdGgodGhpcy5zcGVlZCAqIGRlbHRhVCwgdGhpcy5wYXRoKTtcclxuICAgICAgICAvLyB0aGlzLm93bmVyLnJvdGF0aW9uID0gVmVjMi5VUC5hbmdsZVRvQ0NXKFxyXG4gICAgICAgIC8vICAgdGhpcy5wYXRoLmdldE1vdmVEaXJlY3Rpb24odGhpcy5vd25lcilcclxuICAgICAgICAvLyApO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuaGFuZGxlUGlja1VwSXRlbSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy9UYXJnZXQgYW4gZW5lbXkgYW5kIGF0dGFja1xyXG4gICAgICBpZiAodGhpcy50YXJnZXQgIT0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMubG9va0RpcmVjdGlvbiA9IHRoaXMub3duZXIucG9zaXRpb24uZGlyVG8odGhpcy50YXJnZXQpO1xyXG4gICAgICAgIC8vIHRoaXMuaGFuZGxlVXNlSXRlbSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkYW1hZ2UoZGFtYWdlOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIHRoaXMuaGVhbHRoIC09IGRhbWFnZTtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7fVxyXG59XHJcbiIsImltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvR2FtZU5vZGVcIjtcbmltcG9ydCBCYXR0bGVyQUkgZnJvbSBcIi4uL0FJL0JhdHRsZXJBSVwiO1xuaW1wb3J0IFdlYXBvbiBmcm9tIFwiLi9pdGVtcy9XZWFwb25cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmF0dGxlTWFuYWdlciB7XG4gICAgcGxheWVyczogQXJyYXk8QmF0dGxlckFJPjtcblxuICAgIGVuZW1pZXM6IEFycmF5PEJhdHRsZXJBST47XG5cbiAgICBoYW5kbGVJbnRlcmFjdGlvbihhdHRhY2tlclR5cGU6IHN0cmluZywgd2VhcG9uOiBXZWFwb24pIHtcbiAgICAgICAgaWYgKGF0dGFja2VyVHlwZSA9PT0gXCJwbGF5ZXJcIikge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGNvbGxpc2lvbnMgd2l0aCBlbmVtaWVzXG4gICAgICAgICAgICBmb3IgKGxldCBlbmVteSBvZiB0aGlzLmVuZW1pZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAod2VhcG9uLmhpdHMoZW5lbXkub3duZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZW15LmRhbWFnZSh3ZWFwb24udHlwZS5kYW1hZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBjb2xsaXNpb24gd2l0aCBwbGF5ZXJcbiAgICAgICAgICAgIGZvciAobGV0IHBsYXllciBvZiB0aGlzLnBsYXllcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAod2VhcG9uLmhpdHMocGxheWVyLm93bmVyKSkge1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXIuZGFtYWdlKHdlYXBvbi50eXBlLmRhbWFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0UGxheWVycyhwbGF5ZXI6IEFycmF5PEJhdHRsZXJBST4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wbGF5ZXJzID0gcGxheWVyO1xuICAgIH1cblxuICAgIHNldEVuZW1pZXMoZW5lbWllczogQXJyYXk8QmF0dGxlckFJPik6IHZvaWQge1xuICAgICAgICB0aGlzLmVuZW1pZXMgPSBlbmVtaWVzO1xuICAgIH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IHsgR3JhcGhpY1R5cGUgfSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvR3JhcGhpY3MvR3JhcGhpY1R5cGVzXCI7XHJcbmltcG9ydCBSZWN0IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9SZWN0XCI7XHJcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XHJcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvU2NlbmUvU2NlbmVcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9VdGlscy9Db2xvclwiO1xyXG5pbXBvcnQgSXRlbSBmcm9tIFwiLi9pdGVtcy9JdGVtXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnZlbnRvcnlNYW5hZ2VyIHtcclxuICBwcml2YXRlIHBvc2l0aW9uOiBWZWMyO1xyXG4gIHByaXZhdGUgaXRlbXM6IEFycmF5PEl0ZW0+O1xyXG4gIHByaXZhdGUgaW52ZW50b3J5U2xvdHM6IEFycmF5PFNwcml0ZT47XHJcbiAgcHJpdmF0ZSBzbG90U2l6ZTogVmVjMjtcclxuICBwcml2YXRlIHBhZGRpbmc6IG51bWJlcjtcclxuICBwcml2YXRlIGN1cnJlbnRTbG90OiBudW1iZXI7XHJcbiAgcHJpdmF0ZSBzbG90TGF5ZXI6IHN0cmluZztcclxuICBwcml2YXRlIGl0ZW1MYXllcjogc3RyaW5nO1xyXG4gIHByaXZhdGUgc2VsZWN0ZWRTbG90OiBSZWN0O1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHNjZW5lOiBTY2VuZSxcclxuICAgIHNpemU6IG51bWJlcixcclxuICAgIGludmVudG9yeVNsb3Q6IHN0cmluZyxcclxuICAgIHBvc2l0aW9uOiBWZWMyLFxyXG4gICAgcGFkZGluZzogbnVtYmVyLFxyXG4gICAgc2xvdExheWVyOiBzdHJpbmcsXHJcbiAgICBpdGVtTGF5ZXI6IHN0cmluZ1xyXG4gICkge1xyXG4gICAgdGhpcy5pdGVtcyA9IG5ldyBBcnJheShzaXplKTtcclxuICAgIHRoaXMuaW52ZW50b3J5U2xvdHMgPSBuZXcgQXJyYXkoc2l6ZSk7XHJcbiAgICB0aGlzLnBhZGRpbmcgPSBwYWRkaW5nO1xyXG4gICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgdGhpcy5jdXJyZW50U2xvdCA9IDA7XHJcblxyXG4gICAgLy8gQWRkIGxheWVyc1xyXG4gICAgdGhpcy5zbG90TGF5ZXIgPSBzbG90TGF5ZXI7XHJcbiAgICBzY2VuZS5hZGRVSUxheWVyKHRoaXMuc2xvdExheWVyKS5zZXREZXB0aCgxMDApO1xyXG4gICAgdGhpcy5pdGVtTGF5ZXIgPSBpdGVtTGF5ZXI7XHJcbiAgICBzY2VuZS5hZGRVSUxheWVyKHRoaXMuaXRlbUxheWVyKS5zZXREZXB0aCgxMDEpO1xyXG5cclxuICAgIC8vIENyZWF0ZSB0aGUgaW52ZW50b3J5IHNsb3RzXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xyXG4gICAgICB0aGlzLmludmVudG9yeVNsb3RzW2ldID0gc2NlbmUuYWRkLnNwcml0ZShpbnZlbnRvcnlTbG90LCB0aGlzLnNsb3RMYXllcik7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zbG90U2l6ZSA9IHRoaXMuaW52ZW50b3J5U2xvdHNbMF0uc2l6ZS5jbG9uZSgpO1xyXG5cclxuICAgIC8vIFBvc2l0aW9uIHRoZSBpbnZlbnRvcnkgc2xvdHNcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XHJcbiAgICAgIHRoaXMuaW52ZW50b3J5U2xvdHNbaV0ucG9zaXRpb24uc2V0KFxyXG4gICAgICAgIHBvc2l0aW9uLnggKyBpICogKHRoaXMuc2xvdFNpemUueCArIHRoaXMucGFkZGluZyksXHJcbiAgICAgICAgcG9zaXRpb24ueVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCBhIHJlY3QgZm9yIHRoZSBzZWxlY3RlZCBzbG90XHJcbiAgICB0aGlzLnNlbGVjdGVkU2xvdCA9IDxSZWN0PihcclxuICAgICAgc2NlbmUuYWRkLmdyYXBoaWMoR3JhcGhpY1R5cGUuUkVDVCwgc2xvdExheWVyLCB7XHJcbiAgICAgICAgcG9zaXRpb246IHRoaXMucG9zaXRpb24uY2xvbmUoKSxcclxuICAgICAgICBzaXplOiB0aGlzLnNsb3RTaXplLmNsb25lKCkuaW5jKC0yKSxcclxuICAgICAgfSlcclxuICAgICk7XHJcbiAgICB0aGlzLnNlbGVjdGVkU2xvdC5jb2xvciA9IENvbG9yLldISVRFO1xyXG4gICAgdGhpcy5zZWxlY3RlZFNsb3QuY29sb3IuYSA9IDAuMjtcclxuICB9XHJcblxyXG4gIGdldEl0ZW0oKTogSXRlbSB7XHJcbiAgICByZXR1cm4gdGhpcy5pdGVtc1t0aGlzLmN1cnJlbnRTbG90XTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoYW5nZXMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBzbG90XHJcbiAgICovXHJcbiAgY2hhbmdlU2xvdChzbG90OiBudW1iZXIpOiB2b2lkIHtcclxuICAgIHRoaXMuY3VycmVudFNsb3QgPSBzbG90O1xyXG4gICAgdGhpcy5zZWxlY3RlZFNsb3QucG9zaXRpb24uY29weSh0aGlzLmludmVudG9yeVNsb3RzW3Nsb3RdLnBvc2l0aW9uKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBzbG90XHJcbiAgICovXHJcbiAgZ2V0U2xvdCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFNsb3Q7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGFuIGl0ZW0gdG8gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBzbG90XHJcbiAgICovXHJcbiAgYWRkSXRlbShpdGVtOiBJdGVtKTogYm9vbGVhbiB7XHJcbiAgICBpZiAoIXRoaXMuaXRlbXNbdGhpcy5jdXJyZW50U2xvdF0pIHtcclxuICAgICAgLy8gQWRkIHRoZSBpdGVtIHRvIHRoZSBpbnZlbnRvcnlcclxuICAgICAgdGhpcy5pdGVtc1t0aGlzLmN1cnJlbnRTbG90XSA9IGl0ZW07XHJcblxyXG4gICAgICAvLyBVcGRhdGUgdGhlIGd1aVxyXG4gICAgICBpdGVtLm1vdmVTcHJpdGUoXHJcbiAgICAgICAgbmV3IFZlYzIoXHJcbiAgICAgICAgICB0aGlzLnBvc2l0aW9uLnggKyB0aGlzLmN1cnJlbnRTbG90ICogKHRoaXMuc2xvdFNpemUueCArIHRoaXMucGFkZGluZyksXHJcbiAgICAgICAgICB0aGlzLnBvc2l0aW9uLnlcclxuICAgICAgICApLFxyXG4gICAgICAgIHRoaXMuaXRlbUxheWVyXHJcbiAgICAgICk7XHJcblxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGYWlsZWQgdG8gYWRkIGl0ZW0sIHNvbWV0aGluZyB3YXMgYWxyZWFkeSBpbiB0aGUgc2xvdFxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBhbmQgcmV0dXJucyBhbiBpdGVtIGZyb20gdGhlIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgc2xvdCwgaWYgcG9zc2libGVcclxuICAgKi9cclxuICByZW1vdmVJdGVtKCk6IEl0ZW0ge1xyXG4gICAgbGV0IGl0ZW0gPSB0aGlzLml0ZW1zW3RoaXMuY3VycmVudFNsb3RdO1xyXG5cclxuICAgIHRoaXMuaXRlbXNbdGhpcy5jdXJyZW50U2xvdF0gPSBudWxsO1xyXG5cclxuICAgIGlmIChpdGVtKSB7XHJcbiAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGdldFNpemUoKTogTnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLml0ZW1zLmxlbmd0aDtcclxuICB9XHJcblxyXG4gIHNldEFjdGl2ZShhY3RpdmU6IGJvb2xlYW4pIHtcclxuICAgIGlmIChhY3RpdmUpIHtcclxuICAgICAgdGhpcy5pbnZlbnRvcnlTbG90cy5mb3JFYWNoKChzbG90KSA9PiAoc2xvdC5hbHBoYSA9IDEuMCkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5pbnZlbnRvcnlTbG90cy5mb3JFYWNoKChzbG90KSA9PiAoc2xvdC5hbHBoYSA9IDAuNSkpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCBCYXR0bGVyQUkgZnJvbSBcIi4uLy4uL0FJL0JhdHRsZXJBSVwiO1xyXG5pbXBvcnQgSXRlbSBmcm9tIFwiLi9JdGVtXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdHRhY2tEYW1hZ2UgZXh0ZW5kcyBJdGVtIHtcclxuICB1c2UodXNlcjogR2FtZU5vZGUsIC4uLmFyZ3M6IGFueSk6IHZvaWQge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvTm9kZXMvR2FtZU5vZGVcIjtcclxuaW1wb3J0IEJhdHRsZXJBSSBmcm9tIFwiLi4vLi4vQUkvQmF0dGxlckFJXCI7XHJcbmltcG9ydCBJdGVtIGZyb20gXCIuL0l0ZW1cIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF0dGFja1NwZWVkIGV4dGVuZHMgSXRlbSB7XHJcbiAgdXNlKHVzZXI6IEdhbWVOb2RlLCAuLi5hcmdzOiBhbnkpOiB2b2lkIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCBCYXR0bGVyQUkgZnJvbSBcIi4uLy4uL0FJL0JhdHRsZXJBSVwiO1xyXG5pbXBvcnQgSXRlbSBmcm9tIFwiLi9JdGVtXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGVja3BvaW50IGV4dGVuZHMgSXRlbSB7XHJcbiAgdXNlKHVzZXI6IEdhbWVOb2RlLCAuLi5hcmdzOiBhbnkpOiB2b2lkIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCBCYXR0bGVyQUkgZnJvbSBcIi4uLy4uL0FJL0JhdHRsZXJBSVwiO1xyXG5pbXBvcnQgSXRlbSBmcm9tIFwiLi9JdGVtXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGVja3BvaW50Q2xlYXJlZCBleHRlbmRzIEl0ZW0ge1xyXG4gIHVzZSh1c2VyOiBHYW1lTm9kZSwgLi4uYXJnczogYW55KTogdm9pZCB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgQmF0dGxlckFJIGZyb20gXCIuLi8uLi9BSS9CYXR0bGVyQUlcIjtcclxuaW1wb3J0IEl0ZW0gZnJvbSBcIi4vSXRlbVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVhbHRocGFjayBleHRlbmRzIEl0ZW0ge31cclxuIiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvTm9kZXMvR2FtZU5vZGVcIjtcclxuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XHJcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBJdGVtIHtcclxuICB1c2Uob3duZXI6IEFuaW1hdGVkU3ByaXRlLCBhcmcxOiBzdHJpbmcsIGxvb2tEaXJlY3Rpb246IFZlYzIpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xyXG4gIH1cclxuICAvKiogVGhlIHNwcml0ZSB0aGF0IHJlcHJlc2VudHMgdGhpcyB3ZWFwb24gaW4gdGhlIHdvcmxkIG9yIGluIGFuIGludmVudG9yeSAqL1xyXG4gIHNwcml0ZTogU3ByaXRlO1xyXG5cclxuICBjb25zdHJ1Y3RvcihzcHJpdGU6IFNwcml0ZSkge1xyXG4gICAgdGhpcy5zcHJpdGUgPSBzcHJpdGU7XHJcbiAgfVxyXG5cclxuICBtb3ZlU3ByaXRlKHBvc2l0aW9uOiBWZWMyLCBsYXllcj86IHN0cmluZykge1xyXG4gICAgLy8gQ2hhbmdlIHRoZSBsYXllciBpZiBuZWVkZWRcclxuICAgIGlmIChsYXllcikge1xyXG4gICAgICBsZXQgY3VycmVudExheWVyID0gdGhpcy5zcHJpdGUuZ2V0TGF5ZXIoKTtcclxuICAgICAgY3VycmVudExheWVyLnJlbW92ZU5vZGUodGhpcy5zcHJpdGUpO1xyXG4gICAgICBsZXQgbmV3TGF5ZXIgPSB0aGlzLnNwcml0ZS5nZXRTY2VuZSgpLmdldExheWVyKGxheWVyKTtcclxuICAgICAgbmV3TGF5ZXIuYWRkTm9kZSh0aGlzLnNwcml0ZSk7XHJcbiAgICAgIHRoaXMuc3ByaXRlLnNldExheWVyKG5ld0xheWVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNb3ZlIHRoZSBzcHJpdGVcclxuICAgIHRoaXMuc3ByaXRlLnBvc2l0aW9uLmNvcHkocG9zaXRpb24pO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xyXG5pbXBvcnQgQmF0dGxlckFJIGZyb20gXCIuLi8uLi9BSS9CYXR0bGVyQUlcIjtcclxuaW1wb3J0IEl0ZW0gZnJvbSBcIi4vSXRlbVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWF4SGVhbHRoIGV4dGVuZHMgSXRlbSB7fVxyXG4iLCJpbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCBCYXR0bGVyQUkgZnJvbSBcIi4uLy4uL0FJL0JhdHRsZXJBSVwiO1xyXG5pbXBvcnQgSXRlbSBmcm9tIFwiLi9JdGVtXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGVlZCBleHRlbmRzIEl0ZW0ge1xyXG4gIHVzZSh1c2VyOiBHYW1lTm9kZSwgLi4uYXJnczogYW55KTogdm9pZCB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBFbWl0dGVyIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9FdmVudHMvRW1pdHRlclwiO1xyXG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XHJcbmltcG9ydCBUaW1lciBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvVGltaW5nL1RpbWVyXCI7XHJcbmltcG9ydCB7IGh3NF9FdmVudHMgfSBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvY29uc3RhbnRzXCI7XHJcbmltcG9ydCBCYXR0bGVNYW5hZ2VyIGZyb20gXCIuLi9CYXR0bGVNYW5hZ2VyXCI7XHJcbmltcG9ydCBJdGVtIGZyb20gXCIuL0l0ZW1cIjtcclxuaW1wb3J0IFdlYXBvblR5cGUgZnJvbSBcIi4vV2VhcG9uVHlwZXMvV2VhcG9uVHlwZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2VhcG9uIGV4dGVuZHMgSXRlbSB7XHJcbiAgLyoqIFRoZSB0eXBlIG9mIHRoaXMgd2VhcG9uICovXHJcbiAgdHlwZTogV2VhcG9uVHlwZTtcclxuXHJcbiAgLyoqIEEgbGlzdCBvZiBhc3NldHMgdGhpcyB3ZWFwb24gbmVlZHMgdG8gYmUgYW5pbWF0ZWQgKi9cclxuICBhc3NldHM6IEFycmF5PGFueT47XHJcblxyXG4gIC8qKiBBbiBldmVudCBlbWl0dGVyIHRvIGhvb2sgaW50byB0aGUgRXZlbnRRdWV1ZSAqL1xyXG4gIGVtaXR0ZXI6IEVtaXR0ZXI7XHJcblxyXG4gIC8qKiBUaGUgYmF0dGxlIG1hbmFnZXIgKi9cclxuICBiYXR0bGVNYW5hZ2VyOiBCYXR0bGVNYW5hZ2VyO1xyXG5cclxuICAvKiogVGhlIGNvb2xkb3duIHRpbWVyIGZvciB0aGlzIHdlYXBvbidzIHVzZSAqL1xyXG4gIGNvb2xkb3duVGltZXI6IFRpbWVyO1xyXG5cclxuXHJcblxyXG4gIGNvbnN0cnVjdG9yKHNwcml0ZTogU3ByaXRlLCB0eXBlOiBXZWFwb25UeXBlLCBiYXR0bGVNYW5hZ2VyOiBCYXR0bGVNYW5hZ2VyKSB7XHJcbiAgICBzdXBlcihzcHJpdGUpO1xyXG5cclxuICAgIC8vIFNldCB0aGUgd2VhcG9uIHR5cGVcclxuICAgIHRoaXMudHlwZSA9IHR5cGUuY2xvbmUoKTtcclxuXHJcbiAgICAvLyBLZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzcHJpdGUgb2YgdGhpcyB3ZWFwb25cclxuICAgIHRoaXMuc3ByaXRlID0gc3ByaXRlO1xyXG5cclxuICAgIC8vIENyZWF0ZSBhbiBldmVudCBlbWl0dGVyXHJcbiAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xyXG5cclxuICAgIC8vIFNhdmUgYSByZWZlcmVuY2UgdG8gdGhlIGJhdHRsZXIgbWFuYWdlclxyXG4gICAgdGhpcy5iYXR0bGVNYW5hZ2VyID0gYmF0dGxlTWFuYWdlcjtcclxuXHJcbiAgICAvLyBDcmVhdGUgdGhlIGNvb2xkb3duIHRpbWVyXHJcbiAgICB0aGlzLmNvb2xkb3duVGltZXIgPSBuZXcgVGltZXIodHlwZS5jb29sZG93bik7XHJcblxyXG4gIH1cclxuXHJcbiAgLy8gQG92ZXJyaWRlXHJcbiAgLyoqXHJcbiAgICogVXNlcyB0aGlzIHdlYXBvbiBpbiB0aGUgc3BlY2lmaWVkIGRpcmVjdGlvbi5cclxuICAgKiBUaGlzIG9ubHkgd29ya3MgaWYgdGhlIGNvb2xkb3duIHRpbWVyIGhhcyBlbmRlZFxyXG4gICAqL1xyXG4gIHVzZSh1c2VyOiBHYW1lTm9kZSwgdXNlclR5cGU6IHN0cmluZywgZGlyZWN0aW9uOiBWZWMyKTogYm9vbGVhbiB7XHJcbiAgICAvLyBJZiB0aGUgY29vbGRvd24gdGltZXIgaXMgc3RpbGwgcnVubmluZywgd2UgY2FuJ3QgdXNlIHRoZSB3ZWFwb25cclxuICAgIGlmICghdGhpcy5jb29sZG93blRpbWVyLmlzU3RvcHBlZCgpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIFJlbHkgb24gdGhlIHdlYXBvbiB0eXBlIHRvIGNyZWF0ZSBhbnkgbmVjZXNzYXJ5IGFzc2V0c1xyXG4gICAgdGhpcy5hc3NldHMgPSB0aGlzLnR5cGUuY3JlYXRlUmVxdWlyZWRBc3NldHModGhpcy5zcHJpdGUuZ2V0U2NlbmUoKSk7XHJcblxyXG4gICAgLy8gRG8gYSB0eXBlIHNwZWNpZmljIHdlYXBvbiBhbmltYXRpb25cclxuICAgIHRoaXMudHlwZS5kb0FuaW1hdGlvbih1c2VyLCBkaXJlY3Rpb24sIC4uLnRoaXMuYXNzZXRzKTtcclxuXHJcbiAgICAvLyBBcHBseSBkYW1hZ2VcclxuICAgIHRoaXMuYmF0dGxlTWFuYWdlci5oYW5kbGVJbnRlcmFjdGlvbih1c2VyVHlwZSwgdGhpcyk7XHJcblxyXG4gICAgLy8gUmVzZXQgdGhlIGNvb2xkb3duIHRpbWVyXHJcbiAgICB0aGlzLmNvb2xkb3duVGltZXIuc3RhcnQoKTtcclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgY2hlY2sgZm9yIHdoZXRoZXIgb3Igbm90IHRoaXMgd2VhcG9uIGhpdCBhIG5vZGVcclxuICAgKi9cclxuICBoaXRzKG5vZGU6IEdhbWVOb2RlKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy50eXBlLmhpdHMobm9kZSwgLi4udGhpcy5hc3NldHMpO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgQUFCQiBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBHYW1lTm9kZSwgeyBUd2VlbmFibGVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL05vZGVzL0dhbWVOb2RlXCI7XG5pbXBvcnQgeyBHcmFwaGljVHlwZSB9IGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9HcmFwaGljVHlwZXNcIjtcbmltcG9ydCBMaW5lIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9MaW5lXCI7XG5pbXBvcnQgT3J0aG9nb25hbFRpbGVtYXAgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwXCI7XG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL1NjZW5lL1NjZW5lXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL1V0aWxzL0NvbG9yXCI7XG5pbXBvcnQgeyBFYXNlRnVuY3Rpb25UeXBlIH0gZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL1V0aWxzL0Vhc2VGdW5jdGlvbnNcIjtcbmltcG9ydCB7IGh3NF9FdmVudHMgfSBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvY29uc3RhbnRzXCI7XG5pbXBvcnQgV2VhcG9uVHlwZSBmcm9tIFwiLi9XZWFwb25UeXBlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExhc2VyR3VuIGV4dGVuZHMgV2VhcG9uVHlwZSB7XG5cbiAgICBjb2xvcjogQ29sb3I7XG4gICAgcHJpdmF0ZSBoZXhDb2xvcjogc3RyaW5nO1xuXG4gICAgaW5pdGlhbGl6ZShvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGFtYWdlID0gb3B0aW9ucy5kYW1hZ2U7XG4gICAgICAgIHRoaXMuY29vbGRvd24gPSBvcHRpb25zLmNvb2xkb3duO1xuICAgICAgICB0aGlzLmhleENvbG9yID0gb3B0aW9ucy5jb2xvcjtcbiAgICAgICAgdGhpcy5jb2xvciA9IENvbG9yLmZyb21TdHJpbmdIZXgob3B0aW9ucy5jb2xvcik7XG4gICAgICAgIHRoaXMuZGlzcGxheU5hbWUgPSBvcHRpb25zLmRpc3BsYXlOYW1lO1xuICAgICAgICB0aGlzLnNwcml0ZUtleSA9IG9wdGlvbnMuc3ByaXRlS2V5O1xuICAgICAgICB0aGlzLnVzZVZvbHVtZSA9IG9wdGlvbnMudXNlVm9sdW1lO1xuICAgIH1cblxuICAgIGRvQW5pbWF0aW9uKHNob290ZXI6IEdhbWVOb2RlLCBkaXJlY3Rpb246IFZlYzIsIGxpbmU6IExpbmUpOiB2b2lkIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gc2hvb3Rlci5wb3NpdGlvbi5jbG9uZSgpO1xuICAgICAgICBsZXQgZW5kID0gc2hvb3Rlci5wb3NpdGlvbi5jbG9uZSgpLmFkZChkaXJlY3Rpb24uc2NhbGVkKDkwMCkpO1xuICAgICAgICBsZXQgZGVsdGEgPSBlbmQuY2xvbmUoKS5zdWIoc3RhcnQpO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgdGlsZW1hcCByZWdpb24gdW50aWwgd2UgZmluZCBhIGNvbGxpc2lvblxuICAgICAgICBsZXQgbWluWCA9IE1hdGgubWluKHN0YXJ0LngsIGVuZC54KTtcbiAgICAgICAgbGV0IG1heFggPSBNYXRoLm1heChzdGFydC54LCBlbmQueCk7XG4gICAgICAgIGxldCBtaW5ZID0gTWF0aC5taW4oc3RhcnQueSwgZW5kLnkpO1xuICAgICAgICBsZXQgbWF4WSA9IE1hdGgubWF4KHN0YXJ0LnksIGVuZC55KTtcblxuICAgICAgICAvLyBHZXQgdGhlIHdhbGwgdGlsZW1hcFxuICAgICAgICBsZXQgd2FsbHMgPSA8T3J0aG9nb25hbFRpbGVtYXA+c2hvb3Rlci5nZXRTY2VuZSgpLmdldExheWVyKFwiV2FsbFwiKS5nZXRJdGVtcygpWzBdO1xuXG4gICAgICAgIGxldCBtaW5JbmRleCA9IHdhbGxzLmdldENvbFJvd0F0KG5ldyBWZWMyKG1pblgsIG1pblkpKTtcblx0XHRsZXQgbWF4SW5kZXggPSB3YWxscy5nZXRDb2xSb3dBdChuZXcgVmVjMihtYXhYLCBtYXhZKSk7XG5cbiAgICAgICAgbGV0IHRpbGVTaXplID0gd2FsbHMuZ2V0VGlsZVNpemUoKTtcblxuICAgICAgICBmb3IobGV0IGNvbCA9IG1pbkluZGV4Lng7IGNvbCA8PSBtYXhJbmRleC54OyBjb2wrKyl7XG4gICAgICAgICAgICBmb3IobGV0IHJvdyA9IG1pbkluZGV4Lnk7IHJvdyA8PSBtYXhJbmRleC55OyByb3crKyl7XG4gICAgICAgICAgICAgICAgaWYod2FsbHMuaXNUaWxlQ29sbGlkYWJsZShjb2wsIHJvdykpe1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHBvc2l0aW9uIG9mIHRoaXMgdGlsZVxuICAgICAgICAgICAgICAgICAgICBsZXQgdGlsZVBvcyA9IG5ldyBWZWMyKGNvbCAqIHRpbGVTaXplLnggKyB0aWxlU2l6ZS54LzIsIHJvdyAqIHRpbGVTaXplLnkgKyB0aWxlU2l6ZS55LzIpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIGNvbGxpZGVyIGZvciB0aGlzIHRpbGVcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbGxpZGVyID0gbmV3IEFBQkIodGlsZVBvcywgdGlsZVNpemUuc2NhbGVkKDEvMikpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBoaXQgPSBjb2xsaWRlci5pbnRlcnNlY3RTZWdtZW50KHN0YXJ0LCBkZWx0YSwgVmVjMi5aRVJPKTtcblxuICAgICAgICAgICAgICAgICAgICBpZihoaXQgIT09IG51bGwgJiYgc3RhcnQuZGlzdGFuY2VTcVRvKGhpdC5wb3MpIDwgc3RhcnQuZGlzdGFuY2VTcVRvKGVuZCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJGb3VuZCBoaXRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBoaXQucG9zO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGluZS5zdGFydCA9IHN0YXJ0O1xuICAgICAgICBsaW5lLmVuZCA9IGVuZDtcblxuICAgICAgICBsaW5lLnR3ZWVucy5wbGF5KFwiZmFkZVwiKTtcbiAgICB9XG5cbiAgICBjcmVhdGVSZXF1aXJlZEFzc2V0cyhzY2VuZTogU2NlbmUpOiBbTGluZV0ge1xuICAgICAgICBsZXQgbGluZSA9IDxMaW5lPnNjZW5lLmFkZC5ncmFwaGljKEdyYXBoaWNUeXBlLkxJTkUsIFwicHJpbWFyeVwiLCB7c3RhcnQ6IG5ldyBWZWMyKC0xLCAxKSwgZW5kOiBuZXcgVmVjMigtMSwgLTEpfSk7XG4gICAgICAgIGxpbmUuY29sb3IgPSB0aGlzLmNvbG9yO1xuXG4gICAgICAgIGxpbmUudHdlZW5zLmFkZChcImZhZGVcIiwge1xuICAgICAgICAgICAgc3RhcnREZWxheTogMCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAzMDAsXG4gICAgICAgICAgICBlZmZlY3RzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogVHdlZW5hYmxlUHJvcGVydGllcy5hbHBoYSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IDEsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogMCxcbiAgICAgICAgICAgICAgICAgICAgZWFzZTogRWFzZUZ1bmN0aW9uVHlwZS5PVVRfU0lORVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBvbkVuZDogaHc0X0V2ZW50cy5VTkxPQURfQVNTRVRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIFtsaW5lXTtcbiAgICB9XG5cbiAgICBoaXRzKG5vZGU6IEdhbWVOb2RlLCBsaW5lOiBMaW5lKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBub2RlLmNvbGxpc2lvblNoYXBlLmdldEJvdW5kaW5nUmVjdCgpLmludGVyc2VjdFNlZ21lbnQobGluZS5zdGFydCwgbGluZS5lbmQuY2xvbmUoKS5zdWIobGluZS5zdGFydCkpICE9PSBudWxsO1xuICAgIH1cblxuICAgIGNsb25lKCk6IFdlYXBvblR5cGUge1xuICAgICAgICBsZXQgbmV3VHlwZSA9IG5ldyBMYXNlckd1bigpO1xuICAgICAgICBuZXdUeXBlLmluaXRpYWxpemUoe2RhbWFnZTogdGhpcy5kYW1hZ2UsIGNvbG9yOiB0aGlzLmhleENvbG9yLCBjb29sZG93bjogdGhpcy5jb29sZG93biwgZGlzcGxheU5hbWU6IHRoaXMuZGlzcGxheU5hbWUsIHNwcml0ZUtleTogdGhpcy5zcHJpdGVLZXksIHVzZVZvbHVtZTogdGhpcy51c2VWb2x1bWV9KTtcbiAgICAgICAgcmV0dXJuIG5ld1R5cGU7XG4gICAgfVxufSIsImltcG9ydCBBQUJCIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBHYW1lTm9kZSwgeyBUd2VlbmFibGVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCB7IEdyYXBoaWNUeXBlIH0gZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL0dyYXBoaWNUeXBlc1wiO1xyXG5pbXBvcnQgTGluZSBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvTm9kZXMvR3JhcGhpY3MvTGluZVwiO1xyXG5pbXBvcnQgT3J0aG9nb25hbFRpbGVtYXAgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwXCI7XHJcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvU2NlbmUvU2NlbmVcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9VdGlscy9Db2xvclwiO1xyXG5pbXBvcnQgeyBFYXNlRnVuY3Rpb25UeXBlIH0gZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL1V0aWxzL0Vhc2VGdW5jdGlvbnNcIjtcclxuaW1wb3J0IHsgaHc0X0V2ZW50cyB9IGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9jb25zdGFudHNcIjtcclxuaW1wb3J0IFdlYXBvblR5cGUgZnJvbSBcIi4vV2VhcG9uVHlwZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VtaUF1dG9HdW4gZXh0ZW5kcyBXZWFwb25UeXBlIHtcclxuXHJcbiAgICBjb2xvcjogQ29sb3I7XHJcbiAgICBwcml2YXRlIGhleENvbG9yOiBzdHJpbmc7XHJcblxyXG4gICAgaW5pdGlhbGl6ZShvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5kYW1hZ2UgPSBvcHRpb25zLmRhbWFnZTtcclxuICAgICAgICB0aGlzLmNvb2xkb3duID0gb3B0aW9ucy5jb29sZG93bjtcclxuICAgICAgICB0aGlzLmhleENvbG9yID0gb3B0aW9ucy5jb2xvcjtcclxuICAgICAgICB0aGlzLmNvbG9yID0gQ29sb3IuZnJvbVN0cmluZ0hleChvcHRpb25zLmNvbG9yKTtcclxuICAgICAgICB0aGlzLmRpc3BsYXlOYW1lID0gb3B0aW9ucy5kaXNwbGF5TmFtZTtcclxuICAgICAgICB0aGlzLnNwcml0ZUtleSA9IG9wdGlvbnMuc3ByaXRlS2V5O1xyXG4gICAgICAgIHRoaXMudXNlVm9sdW1lID0gb3B0aW9ucy51c2VWb2x1bWU7XHJcbiAgICB9XHJcblxyXG4gICAgZG9BbmltYXRpb24oc2hvb3RlcjogR2FtZU5vZGUsIGRpcmVjdGlvbjogVmVjMiwgbGluZTogTGluZSk6IHZvaWQge1xyXG4gICAgICAgIGxldCBzdGFydCA9IHNob290ZXIucG9zaXRpb24uY2xvbmUoKTtcclxuICAgICAgICBsZXQgZW5kID0gc2hvb3Rlci5wb3NpdGlvbi5jbG9uZSgpLmFkZChkaXJlY3Rpb24uc2NhbGVkKDkwMCkpO1xyXG4gICAgICAgIGxldCBkZWx0YSA9IGVuZC5jbG9uZSgpLnN1YihzdGFydCk7XHJcblxyXG4gICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgdGlsZW1hcCByZWdpb24gdW50aWwgd2UgZmluZCBhIGNvbGxpc2lvblxyXG4gICAgICAgIGxldCBtaW5YID0gTWF0aC5taW4oc3RhcnQueCwgZW5kLngpO1xyXG4gICAgICAgIGxldCBtYXhYID0gTWF0aC5tYXgoc3RhcnQueCwgZW5kLngpO1xyXG4gICAgICAgIGxldCBtaW5ZID0gTWF0aC5taW4oc3RhcnQueSwgZW5kLnkpO1xyXG4gICAgICAgIGxldCBtYXhZID0gTWF0aC5tYXgoc3RhcnQueSwgZW5kLnkpO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIHdhbGwgdGlsZW1hcFxyXG4gICAgICAgIGxldCB3YWxscyA9IDxPcnRob2dvbmFsVGlsZW1hcD5zaG9vdGVyLmdldFNjZW5lKCkuZ2V0TGF5ZXIoXCJXYWxsXCIpLmdldEl0ZW1zKClbMF07XHJcblxyXG4gICAgICAgIGxldCBtaW5JbmRleCA9IHdhbGxzLmdldENvbFJvd0F0KG5ldyBWZWMyKG1pblgsIG1pblkpKTtcclxuXHRcdGxldCBtYXhJbmRleCA9IHdhbGxzLmdldENvbFJvd0F0KG5ldyBWZWMyKG1heFgsIG1heFkpKTtcclxuXHJcbiAgICAgICAgbGV0IHRpbGVTaXplID0gd2FsbHMuZ2V0VGlsZVNpemUoKTtcclxuXHJcbiAgICAgICAgZm9yKGxldCBjb2wgPSBtaW5JbmRleC54OyBjb2wgPD0gbWF4SW5kZXgueDsgY29sKyspe1xyXG4gICAgICAgICAgICBmb3IobGV0IHJvdyA9IG1pbkluZGV4Lnk7IHJvdyA8PSBtYXhJbmRleC55OyByb3crKyl7XHJcbiAgICAgICAgICAgICAgICBpZih3YWxscy5pc1RpbGVDb2xsaWRhYmxlKGNvbCwgcm93KSl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBwb3NpdGlvbiBvZiB0aGlzIHRpbGVcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdGlsZVBvcyA9IG5ldyBWZWMyKGNvbCAqIHRpbGVTaXplLnggKyB0aWxlU2l6ZS54LzIsIHJvdyAqIHRpbGVTaXplLnkgKyB0aWxlU2l6ZS55LzIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBjb2xsaWRlciBmb3IgdGhpcyB0aWxlXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbGxpZGVyID0gbmV3IEFBQkIodGlsZVBvcywgdGlsZVNpemUuc2NhbGVkKDEvMikpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgaGl0ID0gY29sbGlkZXIuaW50ZXJzZWN0U2VnbWVudChzdGFydCwgZGVsdGEsIFZlYzIuWkVSTyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGhpdCAhPT0gbnVsbCAmJiBzdGFydC5kaXN0YW5jZVNxVG8oaGl0LnBvcykgPCBzdGFydC5kaXN0YW5jZVNxVG8oZW5kKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vb25zb2xlLmxvZyhcIkZvdW5kIGhpdFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gaGl0LnBvcztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxpbmUuc3RhcnQgPSBzdGFydDtcclxuICAgICAgICBsaW5lLmVuZCA9IGVuZDtcclxuXHJcbiAgICAgICAgbGluZS50d2VlbnMucGxheShcImZhZGVcIik7XHJcbiAgICAgICAgbGluZS5jb2xvciA9IENvbG9yLldISVRFO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZVJlcXVpcmVkQXNzZXRzKHNjZW5lOiBTY2VuZSk6IFtMaW5lXSB7XHJcbiAgICAgICAgbGV0IGxpbmUgPSA8TGluZT5zY2VuZS5hZGQuZ3JhcGhpYyhHcmFwaGljVHlwZS5MSU5FLCBcInByaW1hcnlcIiwge3N0YXJ0OiBuZXcgVmVjMigtMSwgMSksIGVuZDogbmV3IFZlYzIoLTEsIC0xKX0pO1xyXG4gICAgICAgIGxpbmUuY29sb3IgPSB0aGlzLmNvbG9yO1xyXG5cclxuICAgICAgICBsaW5lLnR3ZWVucy5hZGQoXCJmYWRlXCIsIHtcclxuICAgICAgICAgICAgc3RhcnREZWxheTogMCxcclxuICAgICAgICAgICAgZHVyYXRpb246IDMwMCxcclxuICAgICAgICAgICAgZWZmZWN0czogW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBUd2VlbmFibGVQcm9wZXJ0aWVzLmFscGhhLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiAxLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZDogMCxcclxuICAgICAgICAgICAgICAgICAgICBlYXNlOiBFYXNlRnVuY3Rpb25UeXBlLk9VVF9TSU5FXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIG9uRW5kOiBodzRfRXZlbnRzLlVOTE9BRF9BU1NFVFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gW2xpbmVdO1xyXG4gICAgfVxyXG5cclxuICAgIGhpdHMobm9kZTogR2FtZU5vZGUsIGxpbmU6IExpbmUpOiBib29sZWFuIHtcclxuICAgICAgICBsZXQgYm9vID0gIG5vZGUuY29sbGlzaW9uU2hhcGUuZ2V0Qm91bmRpbmdSZWN0KCkuaW50ZXJzZWN0U2VnbWVudChsaW5lLnN0YXJ0LmNsb25lKCksIGxpbmUuZW5kLmNsb25lKCkuc3ViKGxpbmUuc3RhcnQuY2xvbmUoKSkpICE9PSBudWxsO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGJvbylcclxuICAgICAgICByZXR1cm4gYm9vO1xyXG4gICAgfVxyXG5cclxuICAgIGNsb25lKCk6IFdlYXBvblR5cGUge1xyXG4gICAgICAgIGxldCBuZXdUeXBlID0gbmV3IFNlbWlBdXRvR3VuKCk7XHJcbiAgICAgICAgbmV3VHlwZS5pbml0aWFsaXplKHtjb2xvcjogdGhpcy5oZXhDb2xvcixkYW1hZ2U6IHRoaXMuZGFtYWdlLCBjb29sZG93bjogdGhpcy5jb29sZG93biwgZGlzcGxheU5hbWU6IHRoaXMuZGlzcGxheU5hbWUsIHNwcml0ZUtleTogdGhpcy5zcHJpdGVLZXksIHVzZVZvbHVtZTogdGhpcy51c2VWb2x1bWV9KTtcclxuICAgICAgICByZXR1cm4gbmV3VHlwZTtcclxuICAgIH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZVwiO1xuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL1NjZW5lL1NjZW5lXCI7XG5pbXBvcnQgV2VhcG9uVHlwZSBmcm9tIFwiLi9XZWFwb25UeXBlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNsaWNlIGV4dGVuZHMgV2VhcG9uVHlwZSB7XG5cbiAgICBpbml0aWFsaXplKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kYW1hZ2UgPSBvcHRpb25zLmRhbWFnZTtcbiAgICAgICAgdGhpcy5jb29sZG93biA9IG9wdGlvbnMuY29vbGRvd247XG4gICAgICAgIHRoaXMuZGlzcGxheU5hbWUgPSBvcHRpb25zLmRpc3BsYXlOYW1lO1xuICAgICAgICB0aGlzLnNwcml0ZUtleSA9IG9wdGlvbnMuc3ByaXRlS2V5O1xuICAgICAgICB0aGlzLnVzZVZvbHVtZSA9IG9wdGlvbnMudXNlVm9sdW1lO1xuICAgIH1cblxuICAgIGRvQW5pbWF0aW9uKGF0dGFja2VyOiBHYW1lTm9kZSwgZGlyZWN0aW9uOiBWZWMyLCBzbGljZVNwcml0ZTogQW5pbWF0ZWRTcHJpdGUpOiB2b2lkIHtcbiAgICAgICAgLy8gUm90YXRlIHRoaXMgd2l0aCB0aGUgZ2FtZSBub2RlXG4gICAgICAgIHNsaWNlU3ByaXRlLnJvdGF0aW9uID0gYXR0YWNrZXIucm90YXRpb247XG5cbiAgICAgICAgLy8gTW92ZSB0aGUgc2xpY2Ugb3V0IGZyb20gdGhlIHBsYXllclxuICAgICAgICBzbGljZVNwcml0ZS5wb3NpdGlvbiA9IGF0dGFja2VyLnBvc2l0aW9uLmNsb25lKCkuYWRkKGRpcmVjdGlvbi5zY2FsZWQoMTYpKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFBsYXkgdGhlIHNsaWNlIGFuaW1hdGlvbiB3L28gbG9vcCwgYnV0IHF1ZXVlIHRoZSBub3JtYWwgYW5pbWF0aW9uXG4gICAgICAgIHNsaWNlU3ByaXRlLmFuaW1hdGlvbi5wbGF5KFwiU0xJQ0VcIik7XG4gICAgICAgIHNsaWNlU3ByaXRlLmFuaW1hdGlvbi5xdWV1ZShcIk5PUk1BTFwiLCB0cnVlKTtcbiAgICB9XG5cbiAgICBjcmVhdGVSZXF1aXJlZEFzc2V0cyhzY2VuZTogU2NlbmUpOiBbQW5pbWF0ZWRTcHJpdGVdIHtcbiAgICAgICAgbGV0IHNsaWNlID0gc2NlbmUuYWRkLmFuaW1hdGVkU3ByaXRlKFwic2xpY2VcIiwgXCJwcmltYXJ5XCIpO1xuICAgICAgICBzbGljZS5hbmltYXRpb24ucGxheShcIk5PUk1BTFwiLCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gW3NsaWNlXTtcbiAgICB9XG5cbiAgICBoaXRzKG5vZGU6IEdhbWVOb2RlLCBzbGljZVNwcml0ZTogQW5pbWF0ZWRTcHJpdGUpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlU3ByaXRlLmJvdW5kYXJ5Lm92ZXJsYXBzKG5vZGUuY29sbGlzaW9uU2hhcGUpO1xuICAgIH1cblxuICAgIGNsb25lKCk6IFdlYXBvblR5cGUge1xuICAgICAgICBsZXQgbmV3VHlwZSA9IG5ldyBTbGljZSgpO1xuICAgICAgICBuZXdUeXBlLmluaXRpYWxpemUoe2RhbWFnZTogdGhpcy5kYW1hZ2UsIGNvb2xkb3duOiB0aGlzLmNvb2xkb3duLCBkaXNwbGF5TmFtZTogdGhpcy5kaXNwbGF5TmFtZSwgc3ByaXRlS2V5OiB0aGlzLnNwcml0ZUtleSwgdXNlVm9sdW1lOiB0aGlzLnVzZVZvbHVtZX0pO1xuICAgICAgICByZXR1cm4gbmV3VHlwZTtcbiAgICB9XG59IiwiaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL1NjZW5lL1NjZW5lXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBXZWFwb25UeXBlIHtcclxuICAvKiogVGhlIGtleSBmb3IgdGhpcyBzcHJpdGUgaW1hZ2UgKi9cclxuICBzcHJpdGVLZXk6IHN0cmluZztcclxuXHJcbiAgLyoqIEhvdyBtdWNoIGRhbWFnZSB0aGlzIHdlYXBvbiBkb2VzICovXHJcbiAgZGFtYWdlOiBudW1iZXI7XHJcblxyXG4gIC8qKiBEaXNwbGF5IG5hbWUgKi9cclxuICBkaXNwbGF5TmFtZTogc3RyaW5nO1xyXG5cclxuICAvKiogVGhlIHVzZSBjb29sZG93biBvZiB0aGUgd2VhcG9uICovXHJcbiAgY29vbGRvd246IG51bWJlcjtcclxuXHJcbiAgLyoqIEhvdyBsb3VkIGl0IGlzIHRvIHVzZSB0aGlzIHdlYXBvbiAqL1xyXG4gIHVzZVZvbHVtZTogbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBJbml0aWFsaXplcyB0aGlzIHdlYXBvbiB0eXBlIHdpdGggZGF0YVxyXG4gICAqL1xyXG4gIGFic3RyYWN0IGluaXRpYWxpemUob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBhbmltYXRpb24gdG8gZG8gd2hlbiB0aGlzIHdlYXBvbiBpcyB1c2VkXHJcbiAgICovXHJcbiAgYWJzdHJhY3QgZG9BbmltYXRpb24oLi4uYXJnczogYW55KTogdm9pZDtcclxuXHJcbiAgYWJzdHJhY3QgY3JlYXRlUmVxdWlyZWRBc3NldHMoc2NlbmU6IFNjZW5lKTogQXJyYXk8YW55PjtcclxuXHJcbiAgYWJzdHJhY3QgaGl0cyhub2RlOiBHYW1lTm9kZSwgLi4uYXJnczogYW55KTogYm9vbGVhbjtcclxuXHJcbiAgYWJzdHJhY3QgY2xvbmUoKTogV2VhcG9uVHlwZTtcclxufVxyXG4iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBJbnB1dCBmcm9tIFwiLi4vLi4vV29sZmllMkQvSW5wdXQvSW5wdXRcIjtcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xuaW1wb3J0IHsgVUlFbGVtZW50VHlwZSB9IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL1VJRWxlbWVudFR5cGVzXCI7XG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1NjZW5lL1NjZW5lXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1V0aWxzL0NvbG9yXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhbWVPdmVyIGV4dGVuZHMgU2NlbmUge1xuXG4gICAgc3RhcnRTY2VuZSgpIHtcbiAgICAgICAgY29uc3QgY2VudGVyID0gdGhpcy52aWV3cG9ydC5nZXRDZW50ZXIoKTtcblxuICAgICAgICB0aGlzLmFkZFVJTGF5ZXIoXCJwcmltYXJ5XCIpO1xuXG4gICAgICAgIGNvbnN0IGdhbWVPdmVyID0gPExhYmVsPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkxBQkVMLCBcInByaW1hcnlcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgY2VudGVyLnkpLCB0ZXh0OiBcIkdhbWUgT3ZlclwifSk7XG4gICAgICAgIGdhbWVPdmVyLnRleHRDb2xvciA9IENvbG9yLldISVRFO1xuICAgIH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IHsgVUlFbGVtZW50VHlwZSB9IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL1VJRWxlbWVudFR5cGVzXCI7XHJcbmltcG9ydCBMYXllciBmcm9tIFwiLi4vLi4vV29sZmllMkQvU2NlbmUvTGF5ZXJcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9TY2VuZS9TY2VuZVwiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1V0aWxzL0NvbG9yXCI7XHJcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xyXG5pbXBvcnQgbWFpblNjZW5lIGZyb20gXCIuL01haW5TY2VuZVwiO1xyXG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFpbk1lbnUgZXh0ZW5kcyBTY2VuZSB7XHJcbiAgLy8gTGF5ZXJzLCBmb3IgbXVsdGlwbGUgbWFpbiBtZW51IHNjcmVlbnNcXFxyXG4gIHByaXZhdGUgc3BsYXNoU2NyZWVuOiBMYXllcjtcclxuICBwcml2YXRlIG1haW5NZW51OiBMYXllcjtcclxuICBwcml2YXRlIGhlbHA6IExheWVyO1xyXG4gIHByaXZhdGUgY29udHJvbDogTGF5ZXI7XHJcbiAgcHJpdmF0ZSBzZWxlY3RMZXZlbFNjcmVlbjogTGF5ZXI7XHJcbiAgcHJpdmF0ZSBiZzogU3ByaXRlO1xyXG5cclxuICBsb2FkU2NlbmUoKSB7XHJcbiAgICB0aGlzLmxvYWQuaW1hZ2UoXCJzcGxhc2hcIiwgXCJtYXloZW1Bc3NldHMvYmFja2dyb3VuZC9zcGxhc2guanBnIFwiKTtcclxuICB9XHJcbiAgc3RhcnRTY2VuZSgpIHtcclxuICAgIGNvbnN0IGNlbnRlciA9IHRoaXMudmlld3BvcnQuZ2V0Q2VudGVyKCk7XHJcblxyXG4gICAgLy8vLyMjIyMjIyMjIyMjIyMjIyMjIyBUaGUgU3BsYXNoIFNjcmVlblxyXG5cclxuICAgIHRoaXMuc3BsYXNoU2NyZWVuID0gdGhpcy5hZGRVSUxheWVyKFwic3BsYXNoU2NyZWVuXCIpO1xyXG4gICAgdGhpcy5hZGRQYXJhbGxheExheWVyKFwiYmdcIiwgbmV3IFZlYzIoMC41LCAxKSwgLTEpO1xyXG4gICAgdGhpcy5iZyA9IHRoaXMuYWRkLnNwcml0ZShcInNwbGFzaFwiLCBcImJnXCIpO1xyXG4gICAgdGhpcy5iZy5zaXplID0gbmV3IFZlYzIoMTIwMCwgODAwKTtcclxuICAgIHRoaXMuYmcucG9zaXRpb24uc2V0KFxyXG4gICAgICB0aGlzLnZpZXdwb3J0LmdldEhhbGZTaXplKCkueCxcclxuICAgICAgdGhpcy52aWV3cG9ydC5nZXRIYWxmU2l6ZSgpLnlcclxuICAgICk7XHJcblxyXG4gICAgLy9CdXR0b24gZm9yIGNsaWNraW5nIHRvIG1lbnVcclxuICAgIGNvbnN0IG1haW5NZW51ID0gdGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuQlVUVE9OLCBcInNwbGFzaFNjcmVlblwiLCB7XHJcbiAgICAgIHBvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgY2VudGVyLnkgKyAyNTApLFxyXG4gICAgICB0ZXh0OiBcIkNsaWNrIHRvIFBsYXlcIixcclxuICAgIH0pO1xyXG4gICAgbWFpbk1lbnUuc2l6ZS5zZXQoMjAwLCA1MCk7XHJcbiAgICBtYWluTWVudS5ib3JkZXJXaWR0aCA9IDI7XHJcbiAgICBtYWluTWVudS5ib3JkZXJDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgbWFpbk1lbnUuYmFja2dyb3VuZENvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICBtYWluTWVudS5vbkNsaWNrRXZlbnRJZCA9IFwibWVudVwiO1xyXG5cclxuICAgIC8vKiMjIyMjIyMjIyMjIyMjIyMjIFRPRE86IGRhbyBhZGRlZCB0aGlzLCBxdWljayBwbGF5LCByZW1vdmUgbGF0ZXIvLyBzdGFydHMgYXQgZmlyc3QgbGV2ZWwgaW1tZWRpYXRlbHlcclxuICAgIGNvbnN0IHF1aWNrUGxheSA9IHRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkJVVFRPTiwgXCJzcGxhc2hTY3JlZW5cIiwge1xyXG4gICAgICBwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLngsIGNlbnRlci55KSxcclxuICAgICAgdGV4dDogXCJRdWljayBTdGFydCB0byBMViAxXCIsXHJcbiAgICB9KTtcclxuICAgIHF1aWNrUGxheS5zaXplLnNldCgyMDAsIDUwKTtcclxuICAgIHF1aWNrUGxheS5ib3JkZXJXaWR0aCA9IDI7XHJcbiAgICBxdWlja1BsYXkuYm9yZGVyQ29sb3IgPSBDb2xvci5XSElURTtcclxuICAgIHF1aWNrUGxheS5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgIHF1aWNrUGxheS5vbkNsaWNrRXZlbnRJZCA9IFwiY2hvb3NlbGV2ZWxcIjtcclxuXHJcbiAgICAvLyMjIyMjIyMjIyMjIyMjIyNUaGUgTWVudSBTY3JlZW5cclxuICAgIHRoaXMubWFpbk1lbnUgPSB0aGlzLmFkZFVJTGF5ZXIoXCJtYWluTWVudVwiKTtcclxuICAgIHRoaXMubWFpbk1lbnUuc2V0SGlkZGVuKHRydWUpO1xyXG5cclxuICAgIC8vSGVhZGVyIGZvciBNYWluIE1lbnVcclxuICAgIGNvbnN0IG1haW5tZW51aGVhZCA9IFwiTWFpbiBNZW51XCI7XHJcblxyXG4gICAgY29uc3QgbWFpbk1lbnVoZWFkZXIgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFxyXG4gICAgICBVSUVsZW1lbnRUeXBlLkxBQkVMLFxyXG4gICAgICBcIm1haW5NZW51XCIsXHJcbiAgICAgIHtcclxuICAgICAgICBwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLngsIGNlbnRlci55IC0gMjUwKSxcclxuICAgICAgICB0ZXh0OiBtYWlubWVudWhlYWQsXHJcbiAgICAgIH1cclxuICAgICk7XHJcbiAgICBtYWluTWVudWhlYWRlci50ZXh0Q29sb3IgPSBDb2xvci5XSElURTtcclxuICAgIG1haW5NZW51aGVhZGVyLmJhY2tncm91bmRDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgbWFpbk1lbnVoZWFkZXIuZm9udFNpemUgPSA1MDtcclxuXHJcbiAgICAvLyBBZGQgcGxheSBidXR0b24sIGFuZCBnaXZlIGl0IGFuIGV2ZW50IHRvIGVtaXQgb24gcHJlc3NcclxuXHJcbiAgICBjb25zdCBzZWxlY3RMZXZlbCA9IHRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkJVVFRPTiwgXCJtYWluTWVudVwiLCB7XHJcbiAgICAgIHBvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgY2VudGVyLnkgLSAxMDApLFxyXG4gICAgICB0ZXh0OiBcIlNlbGVjdCBMZXZlbFwiLFxyXG4gICAgfSk7XHJcbiAgICBzZWxlY3RMZXZlbC5zaXplLnNldCgyMDAsIDUwKTtcclxuICAgIHNlbGVjdExldmVsLmJvcmRlcldpZHRoID0gMjtcclxuICAgIHNlbGVjdExldmVsLmJvcmRlckNvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICBzZWxlY3RMZXZlbC5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgIHNlbGVjdExldmVsLm9uQ2xpY2tFdmVudElkID0gXCJzZWxlY3RsZXZlbFwiO1xyXG5cclxuICAgIC8vIEFkZCBoZWxwIGJ1dHRvblxyXG4gICAgY29uc3QgaGVscCA9IHRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkJVVFRPTiwgXCJtYWluTWVudVwiLCB7XHJcbiAgICAgIHBvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgY2VudGVyLnkgKyAyMDApLFxyXG4gICAgICB0ZXh0OiBcIkhlbHBcIixcclxuICAgIH0pO1xyXG4gICAgaGVscC5zaXplLnNldCgyMDAsIDUwKTtcclxuICAgIGhlbHAuYm9yZGVyV2lkdGggPSAyO1xyXG4gICAgaGVscC5ib3JkZXJDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgaGVscC5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgIGhlbHAub25DbGlja0V2ZW50SWQgPSBcImhlbHBcIjtcclxuXHJcbiAgICAvLyAvL1RISVMgSVMgT1VSIGNvbnRyb2xzIGJ1dHRvbiBpbiB0aGUgbWFpbnMgc2NyZWVuIG9mIHRoZSBnYW1lXHJcbiAgICBjb25zdCBjb250cm9sID0gdGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuQlVUVE9OLCBcIm1haW5NZW51XCIsIHtcclxuICAgICAgcG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSArIDUwKSxcclxuICAgICAgdGV4dDogXCJDb250cm9sc1wiLFxyXG4gICAgfSk7XHJcbiAgICBjb250cm9sLnNpemUuc2V0KDIwMCwgNTApO1xyXG4gICAgY29udHJvbC5ib3JkZXJXaWR0aCA9IDI7XHJcbiAgICBjb250cm9sLmJvcmRlckNvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICBjb250cm9sLmJhY2tncm91bmRDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgY29udHJvbC5vbkNsaWNrRXZlbnRJZCA9IFwiY29udHJvbFwiO1xyXG5cclxuICAgIC8qICMjIyMjIyMjIyMgSEVMUCBTQ1JFRU4gIyMjIyMjIyMjIyAqL1xyXG4gICAgdGhpcy5oZWxwID0gdGhpcy5hZGRVSUxheWVyKFwiaGVscFwiKTtcclxuICAgIHRoaXMuaGVscC5zZXRIaWRkZW4odHJ1ZSk7XHJcblxyXG4gICAgY29uc3QgaGVscEhlYWRlciA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJoZWxwXCIsIHtcclxuICAgICAgcG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSAtIDI1MCksXHJcbiAgICAgIHRleHQ6IFwiSGVscFwiLFxyXG4gICAgfSk7XHJcbiAgICBoZWxwSGVhZGVyLnRleHRDb2xvciA9IENvbG9yLldISVRFO1xyXG4gICAgaGVscEhlYWRlci5mb250U2l6ZSA9IDUwO1xyXG4gICAgXHJcblxyXG4gICAgY29uc3QgdGV4dDFoZWFkZXIgPSBcIkJhY2tzdG9yeVwiO1xyXG4gICAgY29uc3QgdGV4dDEgPVxyXG4gICAgICBcIllvdeKAmXJlIGEgcmV0aXJlZCB2ZXRlcmFuLiBZb3UgZm91bmQgb3V0IHRoYXQgeW91ciBkZWFyZXN0IGNvbXJhZGUtaW4tYXJtcyBoYXMgY29tbWl0dGVkIGEgbWlzdW5kZXJzdG9vZCBzaW4gYW5kIGVuZHMgdXAgaW4gaGVsbFwiO1xyXG4gICAgY29uc3QgdGV4dDEyID1cclxuICAgICAgXCJLbm93aW5nIHRoaXMsIHlvdSBlbmQgdXAgdHJ5aW5nIHRvIGJyZWFrIHRocm91Z2ggdGhlIGJhcnJpZXJzIG9mIGhlbGwgdG8gZmluZCBKYWNrc29uIGFuZCBkcmFnIGhpbSBvdXRcIjtcclxuICAgIGNvbnN0IHRleHQxMyA9XHJcbiAgICAgIFwiQXMgeW91IGtpbGwgbW9yZSBkZW1vbiBzcGF3bnMgZnJvbSBoZWxsLCB0aGUgYmFycmllciBpbnRvIGhlbGwgd2Vha2VucywgYWxsb3dpbmcgeW91IHRvIHByb2dyZXNzIHRocm91Z2ggaGVsbCBhbmQgZ2V0dGluZyB5b3UgY2xvc2VyIHRvIHlvdXIgY29tcmFkZVwiO1xyXG4gICAgY29uc3QgdGV4dDJoZWFkZXIgPSBcIkRldmVsb3BlcnNcIjtcclxuICAgIGNvbnN0IHRleHQyID0gXCJMaW4gTmlcIjtcclxuICAgIGNvbnN0IHRleHQyMiA9IFwiRGFvcWluIEdhb1wiXHJcbiAgICBjb25zdCB0ZXh0MjMgPSBcIlJvYmVydCBSb2xzZW5pY1wiXHJcbiAgICBjb25zdCB0ZXh0M2hlYWRlciA9IFwiQ2hlYXQgQ29kZXNcIjtcclxuICAgIGNvbnN0IHRleHQzID0gXCJJTlZJTkNJQkxFIFNLSVAgW05VTUJFUl0gVVBHUkFERSBbQlVGRl1cIjtcclxuXHJcbiAgICBjb25zdCBsaW5lMWhlYWRlciA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJoZWxwXCIsIHtcclxuICAgICAgcG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSAtIDE2MCksXHJcbiAgICAgIHRleHQ6IHRleHQxaGVhZGVyLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBsaW5lMSA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJoZWxwXCIsIHtcclxuICAgICAgcG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSAtIDEyMCksXHJcbiAgICAgIHRleHQ6IHRleHQxLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBsaW5lMTIgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIFwiaGVscFwiLCB7XHJcbiAgICAgIHBvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgY2VudGVyLnkgLSAxMDApLFxyXG4gICAgICB0ZXh0OiB0ZXh0MTIsXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGxpbmUxMyA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJoZWxwXCIsIHtcclxuICAgICAgcG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSAtIDgwKSxcclxuICAgICAgdGV4dDogdGV4dDEzLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBsaW5lMmhlYWRlciA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJoZWxwXCIsIHtcclxuICAgICAgcG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSAtIDEwKSxcclxuICAgICAgdGV4dDogdGV4dDJoZWFkZXIsXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGxpbmUyID0gPExhYmVsPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkxBQkVMLCBcImhlbHBcIiwge1xyXG4gICAgICBwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLngsIGNlbnRlci55ICsgMzApLFxyXG4gICAgICB0ZXh0OiB0ZXh0MixcclxuICAgIH0pO1xyXG4gICAgY29uc3QgbGluZTIyID0gPExhYmVsPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkxBQkVMLCBcImhlbHBcIiwge1xyXG4gICAgICBwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLngsIGNlbnRlci55ICsgNjApLFxyXG4gICAgICB0ZXh0OiB0ZXh0MjIsXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGxpbmUyMyA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJoZWxwXCIsIHtcclxuICAgICAgcG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSArIDkwKSxcclxuICAgICAgdGV4dDogdGV4dDIzLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBsaW5lM2hlYWRlciA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJoZWxwXCIsIHtcclxuICAgICAgcG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSArIDE0MCksXHJcbiAgICAgIHRleHQ6IHRleHQzaGVhZGVyLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBsaW5lMyA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJoZWxwXCIsIHtcclxuICAgICAgcG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSArIDE4MCksXHJcbiAgICAgIHRleHQ6IHRleHQzLFxyXG4gICAgfSk7XHJcblxyXG4gICAgbGluZTEudGV4dENvbG9yID0gQ29sb3IuV0hJVEU7XHJcbiAgICBsaW5lMTIudGV4dENvbG9yID0gQ29sb3IuV0hJVEU7XHJcbiAgICBsaW5lMTMudGV4dENvbG9yID0gQ29sb3IuV0hJVEU7XHJcbiAgICBsaW5lMS5mb250U2l6ZSA9IDE2O1xyXG4gICAgbGluZTEyLmZvbnRTaXplID0gMTY7XHJcbiAgICBsaW5lMTMuZm9udFNpemUgPSAxNjtcclxuXHJcbiAgICBsaW5lMi50ZXh0Q29sb3IgPSBDb2xvci5XSElURTtcclxuICAgIGxpbmUyMi50ZXh0Q29sb3IgPSBDb2xvci5XSElURTtcclxuICAgIGxpbmUyMy50ZXh0Q29sb3IgPSBDb2xvci5XSElURTtcclxuICAgIGxpbmUzLnRleHRDb2xvciA9IENvbG9yLldISVRFO1xyXG4gICAgbGluZTMuZm9udFNpemUgPSAyMDtcclxuICAgIGxpbmUyLmZvbnRTaXplID0gMTg7XHJcbiAgICBsaW5lMjIuZm9udFNpemUgPSAxODtcclxuICAgIGxpbmUyMy5mb250U2l6ZSA9IDE4O1xyXG4gICAgbGluZTMuZm9udFNpemUgPSAxODtcclxuXHJcbiAgICBsaW5lMWhlYWRlci50ZXh0Q29sb3IgPSBDb2xvci5XSElURTtcclxuICAgIGxpbmUyaGVhZGVyLnRleHRDb2xvciA9IENvbG9yLldISVRFO1xyXG4gICAgbGluZTNoZWFkZXIudGV4dENvbG9yID0gQ29sb3IuV0hJVEU7XHJcbiAgICAoPExhYmVsPmxpbmUxKS5mb250ID0gXCJDdXJzaXZlXCI7XHJcbiAgICAoPExhYmVsPmxpbmUxMikuZm9udCA9IFwiQ3Vyc2l2ZVwiO1xyXG4gICAgKDxMYWJlbD5saW5lMTMpLmZvbnQgPSBcIkN1cnNpdmVcIjtcclxuICAgICg8TGFiZWw+bGluZTIpLmZvbnQgPSBcIkN1cnNpdmVcIjtcclxuICAgICg8TGFiZWw+bGluZTIyKS5mb250ID0gXCJDdXJzaXZlXCI7XHJcbiAgICAoPExhYmVsPmxpbmUyMykuZm9udCA9IFwiQ3Vyc2l2ZVwiO1xyXG4gICAgKDxMYWJlbD5saW5lMykuZm9udCA9IFwiQ3Vyc2l2ZVwiO1xyXG5cclxuXHJcbiAgICBjb25zdCBoZWxwQmFjayA9IHRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkJVVFRPTiwgXCJoZWxwXCIsIHtcclxuICAgICAgcG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSArIDMwMCksXHJcbiAgICAgIHRleHQ6IFwiQmFja1wiLFxyXG4gICAgfSk7XHJcbiAgICBoZWxwQmFjay5zaXplLnNldCgyMDAsIDUwKTtcclxuICAgIGhlbHBCYWNrLmJvcmRlcldpZHRoID0gMjtcclxuICAgIGhlbHBCYWNrLmJvcmRlckNvbG9yID0gQ29sb3IuV0hJVEU7XHJcbiAgICBoZWxwQmFjay5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgIGhlbHBCYWNrLm9uQ2xpY2tFdmVudElkID0gXCJtZW51XCI7XHJcbiAgICAoPExhYmVsPmhlbHBCYWNrKS5mb250ID0gXCJGYW50YXN5XCI7XHJcblxyXG4gICAgLyogIyMjIyMjIyMjIyBDT05UUk9MIFNDUkVFTiAjIyMjIyMjIyMjICovXHJcbiAgICB0aGlzLmNvbnRyb2wgPSB0aGlzLmFkZFVJTGF5ZXIoXCJjb250cm9sXCIpO1xyXG4gICAgdGhpcy5jb250cm9sLnNldEhpZGRlbih0cnVlKTtcclxuXHJcbiAgICBjb25zdCBjb250cm9sSGVhZGVyID0gPExhYmVsPnRoaXMuYWRkLnVpRWxlbWVudChcclxuICAgICAgVUlFbGVtZW50VHlwZS5MQUJFTCxcclxuICAgICAgXCJjb250cm9sXCIsXHJcbiAgICAgIHtcclxuICAgICAgICBwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLngsIGNlbnRlci55IC0gMjUwKSxcclxuICAgICAgICB0ZXh0OiBcIkNvbnRyb2xzXCIsXHJcbiAgICAgIH1cclxuICAgICk7XHJcbiAgICBjb250cm9sSGVhZGVyLnRleHRDb2xvciA9IENvbG9yLldISVRFO1xyXG4gICAgY29udHJvbEhlYWRlci5mb250U2l6ZSA9IDUwO1xyXG4gICAgKDxMYWJlbD5jb250cm9sSGVhZGVyKS5mb250ID0gXCJGYW50YXN5XCI7XHJcblxyXG4gICAgY29uc3QgY29udHJvbFRleHQxID0gXCJXQVNEIHRvIG1vdmVcIjtcclxuICAgIGNvbnN0IGNvbnRyb2xUZXh0MiA9IFwiTGVmdCBDbGljayB0byBTaG9vdFwiO1xyXG5cclxuICAgIGNvbnN0IGNvbnRyb2xMaW5lMSA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoXHJcbiAgICAgIFVJRWxlbWVudFR5cGUuTEFCRUwsXHJcbiAgICAgIFwiY29udHJvbFwiLFxyXG4gICAgICB7XHJcbiAgICAgICAgcG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSAtIDUwKSxcclxuICAgICAgICB0ZXh0OiBjb250cm9sVGV4dDEsXHJcbiAgICAgIH1cclxuICAgICk7XHJcbiAgICBjb25zdCBjb250cm9sTGluZTIgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFxyXG4gICAgICBVSUVsZW1lbnRUeXBlLkxBQkVMLFxyXG4gICAgICBcImNvbnRyb2xcIixcclxuICAgICAge1xyXG4gICAgICAgIHBvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgY2VudGVyLnkgKyA1MCksXHJcbiAgICAgICAgdGV4dDogY29udHJvbFRleHQyLFxyXG4gICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIGNvbnRyb2xMaW5lMS50ZXh0Q29sb3IgPSBDb2xvci5XSElURTtcclxuICAgIGNvbnRyb2xMaW5lMi50ZXh0Q29sb3IgPSBDb2xvci5XSElURTtcclxuXHJcbiAgICBjb25zdCBjb250cm9sQmFjayA9IHRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkJVVFRPTiwgXCJjb250cm9sXCIsIHtcclxuICAgICAgcG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSArIDI1MCksXHJcbiAgICAgIHRleHQ6IFwiQmFja1wiLFxyXG4gICAgfSk7XHJcbiAgICBjb250cm9sQmFjay5zaXplLnNldCgyMDAsIDUwKTtcclxuICAgIGNvbnRyb2xCYWNrLmJvcmRlcldpZHRoID0gMjtcclxuICAgIGNvbnRyb2xCYWNrLmJvcmRlckNvbG9yID0gQ29sb3IuV0hJVEU7XHJcbiAgICBjb250cm9sQmFjay5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgIGNvbnRyb2xCYWNrLm9uQ2xpY2tFdmVudElkID0gXCJtZW51XCI7XHJcblxyXG4gICAgLy8jIyMjIyMjIyMjI1NlbGVjdCBMZXZlbHMgU2NyZWVuXHJcbiAgICB0aGlzLnNlbGVjdExldmVsU2NyZWVuID0gdGhpcy5hZGRVSUxheWVyKFwic2VsZWN0TGV2ZWxTY3JlZW5cIik7XHJcbiAgICB0aGlzLnNlbGVjdExldmVsU2NyZWVuLnNldEhpZGRlbih0cnVlKTtcclxuXHJcbiAgICAvL2FkZCBidXR0b24gdG8gZ28gYmFja1xyXG4gICAgY29uc3Qgc2VsZWN0TGV2ZWxCYWNrID0gdGhpcy5hZGQudWlFbGVtZW50KFxyXG4gICAgICBVSUVsZW1lbnRUeXBlLkJVVFRPTixcclxuICAgICAgXCJzZWxlY3RMZXZlbFNjcmVlblwiLFxyXG4gICAgICB7XHJcbiAgICAgICAgcG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSArIDI1MCksXHJcbiAgICAgICAgdGV4dDogXCJCYWNrXCIsXHJcbiAgICAgIH1cclxuICAgICk7XHJcbiAgICBzZWxlY3RMZXZlbEJhY2suc2l6ZS5zZXQoMjAwLCA1MCk7XHJcbiAgICBzZWxlY3RMZXZlbEJhY2suYm9yZGVyV2lkdGggPSAyO1xyXG4gICAgc2VsZWN0TGV2ZWxCYWNrLmJvcmRlckNvbG9yID0gQ29sb3IuV0hJVEU7XHJcbiAgICBzZWxlY3RMZXZlbEJhY2suYmFja2dyb3VuZENvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICBzZWxlY3RMZXZlbEJhY2sub25DbGlja0V2ZW50SWQgPSBcIm1lbnVcIjtcclxuIFxyXG5cclxuICAgIC8vL2hlYWRlciBmb3Igc2VsZWN0IGxldmVsXHJcbiAgICBjb25zdCBzZWxlY3RIZWFkZXIgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFxyXG4gICAgICBVSUVsZW1lbnRUeXBlLkxBQkVMLFxyXG4gICAgICBcInNlbGVjdExldmVsU2NyZWVuXCIsXHJcbiAgICAgIHtcclxuICAgICAgICBwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLngsIGNlbnRlci55IC0gMjUwKSxcclxuICAgICAgICB0ZXh0OiBcIlNlbGVjdCBMZXZlbFwiLFxyXG4gICAgICB9XHJcbiAgICApO1xyXG4gICAgc2VsZWN0SGVhZGVyLnRleHRDb2xvciA9IENvbG9yLldISVRFO1xyXG4gICAgc2VsZWN0SGVhZGVyLmZvbnRTaXplID0gNTA7XHJcblxyXG4gICAgLy8vYnV0dG9ucyBmb3IgYWxsIHRoZSBsZXZlbHNcclxuICAgIGNvbnN0IGxldmVsMSA9IHRoaXMuYWRkLnVpRWxlbWVudChcclxuICAgICAgVUlFbGVtZW50VHlwZS5CVVRUT04sXHJcbiAgICAgIFwic2VsZWN0TGV2ZWxTY3JlZW5cIixcclxuICAgICAge1xyXG4gICAgICAgIHBvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgY2VudGVyLnkgLSAxNTApLFxyXG4gICAgICAgIHRleHQ6IFwiTGV2ZWwgMVwiLFxyXG4gICAgICB9XHJcbiAgICApO1xyXG4gICAgbGV2ZWwxLnNpemUuc2V0KDIwMCwgNTApO1xyXG4gICAgbGV2ZWwxLmJvcmRlcldpZHRoID0gMjtcclxuICAgIGxldmVsMS5ib3JkZXJDb2xvciA9IENvbG9yLldISVRFO1xyXG4gICAgbGV2ZWwxLmJhY2tncm91bmRDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgbGV2ZWwxLm9uQ2xpY2tFdmVudElkID0gXCJjaG9vc2VsZXZlbFwiO1xyXG5cclxuICAgIGNvbnN0IGxldmVsMiA9IHRoaXMuYWRkLnVpRWxlbWVudChcclxuICAgICAgVUlFbGVtZW50VHlwZS5CVVRUT04sXHJcbiAgICAgIFwic2VsZWN0TGV2ZWxTY3JlZW5cIixcclxuICAgICAge1xyXG4gICAgICAgIHBvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCArIDEwMCwgY2VudGVyLnkgLSA5MCksXHJcbiAgICAgICAgdGV4dDogXCJMZXZlbCAyXCIsXHJcbiAgICAgIH1cclxuICAgICk7XHJcbiAgICBsZXZlbDIuc2l6ZS5zZXQoMjAwLCA1MCk7XHJcbiAgICBsZXZlbDIuYm9yZGVyV2lkdGggPSAyO1xyXG4gICAgbGV2ZWwyLmJvcmRlckNvbG9yID0gQ29sb3IuV0hJVEU7XHJcbiAgICBsZXZlbDIuYmFja2dyb3VuZENvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICBsZXZlbDIub25DbGlja0V2ZW50SWQgPSBcImNob29zZWxldmVsXCI7XHJcblxyXG4gICAgY29uc3QgbGV2ZWwzID0gdGhpcy5hZGQudWlFbGVtZW50KFxyXG4gICAgICBVSUVsZW1lbnRUeXBlLkJVVFRPTixcclxuICAgICAgXCJzZWxlY3RMZXZlbFNjcmVlblwiLFxyXG4gICAgICB7XHJcbiAgICAgICAgcG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54ICsgMjAwLCBjZW50ZXIueSAtIDMwKSxcclxuICAgICAgICB0ZXh0OiBcIkxldmVsIDNcIixcclxuICAgICAgfVxyXG4gICAgKTtcclxuICAgIGxldmVsMy5zaXplLnNldCgyMDAsIDUwKTtcclxuICAgIGxldmVsMy5ib3JkZXJXaWR0aCA9IDI7XHJcbiAgICBsZXZlbDMuYm9yZGVyQ29sb3IgPSBDb2xvci5XSElURTtcclxuICAgIGxldmVsMy5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgIGxldmVsMy5vbkNsaWNrRXZlbnRJZCA9IFwiY2hvb3NlbGV2ZWxcIjtcclxuXHJcbiAgICBjb25zdCBsZXZlbDQgPSB0aGlzLmFkZC51aUVsZW1lbnQoXHJcbiAgICAgIFVJRWxlbWVudFR5cGUuQlVUVE9OLFxyXG4gICAgICBcInNlbGVjdExldmVsU2NyZWVuXCIsXHJcbiAgICAgIHtcclxuICAgICAgICBwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLnggKyAxNTAsIGNlbnRlci55ICsgMzApLFxyXG4gICAgICAgIHRleHQ6IFwiTGV2ZWwgNFwiLFxyXG4gICAgICB9XHJcbiAgICApO1xyXG4gICAgbGV2ZWw0LnNpemUuc2V0KDIwMCwgNTApO1xyXG4gICAgbGV2ZWw0LmJvcmRlcldpZHRoID0gMjtcclxuICAgIGxldmVsNC5ib3JkZXJDb2xvciA9IENvbG9yLldISVRFO1xyXG4gICAgbGV2ZWw0LmJhY2tncm91bmRDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgbGV2ZWw0Lm9uQ2xpY2tFdmVudElkID0gXCJjaG9vc2VsZXZlbFwiO1xyXG5cclxuICAgIGNvbnN0IGxldmVsNSA9IHRoaXMuYWRkLnVpRWxlbWVudChcclxuICAgICAgVUlFbGVtZW50VHlwZS5CVVRUT04sXHJcbiAgICAgIFwic2VsZWN0TGV2ZWxTY3JlZW5cIixcclxuICAgICAge1xyXG4gICAgICAgIHBvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCArIDEwMCwgY2VudGVyLnkgKyA5MCksXHJcbiAgICAgICAgdGV4dDogXCJMZXZlbCA1XCIsXHJcbiAgICAgIH1cclxuICAgICk7XHJcbiAgICBsZXZlbDUuc2l6ZS5zZXQoMjAwLCA1MCk7XHJcbiAgICBsZXZlbDUuYm9yZGVyV2lkdGggPSAyO1xyXG4gICAgbGV2ZWw1LmJvcmRlckNvbG9yID0gQ29sb3IuV0hJVEU7XHJcbiAgICBsZXZlbDUuYmFja2dyb3VuZENvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICBsZXZlbDUub25DbGlja0V2ZW50SWQgPSBcImNob29zZWxldmVsXCI7XHJcblxyXG4gICAgY29uc3QgbGV2ZWw2ID0gdGhpcy5hZGQudWlFbGVtZW50KFxyXG4gICAgICBVSUVsZW1lbnRUeXBlLkJVVFRPTixcclxuICAgICAgXCJzZWxlY3RMZXZlbFNjcmVlblwiLFxyXG4gICAgICB7XHJcbiAgICAgICAgcG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54IC0gMTAwLCBjZW50ZXIueSArIDkwKSxcclxuICAgICAgICB0ZXh0OiBcIkxldmVsIDZcIixcclxuICAgICAgfVxyXG4gICAgKTtcclxuICAgIGxldmVsNi5zaXplLnNldCgyMDAsIDUwKTtcclxuICAgIGxldmVsNi5ib3JkZXJXaWR0aCA9IDI7XHJcbiAgICBsZXZlbDYuYm9yZGVyQ29sb3IgPSBDb2xvci5XSElURTtcclxuICAgIGxldmVsNi5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgIGxldmVsNi5vbkNsaWNrRXZlbnRJZCA9IFwiY2hvb3NlbGV2ZWxcIjtcclxuXHJcbiAgICBjb25zdCBsZXZlbDcgPSB0aGlzLmFkZC51aUVsZW1lbnQoXHJcbiAgICAgIFVJRWxlbWVudFR5cGUuQlVUVE9OLFxyXG4gICAgICBcInNlbGVjdExldmVsU2NyZWVuXCIsXHJcbiAgICAgIHtcclxuICAgICAgICBwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLnggLSAxNTAsIGNlbnRlci55ICsgMzApLFxyXG4gICAgICAgIHRleHQ6IFwiTGV2ZWwgN1wiLFxyXG4gICAgICB9XHJcbiAgICApO1xyXG4gICAgbGV2ZWw3LnNpemUuc2V0KDIwMCwgNTApO1xyXG4gICAgbGV2ZWw3LmJvcmRlcldpZHRoID0gMjtcclxuICAgIGxldmVsNy5ib3JkZXJDb2xvciA9IENvbG9yLldISVRFO1xyXG4gICAgbGV2ZWw3LmJhY2tncm91bmRDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgbGV2ZWw3Lm9uQ2xpY2tFdmVudElkID0gXCJjaG9vc2VsZXZlbFwiO1xyXG5cclxuICAgIGNvbnN0IGxldmVsOCA9IHRoaXMuYWRkLnVpRWxlbWVudChcclxuICAgICAgVUlFbGVtZW50VHlwZS5CVVRUT04sXHJcbiAgICAgIFwic2VsZWN0TGV2ZWxTY3JlZW5cIixcclxuICAgICAge1xyXG4gICAgICAgIHBvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCAtIDIwMCwgY2VudGVyLnkgLSAzMCksXHJcbiAgICAgICAgdGV4dDogXCJMZXZlbCA4XCIsXHJcbiAgICAgIH1cclxuICAgICk7XHJcbiAgICBsZXZlbDguc2l6ZS5zZXQoMjAwLCA1MCk7XHJcbiAgICBsZXZlbDguYm9yZGVyV2lkdGggPSAyO1xyXG4gICAgbGV2ZWw4LmJvcmRlckNvbG9yID0gQ29sb3IuV0hJVEU7XHJcbiAgICBsZXZlbDguYmFja2dyb3VuZENvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICBsZXZlbDgub25DbGlja0V2ZW50SWQgPSBcImNob29zZWxldmVsXCI7XHJcblxyXG4gICAgY29uc3QgbGV2ZWw5ID0gdGhpcy5hZGQudWlFbGVtZW50KFxyXG4gICAgICBVSUVsZW1lbnRUeXBlLkJVVFRPTixcclxuICAgICAgXCJzZWxlY3RMZXZlbFNjcmVlblwiLFxyXG4gICAgICB7XHJcbiAgICAgICAgcG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54IC0gMTAwLCBjZW50ZXIueSAtIDkwKSxcclxuICAgICAgICB0ZXh0OiBcIkxldmVsIDlcIixcclxuICAgICAgfVxyXG4gICAgKTtcclxuICAgIGxldmVsOS5zaXplLnNldCgyMDAsIDUwKTtcclxuICAgIGxldmVsOS5ib3JkZXJXaWR0aCA9IDI7XHJcbiAgICBsZXZlbDkuYm9yZGVyQ29sb3IgPSBDb2xvci5XSElURTtcclxuICAgIGxldmVsOS5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgIGxldmVsOS5vbkNsaWNrRXZlbnRJZCA9IFwiY2hvb3NlbGV2ZWxcIjtcclxuXHJcbiAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIGJ1dHRvbiBldmVudHNcclxuICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKFwicGxheVwiKTtcclxuICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKFwiaGVscFwiKTtcclxuICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKFwibWVudVwiKTtcclxuICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKFwiY29udHJvbFwiKTtcclxuICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKFwiY2xpY2t0b3BsYXlcIik7XHJcbiAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShcInNlbGVjdGxldmVsXCIpO1xyXG4gICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoXCJjaG9vc2VsZXZlbFwiKTtcclxuICB9XHJcblxyXG4gIHVwZGF0ZVNjZW5lKCkge1xyXG4gICAgLy9UT0RPOiBnb2luZyB0byBhYm91dCB0byBiYWNrIG1ha2VzIHRoZSBzY3JlZW4gZnJvemVuXHJcbiAgICB3aGlsZSAodGhpcy5yZWNlaXZlci5oYXNOZXh0RXZlbnQoKSkge1xyXG4gICAgICBsZXQgZXZlbnQgPSB0aGlzLnJlY2VpdmVyLmdldE5leHRFdmVudCgpO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coZXZlbnQpO1xyXG5cclxuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFwic2VsZWN0bGV2ZWxcIikge1xyXG4gICAgICAgIC8vIHRoaXMuc2NlbmVNYW5hZ2VyLmNoYW5nZVRvU2NlbmUobWFpblNjZW5lLCB7fSk7XHJcbiAgICAgICAgdGhpcy5tYWluTWVudS5zZXRIaWRkZW4odHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RMZXZlbFNjcmVlbi5zZXRIaWRkZW4oZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChldmVudC50eXBlID09PSBcImNob29zZWxldmVsXCIpIHtcclxuICAgICAgICB0aGlzLnNjZW5lTWFuYWdlci5jaGFuZ2VUb1NjZW5lKG1haW5TY2VuZSwge30pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJoZWxwXCIpIHtcclxuICAgICAgICB0aGlzLmhlbHAuc2V0SGlkZGVuKGZhbHNlKTtcclxuICAgICAgICB0aGlzLm1haW5NZW51LnNldEhpZGRlbih0cnVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFwibWVudVwiKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJsb2dnaW5nIG1lbnVcIik7XHJcbiAgICAgICAgdGhpcy5tYWluTWVudS5zZXRIaWRkZW4oZmFsc2UpO1xyXG4gICAgICAgIHRoaXMuaGVscC5zZXRIaWRkZW4odHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5jb250cm9sLnNldEhpZGRlbih0cnVlKTtcclxuICAgICAgICB0aGlzLnNwbGFzaFNjcmVlbi5zZXRIaWRkZW4odHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RMZXZlbFNjcmVlbi5zZXRIaWRkZW4odHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5iZy52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFwiY29udHJvbFwiKSB7XHJcbiAgICAgICAgdGhpcy5tYWluTWVudS5zZXRIaWRkZW4odHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5jb250cm9sLnNldEhpZGRlbihmYWxzZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IFBsYXllckNvbnRyb2xsZXIgZnJvbSBcIi4uL0FJL1BsYXllckNvbnRyb2xsZXJcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBBbmltYXRlZFNwcml0ZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZVwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1NjZW5lL1NjZW5lXCI7XHJcbmltcG9ydCB7IEdyYXBoaWNUeXBlIH0gZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL0dyYXBoaWNUeXBlc1wiO1xyXG5pbXBvcnQgT3J0aG9nb25hbFRpbGVtYXAgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwXCI7XHJcbmltcG9ydCBQb3NpdGlvbkdyYXBoIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvR3JhcGhzL1Bvc2l0aW9uR3JhcGhcIjtcclxuaW1wb3J0IE5hdm1lc2ggZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1BhdGhmaW5kaW5nL05hdm1lc2hcIjtcclxuaW1wb3J0IHsgaHc0X0V2ZW50cywgaHc0X05hbWVzLCBodzRfU3RhdHVzZXMgfSBmcm9tIFwiLi4vLi4vV29sZmllMkQvY29uc3RhbnRzXCI7XHJcbmltcG9ydCBFbmVteUFJIGZyb20gXCIuLi9BSS9FbmVteUFJXCI7XHJcbmltcG9ydCBXZWFwb25UeXBlIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9pdGVtcy9XZWFwb25UeXBlcy9XZWFwb25UeXBlXCI7XHJcbmltcG9ydCBSZWdpc3RyeU1hbmFnZXIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1JlZ2lzdHJ5L1JlZ2lzdHJ5TWFuYWdlclwiO1xyXG5pbXBvcnQgV2VhcG9uIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9pdGVtcy9XZWFwb25cIjtcclxuaW1wb3J0IEhlYWx0aHBhY2sgZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL2l0ZW1zL0hlYWx0aHBhY2tcIjtcclxuaW1wb3J0IEludmVudG9yeU1hbmFnZXIgZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL0ludmVudG9yeU1hbmFnZXJcIjtcclxuaW1wb3J0IEl0ZW0gZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL2l0ZW1zL0l0ZW1cIjtcclxuaW1wb3J0IEFBQkIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xyXG5pbXBvcnQgQmF0dGxlTWFuYWdlciBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvQmF0dGxlTWFuYWdlclwiO1xyXG5pbXBvcnQgQmF0dGxlckFJIGZyb20gXCIuLi9BSS9CYXR0bGVyQUlcIjtcclxuaW1wb3J0IExhYmVsIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XHJcbmltcG9ydCB7IFVJRWxlbWVudFR5cGUgfSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9VSUVsZW1lbnRUeXBlc1wiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1V0aWxzL0NvbG9yXCI7XHJcbmltcG9ydCBJbnB1dCBmcm9tIFwiLi4vLi4vV29sZmllMkQvSW5wdXQvSW5wdXRcIjtcclxuaW1wb3J0IEdhbWVPdmVyIGZyb20gXCIuL0dhbWVPdmVyXCI7XHJcbmltcG9ydCBBdHRhY2tBY3Rpb24gZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0FJL0VuZW15QWN0aW9ucy9BdHRhY2tBY3Rpb25cIjtcclxuaW1wb3J0IE1vdmUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0FJL0VuZW15QWN0aW9ucy9Nb3ZlXCI7XHJcbmltcG9ydCBSZXRyZWF0IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9BSS9FbmVteUFjdGlvbnMvUmV0cmVhdFwiO1xyXG5pbXBvcnQgQmVyc2VyayBmcm9tIFwiLi4vLi4vV29sZmllMkQvQUkvRW5lbXlBY3Rpb25zL0JlcnNlcmtcIjtcclxuaW1wb3J0IEJ1dHRvbiBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9CdXR0b25cIjtcclxuaW1wb3J0IE1heEhlYWx0aCBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvaXRlbXMvTWF4SGVhbHRoXCI7XHJcbmltcG9ydCBTcGVlZCBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvaXRlbXMvU3BlZWRcIjtcclxuaW1wb3J0IEF0dGFja1NwZWVkIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9pdGVtcy9BdHRhY2tTcGVlZFwiO1xyXG5pbXBvcnQgQXR0YWNrRGFtYWdlIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9pdGVtcy9BdHRhY2tEYW1hZ2VcIjtcclxuaW1wb3J0IENoZWNrcG9pbnQgZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL2l0ZW1zL0NoZWNrcG9pbnRcIjtcclxuaW1wb3J0IENoZWNrcG9pbnRDbGVhcmVkIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9pdGVtcy9DaGVja3BvaW50Q2xlYXJlZFwiO1xyXG5pbXBvcnQgTmV4dExldmVsIGZyb20gXCIuL05leHRMZXZlbFwiO1xyXG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xyXG5pbXBvcnQgVUlFbGVtZW50IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIG1haW5TY2VuZSBleHRlbmRzIFNjZW5lIHtcclxuICAvLyBUaGUgcGxheWVyXHJcbiAgcHJpdmF0ZSBtYWluUGxheWVyOiBBbmltYXRlZFNwcml0ZTtcclxuXHJcbiAgLy8gQSBsaXN0IG9mIGVuZW1pZXNcclxuICBwcml2YXRlIGVuZW1pZXM6IEFycmF5PEFuaW1hdGVkU3ByaXRlPjtcclxuXHJcbiAgLy8gVGhlIHdhbGwgbGF5ZXIgb2YgdGhlIHRpbGVtYXAgdG8gdXNlIGZvciBidWxsZXQgdmlzdWFsaXphdGlvblxyXG4gIHByaXZhdGUgd2FsbHM6IE9ydGhvZ29uYWxUaWxlbWFwO1xyXG5cclxuICAvLyBUaGUgcG9zaXRpb24gZ3JhcGggZm9yIHRoZSBuYXZtZXNoXHJcbiAgcHJpdmF0ZSBncmFwaDogUG9zaXRpb25HcmFwaDtcclxuXHJcbiAgLy8gQSBsaXN0IG9mIGl0ZW1zIGluIHRoZSBzY2VuZVxyXG4gIHByaXZhdGUgaXRlbXM6IEFycmF5PEl0ZW0+O1xyXG5cclxuICAvLyBUaGUgYmF0dGxlIG1hbmFnZXIgZm9yIHRoZSBzY2VuZXNcclxuICBwcml2YXRlIGJhdHRsZU1hbmFnZXI6IEJhdHRsZU1hbmFnZXI7XHJcblxyXG4gIC8vIFBsYXllciBoZWFsdGhcclxuICBwcml2YXRlIGhlYWx0aERpc3BsYXlzOiBMYWJlbDtcclxuXHJcbiAgLy8gUGxheWVyIERhbWFnZVxyXG4gIHByaXZhdGUgYXR0YWNrRGlzcGxheXM6IExhYmVsO1xyXG5cclxuICBwcml2YXRlIG1heGhlYWx0aERpc3BsYXlzOiBMYWJlbDtcclxuXHJcbiAgcHJpdmF0ZSBwYXVzZUJ1dHRvbjogQnV0dG9uO1xyXG5cclxuICBwcml2YXRlIHBsYXlCdXR0b246IEJ1dHRvbjtcclxuXHJcbiAgcHJpdmF0ZSBhdHRhY2tEYW1hZ2VCdWZmID0gMDtcclxuICBwcml2YXRlIGF0dGFja1NwZWVkQnVmZiA9IDA7XHJcbiAgcHJpdmF0ZSBzcGVlZEJ1ZmYgPSAwO1xyXG4gIHByaXZhdGUgaGVhbHRodXBCdWZmID0gMDtcclxuXHJcbiAgYXR0YWNrRGFtYWdlQnVmZkxhYmVsOiBMYWJlbDtcclxuICBzcGVlZEJ1ZmZMYWJlbDogTGFiZWw7XHJcbiAgYXR0YWNrU3BlZWRCdWZmTGFiZWw6IExhYmVsO1xyXG4gIGhlYWx0aHVwQnVmZkxhYmVsOiBMYWJlbDtcclxuXHJcbiAga25pZmVFbmVteUNsb25lOiBBbmltYXRlZFNwcml0ZTtcclxuICBoZWFsdGhiYXI6IExhYmVsO1xyXG4gIGhlYWx0aGJhcmdyZWVuOiBTcHJpdGU7XHJcblxyXG4gIHRvdGFsRW5lbWllc0tpbGxlZCA9IDA7XHJcbiAgdGlsZU1hcE1heFNpemU6IFZlYzI7XHJcbiAgbG9hZFNjZW5lKCkge1xyXG4gICAgLy8gTG9hZCB0aGUgcGxheWVyIGFuZCBlbmVteSBzcHJpdGVzaGVldHNcclxuXHJcbiAgICAvL3RoZXJlIHdpbGwgb25seSBiZSBvbmUgcGxheWVyXHJcbiAgICB0aGlzLmxvYWQuc3ByaXRlc2hlZXQoXHJcbiAgICAgIFwibWFpbnBsYXllclwiLFxyXG4gICAgICBcIm1heWhlbUFzc2V0cy9zcHJpdGVzaGVldHMvbWFpbnBsYXllci5qc29uXCJcclxuICAgICk7XHJcblxyXG4gICAgdGhpcy5sb2FkLnNwcml0ZXNoZWV0KFwiaW1wXCIsIFwibWF5aGVtQXNzZXRzL3Nwcml0ZXNoZWV0cy9pbXAuanNvblwiKTtcclxuXHJcbiAgICB0aGlzLmxvYWQuc3ByaXRlc2hlZXQoXCJzbGljZVwiLCBcIm1heWhlbUFzc2V0cy9zcHJpdGVzaGVldHMvc2xpY2UuanNvblwiKTtcclxuICAgIHRoaXMubG9hZC50aWxlbWFwKFwibGV2ZWxcIiwgXCJtYXloZW1Bc3NldHMvdGlsZW1hcHMvbWF5aGVtVGlsZUpzb24uanNvblwiKTtcclxuICAgIHRoaXMubG9hZC5vYmplY3QoXCJ3ZWFwb25EYXRhXCIsIFwibWF5aGVtQXNzZXRzL2RhdGEvd2VhcG9uRGF0YS5qc29uXCIpO1xyXG4gICAgdGhpcy5sb2FkLm9iamVjdChcIm5hdm1lc2hcIiwgXCJtYXloZW1Bc3NldHMvZGF0YS9uYXZtZXNoLmpzb25cIik7XHJcbiAgICB0aGlzLmxvYWQub2JqZWN0KFwiZW5lbXlEYXRhXCIsIFwibWF5aGVtQXNzZXRzL2RhdGEvZW5lbXkuanNvblwiKTtcclxuICAgIHRoaXMubG9hZC5vYmplY3QoXCJpdGVtRGF0YVwiLCBcIm1heWhlbUFzc2V0cy9kYXRhL2l0ZW1zLmpzb25cIik7XHJcbiAgICAvL2J1ZmZzXHJcbiAgICB0aGlzLmxvYWQuaW1hZ2UoXCJoZWFsdGhwYWNrXCIsIFwibWF5aGVtQXNzZXRzL3Nwcml0ZXMvaGVhbHRocGFjay5wbmdcIik7XHJcbiAgICB0aGlzLmxvYWQuaW1hZ2UoXCJoZWFsdGhtYXhcIiwgXCJtYXloZW1Bc3NldHMvc3ByaXRlcy9oZWFsdGhtYXgucG5nXCIpO1xyXG4gICAgdGhpcy5sb2FkLmltYWdlKFwiYXR0YWNrc3BlZWRcIiwgXCJtYXloZW1Bc3NldHMvc3ByaXRlcy9hdHRhY2tzcGVlZC5wbmdcIik7XHJcbiAgICB0aGlzLmxvYWQuaW1hZ2UoXCJhdHRhY2tkYW1hZ2VcIiwgXCJtYXloZW1Bc3NldHMvc3ByaXRlcy9hdHRhY2tkYW1hZ2UucG5nXCIpO1xyXG4gICAgdGhpcy5sb2FkLmltYWdlKFwic3BlZWRcIiwgXCJtYXloZW1Bc3NldHMvc3ByaXRlcy9zcGVlZC5wbmdcIik7XHJcbiAgICB0aGlzLmxvYWQuaW1hZ2UoXCJjaGVja3BvaW50XCIsIFwibWF5aGVtQXNzZXRzL3Nwcml0ZXMvY2hlY2twb2ludC5wbmdcIik7XHJcbiAgICB0aGlzLmxvYWQuaW1hZ2UoXHJcbiAgICAgIFwiY2hlY2twb2ludGNsZWFyZWRcIixcclxuICAgICAgXCJtYXloZW1Bc3NldHMvc3ByaXRlcy9jaGVja3BvaW50Y2xlYXJlZC5wbmdcIlxyXG4gICAgKTtcclxuICAgIHRoaXMubG9hZC5pbWFnZShcclxuICAgICAgXCJoZWFsdGhiYXJFbXB0eVwiLFxyXG4gICAgICBcIm1heWhlbUFzc2V0cy9zcHJpdGVzL2hlYWx0aGJhckVtcHR5LnBuZ1wiXHJcbiAgICApO1xyXG4gICAgdGhpcy5sb2FkLmltYWdlKFxyXG4gICAgICBcImhlYWx0aGJhckdyZWVuXCIsXHJcbiAgICAgIFwibWF5aGVtQXNzZXRzL3Nwcml0ZXMvaGVhbHRoYmFyR3JlZW4ucG5nXCJcclxuICAgICk7XHJcblxyXG4gICAgdGhpcy5sb2FkLmltYWdlKFwiaW52ZW50b3J5U2xvdFwiLCBcIm1heWhlbUFzc2V0cy9zcHJpdGVzL2ludmVudG9yeS5wbmdcIik7XHJcbiAgICB0aGlzLmxvYWQuaW1hZ2UoXCJrbmlmZVwiLCBcIm1heWhlbUFzc2V0cy9zcHJpdGVzL2tuaWZlLnBuZ1wiKTtcclxuICAgIHRoaXMubG9hZC5pbWFnZShcImxhc2VyR3VuXCIsIFwibWF5aGVtQXNzZXRzL3Nwcml0ZXMvbGFzZXJHdW4ucG5nXCIpO1xyXG4gICAgdGhpcy5sb2FkLmltYWdlKFwicGlzdG9sXCIsIFwibWF5aGVtQXNzZXRzL3Nwcml0ZXMvcGlzdG9sLnBuZ1wiKTtcclxuICB9XHJcblxyXG4gIHN0YXJ0U2NlbmUoKSB7XHJcbiAgICAvLyBIT01FV09SSyA0IC0gVE9ET1xyXG4gICAgLypcclxuICAgICAgICAgICAgTW9kaWZ5IHRoaXMgbGluZSBpZiBuZWVkZWQuXHJcblxyXG4gICAgICAgICAgICBUaGlzIGxpbmUgaXMganVzdCBnZXR0aW5nIHRoZSB3YWxsIGxheWVyIG9mIHlvdXIgdGlsZW1hcCB0byB1c2UgZm9yIHNvbWUgY2FsY3VsYXRpb25zLlxyXG4gICAgICAgICAgICBNYWtlIHN1cmUgaXQgaXMgc3RpbGwgZG9pbmcgc28uXHJcblxyXG4gICAgICAgICAgICBXaGF0IHRoZSBsaW5lIGlzIHNheWluZyBpcyB0byBnZXQgdGhlIGZpcnN0IGxldmVsIGZyb20gdGhlIGJvdHRvbSAodGlsZW1hcExheWVyc1sxXSksXHJcbiAgICAgICAgICAgIHdoaWNoIGluIG15IGNhc2Ugd2FzIHRoZSBXYWxscyBsYXllci5cclxuXHJcbiAgICAgICAgICAgIEFsc28sIHlvdXIgdGlsZW1hcCB3aWxsIGJlIG1hZGUgd2l0aCAzMngzMiB0aWxlcyB3aGlsZSB0aGUgZXhhbXBsZSBtYXAgaXMgbWFkZSB3aXRoIDE2eDE2IHRpbGVzLlxyXG4gICAgICAgICAgICBZb3UnbGwgbmVlZCB0byBzY2FsZSBpdCBkb3duIGZvciBvdXIgMTZ4MTYgcGxheWVycyBhbmQgZW5lbXkgc3ByaXRlcy4gVGhlIGNvZGUgZm9yIHRoaXNcclxuICAgICAgICAgICAgaXMgbGlzdGVkIGJlbG93LCBpdCdzIGp1c3QgYSBzY2FsaW5nIGRvd24gYnkgMS8yIGZvciB0aGUgdGlsZW1hcCBzaXplLlxyXG4gICAgICAgICovXHJcblxyXG4gICAgLy8gQWRkIGluIHRoZSB0aWxlbWFwXHJcbiAgICBsZXQgdGlsZW1hcExheWVycyA9IHRoaXMuYWRkLnRpbGVtYXAoXCJsZXZlbFwiLCBuZXcgVmVjMigwLjUsIDAuNSkpO1xyXG5cclxuICAgIC8vIEdldCB0aGUgd2FsbCBsYXllclxyXG4gICAgdGhpcy53YWxscyA9IDxPcnRob2dvbmFsVGlsZW1hcD50aWxlbWFwTGF5ZXJzWzFdLmdldEl0ZW1zKClbMF07XHJcblxyXG4gICAgLy8gU2V0IHRoZSB2aWV3cG9ydCBib3VuZHMgdG8gdGhlIHRpbGVtYXBcclxuICAgIGxldCB0aWxlbWFwU2l6ZTogVmVjMiA9IHRoaXMud2FsbHMuc2l6ZS5zY2FsZWQoMC41KTtcclxuICAgIHRoaXMudGlsZU1hcE1heFNpemUgPSB0aWxlbWFwU2l6ZTtcclxuXHJcbiAgICB0aGlzLnZpZXdwb3J0LnNldEJvdW5kcygwLCAwLCB0aWxlbWFwU2l6ZS54LCB0aWxlbWFwU2l6ZS55KTtcclxuXHJcbiAgICB0aGlzLmFkZExheWVyKFwicHJpbWFyeVwiLCAxMCk7XHJcblxyXG4gICAgLy8gQ3JlYXRlIHRoZSBiYXR0bGUgbWFuYWdlclxyXG4gICAgdGhpcy5iYXR0bGVNYW5hZ2VyID0gbmV3IEJhdHRsZU1hbmFnZXIoKTtcclxuXHJcbiAgICB0aGlzLmluaXRpYWxpemVXZWFwb25zKCk7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgaXRlbXMgYXJyYXkgLSB0aGlzIHJlcHJlc2VudHMgaXRlbXMgdGhhdCBhcmUgaW4gdGhlIGdhbWUgd29ybGRcclxuICAgIHRoaXMuaXRlbXMgPSBbXTtcclxuXHJcbiAgICAvLyBDcmVhdGUgdGhlIHBsYXllclxyXG4gICAgdGhpcy5pbml0aWFsaXplUGxheWVyKCk7XHJcblxyXG4gICAgLy8gTWFrZSB0aGUgdmlld3BvcnQgZm9sbG93IHRoZSBwbGF5ZXJcclxuICAgIHRoaXMudmlld3BvcnQuZm9sbG93KHRoaXMubWFpblBsYXllcik7XHJcblxyXG4gICAgLy8gWm9vbSBpbiB0byBhIHJlYXNvbmFibGUgbGV2ZWxcclxuICAgIHRoaXMudmlld3BvcnQuZW5hYmxlWm9vbSgpO1xyXG4gICAgdGhpcy52aWV3cG9ydC5zZXRab29tTGV2ZWwoNCk7XHJcblxyXG4gICAgLy8gQ3JlYXRlIHRoZSBuYXZtZXNoXHJcbiAgICB0aGlzLmNyZWF0ZU5hdm1lc2goKTtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIGFsbCBlbmVtaWVzXHJcbiAgICB0aGlzLmluaXRpYWxpemVFbmVtaWVzKCk7XHJcblxyXG4gICAgLy8gU2VuZCB0aGUgcGxheWVyIGFuZCBlbmVtaWVzIHRvIHRoZSBiYXR0bGUgbWFuYWdlclxyXG4gICAgdGhpcy5iYXR0bGVNYW5hZ2VyLnNldFBsYXllcnMoWzxCYXR0bGVyQUk+dGhpcy5tYWluUGxheWVyLl9haV0pO1xyXG4gICAgdGhpcy5iYXR0bGVNYW5hZ2VyLnNldEVuZW1pZXMoXHJcbiAgICAgIHRoaXMuZW5lbWllcy5tYXAoKGVuZW15KSA9PiA8QmF0dGxlckFJPmVuZW15Ll9haSlcclxuICAgICk7XHJcblxyXG4gICAgLy8gU3Vic2NyaWJlIHRvIHJlbGV2YW50IGV2ZW50c1xyXG4gICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoXCJoZWFsdGhwYWNrXCIpO1xyXG4gICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoXCJlbmVteURpZWRcIik7XHJcbiAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShcImNoZWNrcG9pbnRfY2xlYXJlZFwiKTtcclxuICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKFwibmV3YnVmZlwiKTtcclxuICAgIC8vIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKGh3NF9FdmVudHMuVU5MT0FEX0FTU0VUKTtcclxuXHJcbiAgICAvLyBTcGF3biBpdGVtcyBpbnRvIHRoZSB3b3JsZFxyXG4gICAgdGhpcy5zcGF3bkl0ZW1zKCk7XHJcblxyXG4gICAgLy8vYWRkaW5nIGhlYWx0aGJhclxyXG4gICAgdGhpcy5hZGRVSUxheWVyKFwiaGVhbHRoYmFyXCIpO1xyXG4gICAgdmFyIGhlYWx0aGJhciA9IHRoaXMuYWRkLnNwcml0ZShcImhlYWx0aGJhckVtcHR5XCIsIFwiaGVhbHRoYmFyXCIpO1xyXG4gICAgaGVhbHRoYmFyLnBvc2l0aW9uLnNldCgxMDAsIDE2KTtcclxuXHJcbiAgICB0aGlzLmhlYWx0aGJhcmdyZWVuID0gdGhpcy5hZGQuc3ByaXRlKFwiaGVhbHRoYmFyR3JlZW5cIiwgXCJoZWFsdGhiYXJcIik7XHJcbiAgICB0aGlzLmhlYWx0aGJhcmdyZWVuLnBvc2l0aW9uLnNldCgxMDAsIDE2KTtcclxuICAgIC8vLyg8UGxheWVyQ29udHJvbGxlcj50aGlzLm1haW5QbGF5ZXIuX2FpKS5oZWFsdGhcclxuICAgIHRoaXMuaGVhbHRoYmFyZ3JlZW4uc2l6ZS5zZXQoXHJcbiAgICAgICg8UGxheWVyQ29udHJvbGxlcj50aGlzLm1haW5QbGF5ZXIuX2FpKS5oZWFsdGgsXHJcbiAgICAgIDE2XHJcbiAgICApO1xyXG4gICAgLy8gQWRkIGEgVUkgZm9yIGhlYWx0aFxyXG4gICAgdGhpcy5hZGRVSUxheWVyKFwiaGVhbHRoXCIpO1xyXG5cclxuICAgIHRoaXMuaGVhbHRoRGlzcGxheXMgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFxyXG4gICAgICBVSUVsZW1lbnRUeXBlLkxBQkVMLFxyXG4gICAgICBcImhlYWx0aFwiLFxyXG4gICAgICB7XHJcbiAgICAgICAgcG9zaXRpb246IG5ldyBWZWMyKDYwLCAxNiksXHJcbiAgICAgICAgdGV4dDogXCJIZWFsdGg6IFwiICsgKDxCYXR0bGVyQUk+dGhpcy5tYWluUGxheWVyLl9haSkuaGVhbHRoLFxyXG4gICAgICB9XHJcbiAgICApO1xyXG4gICAgdGhpcy5oZWFsdGhEaXNwbGF5cy50ZXh0Q29sb3IgPSBDb2xvci5XSElURTtcclxuXHJcbiAgICB0aGlzLmFkZFVJTGF5ZXIoXCJtYXhoZWFsdGhcIik7XHJcblxyXG4gICAgdGhpcy5tYXhoZWFsdGhEaXNwbGF5cyA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoXHJcbiAgICAgIFVJRWxlbWVudFR5cGUuTEFCRUwsXHJcbiAgICAgIFwibWF4aGVhbHRoXCIsXHJcbiAgICAgIHtcclxuICAgICAgICBwb3NpdGlvbjogbmV3IFZlYzIoMTMwLCAxNiksXHJcbiAgICAgICAgdGV4dDpcclxuICAgICAgICAgIFwiTWF4IEhlYWx0aDogXCIgKyAoPFBsYXllckNvbnRyb2xsZXI+dGhpcy5tYWluUGxheWVyLl9haSkubWF4SGVhbHRoLFxyXG4gICAgICB9XHJcbiAgICApO1xyXG4gICAgdGhpcy5tYXhoZWFsdGhEaXNwbGF5cy50ZXh0Q29sb3IgPSBDb2xvci5XSElURTtcclxuXHJcbiAgICB0aGlzLmFkZFVJTGF5ZXIoXCJhdHRhY2tcIik7XHJcblxyXG4gICAgdGhpcy5hdHRhY2tEaXNwbGF5cyA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoXHJcbiAgICAgIFVJRWxlbWVudFR5cGUuTEFCRUwsXHJcbiAgICAgIFwiYXR0YWNrXCIsXHJcbiAgICAgIHtcclxuICAgICAgICBwb3NpdGlvbjogbmV3IFZlYzIoMTkwLCAxNiksXHJcbiAgICAgICAgdGV4dDpcclxuICAgICAgICAgIFwiQXR0YWNrOiBcIiArXHJcbiAgICAgICAgICAoPFBsYXllckNvbnRyb2xsZXI+dGhpcy5tYWluUGxheWVyLl9haSkud2VhcG9uLnR5cGUuZGFtYWdlLFxyXG4gICAgICB9XHJcbiAgICApO1xyXG4gICAgdGhpcy5hdHRhY2tEaXNwbGF5cy50ZXh0Q29sb3IgPSBDb2xvci5XSElURTtcclxuXHJcbiAgICB0aGlzLmFkZFVJTGF5ZXIoXCJwYXVzZVwiKTtcclxuICAgIHRoaXMuYWRkVUlMYXllcihcInBsYXlcIik7XHJcbiAgICB0aGlzLnBhdXNlQnV0dG9uID0gPEJ1dHRvbj50aGlzLmFkZC51aUVsZW1lbnQoXHJcbiAgICAgIFVJRWxlbWVudFR5cGUuQlVUVE9OLFxyXG4gICAgICBcInBhdXNlXCIsXHJcbiAgICAgIHtcclxuICAgICAgICBwb3NpdGlvbjogbmV3IFZlYzIoMjYwLCAxNiksXHJcbiAgICAgICAgdGV4dDogXCJQYXVzZVwiLFxyXG4gICAgICB9XHJcbiAgICApO1xyXG4gICAgdGhpcy5wYXVzZUJ1dHRvbi5zaXplLnNldCgyMDAsIDUwKTtcclxuICAgIHRoaXMucGF1c2VCdXR0b24uYm9yZGVyQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgIHRoaXMucGF1c2VCdXR0b24uYmFja2dyb3VuZENvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICB0aGlzLnBhdXNlQnV0dG9uLm9uQ2xpY2tFdmVudElkID0gXCJwYXVzZVwiO1xyXG5cclxuICAgIHRoaXMucGxheUJ1dHRvbiA9IDxCdXR0b24+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuQlVUVE9OLCBcInBsYXlcIiwge1xyXG4gICAgICBwb3NpdGlvbjogbmV3IFZlYzIoMjMwLCAxNiksXHJcbiAgICAgIHRleHQ6IFwiUGxheVwiLFxyXG4gICAgfSk7XHJcbiAgICB0aGlzLnBsYXlCdXR0b24uc2l6ZS5zZXQoMjAwLCA1MCk7XHJcbiAgICB0aGlzLnBsYXlCdXR0b24uYm9yZGVyQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgIHRoaXMucGxheUJ1dHRvbi5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgIHRoaXMucGxheUJ1dHRvbi5vbkNsaWNrRXZlbnRJZCA9IFwicGxheVwiO1xyXG5cclxuICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKFwicGF1c2VcIik7XHJcbiAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShcInBsYXlcIik7XHJcblxyXG4gICAgdGhpcy5hZGRVSUxheWVyKFwiYXR0YWNrZGFtYWdlXCIpO1xyXG4gICAgdGhpcy5hZGRVSUxheWVyKFwiYXR0YWNrc3BlZWRcIik7XHJcbiAgICB0aGlzLmFkZFVJTGF5ZXIoXCJzcGVlZFwiKTtcclxuICAgIHRoaXMuYWRkVUlMYXllcihcImhlYWx0aHVwXCIpO1xyXG4gICAgdGhpcy5hZGRVSUxheWVyKFwiYnVmZnNwaWN0dXJlXCIpLnNldERlcHRoKDEwMCk7XHJcbiAgICB2YXIgYXR0YWNrZGFtYWdlcGljID0gdGhpcy5hZGQuc3ByaXRlKFwiYXR0YWNrZGFtYWdlXCIsIFwiYnVmZnNwaWN0dXJlXCIpO1xyXG4gICAgYXR0YWNrZGFtYWdlcGljLnBvc2l0aW9uLnNldCgyODAsIDMwKTtcclxuICAgIHZhciBhdHRhY2tzcGVlZHBpYyA9IHRoaXMuYWRkLnNwcml0ZShcImF0dGFja3NwZWVkXCIsIFwiYnVmZnNwaWN0dXJlXCIpO1xyXG4gICAgYXR0YWNrc3BlZWRwaWMucG9zaXRpb24uc2V0KDI4MCwgNTApO1xyXG4gICAgdmFyIHNwZWVkcGljID0gdGhpcy5hZGQuc3ByaXRlKFwic3BlZWRcIiwgXCJidWZmc3BpY3R1cmVcIik7XHJcbiAgICBzcGVlZHBpYy5wb3NpdGlvbi5zZXQoMjgwLCA3MCk7XHJcbiAgICB2YXIgaGVhbHRocGljID0gdGhpcy5hZGQuc3ByaXRlKFwiaGVhbHRobWF4XCIsIFwiYnVmZnNwaWN0dXJlXCIpO1xyXG4gICAgaGVhbHRocGljLnBvc2l0aW9uLnNldCgyODAsIDkwKTtcclxuXHJcbiAgICB0aGlzLmF0dGFja0RhbWFnZUJ1ZmZMYWJlbCA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoXHJcbiAgICAgIFVJRWxlbWVudFR5cGUuTEFCRUwsXHJcbiAgICAgIFwiYXR0YWNrZGFtYWdlXCIsXHJcbiAgICAgIHtcclxuICAgICAgICBwb3NpdGlvbjogbmV3IFZlYzIoMjk1LCAzMCksXHJcbiAgICAgICAgdGV4dDogXCJcIiArIHRoaXMuYXR0YWNrRGFtYWdlQnVmZixcclxuICAgICAgfVxyXG4gICAgKTtcclxuICAgIHRoaXMuYXR0YWNrRGFtYWdlQnVmZkxhYmVsLnRleHRDb2xvciA9IENvbG9yLldISVRFO1xyXG5cclxuICAgIHRoaXMuYXR0YWNrU3BlZWRCdWZmTGFiZWwgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFxyXG4gICAgICBVSUVsZW1lbnRUeXBlLkxBQkVMLFxyXG4gICAgICBcImF0dGFja3NwZWVkXCIsXHJcbiAgICAgIHtcclxuICAgICAgICBwb3NpdGlvbjogbmV3IFZlYzIoMjk1LCA1MCksXHJcbiAgICAgICAgdGV4dDogXCJcIiArIHRoaXMuYXR0YWNrU3BlZWRCdWZmLFxyXG4gICAgICB9XHJcbiAgICApO1xyXG4gICAgdGhpcy5hdHRhY2tTcGVlZEJ1ZmZMYWJlbC50ZXh0Q29sb3IgPSBDb2xvci5XSElURTtcclxuXHJcbiAgICB0aGlzLnNwZWVkQnVmZkxhYmVsID0gPExhYmVsPnRoaXMuYWRkLnVpRWxlbWVudChcclxuICAgICAgVUlFbGVtZW50VHlwZS5MQUJFTCxcclxuICAgICAgXCJzcGVlZFwiLFxyXG4gICAgICB7XHJcbiAgICAgICAgcG9zaXRpb246IG5ldyBWZWMyKDI5NSwgNzApLFxyXG4gICAgICAgIHRleHQ6IFwiXCIgKyB0aGlzLnNwZWVkQnVmZixcclxuICAgICAgfVxyXG4gICAgKTtcclxuICAgIHRoaXMuc3BlZWRCdWZmTGFiZWwudGV4dENvbG9yID0gQ29sb3IuV0hJVEU7XHJcblxyXG4gICAgdGhpcy5oZWFsdGh1cEJ1ZmZMYWJlbCA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoXHJcbiAgICAgIFVJRWxlbWVudFR5cGUuTEFCRUwsXHJcbiAgICAgIFwiaGVhbHRodXBcIixcclxuICAgICAge1xyXG4gICAgICAgIHBvc2l0aW9uOiBuZXcgVmVjMigyOTUsIDkwKSxcclxuICAgICAgICB0ZXh0OiBcIlwiICsgdGhpcy5oZWFsdGh1cEJ1ZmYsXHJcbiAgICAgIH1cclxuICAgICk7XHJcbiAgICB0aGlzLmhlYWx0aHVwQnVmZkxhYmVsLnRleHRDb2xvciA9IENvbG9yLldISVRFO1xyXG4gIH1cclxuXHJcbiAgbG9vdEdlbmVyYXRlKHBvczogVmVjMikge1xyXG4gICAgaWYgKE1hdGgucmFuZG9tKCkgPCAwLjQpIHtcclxuICAgICAgLy8gU3Bhd24gYSBoZWFsdGhwYWNrXHJcbiAgICAgIGxldCBtaW4gPSAxO1xyXG4gICAgICBsZXQgbWF4ID0gNDtcclxuICAgICAgbGV0IGxvb3RUeXBlID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW4pO1xyXG4gICAgICAvLyB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KFwiaGVhbHRocGFja1wiLCB7IHBvc30pO1xyXG4gICAgICBpZiAobG9vdFR5cGUgPT09IDEpIHtcclxuICAgICAgICB0aGlzLmNyZWF0ZUF0dGFja0RhbWFnZShwb3MpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChsb290VHlwZSA9PT0gMikge1xyXG4gICAgICAgIHRoaXMuY3JlYXRlQXR0YWNrc3BlZWQocG9zKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAobG9vdFR5cGUgPT09IDMpIHtcclxuICAgICAgICAvLyB0aGlzLmNyZWF0ZUhlYWx0aHBhY2socG9zKVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChsb290VHlwZSA9PT0gNCkge1xyXG4gICAgICAgIHRoaXMuY3JlYXRlTWF4aGVhbHRoKHBvcyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgdXBkYXRlU2NlbmUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIHdoaWxlICh0aGlzLnJlY2VpdmVyLmhhc05leHRFdmVudCgpKSB7XHJcbiAgICAgIGxldCBldmVudCA9IHRoaXMucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KCk7XHJcbiAgICAgIGlmIChldmVudC5pc1R5cGUoXCJoZWFsdGhwYWNrXCIpKSB7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVIZWFsdGhwYWNrKGV2ZW50LmRhdGEuZ2V0KFwicG9zaXRpb25cIikpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChldmVudC5pc1R5cGUoXCJlbmVteURpZWRcIikpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZW5lbWllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgaWYgKHRoaXMuZW5lbWllc1tpXSA9PT0gZXZlbnQuZGF0YS5nZXQoXCJlbmVteVwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLmVuZW1pZXNbaV0uaHBEaXNwbGF5LmRlc3Ryb3koKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubG9vdEdlbmVyYXRlKGV2ZW50LmRhdGEuZ2V0KFwiZW5lbXlcIikucG9zaXRpb24uY2xvbmUoKSk7XHJcbiAgICAgICAgdGhpcy5lbmVtaWVzID0gdGhpcy5lbmVtaWVzLmZpbHRlcihcclxuICAgICAgICAgIChlbmVteSkgPT4gZW5lbXkgIT09IGV2ZW50LmRhdGEuZ2V0KFwiZW5lbXlcIilcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMuYmF0dGxlTWFuYWdlci5lbmVtaWVzID0gdGhpcy5iYXR0bGVNYW5hZ2VyLmVuZW1pZXMuZmlsdGVyKFxyXG4gICAgICAgICAgKGVuZW15KSA9PiBlbmVteSAhPT0gPEJhdHRsZXJBST5ldmVudC5kYXRhLmdldChcImVuZW15XCIpLl9haVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy50b3RhbEVuZW1pZXNLaWxsZWQrKztcclxuICAgICAgICB0aGlzLnNwYXduUmFuZG9tRW5lbXkoKTtcclxuICAgICAgICB0aGlzLnNwYXduUmFuZG9tRW5lbXkoKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZXZlbnQuaXNUeXBlKFwiY2hlY2twb2ludF9jbGVhcmVkXCIpKSB7XHJcbiAgICAgICAgbGV0IHNwcml0ZSA9IHRoaXMuYWRkLnNwcml0ZShcImNoZWNrcG9pbnRjbGVhcmVkXCIsIFwicHJpbWFyeVwiKTtcclxuICAgICAgICBsZXQgY2hlY2twb2ludGNsZWFyZWQgPSBuZXcgQ2hlY2twb2ludENsZWFyZWQoc3ByaXRlKTtcclxuICAgICAgICBjaGVja3BvaW50Y2xlYXJlZC5tb3ZlU3ByaXRlKGV2ZW50LmRhdGEuZ2V0KFwicG9zaXRpb25cIikpO1xyXG4gICAgICAgIHRoaXMubWFpblBsYXllci52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIuY2hhbmdlVG9TY2VuZShOZXh0TGV2ZWwpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChldmVudC5pc1R5cGUoXCJwYXVzZVwiKSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiUGF1c2luZyBHYW1lXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChldmVudC5pc1R5cGUoXCJwbGF5XCIpKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJSZXN1bWUgR2FtZVwiKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZXZlbnQuaXNUeXBlKFwibmV3YnVmZlwiKSkge1xyXG4gICAgICAgIHZhciBidWZmID0gZXZlbnQuZGF0YS5nZXQoXCJidWZmXCIpO1xyXG4gICAgICAgIGlmIChidWZmIGluc3RhbmNlb2YgQXR0YWNrRGFtYWdlKSB7XHJcbiAgICAgICAgICB0aGlzLmF0dGFja0RhbWFnZUJ1ZmYgKz0gMTtcclxuICAgICAgICAgIHRoaXMuYXR0YWNrRGFtYWdlQnVmZkxhYmVsLnRleHQgPSBcIlwiICsgdGhpcy5hdHRhY2tEYW1hZ2VCdWZmO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYnVmZiBpbnN0YW5jZW9mIEF0dGFja1NwZWVkKSB7XHJcbiAgICAgICAgICB0aGlzLmF0dGFja1NwZWVkQnVmZiArPSAxO1xyXG4gICAgICAgICAgdGhpcy5hdHRhY2tTcGVlZEJ1ZmZMYWJlbC50ZXh0ID0gXCJcIiArIHRoaXMuYXR0YWNrU3BlZWRCdWZmO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYnVmZiBpbnN0YW5jZW9mIFNwZWVkKSB7XHJcbiAgICAgICAgICB0aGlzLnNwZWVkQnVmZiArPSAxO1xyXG4gICAgICAgICAgdGhpcy5zcGVlZEJ1ZmZMYWJlbC50ZXh0ID0gXCJcIiArIHRoaXMuc3BlZWRCdWZmO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYnVmZiBpbnN0YW5jZW9mIE1heEhlYWx0aCkge1xyXG4gICAgICAgICAgdGhpcy5oZWFsdGh1cEJ1ZmYgKz0gMTtcclxuICAgICAgICAgIHRoaXMuaGVhbHRodXBCdWZmTGFiZWwudGV4dCA9IFwiXCIgKyB0aGlzLmhlYWx0aHVwQnVmZjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGV2ZW50LmlzVHlwZShodzRfRXZlbnRzLlVOTE9BRF9BU1NFVCkpIHtcclxuICAgICAgICBsZXQgYXNzZXQgPSB0aGlzLnNjZW5lR3JhcGguZ2V0Tm9kZShldmVudC5kYXRhLmdldChcIm5vZGVcIikpO1xyXG4gICAgICAgIGFzc2V0LmRlc3Ryb3koKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gY2hlY2sgaGVhbHRoIG9mIGVhY2ggcGxheWVyXHJcbiAgICBsZXQgaGVhbHRoID0gKDxCYXR0bGVyQUk+dGhpcy5tYWluUGxheWVyLl9haSkuaGVhbHRoO1xyXG5cclxuICAgIC8vSWYgYm90aCBhcmUgZGVhZCwgZ2FtZSBvdmVyXHJcblxyXG4gICAgaWYgKGhlYWx0aCA8PSAwKSB7XHJcbiAgICAgIHRoaXMubWFpblBsYXllci5wb3NpdGlvbiA9IG5ldyBWZWMyKC0xMDAwLCAtMTAwMCk7XHJcbiAgICAgIHRoaXMubWFpblBsYXllci52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLmNoYW5nZVRvU2NlbmUoR2FtZU92ZXIpO1xyXG4gICAgfVxyXG4gICAgLy8gVXBkYXRlIGhlYWx0aCBndWlcclxuICAgIHRoaXMuaGVhbHRoRGlzcGxheXMudGV4dCA9IFwiSGVhbHRoOiBcIiArIGhlYWx0aDtcclxuICAgIHRoaXMuYXR0YWNrRGlzcGxheXMudGV4dCA9XHJcbiAgICAgIFwiQXR0YWNrOiBcIiArICg8UGxheWVyQ29udHJvbGxlcj50aGlzLm1haW5QbGF5ZXIuX2FpKS53ZWFwb24udHlwZS5kYW1hZ2U7XHJcbiAgICB0aGlzLm1heGhlYWx0aERpc3BsYXlzLnRleHQgPVxyXG4gICAgICBcIk1heCBIZWFsdGg6IFwiICsgKDxQbGF5ZXJDb250cm9sbGVyPnRoaXMubWFpblBsYXllci5fYWkpLm1heEhlYWx0aDtcclxuXHJcbiAgICAvL3VwZGF0ZSBlbmVteSBocFxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5lbmVtaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmICh0aGlzLmVuZW1pZXNbaV0pIHtcclxuICAgICAgICAvLyAoPEdhbWVOb2RlPmRhdGEuaHBkaXNwbGF5KS5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5lbmVtaWVzW2ldLmhwRGlzcGxheS5zZXRQb3NpdGlvbihcclxuICAgICAgICAgIG5ldyBWZWMyKHRoaXMuZW5lbWllc1tpXS5wb3NpdGlvbi54LCB0aGlzLmVuZW1pZXNbaV0ucG9zaXRpb24ueSlcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMuZW5lbWllc1tpXS5ocERpc3BsYXkudGV4dCA9XHJcbiAgICAgICAgICBcIlwiICsgKDxFbmVteUFJPnRoaXMuZW5lbWllc1tpXS5fYWkpLmhlYWx0aDtcclxuICAgICAgfVxyXG4gICAgICAvLyBkYXRhLmhwZGlzcGxheT0gPExhYmVsPnRoaXMuYWRkLnVpRWxlbWVudChcclxuICAgICAgLy8gICBVSUVsZW1lbnRUeXBlLkxBQkVMLFxyXG4gICAgICAvLyAgIFwicHJpbWFyeVwiLFxyXG4gICAgICAvLyAgIHtcclxuICAgICAgLy8gICAgIHBvc2l0aW9uOiBuZXcgVmVjMih0aGlzLmVuZW1pZXNbaV0ucG9zaXRpb24ueCAsdGhpcy5lbmVtaWVzW2ldLnBvc2l0aW9uLnkpLFxyXG4gICAgICAvLyAgICAgdGV4dDogXCJcIiArIGRhdGEuaGVhbHRoXHJcbiAgICAgIC8vICAgfVxyXG4gICAgICAvLyApO1xyXG4gICAgfVxyXG4gICAgdmFyIGN1cnJlbnRocCA9ICg8UGxheWVyQ29udHJvbGxlcj50aGlzLm1haW5QbGF5ZXIuX2FpKS5oZWFsdGg7XHJcbiAgICB2YXIgbWF4aHAgPSAoPFBsYXllckNvbnRyb2xsZXI+dGhpcy5tYWluUGxheWVyLl9haSkubWF4SGVhbHRoO1xyXG4gICAgdGhpcy5oZWFsdGhiYXJncmVlbi5zaXplLnNldCgoY3VycmVudGhwIC8gbWF4aHApICogMTI4LCAxNik7XHJcblxyXG4gICAgLy8gRGVidWcgbW9kZSBncmFwaFxyXG4gICAgaWYgKElucHV0LmlzS2V5SnVzdFByZXNzZWQoXCJnXCIpKSB7XHJcbiAgICAgIHRoaXMuZ2V0TGF5ZXIoXCJncmFwaFwiKS5zZXRIaWRkZW4oIXRoaXMuZ2V0TGF5ZXIoXCJncmFwaFwiKS5pc0hpZGRlbigpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEhPTUVXT1JLIDQgLSBUT0RPXHJcbiAgLyoqXHJcbiAgICogVGhpcyBmdW5jdGlvbiBzcGF3bnMgaW4gYWxsIG9mIHRoZSBpdGVtcyBpbiBcIml0ZW1zLmpzb25cIlxyXG4gICAqXHJcbiAgICogWW91IHNob3VsZG4ndCBoYXZlIHRvIHB1dCBhbnkgbmV3IGNvZGUgaGVyZSwgaG93ZXZlciwgeW91IHdpbGwgaGF2ZSB0byBtb2RpZnkgaXRlbXMuanNvbi5cclxuICAgKlxyXG4gICAqIE1ha2Ugc3VyZSB5b3UgYXJlIHNwYXduaW5nIGluIDUgcGlzdG9scyBhbmQgNSBsYXNlciBndW5zIHNvbWV3aGVyZSAoYWNjZXNzaWJsZSkgaW4geW91ciB3b3JsZC5cclxuICAgKlxyXG4gICAqIFlvdSdsbCBub3RpY2UgdGhhdCByaWdodCBub3csIHNvbWUgaGVhbHRocGFja3MgYXJlIGFsc28gc3Bhd25pbmcgaW4uIFRoZXNlIGFsc28gZHJvcCBmcm9tIGd1YXJkcy5cclxuICAgKiBGZWVsIGZyZWUgdG8gc3Bhd24gc29tZSBoZWFsdGhwYWNrcyBpZiB5b3Ugd2FudCwgb3IgeW91IGNhbiBqdXN0IGxldCB0aGUgcGxheWVyIHN1ZmZlciA+OilcclxuICAgKi9cclxuICBzcGF3bkl0ZW1zKCk6IHZvaWQge1xyXG4gICAgLy8gR2V0IHRoZSBpdGVtIGRhdGFcclxuICAgIGxldCBpdGVtRGF0YSA9IHRoaXMubG9hZC5nZXRPYmplY3QoXCJpdGVtRGF0YVwiKTtcclxuXHJcbiAgICBmb3IgKGxldCBpdGVtIG9mIGl0ZW1EYXRhLml0ZW1zKSB7XHJcbiAgICAgIGlmIChpdGVtLnR5cGUgPT09IFwiaGVhbHRocGFja1wiKSB7XHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgaGVhbHRocGFja1xyXG4gICAgICAgIHRoaXMuY3JlYXRlSGVhbHRocGFjayhcclxuICAgICAgICAgIG5ldyBWZWMyKGl0ZW0ucG9zaXRpb25bMF0gLyAyLCBpdGVtLnBvc2l0aW9uWzFdIC8gMilcclxuICAgICAgICApO1xyXG4gICAgICB9IGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gXCJoZWFsdGhtYXhcIikge1xyXG4gICAgICAgIHRoaXMuY3JlYXRlTWF4aGVhbHRoKFxyXG4gICAgICAgICAgbmV3IFZlYzIoaXRlbS5wb3NpdGlvblswXSAvIDIsIGl0ZW0ucG9zaXRpb25bMV0gLyAyKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSBcImF0dGFja3NwZWVkXCIpIHtcclxuICAgICAgICB0aGlzLmNyZWF0ZUF0dGFja3NwZWVkKFxyXG4gICAgICAgICAgbmV3IFZlYzIoaXRlbS5wb3NpdGlvblswXSAvIDIsIGl0ZW0ucG9zaXRpb25bMV0gLyAyKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSBcImF0dGFja2RhbWFnZVwiKSB7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVBdHRhY2tEYW1hZ2UoXHJcbiAgICAgICAgICBuZXcgVmVjMihpdGVtLnBvc2l0aW9uWzBdIC8gMiwgaXRlbS5wb3NpdGlvblsxXSAvIDIpXHJcbiAgICAgICAgKTtcclxuICAgICAgfSBlbHNlIGlmIChpdGVtLnR5cGUgPT09IFwic3BlZWRcIikge1xyXG4gICAgICAgIHRoaXMuY3JlYXRlU3BlZWQobmV3IFZlYzIoaXRlbS5wb3NpdGlvblswXSAvIDIsIGl0ZW0ucG9zaXRpb25bMV0gLyAyKSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSBcImNoZWNrcG9pbnRcIikge1xyXG4gICAgICAgIHRoaXMuY3JlYXRlQ2hlY2twb2ludChcclxuICAgICAgICAgIG5ldyBWZWMyKGl0ZW0ucG9zaXRpb25bMF0gLyAyLCBpdGVtLnBvc2l0aW9uWzFdIC8gMilcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKlxyXG4gICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBuZXcgd2VhcG9uXHJcbiAgICogQHBhcmFtIHR5cGUgVGhlIHdlYXBvblR5cGUgb2YgdGhlIHdlYXBvbiwgYXMgYSBzdHJpbmdcclxuICAgKi9cclxuICBjcmVhdGVXZWFwb24odHlwZTogc3RyaW5nKTogV2VhcG9uIHtcclxuICAgIGxldCB3ZWFwb25UeXBlID0gPFdlYXBvblR5cGU+KFxyXG4gICAgICBSZWdpc3RyeU1hbmFnZXIuZ2V0UmVnaXN0cnkoXCJ3ZWFwb25UeXBlc1wiKS5nZXQodHlwZSlcclxuICAgICk7XHJcblxyXG4gICAgbGV0IHNwcml0ZSA9IHRoaXMuYWRkLnNwcml0ZSh3ZWFwb25UeXBlLnNwcml0ZUtleSwgXCJwcmltYXJ5XCIpO1xyXG5cclxuICAgIHJldHVybiBuZXcgV2VhcG9uKHNwcml0ZSwgd2VhcG9uVHlwZSwgdGhpcy5iYXR0bGVNYW5hZ2VyKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBoZWFsdGhwYWNrIGF0IGEgY2VydGFpbiBwb3NpdGlvbiBpbiB0aGUgd29ybGRcclxuICAgKiBAcGFyYW0gcG9zaXRpb25cclxuICAgKi9cclxuICBjcmVhdGVIZWFsdGhwYWNrKHBvc2l0aW9uOiBWZWMyKTogdm9pZCB7XHJcbiAgICBsZXQgc3ByaXRlID0gdGhpcy5hZGQuc3ByaXRlKFwiaGVhbHRocGFja1wiLCBcInByaW1hcnlcIik7XHJcbiAgICBsZXQgaGVhbHRocGFjayA9IG5ldyBIZWFsdGhwYWNrKHNwcml0ZSk7XHJcbiAgICBoZWFsdGhwYWNrLm1vdmVTcHJpdGUocG9zaXRpb24pO1xyXG4gICAgdGhpcy5pdGVtcy5wdXNoKGhlYWx0aHBhY2spO1xyXG4gIH1cclxuXHJcbiAgY3JlYXRlTWF4aGVhbHRoKHBvc2l0aW9uOiBWZWMyKTogdm9pZCB7XHJcbiAgICBsZXQgc3ByaXRlID0gdGhpcy5hZGQuc3ByaXRlKFwiaGVhbHRobWF4XCIsIFwicHJpbWFyeVwiKTtcclxuICAgIGxldCBtYXhoZWFsdGggPSBuZXcgTWF4SGVhbHRoKHNwcml0ZSk7XHJcbiAgICBtYXhoZWFsdGgubW92ZVNwcml0ZShwb3NpdGlvbik7XHJcbiAgICB0aGlzLml0ZW1zLnB1c2gobWF4aGVhbHRoKTtcclxuICB9XHJcblxyXG4gIGNyZWF0ZVNwZWVkKHBvc2l0aW9uOiBWZWMyKTogdm9pZCB7XHJcbiAgICBsZXQgc3ByaXRlID0gdGhpcy5hZGQuc3ByaXRlKFwic3BlZWRcIiwgXCJwcmltYXJ5XCIpO1xyXG4gICAgbGV0IHNwZWVkID0gbmV3IFNwZWVkKHNwcml0ZSk7XHJcbiAgICBzcGVlZC5tb3ZlU3ByaXRlKHBvc2l0aW9uKTtcclxuICAgIHRoaXMuaXRlbXMucHVzaChzcGVlZCk7XHJcbiAgfVxyXG4gIGNyZWF0ZUF0dGFja0RhbWFnZShwb3NpdGlvbjogVmVjMik6IHZvaWQge1xyXG4gICAgbGV0IHNwcml0ZSA9IHRoaXMuYWRkLnNwcml0ZShcImF0dGFja2RhbWFnZVwiLCBcInByaW1hcnlcIik7XHJcbiAgICBsZXQgYXR0YWNrZGFtYWdlID0gbmV3IEF0dGFja0RhbWFnZShzcHJpdGUpO1xyXG4gICAgYXR0YWNrZGFtYWdlLm1vdmVTcHJpdGUocG9zaXRpb24pO1xyXG4gICAgdGhpcy5pdGVtcy5wdXNoKGF0dGFja2RhbWFnZSk7XHJcbiAgfVxyXG4gIGNyZWF0ZUF0dGFja3NwZWVkKHBvc2l0aW9uOiBWZWMyKTogdm9pZCB7XHJcbiAgICBsZXQgc3ByaXRlID0gdGhpcy5hZGQuc3ByaXRlKFwiYXR0YWNrc3BlZWRcIiwgXCJwcmltYXJ5XCIpO1xyXG4gICAgbGV0IGF0dGFja3NwZWVkID0gbmV3IEF0dGFja1NwZWVkKHNwcml0ZSk7XHJcbiAgICBhdHRhY2tzcGVlZC5tb3ZlU3ByaXRlKHBvc2l0aW9uKTtcclxuICAgIHRoaXMuaXRlbXMucHVzaChhdHRhY2tzcGVlZCk7XHJcbiAgfVxyXG5cclxuICBjcmVhdGVDaGVja3BvaW50KHBvc2l0aW9uOiBWZWMyKSB7XHJcbiAgICBsZXQgc3ByaXRlID0gdGhpcy5hZGQuc3ByaXRlKFwiY2hlY2twb2ludFwiLCBcInByaW1hcnlcIik7XHJcbiAgICBsZXQgY2hlY2twb2ludCA9IG5ldyBDaGVja3BvaW50KHNwcml0ZSk7XHJcbiAgICBjaGVja3BvaW50Lm1vdmVTcHJpdGUocG9zaXRpb24pO1xyXG4gICAgdGhpcy5pdGVtcy5wdXNoKGNoZWNrcG9pbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGFsaXplcyBhbGwgd2VhcG9uIHR5cGVzIGJhc2VkIG9mIGRhdGEgZnJvbSB3ZWFwb25EYXRhLmpzb25cclxuICAgKi9cclxuICBpbml0aWFsaXplV2VhcG9ucygpOiB2b2lkIHtcclxuICAgIGxldCB3ZWFwb25EYXRhID0gdGhpcy5sb2FkLmdldE9iamVjdChcIndlYXBvbkRhdGFcIik7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3ZWFwb25EYXRhLm51bVdlYXBvbnM7IGkrKykge1xyXG4gICAgICBsZXQgd2VhcG9uID0gd2VhcG9uRGF0YS53ZWFwb25zW2ldO1xyXG5cclxuICAgICAgLy8gR2V0IHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgcHJvdG90eXBlXHJcbiAgICAgIGxldCBjb25zdHIgPSBSZWdpc3RyeU1hbmFnZXIuZ2V0UmVnaXN0cnkoXCJ3ZWFwb25UZW1wbGF0ZXNcIikuZ2V0KFxyXG4gICAgICAgIHdlYXBvbi53ZWFwb25UeXBlXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgYSB3ZWFwb24gdHlwZVxyXG4gICAgICBsZXQgd2VhcG9uVHlwZSA9IG5ldyBjb25zdHIoKTtcclxuXHJcbiAgICAgIC8vIEluaXRpYWxpemUgdGhlIHdlYXBvbiB0eXBlXHJcbiAgICAgIHdlYXBvblR5cGUuaW5pdGlhbGl6ZSh3ZWFwb24pO1xyXG5cclxuICAgICAgLy8gUmVnaXN0ZXIgdGhlIHdlYXBvbiB0eXBlXHJcbiAgICAgIFJlZ2lzdHJ5TWFuYWdlci5nZXRSZWdpc3RyeShcIndlYXBvblR5cGVzXCIpLnJlZ2lzdGVySXRlbShcclxuICAgICAgICB3ZWFwb24ubmFtZSxcclxuICAgICAgICB3ZWFwb25UeXBlXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBIT01FV09SSyA0IC0gVE9ET1xyXG4gIC8qKlxyXG4gICAqIENoYW5nZSBwb3NpdGlvbnMgb2YgdGhlIHBsYXllciBjaGFyYWN0ZXJzIHRvIHdoYXRldmVyIGZpdHMgeW91ciBtYXBcclxuICAgKi9cclxuICBpbml0aWFsaXplUGxheWVyKCk6IHZvaWQge1xyXG4gICAgLy8gQ3JlYXRlIHRoZSBpbnZlbnRvcnlcclxuICAgIGxldCBpbnZlbnRvcnkgPSBuZXcgSW52ZW50b3J5TWFuYWdlcihcclxuICAgICAgdGhpcyxcclxuICAgICAgMSxcclxuICAgICAgXCJpbnZlbnRvcnlTbG90XCIsXHJcbiAgICAgIG5ldyBWZWMyKDE2LCAxNiksXHJcbiAgICAgIDIsXHJcbiAgICAgIFwic2xvdHMxXCIsXHJcbiAgICAgIFwiaXRlbXMxXCJcclxuICAgICk7XHJcbiAgICBsZXQgc3RhcnRpbmdXZWFwb24gPSB0aGlzLmNyZWF0ZVdlYXBvbihcIndlYWtfcGlzdG9sXCIpO1xyXG4gICAgaW52ZW50b3J5LmFkZEl0ZW0oc3RhcnRpbmdXZWFwb24pO1xyXG5cclxuICAgIC8vIENyZWF0ZSB0aGUgcGxheWVyc1xyXG4gICAgdGhpcy5tYWluUGxheWVyID0gdGhpcy5hZGQuYW5pbWF0ZWRTcHJpdGUoXCJtYWlucGxheWVyXCIsIFwicHJpbWFyeVwiKTtcclxuICAgIHRoaXMubWFpblBsYXllci5wb3NpdGlvbi5zZXQoNCAqIDgsIDYyICogOCk7XHJcbiAgICB0aGlzLm1haW5QbGF5ZXIuYWRkUGh5c2ljcyhuZXcgQUFCQihWZWMyLlpFUk8sIG5ldyBWZWMyKDgsIDgpKSk7XHJcbiAgICAvL0ZpcnN0IHRoaXNsYXllcmVlIGJhc2VkLCBzdGFydHMgb2ZmIHdpdGggYSBrbmlmZSBhbmQgaXMgc2hvcnQgcmFuZ2VkXHJcbiAgICB0aGlzLm1haW5QbGF5ZXIuYWRkQUkoUGxheWVyQ29udHJvbGxlciwge1xyXG4gICAgICBzcGVlZDogMTAwLFxyXG4gICAgICBoZWFsdGg6IDEyOCwgLy9vcmlnaW5hbCB3YXMgMjUgLy9cclxuICAgICAgbWF4SGVhbHRoOiAxMjgsIC8vYWRkaW5nIG1heGhlYWx0aFxyXG4gICAgICBpbnZlbnRvcnk6IGludmVudG9yeSxcclxuICAgICAgaXRlbXM6IHRoaXMuaXRlbXMsXHJcbiAgICAgIGlucHV0RW5hYmxlZDogdHJ1ZSxcclxuICAgICAgcmFuZ2U6IDE1MCwgLy93ZWFrIHBpc3RvbCByYW5nZVxyXG4gICAgICB3ZWFwb246IHN0YXJ0aW5nV2VhcG9uLFxyXG4gICAgfSk7XHJcbiAgICB0aGlzLm1haW5QbGF5ZXIuYW5pbWF0aW9uLnBsYXkoXCJmYWNlX3JpZ2h0XCIpO1xyXG4gICAgKDxQbGF5ZXJDb250cm9sbGVyPnRoaXMubWFpblBsYXllci5fYWkpLmludmVudG9yeS5zZXRBY3RpdmUodHJ1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiAvLyBIT01FV09SSyA0IC0gVE9ET1xyXG4gICAqIFRoaXMgZnVuY3Rpb24gY3JlYXRlcyB0aGUgbmF2bWVzaCBmb3IgdGhlIGdhbWUgd29ybGQuXHJcbiAgICpcclxuICAgKiBJdCByZWFkcyBpbiBpbmZvcm1hdGlvbiBpbiB0aGUgbmF2bWVzaC5qc29uIGZpbGUuXHJcbiAgICogVGhlIGZvcm1hdCBvZiB0aGUgbmF2bWVzaC5qc29uIGZpbGUgaXMgYXMgZm9sbG93c1xyXG4gICAqXHJcbiAgICoge1xyXG4gICAqICAvLyBBbiBhcnJheSBvZiBwb3NpdGlvbnMgb24gdGhlIHRpbGVtYXAuIFlvdSBjYW4gc2VlIHRoZSBwb3NpdGlvbiBvZiB5b3VyIG1vdXNlIGluIFtyb3csIGNvbF1cclxuICAgKiAgLy8gd2hpbGUgZWRpdGluZyBhIG1hcCBpbiBUaWxlZCwgYW5kIGNhbiBqdXN0IG11bHRpcGx5IHRob3NlIHZhbHVlcyBieSB0aGUgdGlsZSBzaXplLCAxNngxNlxyXG4gICAqICAgICAgXCJub2Rlc1wiOiBbWzEwMCwgMjAwXSwgWzUwLCA0MDBdLCAuLi5dXHJcbiAgICpcclxuICAgKiAgLy8gQW4gYXJyYXkgb2YgZWRnZXMgYmV0d2VlbiBub2Rlcy4gVGhlIG51bWJlcnMgaGVyZSBjb3JyZXNwb25kIHRvIGluZGljZXMgaW4gdGhlIFwibm9kZXNcIiBhcnJheSBhYm92ZS5cclxuICAgKiAgLy8gTm90ZSB0aGF0IGVkZ2VzIGFyZSBub3QgZGlyZWN0ZWQgaGVyZS4gQW4gZWRnZSBbMCwgMV0gZm9lcyBpbiBib3RoIGRpcmVjdGlvbnMuXHJcbiAgICogICAgICBcImVkZ2VzXCI6IFtbMCwgMV0sIFsyLCA0XSwgLi4uXVxyXG4gICAqIH1cclxuICAgKlxyXG4gICAqIFRoZSBuYXZtZXNoIHlvdSBjcmVhdGUgc2hvdWxkIGJlIGRpc3RpbmN0bHkgZGlmZmVyZW50IGZyb20gdGhlIG9uZSBnaXZlbiBhcyBhbiBleGFtcGxlLlxyXG4gICAqL1xyXG4gIGNyZWF0ZU5hdm1lc2goKTogdm9pZCB7XHJcbiAgICAvLyBBZGQgYSBsYXllciB0byBkaXNwbGF5IHRoZSBncmFwaFxyXG4gICAgbGV0IGdMYXllciA9IHRoaXMuYWRkTGF5ZXIoXCJncmFwaFwiKTtcclxuICAgIGdMYXllci5zZXRIaWRkZW4odHJ1ZSk7XHJcblxyXG4gICAgbGV0IG5hdm1lc2hEYXRhID0gdGhpcy5sb2FkLmdldE9iamVjdChcIm5hdm1lc2hcIik7XHJcblxyXG4gICAgLy8gQ3JlYXRlIHRoZSBncmFwaFxyXG4gICAgdGhpcy5ncmFwaCA9IG5ldyBQb3NpdGlvbkdyYXBoKCk7XHJcblxyXG4gICAgLy8gQWRkIGFsbCBub2RlcyB0byBvdXIgZ3JhcGhcclxuICAgIGZvciAobGV0IG5vZGUgb2YgbmF2bWVzaERhdGEubm9kZXMpIHtcclxuICAgICAgdGhpcy5ncmFwaC5hZGRQb3NpdGlvbmVkTm9kZShuZXcgVmVjMihub2RlWzBdIC8gMiwgbm9kZVsxXSAvIDIpKTtcclxuICAgICAgdGhpcy5hZGQuZ3JhcGhpYyhHcmFwaGljVHlwZS5QT0lOVCwgXCJncmFwaFwiLCB7XHJcbiAgICAgICAgcG9zaXRpb246IG5ldyBWZWMyKG5vZGVbMF0gLyAyLCBub2RlWzFdIC8gMiksXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCBhbGwgZWRnZXMgdG8gb3VyIGdyYXBoXHJcbiAgICBmb3IgKGxldCBlZGdlIG9mIG5hdm1lc2hEYXRhLmVkZ2VzKSB7XHJcbiAgICAgIHRoaXMuZ3JhcGguYWRkRWRnZShlZGdlWzBdLCBlZGdlWzFdKTtcclxuICAgICAgdGhpcy5hZGQuZ3JhcGhpYyhHcmFwaGljVHlwZS5MSU5FLCBcImdyYXBoXCIsIHtcclxuICAgICAgICBzdGFydDogdGhpcy5ncmFwaC5nZXROb2RlUG9zaXRpb24oZWRnZVswXSksXHJcbiAgICAgICAgZW5kOiB0aGlzLmdyYXBoLmdldE5vZGVQb3NpdGlvbihlZGdlWzFdKSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2V0IHRoaXMgZ3JhcGggYXMgYSBuYXZpZ2FibGUgZW50aXR5XHJcbiAgICBsZXQgbmF2bWVzaCA9IG5ldyBOYXZtZXNoKHRoaXMuZ3JhcGgpO1xyXG5cclxuICAgIHRoaXMubmF2TWFuYWdlci5hZGROYXZpZ2FibGVFbnRpdHkoaHc0X05hbWVzLk5BVk1FU0gsIG5hdm1lc2gpO1xyXG4gIH1cclxuXHJcbiAgYWN0aW9uS25pZmUgPSBbXHJcbiAgICBuZXcgQXR0YWNrQWN0aW9uKDMsIFtodzRfU3RhdHVzZXMuSU5fUkFOR0VdLCBbaHc0X1N0YXR1c2VzLlJFQUNIRURfR09BTF0pLFxyXG4gICAgbmV3IE1vdmUoMiwgW10sIFtodzRfU3RhdHVzZXMuSU5fUkFOR0VdLCB7IGluUmFuZ2U6IDIwIH0pLFxyXG4gICAgLy9uZXcgUmV0cmVhdCgxLCBbaHc0X1N0YXR1c2VzLkxPV19IRUFMVEgsIGh3NF9TdGF0dXNlcy5DQU5fUkVUUkVBVF0sIFtodzRfU3RhdHVzZXMuUkVBQ0hFRF9HT0FMXSwge3JldHJlYXREaXN0YW5jZTogMjAwfSksLFxyXG4gIF07XHJcbiAgYWN0aW9uc0d1biA9IFtcclxuICAgIG5ldyBBdHRhY2tBY3Rpb24oMywgW2h3NF9TdGF0dXNlcy5JTl9SQU5HRV0sIFtodzRfU3RhdHVzZXMuUkVBQ0hFRF9HT0FMXSksXHJcbiAgICBuZXcgTW92ZSgyLCBbXSwgW2h3NF9TdGF0dXNlcy5JTl9SQU5HRV0sIHsgaW5SYW5nZTogMTAwIH0pLFxyXG4gICAgbmV3IFJldHJlYXQoXHJcbiAgICAgIDEsXHJcbiAgICAgIFtodzRfU3RhdHVzZXMuTE9XX0hFQUxUSCwgaHc0X1N0YXR1c2VzLkNBTl9SRVRSRUFUXSxcclxuICAgICAgW2h3NF9TdGF0dXNlcy5SRUFDSEVEX0dPQUwsIGh3NF9TdGF0dXNlcy5DQU5fQkVSU0VSS10sXHJcbiAgICAgIHsgcmV0cmVhdERpc3RhbmNlOiAyMDAgfVxyXG4gICAgKSxcclxuICAgIG5ldyBCZXJzZXJrKFxyXG4gICAgICAxLFxyXG4gICAgICBbaHc0X1N0YXR1c2VzLkxPV19IRUFMVEgsIGh3NF9TdGF0dXNlcy5DQU5fQkVSU0VSS10sXHJcbiAgICAgIFtodzRfU3RhdHVzZXMuUkVBQ0hFRF9HT0FMXVxyXG4gICAgKSxcclxuICBdO1xyXG5cclxuICBzcGF3bkVuZW15KGRhdGE6IGFueSwgcG9zOiBWZWMyKSB7XHJcbiAgICBpZiAodGhpcy5lbmVtaWVzLmxlbmd0aCA+PSAxMDApIHtcclxuICAgICAgcmV0dXJuOyAvL2hhcmQgbGltaXQgb24gdGhlIG1heCBlbmVtaWVzIHRoZXJlIGNhbiBiZSBpbiB0aGlzIGdhbWVcclxuICAgIH1cclxuXHJcbiAgICAvLyBDcmVhdGUgYW4gZW5lbXlcclxuXHJcbiAgICB0aGlzLmVuZW1pZXMucHVzaCh0aGlzLmFkZC5hbmltYXRlZFNwcml0ZShkYXRhLnR5cGUsIFwicHJpbWFyeVwiKSk7XHJcbiAgICBsZXQgbGFzdEluZGV4ID0gdGhpcy5lbmVtaWVzLmxlbmd0aCAtIDE7XHJcbiAgICB0aGlzLmVuZW1pZXNbbGFzdEluZGV4XS5wb3NpdGlvbi5zZXQoXHJcbiAgICAgIGRhdGEucG9zaXRpb25bMF0gLyAyLFxyXG4gICAgICBkYXRhLnBvc2l0aW9uWzFdIC8gMlxyXG4gICAgKTtcclxuICAgIHRoaXMuZW5lbWllc1tsYXN0SW5kZXhdLmFuaW1hdGlvbi5wbGF5KFwiZmFjZV9yaWdodFwiKTtcclxuICAgIHRoaXMuZW5lbWllc1tsYXN0SW5kZXhdLmFkZFBoeXNpY3MobmV3IEFBQkIoVmVjMi5aRVJPLCBuZXcgVmVjMig4LCA4KSkpO1xyXG5cclxuICAgIGlmIChkYXRhLnJvdXRlKSB7XHJcbiAgICAgIGRhdGEucm91dGUgPSBkYXRhLnJvdXRlLm1hcCgoaW5kZXg6IG51bWJlcikgPT5cclxuICAgICAgICB0aGlzLmdyYXBoLmdldE5vZGVQb3NpdGlvbihpbmRleClcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZGF0YS5ndWFyZFBvc2l0aW9uKSB7XHJcbiAgICAgIGRhdGEuZ3VhcmRQb3NpdGlvbiA9IG5ldyBWZWMyKFxyXG4gICAgICAgIGRhdGEuZ3VhcmRQb3NpdGlvblswXSAvIDIsXHJcbiAgICAgICAgZGF0YS5ndWFyZFBvc2l0aW9uWzFdIC8gMlxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qaW5pdGFsaXplIHN0YXR1cyBhbmQgYWN0aW9ucyBmb3IgZWFjaCBlbmVteS4gVGhpcyBjYW4gYmUgZWRpdGVkIGlmIHlvdSB3YW50IHlvdXIgY3VzdG9tIGVuZW1pZXMgdG8gc3RhcnQgb3V0IHdpdGhcclxuICAgICAgICAgIGRpZmZlcmVudCBzdGF0dXNlcywgYnV0IGRvbnQgcmVtb3ZlIHRoZXNlIHN0YXR1c2VzIGZvciB0aGUgb3JpZ2luYWwgdHdvIGVuZW1pZXMqL1xyXG4gICAgbGV0IHN0YXR1c0FycmF5OiBBcnJheTxzdHJpbmc+ID0gW1xyXG4gICAgICBodzRfU3RhdHVzZXMuQ0FOX1JFVFJFQVQsXHJcbiAgICAgIGh3NF9TdGF0dXNlcy5DQU5fQkVSU0VSSyxcclxuICAgIF07XHJcblxyXG4gICAgbGV0IHdlYXBvbjtcclxuICAgIGxldCBhY3Rpb25zO1xyXG4gICAgbGV0IHJhbmdlO1xyXG4gICAgaWYgKGRhdGEudHlwZSA9PT0gXCJndW5fZW5lbXlcIikge1xyXG4gICAgICB3ZWFwb24gPSB0aGlzLmNyZWF0ZVdlYXBvbihcIndlYWtfcGlzdG9sXCIpO1xyXG4gICAgICBhY3Rpb25zID0gdGhpcy5hY3Rpb25zR3VuO1xyXG4gICAgICByYW5nZSA9IDEwMDtcclxuICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSBcImltcFwiKSB7XHJcbiAgICAgIHdlYXBvbiA9IHRoaXMuY3JlYXRlV2VhcG9uKFwia25pZmVcIik7XHJcbiAgICAgIGFjdGlvbnMgPSB0aGlzLmFjdGlvbktuaWZlO1xyXG4gICAgICByYW5nZSA9IDIwO1xyXG4gICAgICAvL0FERCBDT0RFIEhFUkVcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZW5lbXlocCA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJwcmltYXJ5XCIsIHtcclxuICAgICAgcG9zaXRpb246IG5ldyBWZWMyKGRhdGEucG9zaXRpb25bMF0gLyAyLCBkYXRhLnBvc2l0aW9uWzFdIC8gMiksXHJcbiAgICAgIHRleHQ6IFwiXCIgKyBkYXRhLmhlYWx0aCxcclxuICAgIH0pO1xyXG4gICAgZW5lbXlocC50ZXh0Q29sb3IgPSBDb2xvci5XSElURTtcclxuICAgIHRoaXMuZW5lbWllc1tsYXN0SW5kZXhdLmhwRGlzcGxheSA9IGVuZW15aHA7XHJcblxyXG4gICAgbGV0IGVuZW15T3B0aW9ucyA9IHtcclxuICAgICAgZGVmYXVsdE1vZGU6IGRhdGEubW9kZSxcclxuICAgICAgcGF0cm9sUm91dGU6IGRhdGEucm91dGUsIC8vIFRoaXMgb25seSBtYXR0ZXJzIGlmIHRoZXkncmUgYSBwYXRyb2xsZXJcclxuICAgICAgZ3VhcmRQb3NpdGlvbjogZGF0YS5ndWFyZFBvc2l0aW9uLCAvLyBUaGlzIG9ubHkgbWF0dGVycyBpZiB0aGUncmUgYSBndWFyZFxyXG4gICAgICBoZWFsdGg6IGRhdGEuaGVhbHRoLFxyXG4gICAgICBwbGF5ZXIxOiB0aGlzLm1haW5QbGF5ZXIsXHJcbiAgICAgIHdlYXBvbjogd2VhcG9uLFxyXG4gICAgICBnb2FsOiBodzRfU3RhdHVzZXMuUkVBQ0hFRF9HT0FMLFxyXG4gICAgICBzdGF0dXM6IHN0YXR1c0FycmF5LFxyXG4gICAgICBhY3Rpb25zOiBhY3Rpb25zLFxyXG4gICAgICBpblJhbmdlOiByYW5nZSxcclxuICAgIH07XHJcbiAgICB0aGlzLmVuZW1pZXNbbGFzdEluZGV4XS5hZGRBSShFbmVteUFJLCBlbmVteU9wdGlvbnMpO1xyXG4gICAgaWYgKHBvcyAhPT0gbnVsbCkge1xyXG4gICAgICB0aGlzLmVuZW1pZXNbbGFzdEluZGV4XS5wb3NpdGlvbiA9IHBvcy5jbG9uZSgpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5iYXR0bGVNYW5hZ2VyLnNldEVuZW1pZXMoXHJcbiAgICAgIHRoaXMuZW5lbWllcy5tYXAoKGVuZW15KSA9PiA8QmF0dGxlckFJPmVuZW15Ll9haSlcclxuICAgICk7XHJcbiAgfVxyXG4gIGluaXRpYWxpemVFbmVtaWVzKCkge1xyXG4gICAgdGhpcy5lbmVtaWVzID0gbmV3IEFycmF5KDApO1xyXG4gICAgY29uc3QgZW5lbXlEYXRhID0gdGhpcy5sb2FkLmdldE9iamVjdChcImVuZW15RGF0YVwiKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5lbXlEYXRhLm51bUVuZW1pZXM7IGkrKykge1xyXG4gICAgICBsZXQgZGF0YSA9IGVuZW15RGF0YS5lbmVtaWVzW2ldO1xyXG4gICAgICB0aGlzLnNwYXduRW5lbXkoSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSksIG51bGwpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy90aGlzIHNwYXducyBpbiB0aGUgbGFzdCBlbmVteSBvZiB0aGUgZW5lbXkuanNvblxyXG4gIHNwYXduSW1wKHBvczogVmVjMik6IHZvaWQge1xyXG4gICAgY29uc3QgZW5lbXlEYXRhID0gdGhpcy5sb2FkLmdldE9iamVjdChcImVuZW15RGF0YVwiKTtcclxuICAgIGxldCBkYXRhID0gZW5lbXlEYXRhLmVuZW1pZXNbMjBdO1xyXG4gICAgdGhpcy5zcGF3bkVuZW15KEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpLCBwb3MpO1xyXG4gIH1cclxuICBzcGF3blJhbmRvbUVuZW15KCk6IHZvaWQge1xyXG4gICAgbGV0IHggPSBNYXRoLnJhbmRvbSgpICogdGhpcy50aWxlTWFwTWF4U2l6ZS54O1xyXG4gICAgbGV0IHkgPSBNYXRoLnJhbmRvbSgpICogdGhpcy50aWxlTWFwTWF4U2l6ZS55O1xyXG4gICAgbGV0IG5ld1BvcyA9IG5ldyBWZWMyKHgsIHkpO1xyXG4gICAgdGhpcy5zcGF3bkltcChuZXdQb3MpO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IExhYmVsIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XHJcbmltcG9ydCB7IFVJRWxlbWVudFR5cGUgfSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9VSUVsZW1lbnRUeXBlc1wiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1NjZW5lL1NjZW5lXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vV29sZmllMkQvVXRpbHMvQ29sb3JcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5leHRMZXZlbCBleHRlbmRzIFNjZW5lIHtcclxuXHJcbiAgICBzdGFydFNjZW5lKCkge1xyXG4gICAgICAgIGNvbnN0IGNlbnRlciA9IHRoaXMudmlld3BvcnQuZ2V0Q2VudGVyKCk7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkVUlMYXllcihcInByaW1hcnlcIik7XHJcblxyXG4gICAgICAgIGNvbnN0IG5leHRsZXZlbCA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJwcmltYXJ5XCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLngsIGNlbnRlci55KSwgdGV4dDogXCJOZXh0IExldmVsXCJ9KTtcclxuICAgICAgICBuZXh0bGV2ZWwudGV4dENvbG9yID0gQ29sb3IuV0hJVEU7XHJcbiAgICB9XHJcbn0iXX0=